{
  "version": 3,
  "sources": ["../../@vue/shared/dist/shared.esm-bundler.js", "../../@vue/language-core/lib/utils/shared.js", "../../@vue/language-core/lib/codegen/globalTypes.js", "../../@vue/compiler-core/dist/compiler-core.esm-bundler.js", "../../@vue/compiler-dom/dist/compiler-dom.esm-bundler.js", "../../@vue/language-core/lib/parsers/scriptSetupRanges.js", "../../@vue/language-core/lib/codegen/common.js", "../../@vue/language-core/lib/codegen/template/context.js", "../../@vue/language-core/lib/codegen/template/camelized.js", "../../@vue/language-core/lib/codegen/template/interpolation.js", "../../balanced-match/index.js", "../../brace-expansion/index.js", "../../minimatch/src/assert-valid-pattern.ts", "../../minimatch/src/brace-expressions.ts", "../../minimatch/src/unescape.ts", "../../minimatch/src/ast.ts", "../../minimatch/src/escape.ts", "../../minimatch/src/index.ts", "../../muggle-string/out/binarySearch.js", "../../muggle-string/out/track.js", "../../muggle-string/out/types.js", "../../muggle-string/out/index.js", "../../@vue/language-core/lib/codegen/template/elementEvents.js", "../../@vue/language-core/lib/codegen/template/stringLiteralKey.js", "../../@vue/language-core/lib/codegen/template/objectProperty.js", "../../@vue/language-core/lib/codegen/inlayHints.js", "../../@vue/language-core/lib/codegen/template/elementProps.js", "../../@vue/language-core/lib/codegen/template/slotOutlet.js", "../../@vue/language-core/lib/codegen/template/vFor.js", "../../@vue/language-core/lib/codegen/template/vIf.js", "../../@vue/language-core/lib/codegen/template/templateChild.js", "../../@vue/language-core/lib/codegen/template/elementChildren.js", "../../@vue/language-core/lib/codegen/template/elementDirectives.js", "../../@vue/language-core/lib/codegen/template/propertyAccess.js", "../../@vue/language-core/lib/codegen/template/element.js", "../../@vue/language-core/lib/codegen/template/styleScopedClasses.js", "../../@vue/language-core/lib/codegen/template/index.js", "../../@volar/source-map/lib/binarySearch.js", "../../@volar/source-map/lib/translateOffset.js", "../../@volar/source-map/lib/sourceMap.js", "../../@volar/source-map/index.js", "../../@volar/language-core/lib/editor.js", "../../@volar/language-core/lib/linkedCodeMap.js", "../../@volar/language-core/lib/types.js", "../../@volar/language-core/lib/utils.js", "../../@volar/language-core/index.js", "../../@vue/language-core/lib/plugins/file-html.js", "../../@vue/language-core/lib/utils/buildMappings.js", "../../@vue/language-core/lib/utils/parseSfc.js", "../../@vue/language-core/lib/plugins/file-md.js", "../../@vue/language-core/lib/plugins/file-vue.js", "../../@vue/language-core/lib/plugins/shared.js", "../../@vue/language-core/lib/plugins/vue-root-tags.js", "../../@vue/language-core/lib/plugins/vue-script-js.js", "../../@vue/language-core/lib/plugins/vue-sfc-customblocks.js", "../../@vue/language-core/lib/plugins/vue-sfc-scripts.js", "../../@vue/language-core/lib/plugins/vue-sfc-styles.js", "../../@vue/language-core/lib/plugins/vue-sfc-template.js", "../../@vue/language-core/lib/plugins/vue-template-html.js", "../../@vue/language-core/lib/plugins/vue-template-inline-css.js", "../../@vue/language-core/lib/plugins/vue-template-inline-ts.js", "../../alien-signals/cjs/system.js", "../../alien-signals/cjs/computed.js", "../../alien-signals/cjs/effectScope.js", "../../alien-signals/cjs/effect.js", "../../alien-signals/cjs/signal.js", "../../alien-signals/cjs/unstable/computedArray.js", "../../alien-signals/cjs/unstable/computedSet.js", "../../alien-signals/cjs/unstable/equalityComputed.js", "../../alien-signals/cjs/unstable/index.js", "../../alien-signals/cjs/index.js", "../../path-browserify/index.js", "../../@vue/language-core/lib/codegen/script/component.js", "../../@vue/language-core/lib/codegen/script/template.js", "../../@vue/language-core/lib/codegen/script/componentSelf.js", "../../@vue/language-core/lib/codegen/localTypes.js", "../../@vue/language-core/lib/codegen/script/context.js", "../../@vue/language-core/lib/codegen/script/scriptSetup.js", "../../@vue/language-core/lib/codegen/script/src.js", "../../@vue/language-core/lib/codegen/script/styleModulesType.js", "../../@vue/language-core/lib/codegen/script/index.js", "../../@vue/language-core/lib/parsers/scriptRanges.js", "../../@vue/language-core/lib/plugins/vue-tsx.js", "../../@vue/language-core/lib/types.js", "../../@vue/language-core/lib/plugins.js", "../../de-indent/index.js", "../../he/he.js", "../../@vue/compiler-vue2/build.js", "../../@vue/language-core/lib/utils/vue2TemplateCompiler.js", "../../@vue/language-core/lib/virtualFile/embeddedFile.js", "../../@vue/language-core/lib/virtualFile/computedEmbeddedCodes.js", "../../@vue/language-core/lib/utils/parseCssVars.js", "../../@vue/language-core/lib/utils/parseCssClassNames.js", "../../@vue/language-core/lib/virtualFile/computedSfc.js", "../../@vue/language-core/lib/virtualFile/computedVueSfc.js", "../../@vue/language-core/lib/virtualFile/vueFile.js", "../../@vue/language-core/lib/languagePlugin.js", "../../@vue/language-core/lib/utils/ts.js", "../../@vue/language-core/index.js", "../../ms/index.js", "../../debug/src/common.js", "../../debug/src/browser.js", "../../@shikijs/types/dist/index.mjs", "../../@shikijs/engine-oniguruma/dist/index.mjs", "../../@shikijs/core/dist/shared/core.Bn_XU0Iv.mjs", "../../html-void-elements/index.js", "../../property-information/lib/util/schema.js", "../../property-information/lib/util/merge.js", "../../property-information/lib/normalize.js", "../../property-information/lib/util/info.js", "../../property-information/lib/util/types.js", "../../property-information/lib/util/defined-info.js", "../../property-information/lib/util/create.js", "../../property-information/lib/aria.js", "../../property-information/lib/util/case-sensitive-transform.js", "../../property-information/lib/util/case-insensitive-transform.js", "../../property-information/lib/html.js", "../../property-information/lib/svg.js", "../../property-information/lib/xlink.js", "../../property-information/lib/xmlns.js", "../../property-information/lib/xml.js", "../../property-information/lib/find.js", "../../property-information/index.js", "../../zwitch/index.js", "../../stringify-entities/lib/core.js", "../../stringify-entities/lib/util/to-hexadecimal.js", "../../stringify-entities/lib/util/to-decimal.js", "../../character-entities-legacy/index.js", "../../character-entities-html4/index.js", "../../stringify-entities/lib/constant/dangerous.js", "../../stringify-entities/lib/util/to-named.js", "../../stringify-entities/lib/util/format-smart.js", "../../stringify-entities/lib/index.js", "../../hast-util-to-html/lib/handle/comment.js", "../../hast-util-to-html/lib/handle/doctype.js", "../../ccount/index.js", "../../comma-separated-tokens/index.js", "../../space-separated-tokens/index.js", "../../hast-util-whitespace/lib/index.js", "../../hast-util-to-html/lib/omission/util/siblings.js", "../../hast-util-to-html/lib/omission/omission.js", "../../hast-util-to-html/lib/omission/closing.js", "../../hast-util-to-html/lib/omission/opening.js", "../../hast-util-to-html/lib/handle/element.js", "../../hast-util-to-html/lib/handle/text.js", "../../hast-util-to-html/lib/handle/raw.js", "../../hast-util-to-html/lib/handle/root.js", "../../hast-util-to-html/lib/handle/index.js", "../../hast-util-to-html/lib/index.js", "../../emoji-regex-xs/index.mjs", "../../regex-utilities/src/index.js", "../../regex/src/subclass.js", "../../regex/src/utils-internals.js", "../../regex/src/atomic.js", "../../regex-recursion/src/index.js", "../../oniguruma-to-es/src/utils.js", "../../oniguruma-to-es/src/options.js", "../../oniguruma-to-es/src/unicode.js", "../../oniguruma-to-es/src/tokenize.js", "../../oniguruma-to-es/src/utils-ast.js", "../../oniguruma-to-es/src/traverse.js", "../../oniguruma-to-es/src/parse.js", "../../oniguruma-to-es/src/transform.js", "../../oniguruma-to-es/src/generate.js", "../../oniguruma-to-es/src/subclass.js", "../../oniguruma-to-es/src/index.js", "../../@shikijs/core/dist/index.mjs", "../../@shikijs/twoslash/dist/core.mjs", "../../twoslash/dist/index.mjs", "../../@typescript/vfs/src/index.ts", "../../twoslash-protocol/dist/index.mjs", "../../twoslash/dist/shared/twoslash.a8564bda.mjs", "../../twoslash/dist/core.mjs", "../../twoslash-vue/dist/index.mjs", "../../devlop/lib/development.js", "../../mdast-util-to-string/lib/index.js", "../../decode-named-character-reference/index.dom.js", "../../micromark-util-symbol/lib/codes.js", "../../micromark-util-symbol/lib/constants.js", "../../micromark-util-symbol/lib/types.js", "../../micromark-util-symbol/lib/values.js", "../../micromark-util-chunked/dev/index.js", "../../micromark-util-combine-extensions/index.js", "../../micromark-util-decode-numeric-character-reference/dev/index.js", "../../micromark-util-normalize-identifier/dev/index.js", "../../micromark-util-character/dev/index.js", "../../micromark-util-sanitize-uri/dev/index.js", "../../micromark/dev/lib/compile.js", "../../micromark-factory-space/dev/index.js", "../../micromark/dev/lib/initialize/content.js", "../../micromark/dev/lib/initialize/document.js", "../../micromark-util-classify-character/dev/index.js", "../../micromark-util-resolve-all/index.js", "../../micromark-core-commonmark/dev/lib/attention.js", "../../micromark-core-commonmark/dev/lib/autolink.js", "../../micromark-core-commonmark/dev/lib/blank-line.js", "../../micromark-core-commonmark/dev/lib/block-quote.js", "../../micromark-core-commonmark/dev/lib/character-escape.js", "../../micromark-core-commonmark/dev/lib/character-reference.js", "../../micromark-core-commonmark/dev/lib/code-fenced.js", "../../micromark-core-commonmark/dev/lib/code-indented.js", "../../micromark-core-commonmark/dev/lib/code-text.js", "../../micromark-util-subtokenize/dev/lib/splice-buffer.js", "../../micromark-util-subtokenize/dev/index.js", "../../micromark-core-commonmark/dev/lib/content.js", "../../micromark-factory-destination/dev/index.js", "../../micromark-factory-label/dev/index.js", "../../micromark-factory-title/dev/index.js", "../../micromark-factory-whitespace/dev/index.js", "../../micromark-core-commonmark/dev/lib/definition.js", "../../micromark-core-commonmark/dev/lib/hard-break-escape.js", "../../micromark-core-commonmark/dev/lib/heading-atx.js", "../../micromark-util-html-tag-name/index.js", "../../micromark-core-commonmark/dev/lib/html-flow.js", "../../micromark-core-commonmark/dev/lib/html-text.js", "../../micromark-core-commonmark/dev/lib/label-end.js", "../../micromark-core-commonmark/dev/lib/label-start-image.js", "../../micromark-core-commonmark/dev/lib/label-start-link.js", "../../micromark-core-commonmark/dev/lib/line-ending.js", "../../micromark-core-commonmark/dev/lib/thematic-break.js", "../../micromark-core-commonmark/dev/lib/list.js", "../../micromark-core-commonmark/dev/lib/setext-underline.js", "../../micromark/dev/lib/initialize/flow.js", "../../micromark/dev/lib/initialize/text.js", "../../micromark/dev/lib/constructs.js", "../../micromark/dev/lib/create-tokenizer.js", "../../micromark/dev/lib/parse.js", "../../micromark/dev/lib/postprocess.js", "../../micromark/dev/lib/preprocess.js", "../../micromark-util-decode-string/dev/index.js", "../../unist-util-stringify-position/lib/index.js", "../../mdast-util-from-markdown/dev/lib/index.js", "../../escape-string-regexp/index.js", "../../unist-util-is/lib/index.js", "../../unist-util-visit-parents/lib/color.js", "../../unist-util-visit-parents/lib/index.js", "../../mdast-util-find-and-replace/lib/index.js", "../../mdast-util-gfm-autolink-literal/lib/index.js", "../../mdast-util-gfm-footnote/lib/index.js", "../../mdast-util-gfm-strikethrough/lib/index.js", "../../mdast-util-to-markdown/lib/configure.js", "../../mdast-util-to-markdown/lib/util/check-quote.js", "../../mdast-util-to-markdown/lib/util/check-emphasis.js", "../../mdast-util-to-markdown/lib/util/encode-character-reference.js", "../../mdast-util-to-markdown/lib/util/encode-info.js", "../../mdast-util-to-markdown/lib/handle/emphasis.js", "../../unist-util-visit/lib/index.js", "../../mdast-util-to-markdown/lib/handle/html.js", "../../mdast-util-to-markdown/lib/handle/image.js", "../../mdast-util-to-markdown/lib/handle/image-reference.js", "../../mdast-util-to-markdown/lib/handle/inline-code.js", "../../mdast-util-to-markdown/lib/util/format-link-as-autolink.js", "../../mdast-util-to-markdown/lib/handle/link.js", "../../mdast-util-to-markdown/lib/handle/link-reference.js", "../../mdast-util-phrasing/lib/index.js", "../../mdast-util-to-markdown/lib/util/check-strong.js", "../../mdast-util-to-markdown/lib/handle/strong.js", "../../mdast-util-gfm-table/lib/index.js", "../../mdast-util-gfm-task-list-item/lib/index.js", "../../mdast-util-gfm/lib/index.js", "../../mdast-util-to-hast/lib/handlers/blockquote.js", "../../mdast-util-to-hast/lib/handlers/break.js", "../../mdast-util-to-hast/lib/handlers/code.js", "../../mdast-util-to-hast/lib/handlers/delete.js", "../../mdast-util-to-hast/lib/handlers/emphasis.js", "../../mdast-util-to-hast/lib/handlers/footnote-reference.js", "../../mdast-util-to-hast/lib/handlers/heading.js", "../../mdast-util-to-hast/lib/handlers/html.js", "../../mdast-util-to-hast/lib/revert.js", "../../mdast-util-to-hast/lib/handlers/image-reference.js", "../../mdast-util-to-hast/lib/handlers/image.js", "../../mdast-util-to-hast/lib/handlers/inline-code.js", "../../mdast-util-to-hast/lib/handlers/link-reference.js", "../../mdast-util-to-hast/lib/handlers/link.js", "../../mdast-util-to-hast/lib/handlers/list-item.js", "../../mdast-util-to-hast/lib/handlers/list.js", "../../mdast-util-to-hast/lib/handlers/paragraph.js", "../../mdast-util-to-hast/lib/handlers/root.js", "../../mdast-util-to-hast/lib/handlers/strong.js", "../../unist-util-position/lib/index.js", "../../mdast-util-to-hast/lib/handlers/table.js", "../../mdast-util-to-hast/lib/handlers/table-row.js", "../../mdast-util-to-hast/lib/handlers/table-cell.js", "../../trim-lines/index.js", "../../mdast-util-to-hast/lib/handlers/text.js", "../../mdast-util-to-hast/lib/handlers/thematic-break.js", "../../mdast-util-to-hast/lib/handlers/index.js", "../../@ungap/structured-clone/esm/types.js", "../../@ungap/structured-clone/esm/deserialize.js", "../../@ungap/structured-clone/esm/serialize.js", "../../@ungap/structured-clone/esm/index.js", "../../mdast-util-to-hast/lib/footer.js", "../../mdast-util-to-hast/lib/state.js", "../../mdast-util-to-hast/lib/index.js", "../../@shikijs/vitepress-twoslash/dist/index.mjs"],
  "sourcesContent": ["/**\n* @vue/shared v3.5.24\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\")) map[key] = 1;\n  return (val) => val in map;\n}\n\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\nconst EMPTY_ARR = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter\n(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return ((str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  });\n};\nconst camelizeRE = /-\\w/g;\nconst camelize = cacheStringFunction(\n  (str) => {\n    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());\n  }\n);\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction(\n  (str) => {\n    const s = str ? `on${capitalize(str)}` : ``;\n    return s;\n  }\n);\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, ...arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](...arg);\n  }\n};\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\nfunction genCacheKey(source, options) {\n  return source + JSON.stringify(\n    options,\n    (_, val) => typeof val === \"function\" ? val.toString() : val\n  );\n}\n\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"CACHED\": -1,\n  \"-1\": \"CACHED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `CACHED`,\n  [-2]: `BAIL`\n};\n\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\n\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  start = Math.max(0, Math.min(start, source.length));\n  end = Math.max(0, Math.min(end, source.length));\n  if (start > end) return \"\";\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  if (!styles) return \"\";\n  if (isString(styles)) return styles;\n  let ret = \"\";\n  for (const key in styles) {\n    const value = styles[key];\n    if (isString(value) || typeof value === \"number\") {\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\nconst isKnownMathMLAttr = /* @__PURE__ */ makeMap(\n  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`\n);\nfunction isRenderableAttrValue(value) {\n  if (value == null) {\n    return false;\n  }\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\nconst cssVarNameEscapeSymbolsRE = /[ !\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~]/g;\nfunction getEscapedCssVarName(key, doubleEscape) {\n  return key.replace(\n    cssVarNameEscapeSymbolsRE,\n    (s) => doubleEscape ? s === '\"' ? '\\\\\\\\\\\\\"' : `\\\\\\\\${s}` : `\\\\${s}`\n  );\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst isRef = (val) => {\n  return !!(val && val[\"__v_isRef\"] === true);\n};\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (isRef(val)) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce(\n        (entries, [key, val2], i) => {\n          entries[stringifySymbol(key, i) + \" =>\"] = val2;\n          return entries;\n        },\n        {}\n      )\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return (\n    // Symbol.description in es2019+ so we need to cast here to pass\n    // the lib: es2016 check\n    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v\n  );\n};\n\nfunction normalizeCssVarValue(value) {\n  if (value == null) {\n    return \"initial\";\n  }\n  if (typeof value === \"string\") {\n    return value === \"\" ? \" \" : value;\n  }\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(\n        \"[Vue warn] Invalid value used for CSS binding. Expected a string or a finite number but received:\",\n        value\n      );\n    }\n  }\n  return String(value);\n}\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, PatchFlags, ShapeFlags, SlotFlags, camelize, capitalize, cssVarNameEscapeSymbolsRE, def, escapeHtml, escapeHtmlComment, extend, genCacheKey, genPropsAccessExp, generateCodeFrame, getEscapedCssVarName, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyAllowed, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownMathMLAttr, isKnownSvgAttr, isMap, isMathMLTag, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isRenderableAttrValue, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeCssVarValue, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hyphenateTag = void 0;\nexports.getSlotsPropertyName = getSlotsPropertyName;\nexports.hyphenateAttr = hyphenateAttr;\nconst shared_1 = require(\"@vue/shared\");\nfunction getSlotsPropertyName(vueVersion) {\n    return vueVersion < 3 ? '$scopedSlots' : '$slots';\n}\nvar shared_2 = require(\"@vue/shared\");\nObject.defineProperty(exports, \"hyphenateTag\", { enumerable: true, get: function () { return shared_2.hyphenate; } });\nfunction hyphenateAttr(str) {\n    let hyphencase = (0, shared_1.hyphenate)(str);\n    // fix https://github.com/vuejs/core/issues/8811\n    if (str.length && str[0] !== str[0].toLowerCase()) {\n        hyphencase = '-' + hyphencase;\n    }\n    return hyphencase;\n}\n//# sourceMappingURL=shared.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateGlobalTypes = generateGlobalTypes;\nconst shared_1 = require(\"../utils/shared\");\nfunction generateGlobalTypes(lib, target, strictTemplates) {\n    const fnPropsType = `(K extends { $props: infer Props } ? Props : any)${strictTemplates ? '' : ' & Record<string, unknown>'}`;\n    let text = ``;\n    if (target < 3.5) {\n        text += `\n; declare module '${lib}' {\n\texport interface GlobalComponents { }\n\texport interface GlobalDirectives { }\n}`;\n    }\n    text += `\n; declare global {\n\tconst __VLS_intrinsicElements: __VLS_IntrinsicElements;\n\tconst __VLS_directiveBindingRestFields: { instance: null, oldValue: null, modifiers: any, dir: any };\n\tconst __VLS_unref: typeof import('${lib}').unref;\n\n\tconst __VLS_nativeElements = {\n\t\t...{} as SVGElementTagNameMap,\n\t\t...{} as HTMLElementTagNameMap,\n\t};\n\n\ttype __VLS_IntrinsicElements = ${(target >= 3.3\n        ? `import('${lib}/jsx-runtime').JSX.IntrinsicElements;`\n        : `globalThis.JSX.IntrinsicElements;`)}\n\ttype __VLS_Element = ${(target >= 3.3\n        ? `import('${lib}/jsx-runtime').JSX.Element;`\n        : `globalThis.JSX.Element;`)}\n\ttype __VLS_GlobalComponents = ${(target >= 3.5\n        ? `import('${lib}').GlobalComponents;`\n        : `import('${lib}').GlobalComponents & Pick<typeof import('${lib}'), 'Transition' | 'TransitionGroup' | 'KeepAlive' | 'Suspense' | 'Teleport'>;`)}\n\ttype __VLS_GlobalDirectives = import('${lib}').GlobalDirectives;\n\ttype __VLS_IsAny<T> = 0 extends 1 & T ? true : false;\n\ttype __VLS_PickNotAny<A, B> = __VLS_IsAny<A> extends true ? B : A;\n\ttype __VLS_unknownDirective = (arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown) => void;\n\ttype __VLS_WithComponent<N0 extends string, LocalComponents, N1 extends string, N2 extends string, N3 extends string> =\n\t\tN1 extends keyof LocalComponents ? N1 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : { [K in N0]: LocalComponents[N1] } :\n\t\tN2 extends keyof LocalComponents ? N2 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : { [K in N0]: LocalComponents[N2] } :\n\t\tN3 extends keyof LocalComponents ? N3 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : { [K in N0]: LocalComponents[N3] } :\n\t\tN1 extends keyof __VLS_GlobalComponents ? N1 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : { [K in N0]: __VLS_GlobalComponents[N1] } :\n\t\tN2 extends keyof __VLS_GlobalComponents ? N2 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : { [K in N0]: __VLS_GlobalComponents[N2] } :\n\t\tN3 extends keyof __VLS_GlobalComponents ? N3 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : { [K in N0]: __VLS_GlobalComponents[N3] } :\n\t\t${strictTemplates ? '{}' : '{ [K in N0]: unknown }'}\n\ttype __VLS_FunctionalComponentProps<T, K> =\n\t\t'__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends { __ctx?: { props?: infer P } } ? NonNullable<P> : never\n\t\t: T extends (props: infer P, ...args: any) => any ? P :\n\t\t{};\n\ttype __VLS_IsFunction<T, K> = K extends keyof T\n\t\t? __VLS_IsAny<T[K]> extends false\n\t\t? unknown extends T[K]\n\t\t? false\n\t\t: true\n\t\t: false\n\t\t: false;\n\t// fix https://github.com/vuejs/language-tools/issues/926\n\ttype __VLS_UnionToIntersection<U> = (U extends unknown ? (arg: U) => unknown : never) extends ((arg: infer P) => unknown) ? P : never;\n\ttype __VLS_OverloadUnionInner<T, U = unknown> = U & T extends (...args: infer A) => infer R\n\t\t? U extends T\n\t\t? never\n\t\t: __VLS_OverloadUnionInner<T, Pick<T, keyof T> & U & ((...args: A) => R)> | ((...args: A) => R)\n\t\t: never;\n\ttype __VLS_OverloadUnion<T> = Exclude<\n\t\t__VLS_OverloadUnionInner<(() => never) & T>,\n\t\tT extends () => never ? never : () => never\n\t>;\n\ttype __VLS_ConstructorOverloads<T> = __VLS_OverloadUnion<T> extends infer F\n\t\t? F extends (event: infer E, ...args: infer A) => any\n\t\t? { [K in E & string]: (...args: A) => void; }\n\t\t: never\n\t\t: never;\n\ttype __VLS_NormalizeEmits<T> = __VLS_PrettifyGlobal<\n\t\t__VLS_UnionToIntersection<\n\t\t\t__VLS_ConstructorOverloads<T> & {\n\t\t\t\t[K in keyof T]: T[K] extends any[] ? { (...args: T[K]): void } : never\n\t\t\t}\n\t\t>\n\t>;\n\ttype __VLS_PrettifyGlobal<T> = { [K in keyof T]: T[K]; } & {};\n\ttype __VLS_PickFunctionalComponentCtx<T, K> = NonNullable<__VLS_PickNotAny<\n\t\t'__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends { __ctx?: infer Ctx } ? Ctx : never : any\n\t\t, T extends (props: any, ctx: infer Ctx) => any ? Ctx : any\n\t>>;\n\ttype __VLS_UseTemplateRef<T> = Readonly<import('${lib}').ShallowRef<T | null>>;\n\n\tfunction __VLS_getVForSourceType(source: number): [number, number, number][];\n\tfunction __VLS_getVForSourceType(source: string): [string, number, number][];\n\tfunction __VLS_getVForSourceType<T extends any[]>(source: T): [\n\t\titem: T[number],\n\t\tkey: number,\n\t\tindex: number,\n\t][];\n\tfunction __VLS_getVForSourceType<T extends { [Symbol.iterator](): Iterator<any> }>(source: T): [\n\t\titem: T extends { [Symbol.iterator](): Iterator<infer T1> } ? T1 : never, \n\t\tkey: number,\n\t\tindex: undefined,\n\t][];\n\t// #3845\n\tfunction __VLS_getVForSourceType<T extends number | { [Symbol.iterator](): Iterator<any> }>(source: T): [\n\t\titem: number | (Exclude<T, number> extends { [Symbol.iterator](): Iterator<infer T1> } ? T1 : never), \n\t\tkey: number,\n\t\tindex: undefined,\n\t][];\n\tfunction __VLS_getVForSourceType<T>(source: T): [\n\t\titem: T[keyof T],\n\t\tkey: keyof T,\n\t\tindex: number,\n\t][];\n\t// @ts-ignore\n\tfunction __VLS_getSlotParams<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>;\n\t// @ts-ignore\n\tfunction __VLS_getSlotParam<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>[0];\n\tfunction __VLS_asFunctionalDirective<T>(dir: T): T extends import('${lib}').ObjectDirective\n\t\t? NonNullable<T['created' | 'beforeMount' | 'mounted' | 'beforeUpdate' | 'updated' | 'beforeUnmount' | 'unmounted']>\n\t\t: T extends (...args: any) => any\n\t\t\t? T\n\t\t\t: __VLS_unknownDirective;\n\tfunction __VLS_withScope<T, K>(ctx: T, scope: K): ctx is T & K;\n\tfunction __VLS_makeOptional<T>(t: T): { [K in keyof T]?: T[K] };\n\tfunction __VLS_nonNullable<T>(t: T): T extends null | undefined ? never : T;\n\tfunction __VLS_asFunctionalComponent<T, K = T extends new (...args: any) => any ? InstanceType<T> : unknown>(t: T, instance?: K):\n\t\tT extends new (...args: any) => any\n\t\t? (props: ${fnPropsType}, ctx?: any) => __VLS_Element & { __ctx?: {\n\t\t\tattrs?: any,\n\t\t\tslots?: K extends { ${(0, shared_1.getSlotsPropertyName)(target)}: infer Slots } ? Slots : any,\n\t\t\temit?: K extends { $emit: infer Emit } ? Emit : any\n\t\t} & { props?: ${fnPropsType}; expose?(exposed: K): void; } }\n\t\t: T extends () => any ? (props: {}, ctx?: any) => ReturnType<T>\n\t\t: T extends (...args: any) => any ? T\n\t\t: (_: {}${strictTemplates ? '' : ' & Record<string, unknown>'}, ctx?: any) => { __ctx?: { attrs?: any, expose?: any, slots?: any, emit?: any, props?: {}${strictTemplates ? '' : ' & Record<string, unknown>'} } };\n\tfunction __VLS_elementAsFunction<T>(tag: T, endTag?: T): (_: T${strictTemplates ? '' : ' & Record<string, unknown>'}) => void;\n\tfunction __VLS_functionalComponentArgsRest<T extends (...args: any) => any>(t: T): 2 extends Parameters<T>['length'] ? [any] : [];\n\tfunction __VLS_normalizeSlot<S>(s: S): S extends () => infer R ? (props: {}) => R : S;\n\tfunction __VLS_tryAsConstant<const T>(t: T): T;\n}\n`;\n    return text;\n}\n;\n//# sourceMappingURL=globalTypes.js.map", "/**\n* @vue/compiler-core v3.5.24\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { isString, NOOP, isObject, extend, NO, isSymbol, PatchFlagNames, isArray, capitalize, camelize, EMPTY_OBJ, slotFlagsText, isOn, isBuiltInDirective, isReservedProp, toHandlerKey } from '@vue/shared';\nexport { generateCodeFrame } from '@vue/shared';\n\nconst FRAGMENT = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `Fragment` : ``);\nconst TELEPORT = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `Teleport` : ``);\nconst SUSPENSE = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `Suspense` : ``);\nconst KEEP_ALIVE = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `KeepAlive` : ``);\nconst BASE_TRANSITION = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `BaseTransition` : ``\n);\nconst OPEN_BLOCK = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `openBlock` : ``);\nconst CREATE_BLOCK = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `createBlock` : ``);\nconst CREATE_ELEMENT_BLOCK = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `createElementBlock` : ``\n);\nconst CREATE_VNODE = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `createVNode` : ``);\nconst CREATE_ELEMENT_VNODE = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `createElementVNode` : ``\n);\nconst CREATE_COMMENT = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `createCommentVNode` : ``\n);\nconst CREATE_TEXT = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `createTextVNode` : ``\n);\nconst CREATE_STATIC = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `createStaticVNode` : ``\n);\nconst RESOLVE_COMPONENT = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `resolveComponent` : ``\n);\nconst RESOLVE_DYNAMIC_COMPONENT = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `resolveDynamicComponent` : ``\n);\nconst RESOLVE_DIRECTIVE = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `resolveDirective` : ``\n);\nconst RESOLVE_FILTER = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `resolveFilter` : ``\n);\nconst WITH_DIRECTIVES = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `withDirectives` : ``\n);\nconst RENDER_LIST = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `renderList` : ``);\nconst RENDER_SLOT = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `renderSlot` : ``);\nconst CREATE_SLOTS = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `createSlots` : ``);\nconst TO_DISPLAY_STRING = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `toDisplayString` : ``\n);\nconst MERGE_PROPS = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `mergeProps` : ``);\nconst NORMALIZE_CLASS = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `normalizeClass` : ``\n);\nconst NORMALIZE_STYLE = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `normalizeStyle` : ``\n);\nconst NORMALIZE_PROPS = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `normalizeProps` : ``\n);\nconst GUARD_REACTIVE_PROPS = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `guardReactiveProps` : ``\n);\nconst TO_HANDLERS = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `toHandlers` : ``);\nconst CAMELIZE = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `camelize` : ``);\nconst CAPITALIZE = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `capitalize` : ``);\nconst TO_HANDLER_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `toHandlerKey` : ``\n);\nconst SET_BLOCK_TRACKING = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `setBlockTracking` : ``\n);\nconst PUSH_SCOPE_ID = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `pushScopeId` : ``);\nconst POP_SCOPE_ID = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `popScopeId` : ``);\nconst WITH_CTX = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `withCtx` : ``);\nconst UNREF = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `unref` : ``);\nconst IS_REF = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `isRef` : ``);\nconst WITH_MEMO = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `withMemo` : ``);\nconst IS_MEMO_SAME = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `isMemoSame` : ``);\nconst helperNameMap = {\n  [FRAGMENT]: `Fragment`,\n  [TELEPORT]: `Teleport`,\n  [SUSPENSE]: `Suspense`,\n  [KEEP_ALIVE]: `KeepAlive`,\n  [BASE_TRANSITION]: `BaseTransition`,\n  [OPEN_BLOCK]: `openBlock`,\n  [CREATE_BLOCK]: `createBlock`,\n  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\n  [CREATE_VNODE]: `createVNode`,\n  [CREATE_ELEMENT_VNODE]: `createElementVNode`,\n  [CREATE_COMMENT]: `createCommentVNode`,\n  [CREATE_TEXT]: `createTextVNode`,\n  [CREATE_STATIC]: `createStaticVNode`,\n  [RESOLVE_COMPONENT]: `resolveComponent`,\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\n  [RESOLVE_FILTER]: `resolveFilter`,\n  [WITH_DIRECTIVES]: `withDirectives`,\n  [RENDER_LIST]: `renderList`,\n  [RENDER_SLOT]: `renderSlot`,\n  [CREATE_SLOTS]: `createSlots`,\n  [TO_DISPLAY_STRING]: `toDisplayString`,\n  [MERGE_PROPS]: `mergeProps`,\n  [NORMALIZE_CLASS]: `normalizeClass`,\n  [NORMALIZE_STYLE]: `normalizeStyle`,\n  [NORMALIZE_PROPS]: `normalizeProps`,\n  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\n  [TO_HANDLERS]: `toHandlers`,\n  [CAMELIZE]: `camelize`,\n  [CAPITALIZE]: `capitalize`,\n  [TO_HANDLER_KEY]: `toHandlerKey`,\n  [SET_BLOCK_TRACKING]: `setBlockTracking`,\n  [PUSH_SCOPE_ID]: `pushScopeId`,\n  [POP_SCOPE_ID]: `popScopeId`,\n  [WITH_CTX]: `withCtx`,\n  [UNREF]: `unref`,\n  [IS_REF]: `isRef`,\n  [WITH_MEMO]: `withMemo`,\n  [IS_MEMO_SAME]: `isMemoSame`\n};\nfunction registerRuntimeHelpers(helpers) {\n  Object.getOwnPropertySymbols(helpers).forEach((s) => {\n    helperNameMap[s] = helpers[s];\n  });\n}\n\nconst Namespaces = {\n  \"HTML\": 0,\n  \"0\": \"HTML\",\n  \"SVG\": 1,\n  \"1\": \"SVG\",\n  \"MATH_ML\": 2,\n  \"2\": \"MATH_ML\"\n};\nconst NodeTypes = {\n  \"ROOT\": 0,\n  \"0\": \"ROOT\",\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"TEXT\": 2,\n  \"2\": \"TEXT\",\n  \"COMMENT\": 3,\n  \"3\": \"COMMENT\",\n  \"SIMPLE_EXPRESSION\": 4,\n  \"4\": \"SIMPLE_EXPRESSION\",\n  \"INTERPOLATION\": 5,\n  \"5\": \"INTERPOLATION\",\n  \"ATTRIBUTE\": 6,\n  \"6\": \"ATTRIBUTE\",\n  \"DIRECTIVE\": 7,\n  \"7\": \"DIRECTIVE\",\n  \"COMPOUND_EXPRESSION\": 8,\n  \"8\": \"COMPOUND_EXPRESSION\",\n  \"IF\": 9,\n  \"9\": \"IF\",\n  \"IF_BRANCH\": 10,\n  \"10\": \"IF_BRANCH\",\n  \"FOR\": 11,\n  \"11\": \"FOR\",\n  \"TEXT_CALL\": 12,\n  \"12\": \"TEXT_CALL\",\n  \"VNODE_CALL\": 13,\n  \"13\": \"VNODE_CALL\",\n  \"JS_CALL_EXPRESSION\": 14,\n  \"14\": \"JS_CALL_EXPRESSION\",\n  \"JS_OBJECT_EXPRESSION\": 15,\n  \"15\": \"JS_OBJECT_EXPRESSION\",\n  \"JS_PROPERTY\": 16,\n  \"16\": \"JS_PROPERTY\",\n  \"JS_ARRAY_EXPRESSION\": 17,\n  \"17\": \"JS_ARRAY_EXPRESSION\",\n  \"JS_FUNCTION_EXPRESSION\": 18,\n  \"18\": \"JS_FUNCTION_EXPRESSION\",\n  \"JS_CONDITIONAL_EXPRESSION\": 19,\n  \"19\": \"JS_CONDITIONAL_EXPRESSION\",\n  \"JS_CACHE_EXPRESSION\": 20,\n  \"20\": \"JS_CACHE_EXPRESSION\",\n  \"JS_BLOCK_STATEMENT\": 21,\n  \"21\": \"JS_BLOCK_STATEMENT\",\n  \"JS_TEMPLATE_LITERAL\": 22,\n  \"22\": \"JS_TEMPLATE_LITERAL\",\n  \"JS_IF_STATEMENT\": 23,\n  \"23\": \"JS_IF_STATEMENT\",\n  \"JS_ASSIGNMENT_EXPRESSION\": 24,\n  \"24\": \"JS_ASSIGNMENT_EXPRESSION\",\n  \"JS_SEQUENCE_EXPRESSION\": 25,\n  \"25\": \"JS_SEQUENCE_EXPRESSION\",\n  \"JS_RETURN_STATEMENT\": 26,\n  \"26\": \"JS_RETURN_STATEMENT\"\n};\nconst ElementTypes = {\n  \"ELEMENT\": 0,\n  \"0\": \"ELEMENT\",\n  \"COMPONENT\": 1,\n  \"1\": \"COMPONENT\",\n  \"SLOT\": 2,\n  \"2\": \"SLOT\",\n  \"TEMPLATE\": 3,\n  \"3\": \"TEMPLATE\"\n};\nconst ConstantTypes = {\n  \"NOT_CONSTANT\": 0,\n  \"0\": \"NOT_CONSTANT\",\n  \"CAN_SKIP_PATCH\": 1,\n  \"1\": \"CAN_SKIP_PATCH\",\n  \"CAN_CACHE\": 2,\n  \"2\": \"CAN_CACHE\",\n  \"CAN_STRINGIFY\": 3,\n  \"3\": \"CAN_STRINGIFY\"\n};\nconst locStub = {\n  start: { line: 1, column: 1, offset: 0 },\n  end: { line: 1, column: 1, offset: 0 },\n  source: \"\"\n};\nfunction createRoot(children, source = \"\") {\n  return {\n    type: 0,\n    source,\n    children,\n    helpers: /* @__PURE__ */ new Set(),\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: [],\n    temps: 0,\n    codegenNode: void 0,\n    loc: locStub\n  };\n}\nfunction createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {\n  if (context) {\n    if (isBlock) {\n      context.helper(OPEN_BLOCK);\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));\n    } else {\n      context.helper(getVNodeHelper(context.inSSR, isComponent));\n    }\n    if (directives) {\n      context.helper(WITH_DIRECTIVES);\n    }\n  }\n  return {\n    type: 13,\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent,\n    loc\n  };\n}\nfunction createArrayExpression(elements, loc = locStub) {\n  return {\n    type: 17,\n    loc,\n    elements\n  };\n}\nfunction createObjectExpression(properties, loc = locStub) {\n  return {\n    type: 15,\n    loc,\n    properties\n  };\n}\nfunction createObjectProperty(key, value) {\n  return {\n    type: 16,\n    loc: locStub,\n    key: isString(key) ? createSimpleExpression(key, true) : key,\n    value\n  };\n}\nfunction createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {\n  return {\n    type: 4,\n    loc,\n    content,\n    isStatic,\n    constType: isStatic ? 3 : constType\n  };\n}\nfunction createInterpolation(content, loc) {\n  return {\n    type: 5,\n    loc,\n    content: isString(content) ? createSimpleExpression(content, false, loc) : content\n  };\n}\nfunction createCompoundExpression(children, loc = locStub) {\n  return {\n    type: 8,\n    loc,\n    children\n  };\n}\nfunction createCallExpression(callee, args = [], loc = locStub) {\n  return {\n    type: 14,\n    loc,\n    callee,\n    arguments: args\n  };\n}\nfunction createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {\n  return {\n    type: 18,\n    params,\n    returns,\n    newline,\n    isSlot,\n    loc\n  };\n}\nfunction createConditionalExpression(test, consequent, alternate, newline = true) {\n  return {\n    type: 19,\n    test,\n    consequent,\n    alternate,\n    newline,\n    loc: locStub\n  };\n}\nfunction createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {\n  return {\n    type: 20,\n    index,\n    value,\n    needPauseTracking,\n    inVOnce,\n    needArraySpread: false,\n    loc: locStub\n  };\n}\nfunction createBlockStatement(body) {\n  return {\n    type: 21,\n    body,\n    loc: locStub\n  };\n}\nfunction createTemplateLiteral(elements) {\n  return {\n    type: 22,\n    elements,\n    loc: locStub\n  };\n}\nfunction createIfStatement(test, consequent, alternate) {\n  return {\n    type: 23,\n    test,\n    consequent,\n    alternate,\n    loc: locStub\n  };\n}\nfunction createAssignmentExpression(left, right) {\n  return {\n    type: 24,\n    left,\n    right,\n    loc: locStub\n  };\n}\nfunction createSequenceExpression(expressions) {\n  return {\n    type: 25,\n    expressions,\n    loc: locStub\n  };\n}\nfunction createReturnStatement(returns) {\n  return {\n    type: 26,\n    returns,\n    loc: locStub\n  };\n}\nfunction getVNodeHelper(ssr, isComponent) {\n  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;\n}\nfunction getVNodeBlockHelper(ssr, isComponent) {\n  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;\n}\nfunction convertToBlock(node, { helper, removeHelper, inSSR }) {\n  if (!node.isBlock) {\n    node.isBlock = true;\n    removeHelper(getVNodeHelper(inSSR, node.isComponent));\n    helper(OPEN_BLOCK);\n    helper(getVNodeBlockHelper(inSSR, node.isComponent));\n  }\n}\n\nconst defaultDelimitersOpen = new Uint8Array([123, 123]);\nconst defaultDelimitersClose = new Uint8Array([125, 125]);\nfunction isTagStartChar(c) {\n  return c >= 97 && c <= 122 || c >= 65 && c <= 90;\n}\nfunction isWhitespace(c) {\n  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;\n}\nfunction isEndOfTagSection(c) {\n  return c === 47 || c === 62 || isWhitespace(c);\n}\nfunction toCharCodes(str) {\n  const ret = new Uint8Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    ret[i] = str.charCodeAt(i);\n  }\n  return ret;\n}\nconst Sequences = {\n  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),\n  // CDATA[\n  CdataEnd: new Uint8Array([93, 93, 62]),\n  // ]]>\n  CommentEnd: new Uint8Array([45, 45, 62]),\n  // `-->`\n  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),\n  // `<\\/script`\n  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),\n  // `</style`\n  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),\n  // `</title`\n  TextareaEnd: new Uint8Array([\n    60,\n    47,\n    116,\n    101,\n    120,\n    116,\n    97,\n    114,\n    101,\n    97\n  ])\n  // `</textarea\n};\nclass Tokenizer {\n  constructor(stack, cbs) {\n    this.stack = stack;\n    this.cbs = cbs;\n    /** The current state the tokenizer is in. */\n    this.state = 1;\n    /** The read buffer. */\n    this.buffer = \"\";\n    /** The beginning of the section that is currently being read. */\n    this.sectionStart = 0;\n    /** The index within the buffer that we are currently looking at. */\n    this.index = 0;\n    /** The start of the last entity. */\n    this.entityStart = 0;\n    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n    this.baseState = 1;\n    /** For special parsing behavior inside of script and style tags. */\n    this.inRCDATA = false;\n    /** For disabling RCDATA tags handling */\n    this.inXML = false;\n    /** For disabling interpolation parsing in v-pre */\n    this.inVPre = false;\n    /** Record newline positions for fast line / column calculation */\n    this.newlines = [];\n    this.mode = 0;\n    this.delimiterOpen = defaultDelimitersOpen;\n    this.delimiterClose = defaultDelimitersClose;\n    this.delimiterIndex = -1;\n    this.currentSequence = void 0;\n    this.sequenceIndex = 0;\n  }\n  get inSFCRoot() {\n    return this.mode === 2 && this.stack.length === 0;\n  }\n  reset() {\n    this.state = 1;\n    this.mode = 0;\n    this.buffer = \"\";\n    this.sectionStart = 0;\n    this.index = 0;\n    this.baseState = 1;\n    this.inRCDATA = false;\n    this.currentSequence = void 0;\n    this.newlines.length = 0;\n    this.delimiterOpen = defaultDelimitersOpen;\n    this.delimiterClose = defaultDelimitersClose;\n  }\n  /**\n   * Generate Position object with line / column information using recorded\n   * newline positions. We know the index is always going to be an already\n   * processed index, so all the newlines up to this index should have been\n   * recorded.\n   */\n  getPos(index) {\n    let line = 1;\n    let column = index + 1;\n    for (let i = this.newlines.length - 1; i >= 0; i--) {\n      const newlineIndex = this.newlines[i];\n      if (index > newlineIndex) {\n        line = i + 2;\n        column = index - newlineIndex;\n        break;\n      }\n    }\n    return {\n      column,\n      line,\n      offset: index\n    };\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.index + 1);\n  }\n  stateText(c) {\n    if (c === 60) {\n      if (this.index > this.sectionStart) {\n        this.cbs.ontext(this.sectionStart, this.index);\n      }\n      this.state = 5;\n      this.sectionStart = this.index;\n    } else if (!this.inVPre && c === this.delimiterOpen[0]) {\n      this.state = 2;\n      this.delimiterIndex = 0;\n      this.stateInterpolationOpen(c);\n    }\n  }\n  stateInterpolationOpen(c) {\n    if (c === this.delimiterOpen[this.delimiterIndex]) {\n      if (this.delimiterIndex === this.delimiterOpen.length - 1) {\n        const start = this.index + 1 - this.delimiterOpen.length;\n        if (start > this.sectionStart) {\n          this.cbs.ontext(this.sectionStart, start);\n        }\n        this.state = 3;\n        this.sectionStart = start;\n      } else {\n        this.delimiterIndex++;\n      }\n    } else if (this.inRCDATA) {\n      this.state = 32;\n      this.stateInRCDATA(c);\n    } else {\n      this.state = 1;\n      this.stateText(c);\n    }\n  }\n  stateInterpolation(c) {\n    if (c === this.delimiterClose[0]) {\n      this.state = 4;\n      this.delimiterIndex = 0;\n      this.stateInterpolationClose(c);\n    }\n  }\n  stateInterpolationClose(c) {\n    if (c === this.delimiterClose[this.delimiterIndex]) {\n      if (this.delimiterIndex === this.delimiterClose.length - 1) {\n        this.cbs.oninterpolation(this.sectionStart, this.index + 1);\n        if (this.inRCDATA) {\n          this.state = 32;\n        } else {\n          this.state = 1;\n        }\n        this.sectionStart = this.index + 1;\n      } else {\n        this.delimiterIndex++;\n      }\n    } else {\n      this.state = 3;\n      this.stateInterpolation(c);\n    }\n  }\n  stateSpecialStartSequence(c) {\n    const isEnd = this.sequenceIndex === this.currentSequence.length;\n    const isMatch = isEnd ? (\n      // If we are at the end of the sequence, make sure the tag name has ended\n      isEndOfTagSection(c)\n    ) : (\n      // Otherwise, do a case-insensitive comparison\n      (c | 32) === this.currentSequence[this.sequenceIndex]\n    );\n    if (!isMatch) {\n      this.inRCDATA = false;\n    } else if (!isEnd) {\n      this.sequenceIndex++;\n      return;\n    }\n    this.sequenceIndex = 0;\n    this.state = 6;\n    this.stateInTagName(c);\n  }\n  /** Look for an end tag. For <title> and <textarea>, also decode entities. */\n  stateInRCDATA(c) {\n    if (this.sequenceIndex === this.currentSequence.length) {\n      if (c === 62 || isWhitespace(c)) {\n        const endOfText = this.index - this.currentSequence.length;\n        if (this.sectionStart < endOfText) {\n          const actualIndex = this.index;\n          this.index = endOfText;\n          this.cbs.ontext(this.sectionStart, endOfText);\n          this.index = actualIndex;\n        }\n        this.sectionStart = endOfText + 2;\n        this.stateInClosingTagName(c);\n        this.inRCDATA = false;\n        return;\n      }\n      this.sequenceIndex = 0;\n    }\n    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {\n      this.sequenceIndex += 1;\n    } else if (this.sequenceIndex === 0) {\n      if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {\n        if (!this.inVPre && c === this.delimiterOpen[0]) {\n          this.state = 2;\n          this.delimiterIndex = 0;\n          this.stateInterpolationOpen(c);\n        }\n      } else if (this.fastForwardTo(60)) {\n        this.sequenceIndex = 1;\n      }\n    } else {\n      this.sequenceIndex = Number(c === 60);\n    }\n  }\n  stateCDATASequence(c) {\n    if (c === Sequences.Cdata[this.sequenceIndex]) {\n      if (++this.sequenceIndex === Sequences.Cdata.length) {\n        this.state = 28;\n        this.currentSequence = Sequences.CdataEnd;\n        this.sequenceIndex = 0;\n        this.sectionStart = this.index + 1;\n      }\n    } else {\n      this.sequenceIndex = 0;\n      this.state = 23;\n      this.stateInDeclaration(c);\n    }\n  }\n  /**\n   * When we wait for one specific character, we can speed things up\n   * by skipping through the buffer until we find it.\n   *\n   * @returns Whether the character was found.\n   */\n  fastForwardTo(c) {\n    while (++this.index < this.buffer.length) {\n      const cc = this.buffer.charCodeAt(this.index);\n      if (cc === 10) {\n        this.newlines.push(this.index);\n      }\n      if (cc === c) {\n        return true;\n      }\n    }\n    this.index = this.buffer.length - 1;\n    return false;\n  }\n  /**\n   * Comments and CDATA end with `-->` and `]]>`.\n   *\n   * Their common qualities are:\n   * - Their end sequences have a distinct character they start with.\n   * - That character is then repeated, so we have to check multiple repeats.\n   * - All characters but the start character of the sequence can be skipped.\n   */\n  stateInCommentLike(c) {\n    if (c === this.currentSequence[this.sequenceIndex]) {\n      if (++this.sequenceIndex === this.currentSequence.length) {\n        if (this.currentSequence === Sequences.CdataEnd) {\n          this.cbs.oncdata(this.sectionStart, this.index - 2);\n        } else {\n          this.cbs.oncomment(this.sectionStart, this.index - 2);\n        }\n        this.sequenceIndex = 0;\n        this.sectionStart = this.index + 1;\n        this.state = 1;\n      }\n    } else if (this.sequenceIndex === 0) {\n      if (this.fastForwardTo(this.currentSequence[0])) {\n        this.sequenceIndex = 1;\n      }\n    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n      this.sequenceIndex = 0;\n    }\n  }\n  startSpecial(sequence, offset) {\n    this.enterRCDATA(sequence, offset);\n    this.state = 31;\n  }\n  enterRCDATA(sequence, offset) {\n    this.inRCDATA = true;\n    this.currentSequence = sequence;\n    this.sequenceIndex = offset;\n  }\n  stateBeforeTagName(c) {\n    if (c === 33) {\n      this.state = 22;\n      this.sectionStart = this.index + 1;\n    } else if (c === 63) {\n      this.state = 24;\n      this.sectionStart = this.index + 1;\n    } else if (isTagStartChar(c)) {\n      this.sectionStart = this.index;\n      if (this.mode === 0) {\n        this.state = 6;\n      } else if (this.inSFCRoot) {\n        this.state = 34;\n      } else if (!this.inXML) {\n        if (c === 116) {\n          this.state = 30;\n        } else {\n          this.state = c === 115 ? 29 : 6;\n        }\n      } else {\n        this.state = 6;\n      }\n    } else if (c === 47) {\n      this.state = 8;\n    } else {\n      this.state = 1;\n      this.stateText(c);\n    }\n  }\n  stateInTagName(c) {\n    if (isEndOfTagSection(c)) {\n      this.handleTagName(c);\n    }\n  }\n  stateInSFCRootTagName(c) {\n    if (isEndOfTagSection(c)) {\n      const tag = this.buffer.slice(this.sectionStart, this.index);\n      if (tag !== \"template\") {\n        this.enterRCDATA(toCharCodes(`</` + tag), 0);\n      }\n      this.handleTagName(c);\n    }\n  }\n  handleTagName(c) {\n    this.cbs.onopentagname(this.sectionStart, this.index);\n    this.sectionStart = -1;\n    this.state = 11;\n    this.stateBeforeAttrName(c);\n  }\n  stateBeforeClosingTagName(c) {\n    if (isWhitespace(c)) ; else if (c === 62) {\n      if (!!(process.env.NODE_ENV !== \"production\") || false) {\n        this.cbs.onerr(14, this.index);\n      }\n      this.state = 1;\n      this.sectionStart = this.index + 1;\n    } else {\n      this.state = isTagStartChar(c) ? 9 : 27;\n      this.sectionStart = this.index;\n    }\n  }\n  stateInClosingTagName(c) {\n    if (c === 62 || isWhitespace(c)) {\n      this.cbs.onclosetag(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.state = 10;\n      this.stateAfterClosingTagName(c);\n    }\n  }\n  stateAfterClosingTagName(c) {\n    if (c === 62) {\n      this.state = 1;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateBeforeAttrName(c) {\n    if (c === 62) {\n      this.cbs.onopentagend(this.index);\n      if (this.inRCDATA) {\n        this.state = 32;\n      } else {\n        this.state = 1;\n      }\n      this.sectionStart = this.index + 1;\n    } else if (c === 47) {\n      this.state = 7;\n      if ((!!(process.env.NODE_ENV !== \"production\") || false) && this.peek() !== 62) {\n        this.cbs.onerr(22, this.index);\n      }\n    } else if (c === 60 && this.peek() === 47) {\n      this.cbs.onopentagend(this.index);\n      this.state = 5;\n      this.sectionStart = this.index;\n    } else if (!isWhitespace(c)) {\n      if ((!!(process.env.NODE_ENV !== \"production\") || false) && c === 61) {\n        this.cbs.onerr(\n          19,\n          this.index\n        );\n      }\n      this.handleAttrStart(c);\n    }\n  }\n  handleAttrStart(c) {\n    if (c === 118 && this.peek() === 45) {\n      this.state = 13;\n      this.sectionStart = this.index;\n    } else if (c === 46 || c === 58 || c === 64 || c === 35) {\n      this.cbs.ondirname(this.index, this.index + 1);\n      this.state = 14;\n      this.sectionStart = this.index + 1;\n    } else {\n      this.state = 12;\n      this.sectionStart = this.index;\n    }\n  }\n  stateInSelfClosingTag(c) {\n    if (c === 62) {\n      this.cbs.onselfclosingtag(this.index);\n      this.state = 1;\n      this.sectionStart = this.index + 1;\n      this.inRCDATA = false;\n    } else if (!isWhitespace(c)) {\n      this.state = 11;\n      this.stateBeforeAttrName(c);\n    }\n  }\n  stateInAttrName(c) {\n    if (c === 61 || isEndOfTagSection(c)) {\n      this.cbs.onattribname(this.sectionStart, this.index);\n      this.handleAttrNameEnd(c);\n    } else if ((!!(process.env.NODE_ENV !== \"production\") || false) && (c === 34 || c === 39 || c === 60)) {\n      this.cbs.onerr(\n        17,\n        this.index\n      );\n    }\n  }\n  stateInDirName(c) {\n    if (c === 61 || isEndOfTagSection(c)) {\n      this.cbs.ondirname(this.sectionStart, this.index);\n      this.handleAttrNameEnd(c);\n    } else if (c === 58) {\n      this.cbs.ondirname(this.sectionStart, this.index);\n      this.state = 14;\n      this.sectionStart = this.index + 1;\n    } else if (c === 46) {\n      this.cbs.ondirname(this.sectionStart, this.index);\n      this.state = 16;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateInDirArg(c) {\n    if (c === 61 || isEndOfTagSection(c)) {\n      this.cbs.ondirarg(this.sectionStart, this.index);\n      this.handleAttrNameEnd(c);\n    } else if (c === 91) {\n      this.state = 15;\n    } else if (c === 46) {\n      this.cbs.ondirarg(this.sectionStart, this.index);\n      this.state = 16;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateInDynamicDirArg(c) {\n    if (c === 93) {\n      this.state = 14;\n    } else if (c === 61 || isEndOfTagSection(c)) {\n      this.cbs.ondirarg(this.sectionStart, this.index + 1);\n      this.handleAttrNameEnd(c);\n      if (!!(process.env.NODE_ENV !== \"production\") || false) {\n        this.cbs.onerr(\n          27,\n          this.index\n        );\n      }\n    }\n  }\n  stateInDirModifier(c) {\n    if (c === 61 || isEndOfTagSection(c)) {\n      this.cbs.ondirmodifier(this.sectionStart, this.index);\n      this.handleAttrNameEnd(c);\n    } else if (c === 46) {\n      this.cbs.ondirmodifier(this.sectionStart, this.index);\n      this.sectionStart = this.index + 1;\n    }\n  }\n  handleAttrNameEnd(c) {\n    this.sectionStart = this.index;\n    this.state = 17;\n    this.cbs.onattribnameend(this.index);\n    this.stateAfterAttrName(c);\n  }\n  stateAfterAttrName(c) {\n    if (c === 61) {\n      this.state = 18;\n    } else if (c === 47 || c === 62) {\n      this.cbs.onattribend(0, this.sectionStart);\n      this.sectionStart = -1;\n      this.state = 11;\n      this.stateBeforeAttrName(c);\n    } else if (!isWhitespace(c)) {\n      this.cbs.onattribend(0, this.sectionStart);\n      this.handleAttrStart(c);\n    }\n  }\n  stateBeforeAttrValue(c) {\n    if (c === 34) {\n      this.state = 19;\n      this.sectionStart = this.index + 1;\n    } else if (c === 39) {\n      this.state = 20;\n      this.sectionStart = this.index + 1;\n    } else if (!isWhitespace(c)) {\n      this.sectionStart = this.index;\n      this.state = 21;\n      this.stateInAttrValueNoQuotes(c);\n    }\n  }\n  handleInAttrValue(c, quote) {\n    if (c === quote || this.fastForwardTo(quote)) {\n      this.cbs.onattribdata(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.cbs.onattribend(\n        quote === 34 ? 3 : 2,\n        this.index + 1\n      );\n      this.state = 11;\n    }\n  }\n  stateInAttrValueDoubleQuotes(c) {\n    this.handleInAttrValue(c, 34);\n  }\n  stateInAttrValueSingleQuotes(c) {\n    this.handleInAttrValue(c, 39);\n  }\n  stateInAttrValueNoQuotes(c) {\n    if (isWhitespace(c) || c === 62) {\n      this.cbs.onattribdata(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.cbs.onattribend(1, this.index);\n      this.state = 11;\n      this.stateBeforeAttrName(c);\n    } else if ((!!(process.env.NODE_ENV !== \"production\") || false) && c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {\n      this.cbs.onerr(\n        18,\n        this.index\n      );\n    } else ;\n  }\n  stateBeforeDeclaration(c) {\n    if (c === 91) {\n      this.state = 26;\n      this.sequenceIndex = 0;\n    } else {\n      this.state = c === 45 ? 25 : 23;\n    }\n  }\n  stateInDeclaration(c) {\n    if (c === 62 || this.fastForwardTo(62)) {\n      this.state = 1;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateInProcessingInstruction(c) {\n    if (c === 62 || this.fastForwardTo(62)) {\n      this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n      this.state = 1;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateBeforeComment(c) {\n    if (c === 45) {\n      this.state = 28;\n      this.currentSequence = Sequences.CommentEnd;\n      this.sequenceIndex = 2;\n      this.sectionStart = this.index + 1;\n    } else {\n      this.state = 23;\n    }\n  }\n  stateInSpecialComment(c) {\n    if (c === 62 || this.fastForwardTo(62)) {\n      this.cbs.oncomment(this.sectionStart, this.index);\n      this.state = 1;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateBeforeSpecialS(c) {\n    if (c === Sequences.ScriptEnd[3]) {\n      this.startSpecial(Sequences.ScriptEnd, 4);\n    } else if (c === Sequences.StyleEnd[3]) {\n      this.startSpecial(Sequences.StyleEnd, 4);\n    } else {\n      this.state = 6;\n      this.stateInTagName(c);\n    }\n  }\n  stateBeforeSpecialT(c) {\n    if (c === Sequences.TitleEnd[3]) {\n      this.startSpecial(Sequences.TitleEnd, 4);\n    } else if (c === Sequences.TextareaEnd[3]) {\n      this.startSpecial(Sequences.TextareaEnd, 4);\n    } else {\n      this.state = 6;\n      this.stateInTagName(c);\n    }\n  }\n  startEntity() {\n  }\n  stateInEntity() {\n  }\n  /**\n   * Iterates through the buffer, calling the function corresponding to the current state.\n   *\n   * States that are more likely to be hit are higher up, as a performance improvement.\n   */\n  parse(input) {\n    this.buffer = input;\n    while (this.index < this.buffer.length) {\n      const c = this.buffer.charCodeAt(this.index);\n      if (c === 10 && this.state !== 33) {\n        this.newlines.push(this.index);\n      }\n      switch (this.state) {\n        case 1: {\n          this.stateText(c);\n          break;\n        }\n        case 2: {\n          this.stateInterpolationOpen(c);\n          break;\n        }\n        case 3: {\n          this.stateInterpolation(c);\n          break;\n        }\n        case 4: {\n          this.stateInterpolationClose(c);\n          break;\n        }\n        case 31: {\n          this.stateSpecialStartSequence(c);\n          break;\n        }\n        case 32: {\n          this.stateInRCDATA(c);\n          break;\n        }\n        case 26: {\n          this.stateCDATASequence(c);\n          break;\n        }\n        case 19: {\n          this.stateInAttrValueDoubleQuotes(c);\n          break;\n        }\n        case 12: {\n          this.stateInAttrName(c);\n          break;\n        }\n        case 13: {\n          this.stateInDirName(c);\n          break;\n        }\n        case 14: {\n          this.stateInDirArg(c);\n          break;\n        }\n        case 15: {\n          this.stateInDynamicDirArg(c);\n          break;\n        }\n        case 16: {\n          this.stateInDirModifier(c);\n          break;\n        }\n        case 28: {\n          this.stateInCommentLike(c);\n          break;\n        }\n        case 27: {\n          this.stateInSpecialComment(c);\n          break;\n        }\n        case 11: {\n          this.stateBeforeAttrName(c);\n          break;\n        }\n        case 6: {\n          this.stateInTagName(c);\n          break;\n        }\n        case 34: {\n          this.stateInSFCRootTagName(c);\n          break;\n        }\n        case 9: {\n          this.stateInClosingTagName(c);\n          break;\n        }\n        case 5: {\n          this.stateBeforeTagName(c);\n          break;\n        }\n        case 17: {\n          this.stateAfterAttrName(c);\n          break;\n        }\n        case 20: {\n          this.stateInAttrValueSingleQuotes(c);\n          break;\n        }\n        case 18: {\n          this.stateBeforeAttrValue(c);\n          break;\n        }\n        case 8: {\n          this.stateBeforeClosingTagName(c);\n          break;\n        }\n        case 10: {\n          this.stateAfterClosingTagName(c);\n          break;\n        }\n        case 29: {\n          this.stateBeforeSpecialS(c);\n          break;\n        }\n        case 30: {\n          this.stateBeforeSpecialT(c);\n          break;\n        }\n        case 21: {\n          this.stateInAttrValueNoQuotes(c);\n          break;\n        }\n        case 7: {\n          this.stateInSelfClosingTag(c);\n          break;\n        }\n        case 23: {\n          this.stateInDeclaration(c);\n          break;\n        }\n        case 22: {\n          this.stateBeforeDeclaration(c);\n          break;\n        }\n        case 25: {\n          this.stateBeforeComment(c);\n          break;\n        }\n        case 24: {\n          this.stateInProcessingInstruction(c);\n          break;\n        }\n        case 33: {\n          this.stateInEntity();\n          break;\n        }\n      }\n      this.index++;\n    }\n    this.cleanup();\n    this.finish();\n  }\n  /**\n   * Remove data that has already been consumed from the buffer.\n   */\n  cleanup() {\n    if (this.sectionStart !== this.index) {\n      if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {\n        this.cbs.ontext(this.sectionStart, this.index);\n        this.sectionStart = this.index;\n      } else if (this.state === 19 || this.state === 20 || this.state === 21) {\n        this.cbs.onattribdata(this.sectionStart, this.index);\n        this.sectionStart = this.index;\n      }\n    }\n  }\n  finish() {\n    this.handleTrailingData();\n    this.cbs.onend();\n  }\n  /** Handle any trailing data. */\n  handleTrailingData() {\n    const endIndex = this.buffer.length;\n    if (this.sectionStart >= endIndex) {\n      return;\n    }\n    if (this.state === 28) {\n      if (this.currentSequence === Sequences.CdataEnd) {\n        this.cbs.oncdata(this.sectionStart, endIndex);\n      } else {\n        this.cbs.oncomment(this.sectionStart, endIndex);\n      }\n    } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ; else {\n      this.cbs.ontext(this.sectionStart, endIndex);\n    }\n  }\n  emitCodePoint(cp, consumed) {\n  }\n}\n\nconst CompilerDeprecationTypes = {\n  \"COMPILER_IS_ON_ELEMENT\": \"COMPILER_IS_ON_ELEMENT\",\n  \"COMPILER_V_BIND_SYNC\": \"COMPILER_V_BIND_SYNC\",\n  \"COMPILER_V_BIND_OBJECT_ORDER\": \"COMPILER_V_BIND_OBJECT_ORDER\",\n  \"COMPILER_V_ON_NATIVE\": \"COMPILER_V_ON_NATIVE\",\n  \"COMPILER_V_IF_V_FOR_PRECEDENCE\": \"COMPILER_V_IF_V_FOR_PRECEDENCE\",\n  \"COMPILER_NATIVE_TEMPLATE\": \"COMPILER_NATIVE_TEMPLATE\",\n  \"COMPILER_INLINE_TEMPLATE\": \"COMPILER_INLINE_TEMPLATE\",\n  \"COMPILER_FILTERS\": \"COMPILER_FILTERS\"\n};\nconst deprecationData = {\n  [\"COMPILER_IS_ON_ELEMENT\"]: {\n    message: `Platform-native elements with \"is\" prop will no longer be treated as components in Vue 3 unless the \"is\" value is explicitly prefixed with \"vue:\".`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`\n  },\n  [\"COMPILER_V_BIND_SYNC\"]: {\n    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \\`v-bind:${key}.sync\\` should be changed to \\`v-model:${key}\\`.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\n  },\n  [\"COMPILER_V_BIND_OBJECT_ORDER\"]: {\n    message: `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`\n  },\n  [\"COMPILER_V_ON_NATIVE\"]: {\n    message: `.native modifier for v-on has been removed as is no longer necessary.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`\n  },\n  [\"COMPILER_V_IF_V_FOR_PRECEDENCE\"]: {\n    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`\n  },\n  [\"COMPILER_NATIVE_TEMPLATE\"]: {\n    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`\n  },\n  [\"COMPILER_INLINE_TEMPLATE\"]: {\n    message: `\"inline-template\" has been removed in Vue 3.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`\n  },\n  [\"COMPILER_FILTERS\"]: {\n    message: `filters have been removed in Vue 3. The \"|\" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\n  }\n};\nfunction getCompatValue(key, { compatConfig }) {\n  const value = compatConfig && compatConfig[key];\n  if (key === \"MODE\") {\n    return value || 3;\n  } else {\n    return value;\n  }\n}\nfunction isCompatEnabled(key, context) {\n  const mode = getCompatValue(\"MODE\", context);\n  const value = getCompatValue(key, context);\n  return mode === 3 ? value === true : value !== false;\n}\nfunction checkCompatEnabled(key, context, loc, ...args) {\n  const enabled = isCompatEnabled(key, context);\n  if (!!(process.env.NODE_ENV !== \"production\") && enabled) {\n    warnDeprecation(key, context, loc, ...args);\n  }\n  return enabled;\n}\nfunction warnDeprecation(key, context, loc, ...args) {\n  const val = getCompatValue(key, context);\n  if (val === \"suppress-warning\") {\n    return;\n  }\n  const { message, link } = deprecationData[key];\n  const msg = `(deprecation ${key}) ${typeof message === \"function\" ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;\n  const err = new SyntaxError(msg);\n  err.code = key;\n  if (loc) err.loc = loc;\n  context.onWarn(err);\n}\n\nfunction defaultOnError(error) {\n  throw error;\n}\nfunction defaultOnWarn(msg) {\n  !!(process.env.NODE_ENV !== \"production\") && console.warn(`[Vue warn] ${msg.message}`);\n}\nfunction createCompilerError(code, loc, messages, additionalMessage) {\n  const msg = !!(process.env.NODE_ENV !== \"production\") || false ? (messages || errorMessages)[code] + (additionalMessage || ``) : `https://vuejs.org/error-reference/#compiler-${code}`;\n  const error = new SyntaxError(String(msg));\n  error.code = code;\n  error.loc = loc;\n  return error;\n}\nconst ErrorCodes = {\n  \"ABRUPT_CLOSING_OF_EMPTY_COMMENT\": 0,\n  \"0\": \"ABRUPT_CLOSING_OF_EMPTY_COMMENT\",\n  \"CDATA_IN_HTML_CONTENT\": 1,\n  \"1\": \"CDATA_IN_HTML_CONTENT\",\n  \"DUPLICATE_ATTRIBUTE\": 2,\n  \"2\": \"DUPLICATE_ATTRIBUTE\",\n  \"END_TAG_WITH_ATTRIBUTES\": 3,\n  \"3\": \"END_TAG_WITH_ATTRIBUTES\",\n  \"END_TAG_WITH_TRAILING_SOLIDUS\": 4,\n  \"4\": \"END_TAG_WITH_TRAILING_SOLIDUS\",\n  \"EOF_BEFORE_TAG_NAME\": 5,\n  \"5\": \"EOF_BEFORE_TAG_NAME\",\n  \"EOF_IN_CDATA\": 6,\n  \"6\": \"EOF_IN_CDATA\",\n  \"EOF_IN_COMMENT\": 7,\n  \"7\": \"EOF_IN_COMMENT\",\n  \"EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT\": 8,\n  \"8\": \"EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT\",\n  \"EOF_IN_TAG\": 9,\n  \"9\": \"EOF_IN_TAG\",\n  \"INCORRECTLY_CLOSED_COMMENT\": 10,\n  \"10\": \"INCORRECTLY_CLOSED_COMMENT\",\n  \"INCORRECTLY_OPENED_COMMENT\": 11,\n  \"11\": \"INCORRECTLY_OPENED_COMMENT\",\n  \"INVALID_FIRST_CHARACTER_OF_TAG_NAME\": 12,\n  \"12\": \"INVALID_FIRST_CHARACTER_OF_TAG_NAME\",\n  \"MISSING_ATTRIBUTE_VALUE\": 13,\n  \"13\": \"MISSING_ATTRIBUTE_VALUE\",\n  \"MISSING_END_TAG_NAME\": 14,\n  \"14\": \"MISSING_END_TAG_NAME\",\n  \"MISSING_WHITESPACE_BETWEEN_ATTRIBUTES\": 15,\n  \"15\": \"MISSING_WHITESPACE_BETWEEN_ATTRIBUTES\",\n  \"NESTED_COMMENT\": 16,\n  \"16\": \"NESTED_COMMENT\",\n  \"UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME\": 17,\n  \"17\": \"UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME\",\n  \"UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE\": 18,\n  \"18\": \"UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE\",\n  \"UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME\": 19,\n  \"19\": \"UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME\",\n  \"UNEXPECTED_NULL_CHARACTER\": 20,\n  \"20\": \"UNEXPECTED_NULL_CHARACTER\",\n  \"UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME\": 21,\n  \"21\": \"UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME\",\n  \"UNEXPECTED_SOLIDUS_IN_TAG\": 22,\n  \"22\": \"UNEXPECTED_SOLIDUS_IN_TAG\",\n  \"X_INVALID_END_TAG\": 23,\n  \"23\": \"X_INVALID_END_TAG\",\n  \"X_MISSING_END_TAG\": 24,\n  \"24\": \"X_MISSING_END_TAG\",\n  \"X_MISSING_INTERPOLATION_END\": 25,\n  \"25\": \"X_MISSING_INTERPOLATION_END\",\n  \"X_MISSING_DIRECTIVE_NAME\": 26,\n  \"26\": \"X_MISSING_DIRECTIVE_NAME\",\n  \"X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\": 27,\n  \"27\": \"X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\",\n  \"X_V_IF_NO_EXPRESSION\": 28,\n  \"28\": \"X_V_IF_NO_EXPRESSION\",\n  \"X_V_IF_SAME_KEY\": 29,\n  \"29\": \"X_V_IF_SAME_KEY\",\n  \"X_V_ELSE_NO_ADJACENT_IF\": 30,\n  \"30\": \"X_V_ELSE_NO_ADJACENT_IF\",\n  \"X_V_FOR_NO_EXPRESSION\": 31,\n  \"31\": \"X_V_FOR_NO_EXPRESSION\",\n  \"X_V_FOR_MALFORMED_EXPRESSION\": 32,\n  \"32\": \"X_V_FOR_MALFORMED_EXPRESSION\",\n  \"X_V_FOR_TEMPLATE_KEY_PLACEMENT\": 33,\n  \"33\": \"X_V_FOR_TEMPLATE_KEY_PLACEMENT\",\n  \"X_V_BIND_NO_EXPRESSION\": 34,\n  \"34\": \"X_V_BIND_NO_EXPRESSION\",\n  \"X_V_ON_NO_EXPRESSION\": 35,\n  \"35\": \"X_V_ON_NO_EXPRESSION\",\n  \"X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET\": 36,\n  \"36\": \"X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET\",\n  \"X_V_SLOT_MIXED_SLOT_USAGE\": 37,\n  \"37\": \"X_V_SLOT_MIXED_SLOT_USAGE\",\n  \"X_V_SLOT_DUPLICATE_SLOT_NAMES\": 38,\n  \"38\": \"X_V_SLOT_DUPLICATE_SLOT_NAMES\",\n  \"X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN\": 39,\n  \"39\": \"X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN\",\n  \"X_V_SLOT_MISPLACED\": 40,\n  \"40\": \"X_V_SLOT_MISPLACED\",\n  \"X_V_MODEL_NO_EXPRESSION\": 41,\n  \"41\": \"X_V_MODEL_NO_EXPRESSION\",\n  \"X_V_MODEL_MALFORMED_EXPRESSION\": 42,\n  \"42\": \"X_V_MODEL_MALFORMED_EXPRESSION\",\n  \"X_V_MODEL_ON_SCOPE_VARIABLE\": 43,\n  \"43\": \"X_V_MODEL_ON_SCOPE_VARIABLE\",\n  \"X_V_MODEL_ON_PROPS\": 44,\n  \"44\": \"X_V_MODEL_ON_PROPS\",\n  \"X_INVALID_EXPRESSION\": 45,\n  \"45\": \"X_INVALID_EXPRESSION\",\n  \"X_KEEP_ALIVE_INVALID_CHILDREN\": 46,\n  \"46\": \"X_KEEP_ALIVE_INVALID_CHILDREN\",\n  \"X_PREFIX_ID_NOT_SUPPORTED\": 47,\n  \"47\": \"X_PREFIX_ID_NOT_SUPPORTED\",\n  \"X_MODULE_MODE_NOT_SUPPORTED\": 48,\n  \"48\": \"X_MODULE_MODE_NOT_SUPPORTED\",\n  \"X_CACHE_HANDLER_NOT_SUPPORTED\": 49,\n  \"49\": \"X_CACHE_HANDLER_NOT_SUPPORTED\",\n  \"X_SCOPE_ID_NOT_SUPPORTED\": 50,\n  \"50\": \"X_SCOPE_ID_NOT_SUPPORTED\",\n  \"X_VNODE_HOOKS\": 51,\n  \"51\": \"X_VNODE_HOOKS\",\n  \"X_V_BIND_INVALID_SAME_NAME_ARGUMENT\": 52,\n  \"52\": \"X_V_BIND_INVALID_SAME_NAME_ARGUMENT\",\n  \"__EXTEND_POINT__\": 53,\n  \"53\": \"__EXTEND_POINT__\"\n};\nconst errorMessages = {\n  // parse errors\n  [0]: \"Illegal comment.\",\n  [1]: \"CDATA section is allowed only in XML context.\",\n  [2]: \"Duplicate attribute.\",\n  [3]: \"End tag cannot have attributes.\",\n  [4]: \"Illegal '/' in tags.\",\n  [5]: \"Unexpected EOF in tag.\",\n  [6]: \"Unexpected EOF in CDATA section.\",\n  [7]: \"Unexpected EOF in comment.\",\n  [8]: \"Unexpected EOF in script.\",\n  [9]: \"Unexpected EOF in tag.\",\n  [10]: \"Incorrectly closed comment.\",\n  [11]: \"Incorrectly opened comment.\",\n  [12]: \"Illegal tag name. Use '&lt;' to print '<'.\",\n  [13]: \"Attribute value was expected.\",\n  [14]: \"End tag name was expected.\",\n  [15]: \"Whitespace was expected.\",\n  [16]: \"Unexpected '<!--' in comment.\",\n  [17]: `Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).`,\n  [18]: \"Unquoted attribute value cannot contain U+0022 (\\\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).\",\n  [19]: \"Attribute name cannot start with '='.\",\n  [21]: \"'<?' is allowed only in XML context.\",\n  [20]: `Unexpected null character.`,\n  [22]: \"Illegal '/' in tags.\",\n  // Vue-specific parse errors\n  [23]: \"Invalid end tag.\",\n  [24]: \"Element is missing end tag.\",\n  [25]: \"Interpolation end sign was not found.\",\n  [27]: \"End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.\",\n  [26]: \"Legal directive name was expected.\",\n  // transform errors\n  [28]: `v-if/v-else-if is missing expression.`,\n  [29]: `v-if/else branches must use unique keys.`,\n  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\n  [31]: `v-for is missing expression.`,\n  [32]: `v-for has invalid expression.`,\n  [33]: `<template v-for> key should be placed on the <template> tag.`,\n  [34]: `v-bind is missing expression.`,\n  [52]: `v-bind with same-name shorthand only allows static argument.`,\n  [35]: `v-on is missing expression.`,\n  [36]: `Unexpected custom directive on <slot> outlet.`,\n  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,\n  [38]: `Duplicate slot names found. `,\n  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,\n  [40]: `v-slot can only be used on components or <template> tags.`,\n  [41]: `v-model is missing expression.`,\n  [42]: `v-model value must be a valid JavaScript member expression.`,\n  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,\n  [45]: `Error parsing JavaScript expression: `,\n  [46]: `<KeepAlive> expects exactly one child component.`,\n  [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,\n  // generic errors\n  [47]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n  [48]: `ES module mode is not supported in this build of compiler.`,\n  [49]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\n  [50]: `\"scopeId\" option is only supported in module mode.`,\n  // just to fulfill types\n  [53]: ``\n};\n\nfunction walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {\n  {\n    return;\n  }\n}\nfunction isReferencedIdentifier(id, parent, parentStack) {\n  {\n    return false;\n  }\n}\nfunction isInDestructureAssignment(parent, parentStack) {\n  if (parent && (parent.type === \"ObjectProperty\" || parent.type === \"ArrayPattern\")) {\n    let i = parentStack.length;\n    while (i--) {\n      const p = parentStack[i];\n      if (p.type === \"AssignmentExpression\") {\n        return true;\n      } else if (p.type !== \"ObjectProperty\" && !p.type.endsWith(\"Pattern\")) {\n        break;\n      }\n    }\n  }\n  return false;\n}\nfunction isInNewExpression(parentStack) {\n  let i = parentStack.length;\n  while (i--) {\n    const p = parentStack[i];\n    if (p.type === \"NewExpression\") {\n      return true;\n    } else if (p.type !== \"MemberExpression\") {\n      break;\n    }\n  }\n  return false;\n}\nfunction walkFunctionParams(node, onIdent) {\n  for (const p of node.params) {\n    for (const id of extractIdentifiers(p)) {\n      onIdent(id);\n    }\n  }\n}\nfunction walkBlockDeclarations(block, onIdent) {\n  const body = block.type === \"SwitchCase\" ? block.consequent : block.body;\n  for (const stmt of body) {\n    if (stmt.type === \"VariableDeclaration\") {\n      if (stmt.declare) continue;\n      for (const decl of stmt.declarations) {\n        for (const id of extractIdentifiers(decl.id)) {\n          onIdent(id);\n        }\n      }\n    } else if (stmt.type === \"FunctionDeclaration\" || stmt.type === \"ClassDeclaration\") {\n      if (stmt.declare || !stmt.id) continue;\n      onIdent(stmt.id);\n    } else if (isForStatement(stmt)) {\n      walkForStatement(stmt, true, onIdent);\n    } else if (stmt.type === \"SwitchStatement\") {\n      walkSwitchStatement(stmt, true, onIdent);\n    }\n  }\n}\nfunction isForStatement(stmt) {\n  return stmt.type === \"ForOfStatement\" || stmt.type === \"ForInStatement\" || stmt.type === \"ForStatement\";\n}\nfunction walkForStatement(stmt, isVar, onIdent) {\n  const variable = stmt.type === \"ForStatement\" ? stmt.init : stmt.left;\n  if (variable && variable.type === \"VariableDeclaration\" && (variable.kind === \"var\" ? isVar : !isVar)) {\n    for (const decl of variable.declarations) {\n      for (const id of extractIdentifiers(decl.id)) {\n        onIdent(id);\n      }\n    }\n  }\n}\nfunction walkSwitchStatement(stmt, isVar, onIdent) {\n  for (const cs of stmt.cases) {\n    for (const stmt2 of cs.consequent) {\n      if (stmt2.type === \"VariableDeclaration\" && (stmt2.kind === \"var\" ? isVar : !isVar)) {\n        for (const decl of stmt2.declarations) {\n          for (const id of extractIdentifiers(decl.id)) {\n            onIdent(id);\n          }\n        }\n      }\n    }\n    walkBlockDeclarations(cs, onIdent);\n  }\n}\nfunction extractIdentifiers(param, nodes = []) {\n  switch (param.type) {\n    case \"Identifier\":\n      nodes.push(param);\n      break;\n    case \"MemberExpression\":\n      let object = param;\n      while (object.type === \"MemberExpression\") {\n        object = object.object;\n      }\n      nodes.push(object);\n      break;\n    case \"ObjectPattern\":\n      for (const prop of param.properties) {\n        if (prop.type === \"RestElement\") {\n          extractIdentifiers(prop.argument, nodes);\n        } else {\n          extractIdentifiers(prop.value, nodes);\n        }\n      }\n      break;\n    case \"ArrayPattern\":\n      param.elements.forEach((element) => {\n        if (element) extractIdentifiers(element, nodes);\n      });\n      break;\n    case \"RestElement\":\n      extractIdentifiers(param.argument, nodes);\n      break;\n    case \"AssignmentPattern\":\n      extractIdentifiers(param.left, nodes);\n      break;\n  }\n  return nodes;\n}\nconst isFunctionType = (node) => {\n  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);\n};\nconst isStaticProperty = (node) => node && (node.type === \"ObjectProperty\" || node.type === \"ObjectMethod\") && !node.computed;\nconst isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;\nconst TS_NODE_TYPES = [\n  \"TSAsExpression\",\n  // foo as number\n  \"TSTypeAssertion\",\n  // (<number>foo)\n  \"TSNonNullExpression\",\n  // foo!\n  \"TSInstantiationExpression\",\n  // foo<string>\n  \"TSSatisfiesExpression\"\n  // foo satisfies T\n];\nfunction unwrapTSNode(node) {\n  if (TS_NODE_TYPES.includes(node.type)) {\n    return unwrapTSNode(node.expression);\n  } else {\n    return node;\n  }\n}\n\nconst isStaticExp = (p) => p.type === 4 && p.isStatic;\nfunction isCoreComponent(tag) {\n  switch (tag) {\n    case \"Teleport\":\n    case \"teleport\":\n      return TELEPORT;\n    case \"Suspense\":\n    case \"suspense\":\n      return SUSPENSE;\n    case \"KeepAlive\":\n    case \"keep-alive\":\n      return KEEP_ALIVE;\n    case \"BaseTransition\":\n    case \"base-transition\":\n      return BASE_TRANSITION;\n  }\n}\nconst nonIdentifierRE = /^$|^\\d|[^\\$\\w\\xA0-\\uFFFF]/;\nconst isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/;\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/;\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g;\nconst getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;\nconst isMemberExpressionBrowser = (exp) => {\n  const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());\n  let state = 0 /* inMemberExp */;\n  let stateStack = [];\n  let currentOpenBracketCount = 0;\n  let currentOpenParensCount = 0;\n  let currentStringType = null;\n  for (let i = 0; i < path.length; i++) {\n    const char = path.charAt(i);\n    switch (state) {\n      case 0 /* inMemberExp */:\n        if (char === \"[\") {\n          stateStack.push(state);\n          state = 1 /* inBrackets */;\n          currentOpenBracketCount++;\n        } else if (char === \"(\") {\n          stateStack.push(state);\n          state = 2 /* inParens */;\n          currentOpenParensCount++;\n        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {\n          return false;\n        }\n        break;\n      case 1 /* inBrackets */:\n        if (char === `'` || char === `\"` || char === \"`\") {\n          stateStack.push(state);\n          state = 3 /* inString */;\n          currentStringType = char;\n        } else if (char === `[`) {\n          currentOpenBracketCount++;\n        } else if (char === `]`) {\n          if (!--currentOpenBracketCount) {\n            state = stateStack.pop();\n          }\n        }\n        break;\n      case 2 /* inParens */:\n        if (char === `'` || char === `\"` || char === \"`\") {\n          stateStack.push(state);\n          state = 3 /* inString */;\n          currentStringType = char;\n        } else if (char === `(`) {\n          currentOpenParensCount++;\n        } else if (char === `)`) {\n          if (i === path.length - 1) {\n            return false;\n          }\n          if (!--currentOpenParensCount) {\n            state = stateStack.pop();\n          }\n        }\n        break;\n      case 3 /* inString */:\n        if (char === currentStringType) {\n          state = stateStack.pop();\n          currentStringType = null;\n        }\n        break;\n    }\n  }\n  return !currentOpenBracketCount && !currentOpenParensCount;\n};\nconst isMemberExpressionNode = NOOP ;\nconst isMemberExpression = isMemberExpressionBrowser ;\nconst fnExpRE = /^\\s*(?:async\\s*)?(?:\\([^)]*?\\)|[\\w$_]+)\\s*(?::[^=]+)?=>|^\\s*(?:async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/;\nconst isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));\nconst isFnExpressionNode = NOOP ;\nconst isFnExpression = isFnExpressionBrowser ;\nfunction advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\n  return advancePositionWithMutation(\n    {\n      offset: pos.offset,\n      line: pos.line,\n      column: pos.column\n    },\n    source,\n    numberOfCharacters\n  );\n}\nfunction advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\n  let linesCount = 0;\n  let lastNewLinePos = -1;\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10) {\n      linesCount++;\n      lastNewLinePos = i;\n    }\n  }\n  pos.offset += numberOfCharacters;\n  pos.line += linesCount;\n  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;\n  return pos;\n}\nfunction assert(condition, msg) {\n  if (!condition) {\n    throw new Error(msg || `unexpected compiler condition`);\n  }\n}\nfunction findDir(node, name, allowEmpty = false) {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {\n      return p;\n    }\n  }\n}\nfunction findProp(node, name, dynamicOnly = false, allowEmpty = false) {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 6) {\n      if (dynamicOnly) continue;\n      if (p.name === name && (p.value || allowEmpty)) {\n        return p;\n      }\n    } else if (p.name === \"bind\" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {\n      return p;\n    }\n  }\n}\nfunction isStaticArgOf(arg, name) {\n  return !!(arg && isStaticExp(arg) && arg.content === name);\n}\nfunction hasDynamicKeyVBind(node) {\n  return node.props.some(\n    (p) => p.type === 7 && p.name === \"bind\" && (!p.arg || // v-bind=\"obj\"\n    p.arg.type !== 4 || // v-bind:[_ctx.foo]\n    !p.arg.isStatic)\n    // v-bind:[foo]\n  );\n}\nfunction isText$1(node) {\n  return node.type === 5 || node.type === 2;\n}\nfunction isVPre(p) {\n  return p.type === 7 && p.name === \"pre\";\n}\nfunction isVSlot(p) {\n  return p.type === 7 && p.name === \"slot\";\n}\nfunction isTemplateNode(node) {\n  return node.type === 1 && node.tagType === 3;\n}\nfunction isSlotOutlet(node) {\n  return node.type === 1 && node.tagType === 2;\n}\nconst propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);\nfunction getUnnormalizedProps(props, callPath = []) {\n  if (props && !isString(props) && props.type === 14) {\n    const callee = props.callee;\n    if (!isString(callee) && propsHelperSet.has(callee)) {\n      return getUnnormalizedProps(\n        props.arguments[0],\n        callPath.concat(props)\n      );\n    }\n  }\n  return [props, callPath];\n}\nfunction injectProp(node, prop, context) {\n  let propsWithInjection;\n  let props = node.type === 13 ? node.props : node.arguments[2];\n  let callPath = [];\n  let parentCall;\n  if (props && !isString(props) && props.type === 14) {\n    const ret = getUnnormalizedProps(props);\n    props = ret[0];\n    callPath = ret[1];\n    parentCall = callPath[callPath.length - 1];\n  }\n  if (props == null || isString(props)) {\n    propsWithInjection = createObjectExpression([prop]);\n  } else if (props.type === 14) {\n    const first = props.arguments[0];\n    if (!isString(first) && first.type === 15) {\n      if (!hasProp(prop, first)) {\n        first.properties.unshift(prop);\n      }\n    } else {\n      if (props.callee === TO_HANDLERS) {\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n          createObjectExpression([prop]),\n          props\n        ]);\n      } else {\n        props.arguments.unshift(createObjectExpression([prop]));\n      }\n    }\n    !propsWithInjection && (propsWithInjection = props);\n  } else if (props.type === 15) {\n    if (!hasProp(prop, props)) {\n      props.properties.unshift(prop);\n    }\n    propsWithInjection = props;\n  } else {\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n      createObjectExpression([prop]),\n      props\n    ]);\n    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\n      parentCall = callPath[callPath.length - 2];\n    }\n  }\n  if (node.type === 13) {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection;\n    } else {\n      node.props = propsWithInjection;\n    }\n  } else {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection;\n    } else {\n      node.arguments[2] = propsWithInjection;\n    }\n  }\n}\nfunction hasProp(prop, props) {\n  let result = false;\n  if (prop.key.type === 4) {\n    const propKeyName = prop.key.content;\n    result = props.properties.some(\n      (p) => p.key.type === 4 && p.key.content === propKeyName\n    );\n  }\n  return result;\n}\nfunction toValidAssetId(name, type) {\n  return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\n    return searchValue === \"-\" ? \"_\" : name.charCodeAt(replaceValue).toString();\n  })}`;\n}\nfunction hasScopeRef(node, ids) {\n  if (!node || Object.keys(ids).length === 0) {\n    return false;\n  }\n  switch (node.type) {\n    case 1:\n      for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i];\n        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {\n          return true;\n        }\n      }\n      return node.children.some((c) => hasScopeRef(c, ids));\n    case 11:\n      if (hasScopeRef(node.source, ids)) {\n        return true;\n      }\n      return node.children.some((c) => hasScopeRef(c, ids));\n    case 9:\n      return node.branches.some((b) => hasScopeRef(b, ids));\n    case 10:\n      if (hasScopeRef(node.condition, ids)) {\n        return true;\n      }\n      return node.children.some((c) => hasScopeRef(c, ids));\n    case 4:\n      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];\n    case 8:\n      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));\n    case 5:\n    case 12:\n      return hasScopeRef(node.content, ids);\n    case 2:\n    case 3:\n    case 20:\n      return false;\n    default:\n      if (!!(process.env.NODE_ENV !== \"production\")) ;\n      return false;\n  }\n}\nfunction getMemoedVNodeCall(node) {\n  if (node.type === 14 && node.callee === WITH_MEMO) {\n    return node.arguments[1].returns;\n  } else {\n    return node;\n  }\n}\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+(\\S[\\s\\S]*)/;\n\nconst defaultParserOptions = {\n  parseMode: \"base\",\n  ns: 0,\n  delimiters: [`{{`, `}}`],\n  getNamespace: () => 0,\n  isVoidTag: NO,\n  isPreTag: NO,\n  isIgnoreNewlineTag: NO,\n  isCustomElement: NO,\n  onError: defaultOnError,\n  onWarn: defaultOnWarn,\n  comments: !!(process.env.NODE_ENV !== \"production\"),\n  prefixIdentifiers: false\n};\nlet currentOptions = defaultParserOptions;\nlet currentRoot = null;\nlet currentInput = \"\";\nlet currentOpenTag = null;\nlet currentProp = null;\nlet currentAttrValue = \"\";\nlet currentAttrStartIndex = -1;\nlet currentAttrEndIndex = -1;\nlet inPre = 0;\nlet inVPre = false;\nlet currentVPreBoundary = null;\nconst stack = [];\nconst tokenizer = new Tokenizer(stack, {\n  onerr: emitError,\n  ontext(start, end) {\n    onText(getSlice(start, end), start, end);\n  },\n  ontextentity(char, start, end) {\n    onText(char, start, end);\n  },\n  oninterpolation(start, end) {\n    if (inVPre) {\n      return onText(getSlice(start, end), start, end);\n    }\n    let innerStart = start + tokenizer.delimiterOpen.length;\n    let innerEnd = end - tokenizer.delimiterClose.length;\n    while (isWhitespace(currentInput.charCodeAt(innerStart))) {\n      innerStart++;\n    }\n    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {\n      innerEnd--;\n    }\n    let exp = getSlice(innerStart, innerEnd);\n    if (exp.includes(\"&\")) {\n      {\n        exp = currentOptions.decodeEntities(exp, false);\n      }\n    }\n    addNode({\n      type: 5,\n      content: createExp(exp, false, getLoc(innerStart, innerEnd)),\n      loc: getLoc(start, end)\n    });\n  },\n  onopentagname(start, end) {\n    const name = getSlice(start, end);\n    currentOpenTag = {\n      type: 1,\n      tag: name,\n      ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),\n      tagType: 0,\n      // will be refined on tag close\n      props: [],\n      children: [],\n      loc: getLoc(start - 1, end),\n      codegenNode: void 0\n    };\n  },\n  onopentagend(end) {\n    endOpenTag(end);\n  },\n  onclosetag(start, end) {\n    const name = getSlice(start, end);\n    if (!currentOptions.isVoidTag(name)) {\n      let found = false;\n      for (let i = 0; i < stack.length; i++) {\n        const e = stack[i];\n        if (e.tag.toLowerCase() === name.toLowerCase()) {\n          found = true;\n          if (i > 0) {\n            emitError(24, stack[0].loc.start.offset);\n          }\n          for (let j = 0; j <= i; j++) {\n            const el = stack.shift();\n            onCloseTag(el, end, j < i);\n          }\n          break;\n        }\n      }\n      if (!found) {\n        emitError(23, backTrack(start, 60));\n      }\n    }\n  },\n  onselfclosingtag(end) {\n    const name = currentOpenTag.tag;\n    currentOpenTag.isSelfClosing = true;\n    endOpenTag(end);\n    if (stack[0] && stack[0].tag === name) {\n      onCloseTag(stack.shift(), end);\n    }\n  },\n  onattribname(start, end) {\n    currentProp = {\n      type: 6,\n      name: getSlice(start, end),\n      nameLoc: getLoc(start, end),\n      value: void 0,\n      loc: getLoc(start)\n    };\n  },\n  ondirname(start, end) {\n    const raw = getSlice(start, end);\n    const name = raw === \".\" || raw === \":\" ? \"bind\" : raw === \"@\" ? \"on\" : raw === \"#\" ? \"slot\" : raw.slice(2);\n    if (!inVPre && name === \"\") {\n      emitError(26, start);\n    }\n    if (inVPre || name === \"\") {\n      currentProp = {\n        type: 6,\n        name: raw,\n        nameLoc: getLoc(start, end),\n        value: void 0,\n        loc: getLoc(start)\n      };\n    } else {\n      currentProp = {\n        type: 7,\n        name,\n        rawName: raw,\n        exp: void 0,\n        arg: void 0,\n        modifiers: raw === \".\" ? [createSimpleExpression(\"prop\")] : [],\n        loc: getLoc(start)\n      };\n      if (name === \"pre\") {\n        inVPre = tokenizer.inVPre = true;\n        currentVPreBoundary = currentOpenTag;\n        const props = currentOpenTag.props;\n        for (let i = 0; i < props.length; i++) {\n          if (props[i].type === 7) {\n            props[i] = dirToAttr(props[i]);\n          }\n        }\n      }\n    }\n  },\n  ondirarg(start, end) {\n    if (start === end) return;\n    const arg = getSlice(start, end);\n    if (inVPre && !isVPre(currentProp)) {\n      currentProp.name += arg;\n      setLocEnd(currentProp.nameLoc, end);\n    } else {\n      const isStatic = arg[0] !== `[`;\n      currentProp.arg = createExp(\n        isStatic ? arg : arg.slice(1, -1),\n        isStatic,\n        getLoc(start, end),\n        isStatic ? 3 : 0\n      );\n    }\n  },\n  ondirmodifier(start, end) {\n    const mod = getSlice(start, end);\n    if (inVPre && !isVPre(currentProp)) {\n      currentProp.name += \".\" + mod;\n      setLocEnd(currentProp.nameLoc, end);\n    } else if (currentProp.name === \"slot\") {\n      const arg = currentProp.arg;\n      if (arg) {\n        arg.content += \".\" + mod;\n        setLocEnd(arg.loc, end);\n      }\n    } else {\n      const exp = createSimpleExpression(mod, true, getLoc(start, end));\n      currentProp.modifiers.push(exp);\n    }\n  },\n  onattribdata(start, end) {\n    currentAttrValue += getSlice(start, end);\n    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;\n    currentAttrEndIndex = end;\n  },\n  onattribentity(char, start, end) {\n    currentAttrValue += char;\n    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;\n    currentAttrEndIndex = end;\n  },\n  onattribnameend(end) {\n    const start = currentProp.loc.start.offset;\n    const name = getSlice(start, end);\n    if (currentProp.type === 7) {\n      currentProp.rawName = name;\n    }\n    if (currentOpenTag.props.some(\n      (p) => (p.type === 7 ? p.rawName : p.name) === name\n    )) {\n      emitError(2, start);\n    }\n  },\n  onattribend(quote, end) {\n    if (currentOpenTag && currentProp) {\n      setLocEnd(currentProp.loc, end);\n      if (quote !== 0) {\n        if (currentAttrValue.includes(\"&\")) {\n          currentAttrValue = currentOptions.decodeEntities(\n            currentAttrValue,\n            true\n          );\n        }\n        if (currentProp.type === 6) {\n          if (currentProp.name === \"class\") {\n            currentAttrValue = condense(currentAttrValue).trim();\n          }\n          if (quote === 1 && !currentAttrValue) {\n            emitError(13, end);\n          }\n          currentProp.value = {\n            type: 2,\n            content: currentAttrValue,\n            loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)\n          };\n          if (tokenizer.inSFCRoot && currentOpenTag.tag === \"template\" && currentProp.name === \"lang\" && currentAttrValue && currentAttrValue !== \"html\") {\n            tokenizer.enterRCDATA(toCharCodes(`</template`), 0);\n          }\n        } else {\n          let expParseMode = 0 /* Normal */;\n          currentProp.exp = createExp(\n            currentAttrValue,\n            false,\n            getLoc(currentAttrStartIndex, currentAttrEndIndex),\n            0,\n            expParseMode\n          );\n          if (currentProp.name === \"for\") {\n            currentProp.forParseResult = parseForExpression(currentProp.exp);\n          }\n          let syncIndex = -1;\n          if (currentProp.name === \"bind\" && (syncIndex = currentProp.modifiers.findIndex(\n            (mod) => mod.content === \"sync\"\n          )) > -1 && checkCompatEnabled(\n            \"COMPILER_V_BIND_SYNC\",\n            currentOptions,\n            currentProp.loc,\n            currentProp.arg.loc.source\n          )) {\n            currentProp.name = \"model\";\n            currentProp.modifiers.splice(syncIndex, 1);\n          }\n        }\n      }\n      if (currentProp.type !== 7 || currentProp.name !== \"pre\") {\n        currentOpenTag.props.push(currentProp);\n      }\n    }\n    currentAttrValue = \"\";\n    currentAttrStartIndex = currentAttrEndIndex = -1;\n  },\n  oncomment(start, end) {\n    if (currentOptions.comments) {\n      addNode({\n        type: 3,\n        content: getSlice(start, end),\n        loc: getLoc(start - 4, end + 3)\n      });\n    }\n  },\n  onend() {\n    const end = currentInput.length;\n    if ((!!(process.env.NODE_ENV !== \"production\") || false) && tokenizer.state !== 1) {\n      switch (tokenizer.state) {\n        case 5:\n        case 8:\n          emitError(5, end);\n          break;\n        case 3:\n        case 4:\n          emitError(\n            25,\n            tokenizer.sectionStart\n          );\n          break;\n        case 28:\n          if (tokenizer.currentSequence === Sequences.CdataEnd) {\n            emitError(6, end);\n          } else {\n            emitError(7, end);\n          }\n          break;\n        case 6:\n        case 7:\n        case 9:\n        case 11:\n        case 12:\n        case 13:\n        case 14:\n        case 15:\n        case 16:\n        case 17:\n        case 18:\n        case 19:\n        // \"\n        case 20:\n        // '\n        case 21:\n          emitError(9, end);\n          break;\n      }\n    }\n    for (let index = 0; index < stack.length; index++) {\n      onCloseTag(stack[index], end - 1);\n      emitError(24, stack[index].loc.start.offset);\n    }\n  },\n  oncdata(start, end) {\n    if (stack[0].ns !== 0) {\n      onText(getSlice(start, end), start, end);\n    } else {\n      emitError(1, start - 9);\n    }\n  },\n  onprocessinginstruction(start) {\n    if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {\n      emitError(\n        21,\n        start - 1\n      );\n    }\n  }\n});\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nconst stripParensRE = /^\\(|\\)$/g;\nfunction parseForExpression(input) {\n  const loc = input.loc;\n  const exp = input.content;\n  const inMatch = exp.match(forAliasRE);\n  if (!inMatch) return;\n  const [, LHS, RHS] = inMatch;\n  const createAliasExpression = (content, offset, asParam = false) => {\n    const start = loc.start.offset + offset;\n    const end = start + content.length;\n    return createExp(\n      content,\n      false,\n      getLoc(start, end),\n      0,\n      asParam ? 1 /* Params */ : 0 /* Normal */\n    );\n  };\n  const result = {\n    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),\n    value: void 0,\n    key: void 0,\n    index: void 0,\n    finalized: false\n  };\n  let valueContent = LHS.trim().replace(stripParensRE, \"\").trim();\n  const trimmedOffset = LHS.indexOf(valueContent);\n  const iteratorMatch = valueContent.match(forIteratorRE);\n  if (iteratorMatch) {\n    valueContent = valueContent.replace(forIteratorRE, \"\").trim();\n    const keyContent = iteratorMatch[1].trim();\n    let keyOffset;\n    if (keyContent) {\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\n      result.key = createAliasExpression(keyContent, keyOffset, true);\n    }\n    if (iteratorMatch[2]) {\n      const indexContent = iteratorMatch[2].trim();\n      if (indexContent) {\n        result.index = createAliasExpression(\n          indexContent,\n          exp.indexOf(\n            indexContent,\n            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length\n          ),\n          true\n        );\n      }\n    }\n  }\n  if (valueContent) {\n    result.value = createAliasExpression(valueContent, trimmedOffset, true);\n  }\n  return result;\n}\nfunction getSlice(start, end) {\n  return currentInput.slice(start, end);\n}\nfunction endOpenTag(end) {\n  if (tokenizer.inSFCRoot) {\n    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);\n  }\n  addNode(currentOpenTag);\n  const { tag, ns } = currentOpenTag;\n  if (ns === 0 && currentOptions.isPreTag(tag)) {\n    inPre++;\n  }\n  if (currentOptions.isVoidTag(tag)) {\n    onCloseTag(currentOpenTag, end);\n  } else {\n    stack.unshift(currentOpenTag);\n    if (ns === 1 || ns === 2) {\n      tokenizer.inXML = true;\n    }\n  }\n  currentOpenTag = null;\n}\nfunction onText(content, start, end) {\n  {\n    const tag = stack[0] && stack[0].tag;\n    if (tag !== \"script\" && tag !== \"style\" && content.includes(\"&\")) {\n      content = currentOptions.decodeEntities(content, false);\n    }\n  }\n  const parent = stack[0] || currentRoot;\n  const lastNode = parent.children[parent.children.length - 1];\n  if (lastNode && lastNode.type === 2) {\n    lastNode.content += content;\n    setLocEnd(lastNode.loc, end);\n  } else {\n    parent.children.push({\n      type: 2,\n      content,\n      loc: getLoc(start, end)\n    });\n  }\n}\nfunction onCloseTag(el, end, isImplied = false) {\n  if (isImplied) {\n    setLocEnd(el.loc, backTrack(end, 60));\n  } else {\n    setLocEnd(el.loc, lookAhead(end, 62) + 1);\n  }\n  if (tokenizer.inSFCRoot) {\n    if (el.children.length) {\n      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);\n    } else {\n      el.innerLoc.end = extend({}, el.innerLoc.start);\n    }\n    el.innerLoc.source = getSlice(\n      el.innerLoc.start.offset,\n      el.innerLoc.end.offset\n    );\n  }\n  const { tag, ns, children } = el;\n  if (!inVPre) {\n    if (tag === \"slot\") {\n      el.tagType = 2;\n    } else if (isFragmentTemplate(el)) {\n      el.tagType = 3;\n    } else if (isComponent(el)) {\n      el.tagType = 1;\n    }\n  }\n  if (!tokenizer.inRCDATA) {\n    el.children = condenseWhitespace(children);\n  }\n  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {\n    const first = children[0];\n    if (first && first.type === 2) {\n      first.content = first.content.replace(/^\\r?\\n/, \"\");\n    }\n  }\n  if (ns === 0 && currentOptions.isPreTag(tag)) {\n    inPre--;\n  }\n  if (currentVPreBoundary === el) {\n    inVPre = tokenizer.inVPre = false;\n    currentVPreBoundary = null;\n  }\n  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {\n    tokenizer.inXML = false;\n  }\n  {\n    const props = el.props;\n    if (!!(process.env.NODE_ENV !== \"production\") && isCompatEnabled(\n      \"COMPILER_V_IF_V_FOR_PRECEDENCE\",\n      currentOptions\n    )) {\n      let hasIf = false;\n      let hasFor = false;\n      for (let i = 0; i < props.length; i++) {\n        const p = props[i];\n        if (p.type === 7) {\n          if (p.name === \"if\") {\n            hasIf = true;\n          } else if (p.name === \"for\") {\n            hasFor = true;\n          }\n        }\n        if (hasIf && hasFor) {\n          warnDeprecation(\n            \"COMPILER_V_IF_V_FOR_PRECEDENCE\",\n            currentOptions,\n            el.loc\n          );\n          break;\n        }\n      }\n    }\n    if (!tokenizer.inSFCRoot && isCompatEnabled(\n      \"COMPILER_NATIVE_TEMPLATE\",\n      currentOptions\n    ) && el.tag === \"template\" && !isFragmentTemplate(el)) {\n      !!(process.env.NODE_ENV !== \"production\") && warnDeprecation(\n        \"COMPILER_NATIVE_TEMPLATE\",\n        currentOptions,\n        el.loc\n      );\n      const parent = stack[0] || currentRoot;\n      const index = parent.children.indexOf(el);\n      parent.children.splice(index, 1, ...el.children);\n    }\n    const inlineTemplateProp = props.find(\n      (p) => p.type === 6 && p.name === \"inline-template\"\n    );\n    if (inlineTemplateProp && checkCompatEnabled(\n      \"COMPILER_INLINE_TEMPLATE\",\n      currentOptions,\n      inlineTemplateProp.loc\n    ) && el.children.length) {\n      inlineTemplateProp.value = {\n        type: 2,\n        content: getSlice(\n          el.children[0].loc.start.offset,\n          el.children[el.children.length - 1].loc.end.offset\n        ),\n        loc: inlineTemplateProp.loc\n      };\n    }\n  }\n}\nfunction lookAhead(index, c) {\n  let i = index;\n  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;\n  return i;\n}\nfunction backTrack(index, c) {\n  let i = index;\n  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;\n  return i;\n}\nconst specialTemplateDir = /* @__PURE__ */ new Set([\"if\", \"else\", \"else-if\", \"for\", \"slot\"]);\nfunction isFragmentTemplate({ tag, props }) {\n  if (tag === \"template\") {\n    for (let i = 0; i < props.length; i++) {\n      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isComponent({ tag, props }) {\n  if (currentOptions.isCustomElement(tag)) {\n    return false;\n  }\n  if (tag === \"component\" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {\n    return true;\n  }\n  for (let i = 0; i < props.length; i++) {\n    const p = props[i];\n    if (p.type === 6) {\n      if (p.name === \"is\" && p.value) {\n        if (p.value.content.startsWith(\"vue:\")) {\n          return true;\n        } else if (checkCompatEnabled(\n          \"COMPILER_IS_ON_ELEMENT\",\n          currentOptions,\n          p.loc\n        )) {\n          return true;\n        }\n      }\n    } else if (// :is on plain element - only treat as component in compat mode\n    p.name === \"bind\" && isStaticArgOf(p.arg, \"is\") && checkCompatEnabled(\n      \"COMPILER_IS_ON_ELEMENT\",\n      currentOptions,\n      p.loc\n    )) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUpperCase(c) {\n  return c > 64 && c < 91;\n}\nconst windowsNewlineRE = /\\r\\n/g;\nfunction condenseWhitespace(nodes) {\n  const shouldCondense = currentOptions.whitespace !== \"preserve\";\n  let removedWhitespace = false;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (node.type === 2) {\n      if (!inPre) {\n        if (isAllWhitespace(node.content)) {\n          const prev = nodes[i - 1] && nodes[i - 1].type;\n          const next = nodes[i + 1] && nodes[i + 1].type;\n          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {\n            removedWhitespace = true;\n            nodes[i] = null;\n          } else {\n            node.content = \" \";\n          }\n        } else if (shouldCondense) {\n          node.content = condense(node.content);\n        }\n      } else {\n        node.content = node.content.replace(windowsNewlineRE, \"\\n\");\n      }\n    }\n  }\n  return removedWhitespace ? nodes.filter(Boolean) : nodes;\n}\nfunction isAllWhitespace(str) {\n  for (let i = 0; i < str.length; i++) {\n    if (!isWhitespace(str.charCodeAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction hasNewlineChar(str) {\n  for (let i = 0; i < str.length; i++) {\n    const c = str.charCodeAt(i);\n    if (c === 10 || c === 13) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction condense(str) {\n  let ret = \"\";\n  let prevCharIsWhitespace = false;\n  for (let i = 0; i < str.length; i++) {\n    if (isWhitespace(str.charCodeAt(i))) {\n      if (!prevCharIsWhitespace) {\n        ret += \" \";\n        prevCharIsWhitespace = true;\n      }\n    } else {\n      ret += str[i];\n      prevCharIsWhitespace = false;\n    }\n  }\n  return ret;\n}\nfunction addNode(node) {\n  (stack[0] || currentRoot).children.push(node);\n}\nfunction getLoc(start, end) {\n  return {\n    start: tokenizer.getPos(start),\n    // @ts-expect-error allow late attachment\n    end: end == null ? end : tokenizer.getPos(end),\n    // @ts-expect-error allow late attachment\n    source: end == null ? end : getSlice(start, end)\n  };\n}\nfunction cloneLoc(loc) {\n  return getLoc(loc.start.offset, loc.end.offset);\n}\nfunction setLocEnd(loc, end) {\n  loc.end = tokenizer.getPos(end);\n  loc.source = getSlice(loc.start.offset, end);\n}\nfunction dirToAttr(dir) {\n  const attr = {\n    type: 6,\n    name: dir.rawName,\n    nameLoc: getLoc(\n      dir.loc.start.offset,\n      dir.loc.start.offset + dir.rawName.length\n    ),\n    value: void 0,\n    loc: dir.loc\n  };\n  if (dir.exp) {\n    const loc = dir.exp.loc;\n    if (loc.end.offset < dir.loc.end.offset) {\n      loc.start.offset--;\n      loc.start.column--;\n      loc.end.offset++;\n      loc.end.column++;\n    }\n    attr.value = {\n      type: 2,\n      content: dir.exp.content,\n      loc\n    };\n  }\n  return attr;\n}\nfunction createExp(content, isStatic = false, loc, constType = 0, parseMode = 0 /* Normal */) {\n  const exp = createSimpleExpression(content, isStatic, loc, constType);\n  return exp;\n}\nfunction emitError(code, index, message) {\n  currentOptions.onError(\n    createCompilerError(code, getLoc(index, index), void 0, message)\n  );\n}\nfunction reset() {\n  tokenizer.reset();\n  currentOpenTag = null;\n  currentProp = null;\n  currentAttrValue = \"\";\n  currentAttrStartIndex = -1;\n  currentAttrEndIndex = -1;\n  stack.length = 0;\n}\nfunction baseParse(input, options) {\n  reset();\n  currentInput = input;\n  currentOptions = extend({}, defaultParserOptions);\n  if (options) {\n    let key;\n    for (key in options) {\n      if (options[key] != null) {\n        currentOptions[key] = options[key];\n      }\n    }\n  }\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    if (!currentOptions.decodeEntities) {\n      throw new Error(\n        `[@vue/compiler-core] decodeEntities option is required in browser builds.`\n      );\n    }\n  }\n  tokenizer.mode = currentOptions.parseMode === \"html\" ? 1 : currentOptions.parseMode === \"sfc\" ? 2 : 0;\n  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;\n  const delimiters = options && options.delimiters;\n  if (delimiters) {\n    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);\n    tokenizer.delimiterClose = toCharCodes(delimiters[1]);\n  }\n  const root = currentRoot = createRoot([], input);\n  tokenizer.parse(currentInput);\n  root.loc = getLoc(0, input.length);\n  root.children = condenseWhitespace(root.children);\n  currentRoot = null;\n  return root;\n}\n\nfunction cacheStatic(root, context) {\n  walk(\n    root,\n    void 0,\n    context,\n    // Root node is unfortunately non-hoistable due to potential parent\n    // fallthrough attributes.\n    !!getSingleElementRoot(root)\n  );\n}\nfunction getSingleElementRoot(root) {\n  const children = root.children.filter((x) => x.type !== 3);\n  return children.length === 1 && children[0].type === 1 && !isSlotOutlet(children[0]) ? children[0] : null;\n}\nfunction walk(node, parent, context, doNotHoistNode = false, inFor = false) {\n  const { children } = node;\n  const toCache = [];\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (child.type === 1 && child.tagType === 0) {\n      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);\n      if (constantType > 0) {\n        if (constantType >= 2) {\n          child.codegenNode.patchFlag = -1;\n          toCache.push(child);\n          continue;\n        }\n      } else {\n        const codegenNode = child.codegenNode;\n        if (codegenNode.type === 13) {\n          const flag = codegenNode.patchFlag;\n          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {\n            const props = getNodeProps(child);\n            if (props) {\n              codegenNode.props = context.hoist(props);\n            }\n          }\n          if (codegenNode.dynamicProps) {\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);\n          }\n        }\n      }\n    } else if (child.type === 12) {\n      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);\n      if (constantType >= 2) {\n        if (child.codegenNode.type === 14 && child.codegenNode.arguments.length > 0) {\n          child.codegenNode.arguments.push(\n            -1 + (!!(process.env.NODE_ENV !== \"production\") ? ` /* ${PatchFlagNames[-1]} */` : ``)\n          );\n        }\n        toCache.push(child);\n        continue;\n      }\n    }\n    if (child.type === 1) {\n      const isComponent = child.tagType === 1;\n      if (isComponent) {\n        context.scopes.vSlot++;\n      }\n      walk(child, node, context, false, inFor);\n      if (isComponent) {\n        context.scopes.vSlot--;\n      }\n    } else if (child.type === 11) {\n      walk(child, node, context, child.children.length === 1, true);\n    } else if (child.type === 9) {\n      for (let i2 = 0; i2 < child.branches.length; i2++) {\n        walk(\n          child.branches[i2],\n          node,\n          context,\n          child.branches[i2].children.length === 1,\n          inFor\n        );\n      }\n    }\n  }\n  let cachedAsArray = false;\n  if (toCache.length === children.length && node.type === 1) {\n    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {\n      node.codegenNode.children = getCacheExpression(\n        createArrayExpression(node.codegenNode.children)\n      );\n      cachedAsArray = true;\n    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {\n      const slot = getSlotNode(node.codegenNode, \"default\");\n      if (slot) {\n        slot.returns = getCacheExpression(\n          createArrayExpression(slot.returns)\n        );\n        cachedAsArray = true;\n      }\n    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {\n      const slotName = findDir(node, \"slot\", true);\n      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);\n      if (slot) {\n        slot.returns = getCacheExpression(\n          createArrayExpression(slot.returns)\n        );\n        cachedAsArray = true;\n      }\n    }\n  }\n  if (!cachedAsArray) {\n    for (const child of toCache) {\n      child.codegenNode = context.cache(child.codegenNode);\n    }\n  }\n  function getCacheExpression(value) {\n    const exp = context.cache(value);\n    exp.needArraySpread = true;\n    return exp;\n  }\n  function getSlotNode(node2, name) {\n    if (node2.children && !isArray(node2.children) && node2.children.type === 15) {\n      const slot = node2.children.properties.find(\n        (p) => p.key === name || p.key.content === name\n      );\n      return slot && slot.value;\n    }\n  }\n  if (toCache.length && context.transformHoist) {\n    context.transformHoist(children, context, node);\n  }\n}\nfunction getConstantType(node, context) {\n  const { constantCache } = context;\n  switch (node.type) {\n    case 1:\n      if (node.tagType !== 0) {\n        return 0;\n      }\n      const cached = constantCache.get(node);\n      if (cached !== void 0) {\n        return cached;\n      }\n      const codegenNode = node.codegenNode;\n      if (codegenNode.type !== 13) {\n        return 0;\n      }\n      if (codegenNode.isBlock && node.tag !== \"svg\" && node.tag !== \"foreignObject\" && node.tag !== \"math\") {\n        return 0;\n      }\n      if (codegenNode.patchFlag === void 0) {\n        let returnType2 = 3;\n        const generatedPropsType = getGeneratedPropsConstantType(node, context);\n        if (generatedPropsType === 0) {\n          constantCache.set(node, 0);\n          return 0;\n        }\n        if (generatedPropsType < returnType2) {\n          returnType2 = generatedPropsType;\n        }\n        for (let i = 0; i < node.children.length; i++) {\n          const childType = getConstantType(node.children[i], context);\n          if (childType === 0) {\n            constantCache.set(node, 0);\n            return 0;\n          }\n          if (childType < returnType2) {\n            returnType2 = childType;\n          }\n        }\n        if (returnType2 > 1) {\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i];\n            if (p.type === 7 && p.name === \"bind\" && p.exp) {\n              const expType = getConstantType(p.exp, context);\n              if (expType === 0) {\n                constantCache.set(node, 0);\n                return 0;\n              }\n              if (expType < returnType2) {\n                returnType2 = expType;\n              }\n            }\n          }\n        }\n        if (codegenNode.isBlock) {\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i];\n            if (p.type === 7) {\n              constantCache.set(node, 0);\n              return 0;\n            }\n          }\n          context.removeHelper(OPEN_BLOCK);\n          context.removeHelper(\n            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)\n          );\n          codegenNode.isBlock = false;\n          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));\n        }\n        constantCache.set(node, returnType2);\n        return returnType2;\n      } else {\n        constantCache.set(node, 0);\n        return 0;\n      }\n    case 2:\n    case 3:\n      return 3;\n    case 9:\n    case 11:\n    case 10:\n      return 0;\n    case 5:\n    case 12:\n      return getConstantType(node.content, context);\n    case 4:\n      return node.constType;\n    case 8:\n      let returnType = 3;\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (isString(child) || isSymbol(child)) {\n          continue;\n        }\n        const childType = getConstantType(child, context);\n        if (childType === 0) {\n          return 0;\n        } else if (childType < returnType) {\n          returnType = childType;\n        }\n      }\n      return returnType;\n    case 20:\n      return 2;\n    default:\n      if (!!(process.env.NODE_ENV !== \"production\")) ;\n      return 0;\n  }\n}\nconst allowHoistedHelperSet = /* @__PURE__ */ new Set([\n  NORMALIZE_CLASS,\n  NORMALIZE_STYLE,\n  NORMALIZE_PROPS,\n  GUARD_REACTIVE_PROPS\n]);\nfunction getConstantTypeOfHelperCall(value, context) {\n  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {\n    const arg = value.arguments[0];\n    if (arg.type === 4) {\n      return getConstantType(arg, context);\n    } else if (arg.type === 14) {\n      return getConstantTypeOfHelperCall(arg, context);\n    }\n  }\n  return 0;\n}\nfunction getGeneratedPropsConstantType(node, context) {\n  let returnType = 3;\n  const props = getNodeProps(node);\n  if (props && props.type === 15) {\n    const { properties } = props;\n    for (let i = 0; i < properties.length; i++) {\n      const { key, value } = properties[i];\n      const keyType = getConstantType(key, context);\n      if (keyType === 0) {\n        return keyType;\n      }\n      if (keyType < returnType) {\n        returnType = keyType;\n      }\n      let valueType;\n      if (value.type === 4) {\n        valueType = getConstantType(value, context);\n      } else if (value.type === 14) {\n        valueType = getConstantTypeOfHelperCall(value, context);\n      } else {\n        valueType = 0;\n      }\n      if (valueType === 0) {\n        return valueType;\n      }\n      if (valueType < returnType) {\n        returnType = valueType;\n      }\n    }\n  }\n  return returnType;\n}\nfunction getNodeProps(node) {\n  const codegenNode = node.codegenNode;\n  if (codegenNode.type === 13) {\n    return codegenNode.props;\n  }\n}\n\nfunction createTransformContext(root, {\n  filename = \"\",\n  prefixIdentifiers = false,\n  hoistStatic = false,\n  hmr = false,\n  cacheHandlers = false,\n  nodeTransforms = [],\n  directiveTransforms = {},\n  transformHoist = null,\n  isBuiltInComponent = NOOP,\n  isCustomElement = NOOP,\n  expressionPlugins = [],\n  scopeId = null,\n  slotted = true,\n  ssr = false,\n  inSSR = false,\n  ssrCssVars = ``,\n  bindingMetadata = EMPTY_OBJ,\n  inline = false,\n  isTS = false,\n  onError = defaultOnError,\n  onWarn = defaultOnWarn,\n  compatConfig\n}) {\n  const nameMatch = filename.replace(/\\?.*$/, \"\").match(/([^/\\\\]+)\\.\\w+$/);\n  const context = {\n    // options\n    filename,\n    selfName: nameMatch && capitalize(camelize(nameMatch[1])),\n    prefixIdentifiers,\n    hoistStatic,\n    hmr,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    transformHoist,\n    isBuiltInComponent,\n    isCustomElement,\n    expressionPlugins,\n    scopeId,\n    slotted,\n    ssr,\n    inSSR,\n    ssrCssVars,\n    bindingMetadata,\n    inline,\n    isTS,\n    onError,\n    onWarn,\n    compatConfig,\n    // state\n    root,\n    helpers: /* @__PURE__ */ new Map(),\n    components: /* @__PURE__ */ new Set(),\n    directives: /* @__PURE__ */ new Set(),\n    hoists: [],\n    imports: [],\n    cached: [],\n    constantCache: /* @__PURE__ */ new WeakMap(),\n    temps: 0,\n    identifiers: /* @__PURE__ */ Object.create(null),\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    parent: null,\n    grandParent: null,\n    currentNode: root,\n    childIndex: 0,\n    inVOnce: false,\n    // methods\n    helper(name) {\n      const count = context.helpers.get(name) || 0;\n      context.helpers.set(name, count + 1);\n      return name;\n    },\n    removeHelper(name) {\n      const count = context.helpers.get(name);\n      if (count) {\n        const currentCount = count - 1;\n        if (!currentCount) {\n          context.helpers.delete(name);\n        } else {\n          context.helpers.set(name, currentCount);\n        }\n      }\n    },\n    helperString(name) {\n      return `_${helperNameMap[context.helper(name)]}`;\n    },\n    replaceNode(node) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        if (!context.currentNode) {\n          throw new Error(`Node being replaced is already removed.`);\n        }\n        if (!context.parent) {\n          throw new Error(`Cannot replace root node.`);\n        }\n      }\n      context.parent.children[context.childIndex] = context.currentNode = node;\n    },\n    removeNode(node) {\n      if (!!(process.env.NODE_ENV !== \"production\") && !context.parent) {\n        throw new Error(`Cannot remove root node.`);\n      }\n      const list = context.parent.children;\n      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;\n      if (!!(process.env.NODE_ENV !== \"production\") && removalIndex < 0) {\n        throw new Error(`node being removed is not a child of current parent`);\n      }\n      if (!node || node === context.currentNode) {\n        context.currentNode = null;\n        context.onNodeRemoved();\n      } else {\n        if (context.childIndex > removalIndex) {\n          context.childIndex--;\n          context.onNodeRemoved();\n        }\n      }\n      context.parent.children.splice(removalIndex, 1);\n    },\n    onNodeRemoved: NOOP,\n    addIdentifiers(exp) {\n    },\n    removeIdentifiers(exp) {\n    },\n    hoist(exp) {\n      if (isString(exp)) exp = createSimpleExpression(exp);\n      context.hoists.push(exp);\n      const identifier = createSimpleExpression(\n        `_hoisted_${context.hoists.length}`,\n        false,\n        exp.loc,\n        2\n      );\n      identifier.hoisted = exp;\n      return identifier;\n    },\n    cache(exp, isVNode = false, inVOnce = false) {\n      const cacheExp = createCacheExpression(\n        context.cached.length,\n        exp,\n        isVNode,\n        inVOnce\n      );\n      context.cached.push(cacheExp);\n      return cacheExp;\n    }\n  };\n  {\n    context.filters = /* @__PURE__ */ new Set();\n  }\n  return context;\n}\nfunction transform(root, options) {\n  const context = createTransformContext(root, options);\n  traverseNode(root, context);\n  if (options.hoistStatic) {\n    cacheStatic(root, context);\n  }\n  if (!options.ssr) {\n    createRootCodegen(root, context);\n  }\n  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);\n  root.components = [...context.components];\n  root.directives = [...context.directives];\n  root.imports = context.imports;\n  root.hoists = context.hoists;\n  root.temps = context.temps;\n  root.cached = context.cached;\n  root.transformed = true;\n  {\n    root.filters = [...context.filters];\n  }\n}\nfunction createRootCodegen(root, context) {\n  const { helper } = context;\n  const { children } = root;\n  if (children.length === 1) {\n    const singleElementRootChild = getSingleElementRoot(root);\n    if (singleElementRootChild && singleElementRootChild.codegenNode) {\n      const codegenNode = singleElementRootChild.codegenNode;\n      if (codegenNode.type === 13) {\n        convertToBlock(codegenNode, context);\n      }\n      root.codegenNode = codegenNode;\n    } else {\n      root.codegenNode = children[0];\n    }\n  } else if (children.length > 1) {\n    let patchFlag = 64;\n    if (!!(process.env.NODE_ENV !== \"production\") && children.filter((c) => c.type !== 3).length === 1) {\n      patchFlag |= 2048;\n    }\n    root.codegenNode = createVNodeCall(\n      context,\n      helper(FRAGMENT),\n      void 0,\n      root.children,\n      patchFlag,\n      void 0,\n      void 0,\n      true,\n      void 0,\n      false\n    );\n  } else ;\n}\nfunction traverseChildren(parent, context) {\n  let i = 0;\n  const nodeRemoved = () => {\n    i--;\n  };\n  for (; i < parent.children.length; i++) {\n    const child = parent.children[i];\n    if (isString(child)) continue;\n    context.grandParent = context.parent;\n    context.parent = parent;\n    context.childIndex = i;\n    context.onNodeRemoved = nodeRemoved;\n    traverseNode(child, context);\n  }\n}\nfunction traverseNode(node, context) {\n  context.currentNode = node;\n  const { nodeTransforms } = context;\n  const exitFns = [];\n  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {\n    const onExit = nodeTransforms[i2](node, context);\n    if (onExit) {\n      if (isArray(onExit)) {\n        exitFns.push(...onExit);\n      } else {\n        exitFns.push(onExit);\n      }\n    }\n    if (!context.currentNode) {\n      return;\n    } else {\n      node = context.currentNode;\n    }\n  }\n  switch (node.type) {\n    case 3:\n      if (!context.ssr) {\n        context.helper(CREATE_COMMENT);\n      }\n      break;\n    case 5:\n      if (!context.ssr) {\n        context.helper(TO_DISPLAY_STRING);\n      }\n      break;\n    // for container types, further traverse downwards\n    case 9:\n      for (let i2 = 0; i2 < node.branches.length; i2++) {\n        traverseNode(node.branches[i2], context);\n      }\n      break;\n    case 10:\n    case 11:\n    case 1:\n    case 0:\n      traverseChildren(node, context);\n      break;\n  }\n  context.currentNode = node;\n  let i = exitFns.length;\n  while (i--) {\n    exitFns[i]();\n  }\n}\nfunction createStructuralDirectiveTransform(name, fn) {\n  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);\n  return (node, context) => {\n    if (node.type === 1) {\n      const { props } = node;\n      if (node.tagType === 3 && props.some(isVSlot)) {\n        return;\n      }\n      const exitFns = [];\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i];\n        if (prop.type === 7 && matches(prop.name)) {\n          props.splice(i, 1);\n          i--;\n          const onExit = fn(node, prop, context);\n          if (onExit) exitFns.push(onExit);\n        }\n      }\n      return exitFns;\n    }\n  };\n}\n\nconst PURE_ANNOTATION = `/*@__PURE__*/`;\nconst aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\nfunction createCodegenContext(ast, {\n  mode = \"function\",\n  prefixIdentifiers = mode === \"module\",\n  sourceMap = false,\n  filename = `template.vue.html`,\n  scopeId = null,\n  optimizeImports = false,\n  runtimeGlobalName = `Vue`,\n  runtimeModuleName = `vue`,\n  ssrRuntimeModuleName = \"vue/server-renderer\",\n  ssr = false,\n  isTS = false,\n  inSSR = false\n}) {\n  const context = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    scopeId,\n    optimizeImports,\n    runtimeGlobalName,\n    runtimeModuleName,\n    ssrRuntimeModuleName,\n    ssr,\n    isTS,\n    inSSR,\n    source: ast.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n    pure: false,\n    map: void 0,\n    helper(key) {\n      return `_${helperNameMap[key]}`;\n    },\n    push(code, newlineIndex = -2 /* None */, node) {\n      context.code += code;\n    },\n    indent() {\n      newline(++context.indentLevel);\n    },\n    deindent(withoutNewLine = false) {\n      if (withoutNewLine) {\n        --context.indentLevel;\n      } else {\n        newline(--context.indentLevel);\n      }\n    },\n    newline() {\n      newline(context.indentLevel);\n    }\n  };\n  function newline(n) {\n    context.push(\"\\n\" + `  `.repeat(n), 0 /* Start */);\n  }\n  return context;\n}\nfunction generate(ast, options = {}) {\n  const context = createCodegenContext(ast, options);\n  if (options.onContextCreated) options.onContextCreated(context);\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context;\n  const helpers = Array.from(ast.helpers);\n  const hasHelpers = helpers.length > 0;\n  const useWithBlock = !prefixIdentifiers && mode !== \"module\";\n  const preambleContext = context;\n  {\n    genFunctionPreamble(ast, preambleContext);\n  }\n  const functionName = ssr ? `ssrRender` : `render`;\n  const args = ssr ? [\"_ctx\", \"_push\", \"_parent\", \"_attrs\"] : [\"_ctx\", \"_cache\"];\n  const signature = args.join(\", \");\n  {\n    push(`function ${functionName}(${signature}) {`);\n  }\n  indent();\n  if (useWithBlock) {\n    push(`with (_ctx) {`);\n    indent();\n    if (hasHelpers) {\n      push(\n        `const { ${helpers.map(aliasHelper).join(\", \")} } = _Vue\n`,\n        -1 /* End */\n      );\n      newline();\n    }\n  }\n  if (ast.components.length) {\n    genAssets(ast.components, \"component\", context);\n    if (ast.directives.length || ast.temps > 0) {\n      newline();\n    }\n  }\n  if (ast.directives.length) {\n    genAssets(ast.directives, \"directive\", context);\n    if (ast.temps > 0) {\n      newline();\n    }\n  }\n  if (ast.filters && ast.filters.length) {\n    newline();\n    genAssets(ast.filters, \"filter\", context);\n    newline();\n  }\n  if (ast.temps > 0) {\n    push(`let `);\n    for (let i = 0; i < ast.temps; i++) {\n      push(`${i > 0 ? `, ` : ``}_temp${i}`);\n    }\n  }\n  if (ast.components.length || ast.directives.length || ast.temps) {\n    push(`\n`, 0 /* Start */);\n    newline();\n  }\n  if (!ssr) {\n    push(`return `);\n  }\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context);\n  } else {\n    push(`null`);\n  }\n  if (useWithBlock) {\n    deindent();\n    push(`}`);\n  }\n  deindent();\n  push(`}`);\n  return {\n    ast,\n    code: context.code,\n    preamble: ``,\n    map: context.map ? context.map.toJSON() : void 0\n  };\n}\nfunction genFunctionPreamble(ast, context) {\n  const {\n    ssr,\n    prefixIdentifiers,\n    push,\n    newline,\n    runtimeModuleName,\n    runtimeGlobalName,\n    ssrRuntimeModuleName\n  } = context;\n  const VueBinding = runtimeGlobalName;\n  const helpers = Array.from(ast.helpers);\n  if (helpers.length > 0) {\n    {\n      push(`const _Vue = ${VueBinding}\n`, -1 /* End */);\n      if (ast.hoists.length) {\n        const staticHelpers = [\n          CREATE_VNODE,\n          CREATE_ELEMENT_VNODE,\n          CREATE_COMMENT,\n          CREATE_TEXT,\n          CREATE_STATIC\n        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(\", \");\n        push(`const { ${staticHelpers} } = _Vue\n`, -1 /* End */);\n      }\n    }\n  }\n  genHoists(ast.hoists, context);\n  newline();\n  push(`return `);\n}\nfunction genAssets(assets, type, { helper, push, newline, isTS }) {\n  const resolver = helper(\n    type === \"filter\" ? RESOLVE_FILTER : type === \"component\" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE\n  );\n  for (let i = 0; i < assets.length; i++) {\n    let id = assets[i];\n    const maybeSelfReference = id.endsWith(\"__self\");\n    if (maybeSelfReference) {\n      id = id.slice(0, -6);\n    }\n    push(\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`\n    );\n    if (i < assets.length - 1) {\n      newline();\n    }\n  }\n}\nfunction genHoists(hoists, context) {\n  if (!hoists.length) {\n    return;\n  }\n  context.pure = true;\n  const { push, newline } = context;\n  newline();\n  for (let i = 0; i < hoists.length; i++) {\n    const exp = hoists[i];\n    if (exp) {\n      push(`const _hoisted_${i + 1} = `);\n      genNode(exp, context);\n      newline();\n    }\n  }\n  context.pure = false;\n}\nfunction isText(n) {\n  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;\n}\nfunction genNodeListAsArray(nodes, context) {\n  const multilines = nodes.length > 3 || !!(process.env.NODE_ENV !== \"production\") && nodes.some((n) => isArray(n) || !isText(n));\n  context.push(`[`);\n  multilines && context.indent();\n  genNodeList(nodes, context, multilines);\n  multilines && context.deindent();\n  context.push(`]`);\n}\nfunction genNodeList(nodes, context, multilines = false, comma = true) {\n  const { push, newline } = context;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (isString(node)) {\n      push(node, -3 /* Unknown */);\n    } else if (isArray(node)) {\n      genNodeListAsArray(node, context);\n    } else {\n      genNode(node, context);\n    }\n    if (i < nodes.length - 1) {\n      if (multilines) {\n        comma && push(\",\");\n        newline();\n      } else {\n        comma && push(\", \");\n      }\n    }\n  }\n}\nfunction genNode(node, context) {\n  if (isString(node)) {\n    context.push(node, -3 /* Unknown */);\n    return;\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node));\n    return;\n  }\n  switch (node.type) {\n    case 1:\n    case 9:\n    case 11:\n      !!(process.env.NODE_ENV !== \"production\") && assert(\n        node.codegenNode != null,\n        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`\n      );\n      genNode(node.codegenNode, context);\n      break;\n    case 2:\n      genText(node, context);\n      break;\n    case 4:\n      genExpression(node, context);\n      break;\n    case 5:\n      genInterpolation(node, context);\n      break;\n    case 12:\n      genNode(node.codegenNode, context);\n      break;\n    case 8:\n      genCompoundExpression(node, context);\n      break;\n    case 3:\n      genComment(node, context);\n      break;\n    case 13:\n      genVNodeCall(node, context);\n      break;\n    case 14:\n      genCallExpression(node, context);\n      break;\n    case 15:\n      genObjectExpression(node, context);\n      break;\n    case 17:\n      genArrayExpression(node, context);\n      break;\n    case 18:\n      genFunctionExpression(node, context);\n      break;\n    case 19:\n      genConditionalExpression(node, context);\n      break;\n    case 20:\n      genCacheExpression(node, context);\n      break;\n    case 21:\n      genNodeList(node.body, context, true, false);\n      break;\n    // SSR only types\n    case 22:\n      break;\n    case 23:\n      break;\n    case 24:\n      break;\n    case 25:\n      break;\n    case 26:\n      break;\n    /* v8 ignore start */\n    case 10:\n      break;\n    default:\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        assert(false, `unhandled codegen node type: ${node.type}`);\n        const exhaustiveCheck = node;\n        return exhaustiveCheck;\n      }\n  }\n}\nfunction genText(node, context) {\n  context.push(JSON.stringify(node.content), -3 /* Unknown */, node);\n}\nfunction genExpression(node, context) {\n  const { content, isStatic } = node;\n  context.push(\n    isStatic ? JSON.stringify(content) : content,\n    -3 /* Unknown */,\n    node\n  );\n}\nfunction genInterpolation(node, context) {\n  const { push, helper, pure } = context;\n  if (pure) push(PURE_ANNOTATION);\n  push(`${helper(TO_DISPLAY_STRING)}(`);\n  genNode(node.content, context);\n  push(`)`);\n}\nfunction genCompoundExpression(node, context) {\n  for (let i = 0; i < node.children.length; i++) {\n    const child = node.children[i];\n    if (isString(child)) {\n      context.push(child, -3 /* Unknown */);\n    } else {\n      genNode(child, context);\n    }\n  }\n}\nfunction genExpressionAsPropertyKey(node, context) {\n  const { push } = context;\n  if (node.type === 8) {\n    push(`[`);\n    genCompoundExpression(node, context);\n    push(`]`);\n  } else if (node.isStatic) {\n    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);\n    push(text, -2 /* None */, node);\n  } else {\n    push(`[${node.content}]`, -3 /* Unknown */, node);\n  }\n}\nfunction genComment(node, context) {\n  const { push, helper, pure } = context;\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  push(\n    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,\n    -3 /* Unknown */,\n    node\n  );\n}\nfunction genVNodeCall(node, context) {\n  const { push, helper, pure } = context;\n  const {\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent\n  } = node;\n  let patchFlagString;\n  if (patchFlag) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      if (patchFlag < 0) {\n        patchFlagString = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;\n      } else {\n        const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);\n        patchFlagString = patchFlag + ` /* ${flagNames} */`;\n      }\n    } else {\n      patchFlagString = String(patchFlag);\n    }\n  }\n  if (directives) {\n    push(helper(WITH_DIRECTIVES) + `(`);\n  }\n  if (isBlock) {\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\n  }\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);\n  push(helper(callHelper) + `(`, -2 /* None */, node);\n  genNodeList(\n    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),\n    context\n  );\n  push(`)`);\n  if (isBlock) {\n    push(`)`);\n  }\n  if (directives) {\n    push(`, `);\n    genNode(directives, context);\n    push(`)`);\n  }\n}\nfunction genNullableArgs(args) {\n  let i = args.length;\n  while (i--) {\n    if (args[i] != null) break;\n  }\n  return args.slice(0, i + 1).map((arg) => arg || `null`);\n}\nfunction genCallExpression(node, context) {\n  const { push, helper, pure } = context;\n  const callee = isString(node.callee) ? node.callee : helper(node.callee);\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  push(callee + `(`, -2 /* None */, node);\n  genNodeList(node.arguments, context);\n  push(`)`);\n}\nfunction genObjectExpression(node, context) {\n  const { push, indent, deindent, newline } = context;\n  const { properties } = node;\n  if (!properties.length) {\n    push(`{}`, -2 /* None */, node);\n    return;\n  }\n  const multilines = properties.length > 1 || !!(process.env.NODE_ENV !== \"production\") && properties.some((p) => p.value.type !== 4);\n  push(multilines ? `{` : `{ `);\n  multilines && indent();\n  for (let i = 0; i < properties.length; i++) {\n    const { key, value } = properties[i];\n    genExpressionAsPropertyKey(key, context);\n    push(`: `);\n    genNode(value, context);\n    if (i < properties.length - 1) {\n      push(`,`);\n      newline();\n    }\n  }\n  multilines && deindent();\n  push(multilines ? `}` : ` }`);\n}\nfunction genArrayExpression(node, context) {\n  genNodeListAsArray(node.elements, context);\n}\nfunction genFunctionExpression(node, context) {\n  const { push, indent, deindent } = context;\n  const { params, returns, body, newline, isSlot } = node;\n  if (isSlot) {\n    push(`_${helperNameMap[WITH_CTX]}(`);\n  }\n  push(`(`, -2 /* None */, node);\n  if (isArray(params)) {\n    genNodeList(params, context);\n  } else if (params) {\n    genNode(params, context);\n  }\n  push(`) => `);\n  if (newline || body) {\n    push(`{`);\n    indent();\n  }\n  if (returns) {\n    if (newline) {\n      push(`return `);\n    }\n    if (isArray(returns)) {\n      genNodeListAsArray(returns, context);\n    } else {\n      genNode(returns, context);\n    }\n  } else if (body) {\n    genNode(body, context);\n  }\n  if (newline || body) {\n    deindent();\n    push(`}`);\n  }\n  if (isSlot) {\n    if (node.isNonScopedSlot) {\n      push(`, undefined, true`);\n    }\n    push(`)`);\n  }\n}\nfunction genConditionalExpression(node, context) {\n  const { test, consequent, alternate, newline: needNewline } = node;\n  const { push, indent, deindent, newline } = context;\n  if (test.type === 4) {\n    const needsParens = !isSimpleIdentifier(test.content);\n    needsParens && push(`(`);\n    genExpression(test, context);\n    needsParens && push(`)`);\n  } else {\n    push(`(`);\n    genNode(test, context);\n    push(`)`);\n  }\n  needNewline && indent();\n  context.indentLevel++;\n  needNewline || push(` `);\n  push(`? `);\n  genNode(consequent, context);\n  context.indentLevel--;\n  needNewline && newline();\n  needNewline || push(` `);\n  push(`: `);\n  const isNested = alternate.type === 19;\n  if (!isNested) {\n    context.indentLevel++;\n  }\n  genNode(alternate, context);\n  if (!isNested) {\n    context.indentLevel--;\n  }\n  needNewline && deindent(\n    true\n    /* without newline */\n  );\n}\nfunction genCacheExpression(node, context) {\n  const { push, helper, indent, deindent, newline } = context;\n  const { needPauseTracking, needArraySpread } = node;\n  if (needArraySpread) {\n    push(`[...(`);\n  }\n  push(`_cache[${node.index}] || (`);\n  if (needPauseTracking) {\n    indent();\n    push(`${helper(SET_BLOCK_TRACKING)}(-1`);\n    if (node.inVOnce) push(`, true`);\n    push(`),`);\n    newline();\n    push(`(`);\n  }\n  push(`_cache[${node.index}] = `);\n  genNode(node.value, context);\n  if (needPauseTracking) {\n    push(`).cacheIndex = ${node.index},`);\n    newline();\n    push(`${helper(SET_BLOCK_TRACKING)}(1),`);\n    newline();\n    push(`_cache[${node.index}]`);\n    deindent();\n  }\n  push(`)`);\n  if (needArraySpread) {\n    push(`)]`);\n  }\n}\n\nconst prohibitedKeywordRE = new RegExp(\n  \"\\\\b\" + \"arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield\".split(\",\").join(\"\\\\b|\\\\b\") + \"\\\\b\"\n);\nconst stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\nfunction validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {\n  const exp = node.content;\n  if (!exp.trim()) {\n    return;\n  }\n  try {\n    new Function(\n      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`\n    );\n  } catch (e) {\n    let message = e.message;\n    const keywordMatch = exp.replace(stripStringRE, \"\").match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      message = `avoid using JavaScript keyword as property name: \"${keywordMatch[0]}\"`;\n    }\n    context.onError(\n      createCompilerError(\n        45,\n        node.loc,\n        void 0,\n        message\n      )\n    );\n  }\n}\n\nconst transformExpression = (node, context) => {\n  if (node.type === 5) {\n    node.content = processExpression(\n      node.content,\n      context\n    );\n  } else if (node.type === 1) {\n    const memo = findDir(node, \"memo\");\n    for (let i = 0; i < node.props.length; i++) {\n      const dir = node.props[i];\n      if (dir.type === 7 && dir.name !== \"for\") {\n        const exp = dir.exp;\n        const arg = dir.arg;\n        if (exp && exp.type === 4 && !(dir.name === \"on\" && arg) && // key has been processed in transformFor(vMemo + vFor)\n        !(memo && arg && arg.type === 4 && arg.content === \"key\")) {\n          dir.exp = processExpression(\n            exp,\n            context,\n            // slot args must be processed as function params\n            dir.name === \"slot\"\n          );\n        }\n        if (arg && arg.type === 4 && !arg.isStatic) {\n          dir.arg = processExpression(arg, context);\n        }\n      }\n    }\n  }\n};\nfunction processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {\n  {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      validateBrowserExpression(node, context, asParams, asRawStatements);\n    }\n    return node;\n  }\n}\nfunction stringifyExpression(exp) {\n  if (isString(exp)) {\n    return exp;\n  } else if (exp.type === 4) {\n    return exp.content;\n  } else {\n    return exp.children.map(stringifyExpression).join(\"\");\n  }\n}\n\nconst transformIf = createStructuralDirectiveTransform(\n  /^(?:if|else|else-if)$/,\n  (node, dir, context) => {\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\n      const siblings = context.parent.children;\n      let i = siblings.indexOf(ifNode);\n      let key = 0;\n      while (i-- >= 0) {\n        const sibling = siblings[i];\n        if (sibling && sibling.type === 9) {\n          key += sibling.branches.length;\n        }\n      }\n      return () => {\n        if (isRoot) {\n          ifNode.codegenNode = createCodegenNodeForBranch(\n            branch,\n            key,\n            context\n          );\n        } else {\n          const parentCondition = getParentCondition(ifNode.codegenNode);\n          parentCondition.alternate = createCodegenNodeForBranch(\n            branch,\n            key + ifNode.branches.length - 1,\n            context\n          );\n        }\n      };\n    });\n  }\n);\nfunction processIf(node, dir, context, processCodegen) {\n  if (dir.name !== \"else\" && (!dir.exp || !dir.exp.content.trim())) {\n    const loc = dir.exp ? dir.exp.loc : node.loc;\n    context.onError(\n      createCompilerError(28, dir.loc)\n    );\n    dir.exp = createSimpleExpression(`true`, false, loc);\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && true && dir.exp) {\n    validateBrowserExpression(dir.exp, context);\n  }\n  if (dir.name === \"if\") {\n    const branch = createIfBranch(node, dir);\n    const ifNode = {\n      type: 9,\n      loc: cloneLoc(node.loc),\n      branches: [branch]\n    };\n    context.replaceNode(ifNode);\n    if (processCodegen) {\n      return processCodegen(ifNode, branch, true);\n    }\n  } else {\n    const siblings = context.parent.children;\n    const comments = [];\n    let i = siblings.indexOf(node);\n    while (i-- >= -1) {\n      const sibling = siblings[i];\n      if (sibling && sibling.type === 3) {\n        context.removeNode(sibling);\n        !!(process.env.NODE_ENV !== \"production\") && comments.unshift(sibling);\n        continue;\n      }\n      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {\n        context.removeNode(sibling);\n        continue;\n      }\n      if (sibling && sibling.type === 9) {\n        if ((dir.name === \"else-if\" || dir.name === \"else\") && sibling.branches[sibling.branches.length - 1].condition === void 0) {\n          context.onError(\n            createCompilerError(30, node.loc)\n          );\n        }\n        context.removeNode();\n        const branch = createIfBranch(node, dir);\n        if (!!(process.env.NODE_ENV !== \"production\") && comments.length && // #3619 ignore comments if the v-if is direct child of <transition>\n        !(context.parent && context.parent.type === 1 && (context.parent.tag === \"transition\" || context.parent.tag === \"Transition\"))) {\n          branch.children = [...comments, ...branch.children];\n        }\n        if (!!(process.env.NODE_ENV !== \"production\") || false) {\n          const key = branch.userKey;\n          if (key) {\n            sibling.branches.forEach(({ userKey }) => {\n              if (isSameKey(userKey, key)) {\n                context.onError(\n                  createCompilerError(\n                    29,\n                    branch.userKey.loc\n                  )\n                );\n              }\n            });\n          }\n        }\n        sibling.branches.push(branch);\n        const onExit = processCodegen && processCodegen(sibling, branch, false);\n        traverseNode(branch, context);\n        if (onExit) onExit();\n        context.currentNode = null;\n      } else {\n        context.onError(\n          createCompilerError(30, node.loc)\n        );\n      }\n      break;\n    }\n  }\n}\nfunction createIfBranch(node, dir) {\n  const isTemplateIf = node.tagType === 3;\n  return {\n    type: 10,\n    loc: node.loc,\n    condition: dir.name === \"else\" ? void 0 : dir.exp,\n    children: isTemplateIf && !findDir(node, \"for\") ? node.children : [node],\n    userKey: findProp(node, `key`),\n    isTemplateIf\n  };\n}\nfunction createCodegenNodeForBranch(branch, keyIndex, context) {\n  if (branch.condition) {\n    return createConditionalExpression(\n      branch.condition,\n      createChildrenCodegenNode(branch, keyIndex, context),\n      // make sure to pass in asBlock: true so that the comment node call\n      // closes the current block.\n      createCallExpression(context.helper(CREATE_COMMENT), [\n        !!(process.env.NODE_ENV !== \"production\") ? '\"v-if\"' : '\"\"',\n        \"true\"\n      ])\n    );\n  } else {\n    return createChildrenCodegenNode(branch, keyIndex, context);\n  }\n}\nfunction createChildrenCodegenNode(branch, keyIndex, context) {\n  const { helper } = context;\n  const keyProperty = createObjectProperty(\n    `key`,\n    createSimpleExpression(\n      `${keyIndex}`,\n      false,\n      locStub,\n      2\n    )\n  );\n  const { children } = branch;\n  const firstChild = children[0];\n  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;\n  if (needFragmentWrapper) {\n    if (children.length === 1 && firstChild.type === 11) {\n      const vnodeCall = firstChild.codegenNode;\n      injectProp(vnodeCall, keyProperty, context);\n      return vnodeCall;\n    } else {\n      let patchFlag = 64;\n      if (!!(process.env.NODE_ENV !== \"production\") && !branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {\n        patchFlag |= 2048;\n      }\n      return createVNodeCall(\n        context,\n        helper(FRAGMENT),\n        createObjectExpression([keyProperty]),\n        children,\n        patchFlag,\n        void 0,\n        void 0,\n        true,\n        false,\n        false,\n        branch.loc\n      );\n    }\n  } else {\n    const ret = firstChild.codegenNode;\n    const vnodeCall = getMemoedVNodeCall(ret);\n    if (vnodeCall.type === 13) {\n      convertToBlock(vnodeCall, context);\n    }\n    injectProp(vnodeCall, keyProperty, context);\n    return ret;\n  }\n}\nfunction isSameKey(a, b) {\n  if (!a || a.type !== b.type) {\n    return false;\n  }\n  if (a.type === 6) {\n    if (a.value.content !== b.value.content) {\n      return false;\n    }\n  } else {\n    const exp = a.exp;\n    const branchExp = b.exp;\n    if (exp.type !== branchExp.type) {\n      return false;\n    }\n    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getParentCondition(node) {\n  while (true) {\n    if (node.type === 19) {\n      if (node.alternate.type === 19) {\n        node = node.alternate;\n      } else {\n        return node;\n      }\n    } else if (node.type === 20) {\n      node = node.value;\n    }\n  }\n}\n\nconst transformFor = createStructuralDirectiveTransform(\n  \"for\",\n  (node, dir, context) => {\n    const { helper, removeHelper } = context;\n    return processFor(node, dir, context, (forNode) => {\n      const renderExp = createCallExpression(helper(RENDER_LIST), [\n        forNode.source\n      ]);\n      const isTemplate = isTemplateNode(node);\n      const memo = findDir(node, \"memo\");\n      const keyProp = findProp(node, `key`, false, true);\n      keyProp && keyProp.type === 7;\n      let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);\n      const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;\n      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;\n      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;\n      forNode.codegenNode = createVNodeCall(\n        context,\n        helper(FRAGMENT),\n        void 0,\n        renderExp,\n        fragmentFlag,\n        void 0,\n        void 0,\n        true,\n        !isStableFragment,\n        false,\n        node.loc\n      );\n      return () => {\n        let childBlock;\n        const { children } = forNode;\n        if ((!!(process.env.NODE_ENV !== \"production\") || false) && isTemplate) {\n          node.children.some((c) => {\n            if (c.type === 1) {\n              const key = findProp(c, \"key\");\n              if (key) {\n                context.onError(\n                  createCompilerError(\n                    33,\n                    key.loc\n                  )\n                );\n                return true;\n              }\n            }\n          });\n        }\n        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;\n        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;\n        if (slotOutlet) {\n          childBlock = slotOutlet.codegenNode;\n          if (isTemplate && keyProperty) {\n            injectProp(childBlock, keyProperty, context);\n          }\n        } else if (needFragmentWrapper) {\n          childBlock = createVNodeCall(\n            context,\n            helper(FRAGMENT),\n            keyProperty ? createObjectExpression([keyProperty]) : void 0,\n            node.children,\n            64,\n            void 0,\n            void 0,\n            true,\n            void 0,\n            false\n          );\n        } else {\n          childBlock = children[0].codegenNode;\n          if (isTemplate && keyProperty) {\n            injectProp(childBlock, keyProperty, context);\n          }\n          if (childBlock.isBlock !== !isStableFragment) {\n            if (childBlock.isBlock) {\n              removeHelper(OPEN_BLOCK);\n              removeHelper(\n                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)\n              );\n            } else {\n              removeHelper(\n                getVNodeHelper(context.inSSR, childBlock.isComponent)\n              );\n            }\n          }\n          childBlock.isBlock = !isStableFragment;\n          if (childBlock.isBlock) {\n            helper(OPEN_BLOCK);\n            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));\n          } else {\n            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));\n          }\n        }\n        if (memo) {\n          const loop = createFunctionExpression(\n            createForLoopParams(forNode.parseResult, [\n              createSimpleExpression(`_cached`)\n            ])\n          );\n          loop.body = createBlockStatement([\n            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),\n            createCompoundExpression([\n              `if (_cached`,\n              ...keyExp ? [` && _cached.key === `, keyExp] : [],\n              ` && ${context.helperString(\n                IS_MEMO_SAME\n              )}(_cached, _memo)) return _cached`\n            ]),\n            createCompoundExpression([`const _item = `, childBlock]),\n            createSimpleExpression(`_item.memo = _memo`),\n            createSimpleExpression(`return _item`)\n          ]);\n          renderExp.arguments.push(\n            loop,\n            createSimpleExpression(`_cache`),\n            createSimpleExpression(String(context.cached.length))\n          );\n          context.cached.push(null);\n        } else {\n          renderExp.arguments.push(\n            createFunctionExpression(\n              createForLoopParams(forNode.parseResult),\n              childBlock,\n              true\n            )\n          );\n        }\n      };\n    });\n  }\n);\nfunction processFor(node, dir, context, processCodegen) {\n  if (!dir.exp) {\n    context.onError(\n      createCompilerError(31, dir.loc)\n    );\n    return;\n  }\n  const parseResult = dir.forParseResult;\n  if (!parseResult) {\n    context.onError(\n      createCompilerError(32, dir.loc)\n    );\n    return;\n  }\n  finalizeForParseResult(parseResult, context);\n  const { addIdentifiers, removeIdentifiers, scopes } = context;\n  const { source, value, key, index } = parseResult;\n  const forNode = {\n    type: 11,\n    loc: dir.loc,\n    source,\n    valueAlias: value,\n    keyAlias: key,\n    objectIndexAlias: index,\n    parseResult,\n    children: isTemplateNode(node) ? node.children : [node]\n  };\n  context.replaceNode(forNode);\n  scopes.vFor++;\n  const onExit = processCodegen && processCodegen(forNode);\n  return () => {\n    scopes.vFor--;\n    if (onExit) onExit();\n  };\n}\nfunction finalizeForParseResult(result, context) {\n  if (result.finalized) return;\n  if (!!(process.env.NODE_ENV !== \"production\") && true) {\n    validateBrowserExpression(result.source, context);\n    if (result.key) {\n      validateBrowserExpression(\n        result.key,\n        context,\n        true\n      );\n    }\n    if (result.index) {\n      validateBrowserExpression(\n        result.index,\n        context,\n        true\n      );\n    }\n    if (result.value) {\n      validateBrowserExpression(\n        result.value,\n        context,\n        true\n      );\n    }\n  }\n  result.finalized = true;\n}\nfunction createForLoopParams({ value, key, index }, memoArgs = []) {\n  return createParamsList([value, key, index, ...memoArgs]);\n}\nfunction createParamsList(args) {\n  let i = args.length;\n  while (i--) {\n    if (args[i]) break;\n  }\n  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));\n}\n\nconst defaultFallback = createSimpleExpression(`undefined`, false);\nconst trackSlotScopes = (node, context) => {\n  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {\n    const vSlot = findDir(node, \"slot\");\n    if (vSlot) {\n      vSlot.exp;\n      context.scopes.vSlot++;\n      return () => {\n        context.scopes.vSlot--;\n      };\n    }\n  }\n};\nconst trackVForSlotScopes = (node, context) => {\n  let vFor;\n  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, \"for\"))) {\n    const result = vFor.forParseResult;\n    if (result) {\n      finalizeForParseResult(result, context);\n      const { value, key, index } = result;\n      const { addIdentifiers, removeIdentifiers } = context;\n      value && addIdentifiers(value);\n      key && addIdentifiers(key);\n      index && addIdentifiers(index);\n      return () => {\n        value && removeIdentifiers(value);\n        key && removeIdentifiers(key);\n        index && removeIdentifiers(index);\n      };\n    }\n  }\n};\nconst buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(\n  props,\n  children,\n  false,\n  true,\n  children.length ? children[0].loc : loc\n);\nfunction buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\n  context.helper(WITH_CTX);\n  const { children, loc } = node;\n  const slotsProperties = [];\n  const dynamicSlots = [];\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\n  const onComponentSlot = findDir(node, \"slot\", true);\n  if (onComponentSlot) {\n    const { arg, exp } = onComponentSlot;\n    if (arg && !isStaticExp(arg)) {\n      hasDynamicSlots = true;\n    }\n    slotsProperties.push(\n      createObjectProperty(\n        arg || createSimpleExpression(\"default\", true),\n        buildSlotFn(exp, void 0, children, loc)\n      )\n    );\n  }\n  let hasTemplateSlots = false;\n  let hasNamedDefaultSlot = false;\n  const implicitDefaultChildren = [];\n  const seenSlotNames = /* @__PURE__ */ new Set();\n  let conditionalBranchIndex = 0;\n  for (let i = 0; i < children.length; i++) {\n    const slotElement = children[i];\n    let slotDir;\n    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, \"slot\", true))) {\n      if (slotElement.type !== 3) {\n        implicitDefaultChildren.push(slotElement);\n      }\n      continue;\n    }\n    if (onComponentSlot) {\n      context.onError(\n        createCompilerError(37, slotDir.loc)\n      );\n      break;\n    }\n    hasTemplateSlots = true;\n    const { children: slotChildren, loc: slotLoc } = slotElement;\n    const {\n      arg: slotName = createSimpleExpression(`default`, true),\n      exp: slotProps,\n      loc: dirLoc\n    } = slotDir;\n    let staticSlotName;\n    if (isStaticExp(slotName)) {\n      staticSlotName = slotName ? slotName.content : `default`;\n    } else {\n      hasDynamicSlots = true;\n    }\n    const vFor = findDir(slotElement, \"for\");\n    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);\n    let vIf;\n    let vElse;\n    if (vIf = findDir(slotElement, \"if\")) {\n      hasDynamicSlots = true;\n      dynamicSlots.push(\n        createConditionalExpression(\n          vIf.exp,\n          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),\n          defaultFallback\n        )\n      );\n    } else if (vElse = findDir(\n      slotElement,\n      /^else(?:-if)?$/,\n      true\n      /* allowEmpty */\n    )) {\n      let j = i;\n      let prev;\n      while (j--) {\n        prev = children[j];\n        if (prev.type !== 3 && isNonWhitespaceContent(prev)) {\n          break;\n        }\n      }\n      if (prev && isTemplateNode(prev) && findDir(prev, /^(?:else-)?if$/)) {\n        let conditional = dynamicSlots[dynamicSlots.length - 1];\n        while (conditional.alternate.type === 19) {\n          conditional = conditional.alternate;\n        }\n        conditional.alternate = vElse.exp ? createConditionalExpression(\n          vElse.exp,\n          buildDynamicSlot(\n            slotName,\n            slotFunction,\n            conditionalBranchIndex++\n          ),\n          defaultFallback\n        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);\n      } else {\n        context.onError(\n          createCompilerError(30, vElse.loc)\n        );\n      }\n    } else if (vFor) {\n      hasDynamicSlots = true;\n      const parseResult = vFor.forParseResult;\n      if (parseResult) {\n        finalizeForParseResult(parseResult, context);\n        dynamicSlots.push(\n          createCallExpression(context.helper(RENDER_LIST), [\n            parseResult.source,\n            createFunctionExpression(\n              createForLoopParams(parseResult),\n              buildDynamicSlot(slotName, slotFunction),\n              true\n            )\n          ])\n        );\n      } else {\n        context.onError(\n          createCompilerError(\n            32,\n            vFor.loc\n          )\n        );\n      }\n    } else {\n      if (staticSlotName) {\n        if (seenSlotNames.has(staticSlotName)) {\n          context.onError(\n            createCompilerError(\n              38,\n              dirLoc\n            )\n          );\n          continue;\n        }\n        seenSlotNames.add(staticSlotName);\n        if (staticSlotName === \"default\") {\n          hasNamedDefaultSlot = true;\n        }\n      }\n      slotsProperties.push(createObjectProperty(slotName, slotFunction));\n    }\n  }\n  if (!onComponentSlot) {\n    const buildDefaultSlotProperty = (props, children2) => {\n      const fn = buildSlotFn(props, void 0, children2, loc);\n      if (context.compatConfig) {\n        fn.isNonScopedSlot = true;\n      }\n      return createObjectProperty(`default`, fn);\n    };\n    if (!hasTemplateSlots) {\n      slotsProperties.push(buildDefaultSlotProperty(void 0, children));\n    } else if (implicitDefaultChildren.length && // #3766\n    // with whitespace: 'preserve', whitespaces between slots will end up in\n    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\n    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {\n      if (hasNamedDefaultSlot) {\n        context.onError(\n          createCompilerError(\n            39,\n            implicitDefaultChildren[0].loc\n          )\n        );\n      } else {\n        slotsProperties.push(\n          buildDefaultSlotProperty(void 0, implicitDefaultChildren)\n        );\n      }\n    }\n  }\n  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;\n  let slots = createObjectExpression(\n    slotsProperties.concat(\n      createObjectProperty(\n        `_`,\n        // 2 = compiled but dynamic = can skip normalization, but must run diff\n        // 1 = compiled and static = can skip normalization AND diff as optimized\n        createSimpleExpression(\n          slotFlag + (!!(process.env.NODE_ENV !== \"production\") ? ` /* ${slotFlagsText[slotFlag]} */` : ``),\n          false\n        )\n      )\n    ),\n    loc\n  );\n  if (dynamicSlots.length) {\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\n      slots,\n      createArrayExpression(dynamicSlots)\n    ]);\n  }\n  return {\n    slots,\n    hasDynamicSlots\n  };\n}\nfunction buildDynamicSlot(name, fn, index) {\n  const props = [\n    createObjectProperty(`name`, name),\n    createObjectProperty(`fn`, fn)\n  ];\n  if (index != null) {\n    props.push(\n      createObjectProperty(`key`, createSimpleExpression(String(index), true))\n    );\n  }\n  return createObjectExpression(props);\n}\nfunction hasForwardedSlots(children) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    switch (child.type) {\n      case 1:\n        if (child.tagType === 2 || hasForwardedSlots(child.children)) {\n          return true;\n        }\n        break;\n      case 9:\n        if (hasForwardedSlots(child.branches)) return true;\n        break;\n      case 10:\n      case 11:\n        if (hasForwardedSlots(child.children)) return true;\n        break;\n    }\n  }\n  return false;\n}\nfunction isNonWhitespaceContent(node) {\n  if (node.type !== 2 && node.type !== 12)\n    return true;\n  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);\n}\n\nconst directiveImportMap = /* @__PURE__ */ new WeakMap();\nconst transformElement = (node, context) => {\n  return function postTransformElement() {\n    node = context.currentNode;\n    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {\n      return;\n    }\n    const { tag, props } = node;\n    const isComponent = node.tagType === 1;\n    let vnodeTag = isComponent ? resolveComponentType(node, context) : `\"${tag}\"`;\n    const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\n    let vnodeProps;\n    let vnodeChildren;\n    let patchFlag = 0;\n    let vnodeDynamicProps;\n    let dynamicPropNames;\n    let vnodeDirectives;\n    let shouldUseBlock = (\n      // dynamic component may resolve to plain elements\n      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block\n      // updates inside get proper isSVG flag at runtime. (#639, #643)\n      // This is technically web-specific, but splitting the logic out of core\n      // leads to too much unnecessary complexity.\n      (tag === \"svg\" || tag === \"foreignObject\" || tag === \"math\")\n    );\n    if (props.length > 0) {\n      const propsBuildResult = buildProps(\n        node,\n        context,\n        void 0,\n        isComponent,\n        isDynamicComponent\n      );\n      vnodeProps = propsBuildResult.props;\n      patchFlag = propsBuildResult.patchFlag;\n      dynamicPropNames = propsBuildResult.dynamicPropNames;\n      const directives = propsBuildResult.directives;\n      vnodeDirectives = directives && directives.length ? createArrayExpression(\n        directives.map((dir) => buildDirectiveArgs(dir, context))\n      ) : void 0;\n      if (propsBuildResult.shouldUseBlock) {\n        shouldUseBlock = true;\n      }\n    }\n    if (node.children.length > 0) {\n      if (vnodeTag === KEEP_ALIVE) {\n        shouldUseBlock = true;\n        patchFlag |= 1024;\n        if (!!(process.env.NODE_ENV !== \"production\") && node.children.length > 1) {\n          context.onError(\n            createCompilerError(46, {\n              start: node.children[0].loc.start,\n              end: node.children[node.children.length - 1].loc.end,\n              source: \"\"\n            })\n          );\n        }\n      }\n      const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling\n      vnodeTag !== TELEPORT && // explained above.\n      vnodeTag !== KEEP_ALIVE;\n      if (shouldBuildAsSlots) {\n        const { slots, hasDynamicSlots } = buildSlots(node, context);\n        vnodeChildren = slots;\n        if (hasDynamicSlots) {\n          patchFlag |= 1024;\n        }\n      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\n        const child = node.children[0];\n        const type = child.type;\n        const hasDynamicTextChild = type === 5 || type === 8;\n        if (hasDynamicTextChild && getConstantType(child, context) === 0) {\n          patchFlag |= 1;\n        }\n        if (hasDynamicTextChild || type === 2) {\n          vnodeChildren = child;\n        } else {\n          vnodeChildren = node.children;\n        }\n      } else {\n        vnodeChildren = node.children;\n      }\n    }\n    if (dynamicPropNames && dynamicPropNames.length) {\n      vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\n    }\n    node.codegenNode = createVNodeCall(\n      context,\n      vnodeTag,\n      vnodeProps,\n      vnodeChildren,\n      patchFlag === 0 ? void 0 : patchFlag,\n      vnodeDynamicProps,\n      vnodeDirectives,\n      !!shouldUseBlock,\n      false,\n      isComponent,\n      node.loc\n    );\n  };\n};\nfunction resolveComponentType(node, context, ssr = false) {\n  let { tag } = node;\n  const isExplicitDynamic = isComponentTag(tag);\n  const isProp = findProp(\n    node,\n    \"is\",\n    false,\n    true\n    /* allow empty */\n  );\n  if (isProp) {\n    if (isExplicitDynamic || isCompatEnabled(\n      \"COMPILER_IS_ON_ELEMENT\",\n      context\n    )) {\n      let exp;\n      if (isProp.type === 6) {\n        exp = isProp.value && createSimpleExpression(isProp.value.content, true);\n      } else {\n        exp = isProp.exp;\n        if (!exp) {\n          exp = createSimpleExpression(`is`, false, isProp.arg.loc);\n        }\n      }\n      if (exp) {\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n          exp\n        ]);\n      }\n    } else if (isProp.type === 6 && isProp.value.content.startsWith(\"vue:\")) {\n      tag = isProp.value.content.slice(4);\n    }\n  }\n  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\n  if (builtIn) {\n    if (!ssr) context.helper(builtIn);\n    return builtIn;\n  }\n  context.helper(RESOLVE_COMPONENT);\n  context.components.add(tag);\n  return toValidAssetId(tag, `component`);\n}\nfunction buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {\n  const { tag, loc: elementLoc, children } = node;\n  let properties = [];\n  const mergeArgs = [];\n  const runtimeDirectives = [];\n  const hasChildren = children.length > 0;\n  let shouldUseBlock = false;\n  let patchFlag = 0;\n  let hasRef = false;\n  let hasClassBinding = false;\n  let hasStyleBinding = false;\n  let hasHydrationEventBinding = false;\n  let hasDynamicKeys = false;\n  let hasVnodeHook = false;\n  const dynamicPropNames = [];\n  const pushMergeArg = (arg) => {\n    if (properties.length) {\n      mergeArgs.push(\n        createObjectExpression(dedupeProperties(properties), elementLoc)\n      );\n      properties = [];\n    }\n    if (arg) mergeArgs.push(arg);\n  };\n  const pushRefVForMarker = () => {\n    if (context.scopes.vFor > 0) {\n      properties.push(\n        createObjectProperty(\n          createSimpleExpression(\"ref_for\", true),\n          createSimpleExpression(\"true\")\n        )\n      );\n    }\n  };\n  const analyzePatchFlag = ({ key, value }) => {\n    if (isStaticExp(key)) {\n      const name = key.content;\n      const isEventHandler = isOn(name);\n      if (isEventHandler && (!isComponent || isDynamicComponent) && // omit the flag for click handlers because hydration gives click\n      // dedicated fast path.\n      name.toLowerCase() !== \"onclick\" && // omit v-model handlers\n      name !== \"onUpdate:modelValue\" && // omit onVnodeXXX hooks\n      !isReservedProp(name)) {\n        hasHydrationEventBinding = true;\n      }\n      if (isEventHandler && isReservedProp(name)) {\n        hasVnodeHook = true;\n      }\n      if (isEventHandler && value.type === 14) {\n        value = value.arguments[0];\n      }\n      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {\n        return;\n      }\n      if (name === \"ref\") {\n        hasRef = true;\n      } else if (name === \"class\") {\n        hasClassBinding = true;\n      } else if (name === \"style\") {\n        hasStyleBinding = true;\n      } else if (name !== \"key\" && !dynamicPropNames.includes(name)) {\n        dynamicPropNames.push(name);\n      }\n      if (isComponent && (name === \"class\" || name === \"style\") && !dynamicPropNames.includes(name)) {\n        dynamicPropNames.push(name);\n      }\n    } else {\n      hasDynamicKeys = true;\n    }\n  };\n  for (let i = 0; i < props.length; i++) {\n    const prop = props[i];\n    if (prop.type === 6) {\n      const { loc, name, nameLoc, value } = prop;\n      let isStatic = true;\n      if (name === \"ref\") {\n        hasRef = true;\n        pushRefVForMarker();\n      }\n      if (name === \"is\" && (isComponentTag(tag) || value && value.content.startsWith(\"vue:\") || isCompatEnabled(\n        \"COMPILER_IS_ON_ELEMENT\",\n        context\n      ))) {\n        continue;\n      }\n      properties.push(\n        createObjectProperty(\n          createSimpleExpression(name, true, nameLoc),\n          createSimpleExpression(\n            value ? value.content : \"\",\n            isStatic,\n            value ? value.loc : loc\n          )\n        )\n      );\n    } else {\n      const { name, arg, exp, loc, modifiers } = prop;\n      const isVBind = name === \"bind\";\n      const isVOn = name === \"on\";\n      if (name === \"slot\") {\n        if (!isComponent) {\n          context.onError(\n            createCompilerError(40, loc)\n          );\n        }\n        continue;\n      }\n      if (name === \"once\" || name === \"memo\") {\n        continue;\n      }\n      if (name === \"is\" || isVBind && isStaticArgOf(arg, \"is\") && (isComponentTag(tag) || isCompatEnabled(\n        \"COMPILER_IS_ON_ELEMENT\",\n        context\n      ))) {\n        continue;\n      }\n      if (isVOn && ssr) {\n        continue;\n      }\n      if (\n        // #938: elements with dynamic keys should be forced into blocks\n        isVBind && isStaticArgOf(arg, \"key\") || // inline before-update hooks need to force block so that it is invoked\n        // before children\n        isVOn && hasChildren && isStaticArgOf(arg, \"vue:before-update\")\n      ) {\n        shouldUseBlock = true;\n      }\n      if (isVBind && isStaticArgOf(arg, \"ref\")) {\n        pushRefVForMarker();\n      }\n      if (!arg && (isVBind || isVOn)) {\n        hasDynamicKeys = true;\n        if (exp) {\n          if (isVBind) {\n            {\n              pushMergeArg();\n              if (!!(process.env.NODE_ENV !== \"production\")) {\n                const hasOverridableKeys = mergeArgs.some((arg2) => {\n                  if (arg2.type === 15) {\n                    return arg2.properties.some(({ key }) => {\n                      if (key.type !== 4 || !key.isStatic) {\n                        return true;\n                      }\n                      return key.content !== \"class\" && key.content !== \"style\" && !isOn(key.content);\n                    });\n                  } else {\n                    return true;\n                  }\n                });\n                if (hasOverridableKeys) {\n                  checkCompatEnabled(\n                    \"COMPILER_V_BIND_OBJECT_ORDER\",\n                    context,\n                    loc\n                  );\n                }\n              }\n              if (isCompatEnabled(\n                \"COMPILER_V_BIND_OBJECT_ORDER\",\n                context\n              )) {\n                mergeArgs.unshift(exp);\n                continue;\n              }\n            }\n            pushRefVForMarker();\n            pushMergeArg();\n            mergeArgs.push(exp);\n          } else {\n            pushMergeArg({\n              type: 14,\n              loc,\n              callee: context.helper(TO_HANDLERS),\n              arguments: isComponent ? [exp] : [exp, `true`]\n            });\n          }\n        } else {\n          context.onError(\n            createCompilerError(\n              isVBind ? 34 : 35,\n              loc\n            )\n          );\n        }\n        continue;\n      }\n      if (isVBind && modifiers.some((mod) => mod.content === \"prop\")) {\n        patchFlag |= 32;\n      }\n      const directiveTransform = context.directiveTransforms[name];\n      if (directiveTransform) {\n        const { props: props2, needRuntime } = directiveTransform(prop, node, context);\n        !ssr && props2.forEach(analyzePatchFlag);\n        if (isVOn && arg && !isStaticExp(arg)) {\n          pushMergeArg(createObjectExpression(props2, elementLoc));\n        } else {\n          properties.push(...props2);\n        }\n        if (needRuntime) {\n          runtimeDirectives.push(prop);\n          if (isSymbol(needRuntime)) {\n            directiveImportMap.set(prop, needRuntime);\n          }\n        }\n      } else if (!isBuiltInDirective(name)) {\n        runtimeDirectives.push(prop);\n        if (hasChildren) {\n          shouldUseBlock = true;\n        }\n      }\n    }\n  }\n  let propsExpression = void 0;\n  if (mergeArgs.length) {\n    pushMergeArg();\n    if (mergeArgs.length > 1) {\n      propsExpression = createCallExpression(\n        context.helper(MERGE_PROPS),\n        mergeArgs,\n        elementLoc\n      );\n    } else {\n      propsExpression = mergeArgs[0];\n    }\n  } else if (properties.length) {\n    propsExpression = createObjectExpression(\n      dedupeProperties(properties),\n      elementLoc\n    );\n  }\n  if (hasDynamicKeys) {\n    patchFlag |= 16;\n  } else {\n    if (hasClassBinding && !isComponent) {\n      patchFlag |= 2;\n    }\n    if (hasStyleBinding && !isComponent) {\n      patchFlag |= 4;\n    }\n    if (dynamicPropNames.length) {\n      patchFlag |= 8;\n    }\n    if (hasHydrationEventBinding) {\n      patchFlag |= 32;\n    }\n  }\n  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\n    patchFlag |= 512;\n  }\n  if (!context.inSSR && propsExpression) {\n    switch (propsExpression.type) {\n      case 15:\n        let classKeyIndex = -1;\n        let styleKeyIndex = -1;\n        let hasDynamicKey = false;\n        for (let i = 0; i < propsExpression.properties.length; i++) {\n          const key = propsExpression.properties[i].key;\n          if (isStaticExp(key)) {\n            if (key.content === \"class\") {\n              classKeyIndex = i;\n            } else if (key.content === \"style\") {\n              styleKeyIndex = i;\n            }\n          } else if (!key.isHandlerKey) {\n            hasDynamicKey = true;\n          }\n        }\n        const classProp = propsExpression.properties[classKeyIndex];\n        const styleProp = propsExpression.properties[styleKeyIndex];\n        if (!hasDynamicKey) {\n          if (classProp && !isStaticExp(classProp.value)) {\n            classProp.value = createCallExpression(\n              context.helper(NORMALIZE_CLASS),\n              [classProp.value]\n            );\n          }\n          if (styleProp && // the static style is compiled into an object,\n          // so use `hasStyleBinding` to ensure that it is a dynamic style binding\n          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,\n          // v-bind:style with static literal object\n          styleProp.value.type === 17)) {\n            styleProp.value = createCallExpression(\n              context.helper(NORMALIZE_STYLE),\n              [styleProp.value]\n            );\n          }\n        } else {\n          propsExpression = createCallExpression(\n            context.helper(NORMALIZE_PROPS),\n            [propsExpression]\n          );\n        }\n        break;\n      case 14:\n        break;\n      default:\n        propsExpression = createCallExpression(\n          context.helper(NORMALIZE_PROPS),\n          [\n            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\n              propsExpression\n            ])\n          ]\n        );\n        break;\n    }\n  }\n  return {\n    props: propsExpression,\n    directives: runtimeDirectives,\n    patchFlag,\n    dynamicPropNames,\n    shouldUseBlock\n  };\n}\nfunction dedupeProperties(properties) {\n  const knownProps = /* @__PURE__ */ new Map();\n  const deduped = [];\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i];\n    if (prop.key.type === 8 || !prop.key.isStatic) {\n      deduped.push(prop);\n      continue;\n    }\n    const name = prop.key.content;\n    const existing = knownProps.get(name);\n    if (existing) {\n      if (name === \"style\" || name === \"class\" || isOn(name)) {\n        mergeAsArray(existing, prop);\n      }\n    } else {\n      knownProps.set(name, prop);\n      deduped.push(prop);\n    }\n  }\n  return deduped;\n}\nfunction mergeAsArray(existing, incoming) {\n  if (existing.value.type === 17) {\n    existing.value.elements.push(incoming.value);\n  } else {\n    existing.value = createArrayExpression(\n      [existing.value, incoming.value],\n      existing.loc\n    );\n  }\n}\nfunction buildDirectiveArgs(dir, context) {\n  const dirArgs = [];\n  const runtime = directiveImportMap.get(dir);\n  if (runtime) {\n    dirArgs.push(context.helperString(runtime));\n  } else {\n    {\n      context.helper(RESOLVE_DIRECTIVE);\n      context.directives.add(dir.name);\n      dirArgs.push(toValidAssetId(dir.name, `directive`));\n    }\n  }\n  const { loc } = dir;\n  if (dir.exp) dirArgs.push(dir.exp);\n  if (dir.arg) {\n    if (!dir.exp) {\n      dirArgs.push(`void 0`);\n    }\n    dirArgs.push(dir.arg);\n  }\n  if (Object.keys(dir.modifiers).length) {\n    if (!dir.arg) {\n      if (!dir.exp) {\n        dirArgs.push(`void 0`);\n      }\n      dirArgs.push(`void 0`);\n    }\n    const trueExpression = createSimpleExpression(`true`, false, loc);\n    dirArgs.push(\n      createObjectExpression(\n        dir.modifiers.map(\n          (modifier) => createObjectProperty(modifier, trueExpression)\n        ),\n        loc\n      )\n    );\n  }\n  return createArrayExpression(dirArgs, dir.loc);\n}\nfunction stringifyDynamicPropNames(props) {\n  let propsNamesString = `[`;\n  for (let i = 0, l = props.length; i < l; i++) {\n    propsNamesString += JSON.stringify(props[i]);\n    if (i < l - 1) propsNamesString += \", \";\n  }\n  return propsNamesString + `]`;\n}\nfunction isComponentTag(tag) {\n  return tag === \"component\" || tag === \"Component\";\n}\n\nconst transformSlotOutlet = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const { children, loc } = node;\n    const { slotName, slotProps } = processSlotOutlet(node, context);\n    const slotArgs = [\n      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\n      slotName,\n      \"{}\",\n      \"undefined\",\n      \"true\"\n    ];\n    let expectedLen = 2;\n    if (slotProps) {\n      slotArgs[2] = slotProps;\n      expectedLen = 3;\n    }\n    if (children.length) {\n      slotArgs[3] = createFunctionExpression([], children, false, false, loc);\n      expectedLen = 4;\n    }\n    if (context.scopeId && !context.slotted) {\n      expectedLen = 5;\n    }\n    slotArgs.splice(expectedLen);\n    node.codegenNode = createCallExpression(\n      context.helper(RENDER_SLOT),\n      slotArgs,\n      loc\n    );\n  }\n};\nfunction processSlotOutlet(node, context) {\n  let slotName = `\"default\"`;\n  let slotProps = void 0;\n  const nonNameProps = [];\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 6) {\n      if (p.value) {\n        if (p.name === \"name\") {\n          slotName = JSON.stringify(p.value.content);\n        } else {\n          p.name = camelize(p.name);\n          nonNameProps.push(p);\n        }\n      }\n    } else {\n      if (p.name === \"bind\" && isStaticArgOf(p.arg, \"name\")) {\n        if (p.exp) {\n          slotName = p.exp;\n        } else if (p.arg && p.arg.type === 4) {\n          const name = camelize(p.arg.content);\n          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);\n        }\n      } else {\n        if (p.name === \"bind\" && p.arg && isStaticExp(p.arg)) {\n          p.arg.content = camelize(p.arg.content);\n        }\n        nonNameProps.push(p);\n      }\n    }\n  }\n  if (nonNameProps.length > 0) {\n    const { props, directives } = buildProps(\n      node,\n      context,\n      nonNameProps,\n      false,\n      false\n    );\n    slotProps = props;\n    if (directives.length) {\n      context.onError(\n        createCompilerError(\n          36,\n          directives[0].loc\n        )\n      );\n    }\n  }\n  return {\n    slotName,\n    slotProps\n  };\n}\n\nconst transformOn = (dir, node, context, augmentor) => {\n  const { loc, modifiers, arg } = dir;\n  if (!dir.exp && !modifiers.length) {\n    context.onError(createCompilerError(35, loc));\n  }\n  let eventName;\n  if (arg.type === 4) {\n    if (arg.isStatic) {\n      let rawName = arg.content;\n      if (!!(process.env.NODE_ENV !== \"production\") && rawName.startsWith(\"vnode\")) {\n        context.onError(createCompilerError(51, arg.loc));\n      }\n      if (rawName.startsWith(\"vue:\")) {\n        rawName = `vnode-${rawName.slice(4)}`;\n      }\n      const eventString = node.tagType !== 0 || rawName.startsWith(\"vnode\") || !/[A-Z]/.test(rawName) ? (\n        // for non-element and vnode lifecycle event listeners, auto convert\n        // it to camelCase. See issue #2249\n        toHandlerKey(camelize(rawName))\n      ) : (\n        // preserve case for plain element listeners that have uppercase\n        // letters, as these may be custom elements' custom events\n        `on:${rawName}`\n      );\n      eventName = createSimpleExpression(eventString, true, arg.loc);\n    } else {\n      eventName = createCompoundExpression([\n        `${context.helperString(TO_HANDLER_KEY)}(`,\n        arg,\n        `)`\n      ]);\n    }\n  } else {\n    eventName = arg;\n    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\n    eventName.children.push(`)`);\n  }\n  let exp = dir.exp;\n  if (exp && !exp.content.trim()) {\n    exp = void 0;\n  }\n  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;\n  if (exp) {\n    const isMemberExp = isMemberExpression(exp);\n    const isInlineStatement = !(isMemberExp || isFnExpression(exp));\n    const hasMultipleStatements = exp.content.includes(`;`);\n    if (!!(process.env.NODE_ENV !== \"production\") && true) {\n      validateBrowserExpression(\n        exp,\n        context,\n        false,\n        hasMultipleStatements\n      );\n    }\n    if (isInlineStatement || shouldCache && isMemberExp) {\n      exp = createCompoundExpression([\n        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\n        exp,\n        hasMultipleStatements ? `}` : `)`\n      ]);\n    }\n  }\n  let ret = {\n    props: [\n      createObjectProperty(\n        eventName,\n        exp || createSimpleExpression(`() => {}`, false, loc)\n      )\n    ]\n  };\n  if (augmentor) {\n    ret = augmentor(ret);\n  }\n  if (shouldCache) {\n    ret.props[0].value = context.cache(ret.props[0].value);\n  }\n  ret.props.forEach((p) => p.key.isHandlerKey = true);\n  return ret;\n};\n\nconst transformBind = (dir, _node, context) => {\n  const { modifiers, loc } = dir;\n  const arg = dir.arg;\n  let { exp } = dir;\n  if (exp && exp.type === 4 && !exp.content.trim()) {\n    {\n      exp = void 0;\n    }\n  }\n  if (arg.type !== 4) {\n    arg.children.unshift(`(`);\n    arg.children.push(`) || \"\"`);\n  } else if (!arg.isStatic) {\n    arg.content = arg.content ? `${arg.content} || \"\"` : `\"\"`;\n  }\n  if (modifiers.some((mod) => mod.content === \"camel\")) {\n    if (arg.type === 4) {\n      if (arg.isStatic) {\n        arg.content = camelize(arg.content);\n      } else {\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\n      }\n    } else {\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\n      arg.children.push(`)`);\n    }\n  }\n  if (!context.inSSR) {\n    if (modifiers.some((mod) => mod.content === \"prop\")) {\n      injectPrefix(arg, \".\");\n    }\n    if (modifiers.some((mod) => mod.content === \"attr\")) {\n      injectPrefix(arg, \"^\");\n    }\n  }\n  return {\n    props: [createObjectProperty(arg, exp)]\n  };\n};\nconst injectPrefix = (arg, prefix) => {\n  if (arg.type === 4) {\n    if (arg.isStatic) {\n      arg.content = prefix + arg.content;\n    } else {\n      arg.content = `\\`${prefix}\\${${arg.content}}\\``;\n    }\n  } else {\n    arg.children.unshift(`'${prefix}' + (`);\n    arg.children.push(`)`);\n  }\n};\n\nconst transformText = (node, context) => {\n  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {\n    return () => {\n      const children = node.children;\n      let currentContainer = void 0;\n      let hasText = false;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (isText$1(child)) {\n          hasText = true;\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j];\n            if (isText$1(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = createCompoundExpression(\n                  [child],\n                  child.loc\n                );\n              }\n              currentContainer.children.push(` + `, next);\n              children.splice(j, 1);\n              j--;\n            } else {\n              currentContainer = void 0;\n              break;\n            }\n          }\n        }\n      }\n      if (!hasText || // if this is a plain element with a single text child, leave it\n      // as-is since the runtime has dedicated fast path for this by directly\n      // setting textContent of the element.\n      // for component root it's always normalized anyway.\n      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756\n      // custom directives can potentially add DOM elements arbitrarily,\n      // we need to avoid setting textContent of the element at runtime\n      // to avoid accidentally overwriting the DOM elements added\n      // by the user through custom directives.\n      !node.props.find(\n        (p) => p.type === 7 && !context.directiveTransforms[p.name]\n      ) && // in compat mode, <template> tags with no special directives\n      // will be rendered as a fragment so its children must be\n      // converted into vnodes.\n      !(node.tag === \"template\"))) {\n        return;\n      }\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (isText$1(child) || child.type === 8) {\n          const callArgs = [];\n          if (child.type !== 2 || child.content !== \" \") {\n            callArgs.push(child);\n          }\n          if (!context.ssr && getConstantType(child, context) === 0) {\n            callArgs.push(\n              1 + (!!(process.env.NODE_ENV !== \"production\") ? ` /* ${PatchFlagNames[1]} */` : ``)\n            );\n          }\n          children[i] = {\n            type: 12,\n            content: child,\n            loc: child.loc,\n            codegenNode: createCallExpression(\n              context.helper(CREATE_TEXT),\n              callArgs\n            )\n          };\n        }\n      }\n    };\n  }\n};\n\nconst seen$1 = /* @__PURE__ */ new WeakSet();\nconst transformOnce = (node, context) => {\n  if (node.type === 1 && findDir(node, \"once\", true)) {\n    if (seen$1.has(node) || context.inVOnce || context.inSSR) {\n      return;\n    }\n    seen$1.add(node);\n    context.inVOnce = true;\n    context.helper(SET_BLOCK_TRACKING);\n    return () => {\n      context.inVOnce = false;\n      const cur = context.currentNode;\n      if (cur.codegenNode) {\n        cur.codegenNode = context.cache(\n          cur.codegenNode,\n          true,\n          true\n        );\n      }\n    };\n  }\n};\n\nconst transformModel = (dir, node, context) => {\n  const { exp, arg } = dir;\n  if (!exp) {\n    context.onError(\n      createCompilerError(41, dir.loc)\n    );\n    return createTransformProps();\n  }\n  const rawExp = exp.loc.source.trim();\n  const expString = exp.type === 4 ? exp.content : rawExp;\n  const bindingType = context.bindingMetadata[rawExp];\n  if (bindingType === \"props\" || bindingType === \"props-aliased\") {\n    context.onError(createCompilerError(44, exp.loc));\n    return createTransformProps();\n  }\n  if (!expString.trim() || !isMemberExpression(exp) && true) {\n    context.onError(\n      createCompilerError(42, exp.loc)\n    );\n    return createTransformProps();\n  }\n  const propName = arg ? arg : createSimpleExpression(\"modelValue\", true);\n  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['\"onUpdate:\" + ', arg]) : `onUpdate:modelValue`;\n  let assignmentExp;\n  const eventArg = context.isTS ? `($event: any)` : `$event`;\n  {\n    assignmentExp = createCompoundExpression([\n      `${eventArg} => ((`,\n      exp,\n      `) = $event)`\n    ]);\n  }\n  const props = [\n    // modelValue: foo\n    createObjectProperty(propName, dir.exp),\n    // \"onUpdate:modelValue\": $event => (foo = $event)\n    createObjectProperty(eventName, assignmentExp)\n  ];\n  if (dir.modifiers.length && node.tagType === 1) {\n    const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);\n    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + \"Modifiers\"']) : `modelModifiers`;\n    props.push(\n      createObjectProperty(\n        modifiersKey,\n        createSimpleExpression(\n          `{ ${modifiers} }`,\n          false,\n          dir.loc,\n          2\n        )\n      )\n    );\n  }\n  return createTransformProps(props);\n};\nfunction createTransformProps(props = []) {\n  return { props };\n}\n\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/;\nconst transformFilter = (node, context) => {\n  if (!isCompatEnabled(\"COMPILER_FILTERS\", context)) {\n    return;\n  }\n  if (node.type === 5) {\n    rewriteFilter(node.content, context);\n  } else if (node.type === 1) {\n    node.props.forEach((prop) => {\n      if (prop.type === 7 && prop.name !== \"for\" && prop.exp) {\n        rewriteFilter(prop.exp, context);\n      }\n    });\n  }\n};\nfunction rewriteFilter(node, context) {\n  if (node.type === 4) {\n    parseFilter(node, context);\n  } else {\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n      if (typeof child !== \"object\") continue;\n      if (child.type === 4) {\n        parseFilter(child, context);\n      } else if (child.type === 8) {\n        rewriteFilter(node, context);\n      } else if (child.type === 5) {\n        rewriteFilter(child.content, context);\n      }\n    }\n  }\n}\nfunction parseFilter(node, context) {\n  const exp = node.content;\n  let inSingle = false;\n  let inDouble = false;\n  let inTemplateString = false;\n  let inRegex = false;\n  let curly = 0;\n  let square = 0;\n  let paren = 0;\n  let lastFilterIndex = 0;\n  let c, prev, i, expression, filters = [];\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 39 && prev !== 92) inSingle = false;\n    } else if (inDouble) {\n      if (c === 34 && prev !== 92) inDouble = false;\n    } else if (inTemplateString) {\n      if (c === 96 && prev !== 92) inTemplateString = false;\n    } else if (inRegex) {\n      if (c === 47 && prev !== 92) inRegex = false;\n    } else if (c === 124 && // pipe\n    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {\n      if (expression === void 0) {\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 34:\n          inDouble = true;\n          break;\n        // \"\n        case 39:\n          inSingle = true;\n          break;\n        // '\n        case 96:\n          inTemplateString = true;\n          break;\n        // `\n        case 40:\n          paren++;\n          break;\n        // (\n        case 41:\n          paren--;\n          break;\n        // )\n        case 91:\n          square++;\n          break;\n        // [\n        case 93:\n          square--;\n          break;\n        // ]\n        case 123:\n          curly++;\n          break;\n        // {\n        case 125:\n          curly--;\n          break;\n      }\n      if (c === 47) {\n        let j = i - 1;\n        let p;\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== \" \") break;\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n  if (expression === void 0) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n  function pushFilter() {\n    filters.push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n  if (filters.length) {\n    !!(process.env.NODE_ENV !== \"production\") && warnDeprecation(\n      \"COMPILER_FILTERS\",\n      context,\n      node.loc\n    );\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i], context);\n    }\n    node.content = expression;\n    node.ast = void 0;\n  }\n}\nfunction wrapFilter(exp, filter, context) {\n  context.helper(RESOLVE_FILTER);\n  const i = filter.indexOf(\"(\");\n  if (i < 0) {\n    context.filters.add(filter);\n    return `${toValidAssetId(filter, \"filter\")}(${exp})`;\n  } else {\n    const name = filter.slice(0, i);\n    const args = filter.slice(i + 1);\n    context.filters.add(name);\n    return `${toValidAssetId(name, \"filter\")}(${exp}${args !== \")\" ? \",\" + args : args}`;\n  }\n}\n\nconst seen = /* @__PURE__ */ new WeakSet();\nconst transformMemo = (node, context) => {\n  if (node.type === 1) {\n    const dir = findDir(node, \"memo\");\n    if (!dir || seen.has(node) || context.inSSR) {\n      return;\n    }\n    seen.add(node);\n    return () => {\n      const codegenNode = node.codegenNode || context.currentNode.codegenNode;\n      if (codegenNode && codegenNode.type === 13) {\n        if (node.tagType !== 1) {\n          convertToBlock(codegenNode, context);\n        }\n        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\n          dir.exp,\n          createFunctionExpression(void 0, codegenNode),\n          `_cache`,\n          String(context.cached.length)\n        ]);\n        context.cached.push(null);\n      }\n    };\n  }\n};\n\nconst transformVBindShorthand = (node, context) => {\n  if (node.type === 1) {\n    for (const prop of node.props) {\n      if (prop.type === 7 && prop.name === \"bind\" && (!prop.exp || // #13930 :foo in in-DOM templates will be parsed into :foo=\"\" by browser\n      prop.exp.type === 4 && !prop.exp.content.trim()) && prop.arg) {\n        const arg = prop.arg;\n        if (arg.type !== 4 || !arg.isStatic) {\n          context.onError(\n            createCompilerError(\n              52,\n              arg.loc\n            )\n          );\n          prop.exp = createSimpleExpression(\"\", true, arg.loc);\n        } else {\n          const propName = camelize(arg.content);\n          if (validFirstIdentCharRE.test(propName[0]) || // allow hyphen first char for https://github.com/vuejs/language-tools/pull/3424\n          propName[0] === \"-\") {\n            prop.exp = createSimpleExpression(propName, false, arg.loc);\n          }\n        }\n      }\n    }\n  }\n};\n\nfunction getBaseTransformPreset(prefixIdentifiers) {\n  return [\n    [\n      transformVBindShorthand,\n      transformOnce,\n      transformIf,\n      transformMemo,\n      transformFor,\n      ...[transformFilter] ,\n      ...!!(process.env.NODE_ENV !== \"production\") ? [transformExpression] : [],\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText\n    ],\n    {\n      on: transformOn,\n      bind: transformBind,\n      model: transformModel\n    }\n  ];\n}\nfunction baseCompile(source, options = {}) {\n  const onError = options.onError || defaultOnError;\n  const isModuleMode = options.mode === \"module\";\n  {\n    if (options.prefixIdentifiers === true) {\n      onError(createCompilerError(47));\n    } else if (isModuleMode) {\n      onError(createCompilerError(48));\n    }\n  }\n  const prefixIdentifiers = false;\n  if (options.cacheHandlers) {\n    onError(createCompilerError(49));\n  }\n  if (options.scopeId && !isModuleMode) {\n    onError(createCompilerError(50));\n  }\n  const resolvedOptions = extend({}, options, {\n    prefixIdentifiers\n  });\n  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;\n  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\n  transform(\n    ast,\n    extend({}, resolvedOptions, {\n      nodeTransforms: [\n        ...nodeTransforms,\n        ...options.nodeTransforms || []\n        // user transforms\n      ],\n      directiveTransforms: extend(\n        {},\n        directiveTransforms,\n        options.directiveTransforms || {}\n        // user transforms\n      )\n    })\n  );\n  return generate(ast, resolvedOptions);\n}\n\nconst BindingTypes = {\n  \"DATA\": \"data\",\n  \"PROPS\": \"props\",\n  \"PROPS_ALIASED\": \"props-aliased\",\n  \"SETUP_LET\": \"setup-let\",\n  \"SETUP_CONST\": \"setup-const\",\n  \"SETUP_REACTIVE_CONST\": \"setup-reactive-const\",\n  \"SETUP_MAYBE_REF\": \"setup-maybe-ref\",\n  \"SETUP_REF\": \"setup-ref\",\n  \"OPTIONS\": \"options\",\n  \"LITERAL_CONST\": \"literal-const\"\n};\n\nconst noopDirectiveTransform = () => ({ props: [] });\n\nexport { BASE_TRANSITION, BindingTypes, CAMELIZE, CAPITALIZE, CREATE_BLOCK, CREATE_COMMENT, CREATE_ELEMENT_BLOCK, CREATE_ELEMENT_VNODE, CREATE_SLOTS, CREATE_STATIC, CREATE_TEXT, CREATE_VNODE, CompilerDeprecationTypes, ConstantTypes, ElementTypes, ErrorCodes, FRAGMENT, GUARD_REACTIVE_PROPS, IS_MEMO_SAME, IS_REF, KEEP_ALIVE, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_PROPS, NORMALIZE_STYLE, Namespaces, NodeTypes, OPEN_BLOCK, POP_SCOPE_ID, PUSH_SCOPE_ID, RENDER_LIST, RENDER_SLOT, RESOLVE_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_FILTER, SET_BLOCK_TRACKING, SUSPENSE, TELEPORT, TO_DISPLAY_STRING, TO_HANDLERS, TO_HANDLER_KEY, TS_NODE_TYPES, UNREF, WITH_CTX, WITH_DIRECTIVES, WITH_MEMO, advancePositionWithClone, advancePositionWithMutation, assert, baseCompile, baseParse, buildDirectiveArgs, buildProps, buildSlots, checkCompatEnabled, convertToBlock, createArrayExpression, createAssignmentExpression, createBlockStatement, createCacheExpression, createCallExpression, createCompilerError, createCompoundExpression, createConditionalExpression, createForLoopParams, createFunctionExpression, createIfStatement, createInterpolation, createObjectExpression, createObjectProperty, createReturnStatement, createRoot, createSequenceExpression, createSimpleExpression, createStructuralDirectiveTransform, createTemplateLiteral, createTransformContext, createVNodeCall, errorMessages, extractIdentifiers, findDir, findProp, forAliasRE, generate, getBaseTransformPreset, getConstantType, getMemoedVNodeCall, getVNodeBlockHelper, getVNodeHelper, hasDynamicKeyVBind, hasScopeRef, helperNameMap, injectProp, isCoreComponent, isFnExpression, isFnExpressionBrowser, isFnExpressionNode, isFunctionType, isInDestructureAssignment, isInNewExpression, isMemberExpression, isMemberExpressionBrowser, isMemberExpressionNode, isReferencedIdentifier, isSimpleIdentifier, isSlotOutlet, isStaticArgOf, isStaticExp, isStaticProperty, isStaticPropertyKey, isTemplateNode, isText$1 as isText, isVPre, isVSlot, locStub, noopDirectiveTransform, processExpression, processFor, processIf, processSlotOutlet, registerRuntimeHelpers, resolveComponentType, stringifyExpression, toValidAssetId, trackSlotScopes, trackVForSlotScopes, transform, transformBind, transformElement, transformExpression, transformModel, transformOn, transformVBindShorthand, traverseNode, unwrapTSNode, validFirstIdentCharRE, walkBlockDeclarations, walkFunctionParams, walkIdentifiers, warnDeprecation };\n", "/**\n* @vue/compiler-dom v3.5.24\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { registerRuntimeHelpers, createSimpleExpression, createCompilerError, createObjectProperty, createCallExpression, getConstantType, TO_DISPLAY_STRING, transformModel as transformModel$1, findProp, hasDynamicKeyVBind, findDir, isStaticArgOf, transformOn as transformOn$1, isStaticExp, createCompoundExpression, checkCompatEnabled, noopDirectiveTransform, baseCompile, baseParse } from '@vue/compiler-core';\nexport * from '@vue/compiler-core';\nimport { isHTMLTag, isSVGTag, isMathMLTag, isVoidTag, parseStringStyle, makeMap, capitalize, extend } from '@vue/shared';\n\nconst V_MODEL_RADIO = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `vModelRadio` : ``);\nconst V_MODEL_CHECKBOX = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `vModelCheckbox` : ``\n);\nconst V_MODEL_TEXT = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `vModelText` : ``);\nconst V_MODEL_SELECT = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `vModelSelect` : ``\n);\nconst V_MODEL_DYNAMIC = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `vModelDynamic` : ``\n);\nconst V_ON_WITH_MODIFIERS = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `vOnModifiersGuard` : ``\n);\nconst V_ON_WITH_KEYS = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `vOnKeysGuard` : ``\n);\nconst V_SHOW = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `vShow` : ``);\nconst TRANSITION = Symbol(!!(process.env.NODE_ENV !== \"production\") ? `Transition` : ``);\nconst TRANSITION_GROUP = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? `TransitionGroup` : ``\n);\nregisterRuntimeHelpers({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`,\n  [V_SHOW]: `vShow`,\n  [TRANSITION]: `Transition`,\n  [TRANSITION_GROUP]: `TransitionGroup`\n});\n\nlet decoder;\nfunction decodeHtmlBrowser(raw, asAttr = false) {\n  if (!decoder) {\n    decoder = document.createElement(\"div\");\n  }\n  if (asAttr) {\n    decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, \"&quot;\")}\">`;\n    return decoder.children[0].getAttribute(\"foo\");\n  } else {\n    decoder.innerHTML = raw;\n    return decoder.textContent;\n  }\n}\n\nconst parserOptions = {\n  parseMode: \"html\",\n  isVoidTag,\n  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),\n  isPreTag: (tag) => tag === \"pre\",\n  isIgnoreNewlineTag: (tag) => tag === \"pre\" || tag === \"textarea\",\n  decodeEntities: decodeHtmlBrowser ,\n  isBuiltInComponent: (tag) => {\n    if (tag === \"Transition\" || tag === \"transition\") {\n      return TRANSITION;\n    } else if (tag === \"TransitionGroup\" || tag === \"transition-group\") {\n      return TRANSITION_GROUP;\n    }\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag, parent, rootNamespace) {\n    let ns = parent ? parent.ns : rootNamespace;\n    if (parent && ns === 2) {\n      if (parent.tag === \"annotation-xml\") {\n        if (tag === \"svg\") {\n          return 1;\n        }\n        if (parent.props.some(\n          (a) => a.type === 6 && a.name === \"encoding\" && a.value != null && (a.value.content === \"text/html\" || a.value.content === \"application/xhtml+xml\")\n        )) {\n          ns = 0;\n        }\n      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== \"mglyph\" && tag !== \"malignmark\") {\n        ns = 0;\n      }\n    } else if (parent && ns === 1) {\n      if (parent.tag === \"foreignObject\" || parent.tag === \"desc\" || parent.tag === \"title\") {\n        ns = 0;\n      }\n    }\n    if (ns === 0) {\n      if (tag === \"svg\") {\n        return 1;\n      }\n      if (tag === \"math\") {\n        return 2;\n      }\n    }\n    return ns;\n  }\n};\n\nconst transformStyle = (node) => {\n  if (node.type === 1) {\n    node.props.forEach((p, i) => {\n      if (p.type === 6 && p.name === \"style\" && p.value) {\n        node.props[i] = {\n          type: 7,\n          name: `bind`,\n          arg: createSimpleExpression(`style`, true, p.loc),\n          exp: parseInlineCSS(p.value.content, p.loc),\n          modifiers: [],\n          loc: p.loc\n        };\n      }\n    });\n  }\n};\nconst parseInlineCSS = (cssText, loc) => {\n  const normalized = parseStringStyle(cssText);\n  return createSimpleExpression(\n    JSON.stringify(normalized),\n    false,\n    loc,\n    3\n  );\n};\n\nfunction createDOMCompilerError(code, loc) {\n  return createCompilerError(\n    code,\n    loc,\n    !!(process.env.NODE_ENV !== \"production\") || false ? DOMErrorMessages : void 0\n  );\n}\nconst DOMErrorCodes = {\n  \"X_V_HTML_NO_EXPRESSION\": 53,\n  \"53\": \"X_V_HTML_NO_EXPRESSION\",\n  \"X_V_HTML_WITH_CHILDREN\": 54,\n  \"54\": \"X_V_HTML_WITH_CHILDREN\",\n  \"X_V_TEXT_NO_EXPRESSION\": 55,\n  \"55\": \"X_V_TEXT_NO_EXPRESSION\",\n  \"X_V_TEXT_WITH_CHILDREN\": 56,\n  \"56\": \"X_V_TEXT_WITH_CHILDREN\",\n  \"X_V_MODEL_ON_INVALID_ELEMENT\": 57,\n  \"57\": \"X_V_MODEL_ON_INVALID_ELEMENT\",\n  \"X_V_MODEL_ARG_ON_ELEMENT\": 58,\n  \"58\": \"X_V_MODEL_ARG_ON_ELEMENT\",\n  \"X_V_MODEL_ON_FILE_INPUT_ELEMENT\": 59,\n  \"59\": \"X_V_MODEL_ON_FILE_INPUT_ELEMENT\",\n  \"X_V_MODEL_UNNECESSARY_VALUE\": 60,\n  \"60\": \"X_V_MODEL_UNNECESSARY_VALUE\",\n  \"X_V_SHOW_NO_EXPRESSION\": 61,\n  \"61\": \"X_V_SHOW_NO_EXPRESSION\",\n  \"X_TRANSITION_INVALID_CHILDREN\": 62,\n  \"62\": \"X_TRANSITION_INVALID_CHILDREN\",\n  \"X_IGNORED_SIDE_EFFECT_TAG\": 63,\n  \"63\": \"X_IGNORED_SIDE_EFFECT_TAG\",\n  \"__EXTEND_POINT__\": 64,\n  \"64\": \"__EXTEND_POINT__\"\n};\nconst DOMErrorMessages = {\n  [53]: `v-html is missing expression.`,\n  [54]: `v-html will override element children.`,\n  [55]: `v-text is missing expression.`,\n  [56]: `v-text will override element children.`,\n  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [58]: `v-model argument is not supported on plain elements.`,\n  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\n  [61]: `v-show is missing expression.`,\n  [62]: `<Transition> expects exactly one child element or component.`,\n  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\n};\n\nconst transformVHtml = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(53, loc)\n    );\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(54, loc)\n    );\n    node.children.length = 0;\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`innerHTML`, true, loc),\n        exp || createSimpleExpression(\"\", true)\n      )\n    ]\n  };\n};\n\nconst transformVText = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(55, loc)\n    );\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(56, loc)\n    );\n    node.children.length = 0;\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`textContent`, true),\n        exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(\n          context.helperString(TO_DISPLAY_STRING),\n          [exp],\n          loc\n        ) : createSimpleExpression(\"\", true)\n      )\n    ]\n  };\n};\n\nconst transformModel = (dir, node, context) => {\n  const baseResult = transformModel$1(dir, node, context);\n  if (!baseResult.props.length || node.tagType === 1) {\n    return baseResult;\n  }\n  if (dir.arg) {\n    context.onError(\n      createDOMCompilerError(\n        58,\n        dir.arg.loc\n      )\n    );\n  }\n  function checkDuplicatedValue() {\n    const value = findDir(node, \"bind\");\n    if (value && isStaticArgOf(value.arg, \"value\")) {\n      context.onError(\n        createDOMCompilerError(\n          60,\n          value.loc\n        )\n      );\n    }\n  }\n  const { tag } = node;\n  const isCustomElement = context.isCustomElement(tag);\n  if (tag === \"input\" || tag === \"textarea\" || tag === \"select\" || isCustomElement) {\n    let directiveToUse = V_MODEL_TEXT;\n    let isInvalidType = false;\n    if (tag === \"input\" || isCustomElement) {\n      const type = findProp(node, `type`);\n      if (type) {\n        if (type.type === 7) {\n          directiveToUse = V_MODEL_DYNAMIC;\n        } else if (type.value) {\n          switch (type.value.content) {\n            case \"radio\":\n              directiveToUse = V_MODEL_RADIO;\n              break;\n            case \"checkbox\":\n              directiveToUse = V_MODEL_CHECKBOX;\n              break;\n            case \"file\":\n              isInvalidType = true;\n              context.onError(\n                createDOMCompilerError(\n                  59,\n                  dir.loc\n                )\n              );\n              break;\n            default:\n              !!(process.env.NODE_ENV !== \"production\") && checkDuplicatedValue();\n              break;\n          }\n        }\n      } else if (hasDynamicKeyVBind(node)) {\n        directiveToUse = V_MODEL_DYNAMIC;\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && checkDuplicatedValue();\n      }\n    } else if (tag === \"select\") {\n      directiveToUse = V_MODEL_SELECT;\n    } else {\n      !!(process.env.NODE_ENV !== \"production\") && checkDuplicatedValue();\n    }\n    if (!isInvalidType) {\n      baseResult.needRuntime = context.helper(directiveToUse);\n    }\n  } else {\n    context.onError(\n      createDOMCompilerError(\n        57,\n        dir.loc\n      )\n    );\n  }\n  baseResult.props = baseResult.props.filter(\n    (p) => !(p.key.type === 4 && p.key.content === \"modelValue\")\n  );\n  return baseResult;\n};\n\nconst isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);\nconst isNonKeyModifier = /* @__PURE__ */ makeMap(\n  // event propagation management\n  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`\n);\nconst maybeKeyModifier = /* @__PURE__ */ makeMap(\"left,right\");\nconst isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`);\nconst resolveModifiers = (key, modifiers, context, loc) => {\n  const keyModifiers = [];\n  const nonKeyModifiers = [];\n  const eventOptionModifiers = [];\n  for (let i = 0; i < modifiers.length; i++) {\n    const modifier = modifiers[i].content;\n    if (modifier === \"native\" && checkCompatEnabled(\n      \"COMPILER_V_ON_NATIVE\",\n      context,\n      loc\n    )) {\n      eventOptionModifiers.push(modifier);\n    } else if (isEventOptionModifier(modifier)) {\n      eventOptionModifiers.push(modifier);\n    } else {\n      if (maybeKeyModifier(modifier)) {\n        if (isStaticExp(key)) {\n          if (isKeyboardEvent(key.content.toLowerCase())) {\n            keyModifiers.push(modifier);\n          } else {\n            nonKeyModifiers.push(modifier);\n          }\n        } else {\n          keyModifiers.push(modifier);\n          nonKeyModifiers.push(modifier);\n        }\n      } else {\n        if (isNonKeyModifier(modifier)) {\n          nonKeyModifiers.push(modifier);\n        } else {\n          keyModifiers.push(modifier);\n        }\n      }\n    }\n  }\n  return {\n    keyModifiers,\n    nonKeyModifiers,\n    eventOptionModifiers\n  };\n};\nconst transformClick = (key, event) => {\n  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === \"onclick\";\n  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([\n    `(`,\n    key,\n    `) === \"onClick\" ? \"${event}\" : (`,\n    key,\n    `)`\n  ]) : key;\n};\nconst transformOn = (dir, node, context) => {\n  return transformOn$1(dir, node, context, (baseResult) => {\n    const { modifiers } = dir;\n    if (!modifiers.length) return baseResult;\n    let { key, value: handlerExp } = baseResult.props[0];\n    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);\n    if (nonKeyModifiers.includes(\"right\")) {\n      key = transformClick(key, `onContextmenu`);\n    }\n    if (nonKeyModifiers.includes(\"middle\")) {\n      key = transformClick(key, `onMouseup`);\n    }\n    if (nonKeyModifiers.length) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\n        handlerExp,\n        JSON.stringify(nonKeyModifiers)\n      ]);\n    }\n    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard\n    (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\n        handlerExp,\n        JSON.stringify(keyModifiers)\n      ]);\n    }\n    if (eventOptionModifiers.length) {\n      const modifierPostfix = eventOptionModifiers.map(capitalize).join(\"\");\n      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`]);\n    }\n    return {\n      props: [createObjectProperty(key, handlerExp)]\n    };\n  });\n};\n\nconst transformShow = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(61, loc)\n    );\n  }\n  return {\n    props: [],\n    needRuntime: context.helper(V_SHOW)\n  };\n};\n\nconst transformTransition = (node, context) => {\n  if (node.type === 1 && node.tagType === 1) {\n    const component = context.isBuiltInComponent(node.tag);\n    if (component === TRANSITION) {\n      return () => {\n        if (!node.children.length) {\n          return;\n        }\n        if (hasMultipleChildren(node)) {\n          context.onError(\n            createDOMCompilerError(\n              62,\n              {\n                start: node.children[0].loc.start,\n                end: node.children[node.children.length - 1].loc.end,\n                source: \"\"\n              }\n            )\n          );\n        }\n        const child = node.children[0];\n        if (child.type === 1) {\n          for (const p of child.props) {\n            if (p.type === 7 && p.name === \"show\") {\n              node.props.push({\n                type: 6,\n                name: \"persisted\",\n                nameLoc: node.loc,\n                value: void 0,\n                loc: node.loc\n              });\n            }\n          }\n        }\n      };\n    }\n  }\n};\nfunction hasMultipleChildren(node) {\n  const children = node.children = node.children.filter(\n    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())\n  );\n  const child = children[0];\n  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);\n}\n\nconst ignoreSideEffectTags = (node, context) => {\n  if (node.type === 1 && node.tagType === 0 && (node.tag === \"script\" || node.tag === \"style\")) {\n    !!(process.env.NODE_ENV !== \"production\") && context.onError(\n      createDOMCompilerError(\n        63,\n        node.loc\n      )\n    );\n    context.removeNode();\n  }\n};\n\nfunction isValidHTMLNesting(parent, child) {\n  if (parent === \"template\") {\n    return true;\n  }\n  if (parent in onlyValidChildren) {\n    return onlyValidChildren[parent].has(child);\n  }\n  if (child in onlyValidParents) {\n    return onlyValidParents[child].has(parent);\n  }\n  if (parent in knownInvalidChildren) {\n    if (knownInvalidChildren[parent].has(child)) return false;\n  }\n  if (child in knownInvalidParents) {\n    if (knownInvalidParents[child].has(parent)) return false;\n  }\n  return true;\n}\nconst headings = /* @__PURE__ */ new Set([\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"]);\nconst emptySet = /* @__PURE__ */ new Set([]);\nconst onlyValidChildren = {\n  head: /* @__PURE__ */ new Set([\n    \"base\",\n    \"basefront\",\n    \"bgsound\",\n    \"link\",\n    \"meta\",\n    \"title\",\n    \"noscript\",\n    \"noframes\",\n    \"style\",\n    \"script\",\n    \"template\"\n  ]),\n  optgroup: /* @__PURE__ */ new Set([\"option\"]),\n  select: /* @__PURE__ */ new Set([\"optgroup\", \"option\", \"hr\"]),\n  // table\n  table: /* @__PURE__ */ new Set([\"caption\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\"]),\n  tr: /* @__PURE__ */ new Set([\"td\", \"th\"]),\n  colgroup: /* @__PURE__ */ new Set([\"col\"]),\n  tbody: /* @__PURE__ */ new Set([\"tr\"]),\n  thead: /* @__PURE__ */ new Set([\"tr\"]),\n  tfoot: /* @__PURE__ */ new Set([\"tr\"]),\n  // these elements can not have any children elements\n  script: emptySet,\n  iframe: emptySet,\n  option: emptySet,\n  textarea: emptySet,\n  style: emptySet,\n  title: emptySet\n};\nconst onlyValidParents = {\n  // sections\n  html: emptySet,\n  body: /* @__PURE__ */ new Set([\"html\"]),\n  head: /* @__PURE__ */ new Set([\"html\"]),\n  // table\n  td: /* @__PURE__ */ new Set([\"tr\"]),\n  colgroup: /* @__PURE__ */ new Set([\"table\"]),\n  caption: /* @__PURE__ */ new Set([\"table\"]),\n  tbody: /* @__PURE__ */ new Set([\"table\"]),\n  tfoot: /* @__PURE__ */ new Set([\"table\"]),\n  col: /* @__PURE__ */ new Set([\"colgroup\"]),\n  th: /* @__PURE__ */ new Set([\"tr\"]),\n  thead: /* @__PURE__ */ new Set([\"table\"]),\n  tr: /* @__PURE__ */ new Set([\"tbody\", \"thead\", \"tfoot\"]),\n  // data list\n  dd: /* @__PURE__ */ new Set([\"dl\", \"div\"]),\n  dt: /* @__PURE__ */ new Set([\"dl\", \"div\"]),\n  // other\n  figcaption: /* @__PURE__ */ new Set([\"figure\"]),\n  // li: new Set([\"ul\", \"ol\"]),\n  summary: /* @__PURE__ */ new Set([\"details\"]),\n  area: /* @__PURE__ */ new Set([\"map\"])\n};\nconst knownInvalidChildren = {\n  p: /* @__PURE__ */ new Set([\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"blockquote\",\n    \"center\",\n    \"details\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"fieldset\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"li\",\n    \"main\",\n    \"nav\",\n    \"menu\",\n    \"ol\",\n    \"p\",\n    \"pre\",\n    \"section\",\n    \"table\",\n    \"ul\"\n  ]),\n  svg: /* @__PURE__ */ new Set([\n    \"b\",\n    \"blockquote\",\n    \"br\",\n    \"code\",\n    \"dd\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"hr\",\n    \"i\",\n    \"img\",\n    \"li\",\n    \"menu\",\n    \"meta\",\n    \"ol\",\n    \"p\",\n    \"pre\",\n    \"ruby\",\n    \"s\",\n    \"small\",\n    \"span\",\n    \"strong\",\n    \"sub\",\n    \"sup\",\n    \"table\",\n    \"u\",\n    \"ul\",\n    \"var\"\n  ])\n};\nconst knownInvalidParents = {\n  a: /* @__PURE__ */ new Set([\"a\"]),\n  button: /* @__PURE__ */ new Set([\"button\"]),\n  dd: /* @__PURE__ */ new Set([\"dd\", \"dt\"]),\n  dt: /* @__PURE__ */ new Set([\"dd\", \"dt\"]),\n  form: /* @__PURE__ */ new Set([\"form\"]),\n  li: /* @__PURE__ */ new Set([\"li\"]),\n  h1: headings,\n  h2: headings,\n  h3: headings,\n  h4: headings,\n  h5: headings,\n  h6: headings\n};\n\nconst validateHtmlNesting = (node, context) => {\n  if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {\n    const error = new SyntaxError(\n      `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`\n    );\n    error.loc = node.loc;\n    context.onWarn(error);\n  }\n};\n\nconst DOMNodeTransforms = [\n  transformStyle,\n  ...!!(process.env.NODE_ENV !== \"production\") ? [transformTransition, validateHtmlNesting] : []\n];\nconst DOMDirectiveTransforms = {\n  cloak: noopDirectiveTransform,\n  html: transformVHtml,\n  text: transformVText,\n  model: transformModel,\n  // override compiler-core\n  on: transformOn,\n  // override compiler-core\n  show: transformShow\n};\nfunction compile(src, options = {}) {\n  return baseCompile(\n    src,\n    extend({}, parserOptions, options, {\n      nodeTransforms: [\n        // ignore <script> and <tag>\n        // this is not put inside DOMNodeTransforms because that list is used\n        // by compiler-ssr to generate vnode fallback branches\n        ignoreSideEffectTags,\n        ...DOMNodeTransforms,\n        ...options.nodeTransforms || []\n      ],\n      directiveTransforms: extend(\n        {},\n        DOMDirectiveTransforms,\n        options.directiveTransforms || {}\n      ),\n      transformHoist: null \n    })\n  );\n}\nfunction parse(template, options = {}) {\n  return baseParse(template, extend({}, parserOptions, options));\n}\n\nexport { DOMDirectiveTransforms, DOMErrorCodes, DOMErrorMessages, DOMNodeTransforms, TRANSITION, TRANSITION_GROUP, V_MODEL_CHECKBOX, V_MODEL_DYNAMIC, V_MODEL_RADIO, V_MODEL_SELECT, V_MODEL_TEXT, V_ON_WITH_KEYS, V_ON_WITH_MODIFIERS, V_SHOW, compile, createDOMCompilerError, parse, parserOptions, transformStyle };\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseScriptSetupRanges = parseScriptSetupRanges;\nexports.parseBindingRanges = parseBindingRanges;\nexports.findBindingVars = findBindingVars;\nexports.getStartEnd = getStartEnd;\nexports.getNodeText = getNodeText;\nconst common_1 = require(\"../codegen/common\");\nfunction parseScriptSetupRanges(ts, ast, vueCompilerOptions) {\n    let foundNonImportExportNode = false;\n    let importSectionEndOffset = 0;\n    const props = {};\n    const slots = {};\n    const emits = {};\n    const expose = {};\n    const options = {};\n    const cssModules = [];\n    const templateRefs = [];\n    const definePropProposalA = vueCompilerOptions.experimentalDefinePropProposal === 'kevinEdition' || ast.text.trimStart().startsWith('// @experimentalDefinePropProposal=kevinEdition');\n    const definePropProposalB = vueCompilerOptions.experimentalDefinePropProposal === 'johnsonEdition' || ast.text.trimStart().startsWith('// @experimentalDefinePropProposal=johnsonEdition');\n    const defineProp = [];\n    const text = ast.text;\n    const leadingCommentEndOffset = ts.getLeadingCommentRanges(text, 0)?.reverse()[0].end ?? 0;\n    const importComponentNames = new Set();\n    let bindings = parseBindingRanges(ts, ast);\n    ts.forEachChild(ast, node => {\n        const isTypeExport = (ts.isTypeAliasDeclaration(node) || ts.isInterfaceDeclaration(node)) && node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);\n        if (!foundNonImportExportNode\n            && !ts.isImportDeclaration(node)\n            && !isTypeExport\n            && !ts.isEmptyStatement(node)\n            // fix https://github.com/vuejs/language-tools/issues/1223\n            && !ts.isImportEqualsDeclaration(node)) {\n            const commentRanges = ts.getLeadingCommentRanges(text, node.pos);\n            if (commentRanges?.length) {\n                const commentRange = commentRanges.sort((a, b) => a.pos - b.pos)[0];\n                importSectionEndOffset = commentRange.pos;\n            }\n            else {\n                importSectionEndOffset = getStartEnd(ts, node, ast).start;\n            }\n            foundNonImportExportNode = true;\n        }\n        if (ts.isImportDeclaration(node)\n            && node.importClause?.name\n            && !node.importClause.isTypeOnly) {\n            const moduleName = getNodeText(ts, node.moduleSpecifier, ast).slice(1, -1);\n            if (vueCompilerOptions.extensions.some(ext => moduleName.endsWith(ext))) {\n                importComponentNames.add(getNodeText(ts, node.importClause.name, ast));\n            }\n        }\n    });\n    ts.forEachChild(ast, child => visitNode(child, [ast]));\n    const templateRefNames = new Set(templateRefs.map(ref => ref.name));\n    bindings = bindings.filter(range => {\n        const name = text.substring(range.start, range.end);\n        return !templateRefNames.has(name);\n    });\n    return {\n        leadingCommentEndOffset,\n        importSectionEndOffset,\n        bindings,\n        importComponentNames,\n        props,\n        slots,\n        emits,\n        expose,\n        options,\n        cssModules,\n        defineProp,\n        templateRefs,\n    };\n    function _getStartEnd(node) {\n        return getStartEnd(ts, node, ast);\n    }\n    function parseDefineFunction(node) {\n        return {\n            ..._getStartEnd(node),\n            exp: _getStartEnd(node.expression),\n            arg: node.arguments.length ? _getStartEnd(node.arguments[0]) : undefined,\n            typeArg: node.typeArguments?.length ? _getStartEnd(node.typeArguments[0]) : undefined,\n        };\n    }\n    function visitNode(node, parents) {\n        const parent = parents[parents.length - 1];\n        if (ts.isCallExpression(node)\n            && ts.isIdentifier(node.expression)) {\n            const callText = getNodeText(ts, node.expression, ast);\n            if (vueCompilerOptions.macros.defineModel.includes(callText)) {\n                let localName;\n                let propName;\n                let options;\n                if (ts.isVariableDeclaration(parent) &&\n                    ts.isIdentifier(parent.name)) {\n                    localName = _getStartEnd(parent.name);\n                }\n                if (node.arguments.length >= 2) {\n                    propName = _getStartEnd(node.arguments[0]);\n                    options = node.arguments[1];\n                }\n                else if (node.arguments.length >= 1) {\n                    if (ts.isStringLiteral(node.arguments[0])) {\n                        propName = _getStartEnd(node.arguments[0]);\n                    }\n                    else {\n                        options = node.arguments[0];\n                    }\n                }\n                let runtimeType;\n                let defaultValue;\n                let required = false;\n                if (options && ts.isObjectLiteralExpression(options)) {\n                    for (const property of options.properties) {\n                        if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {\n                            continue;\n                        }\n                        const text = getNodeText(ts, property.name, ast);\n                        if (text === 'type') {\n                            runtimeType = _getStartEnd(property.initializer);\n                        }\n                        else if (text === 'default') {\n                            defaultValue = _getStartEnd(property.initializer);\n                        }\n                        else if (text === 'required' && property.initializer.kind === ts.SyntaxKind.TrueKeyword) {\n                            required = true;\n                        }\n                    }\n                }\n                defineProp.push({\n                    localName,\n                    name: propName,\n                    type: node.typeArguments?.length ? _getStartEnd(node.typeArguments[0]) : undefined,\n                    modifierType: node.typeArguments && node.typeArguments?.length >= 2 ? _getStartEnd(node.typeArguments[1]) : undefined,\n                    runtimeType,\n                    defaultValue,\n                    required,\n                    isModel: true,\n                });\n            }\n            else if (callText === 'defineProp') {\n                let localName;\n                let propName;\n                let options;\n                if (ts.isVariableDeclaration(parent) &&\n                    ts.isIdentifier(parent.name)) {\n                    localName = _getStartEnd(parent.name);\n                }\n                let runtimeType;\n                let defaultValue;\n                let required = false;\n                if (definePropProposalA) {\n                    if (node.arguments.length >= 2) {\n                        options = node.arguments[1];\n                    }\n                    if (node.arguments.length >= 1) {\n                        propName = _getStartEnd(node.arguments[0]);\n                    }\n                    if (options && ts.isObjectLiteralExpression(options)) {\n                        for (const property of options.properties) {\n                            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {\n                                continue;\n                            }\n                            const text = getNodeText(ts, property.name, ast);\n                            if (text === 'type') {\n                                runtimeType = _getStartEnd(property.initializer);\n                            }\n                            else if (text === 'default') {\n                                defaultValue = _getStartEnd(property.initializer);\n                            }\n                            else if (text === 'required' && property.initializer.kind === ts.SyntaxKind.TrueKeyword) {\n                                required = true;\n                            }\n                        }\n                    }\n                }\n                else if (definePropProposalB) {\n                    if (node.arguments.length >= 3) {\n                        options = node.arguments[2];\n                    }\n                    if (node.arguments.length >= 2) {\n                        if (node.arguments[1].kind === ts.SyntaxKind.TrueKeyword) {\n                            required = true;\n                        }\n                    }\n                    if (node.arguments.length >= 1) {\n                        defaultValue = _getStartEnd(node.arguments[0]);\n                    }\n                    if (options && ts.isObjectLiteralExpression(options)) {\n                        for (const property of options.properties) {\n                            if (!ts.isPropertyAssignment(property) || !ts.isIdentifier(property.name)) {\n                                continue;\n                            }\n                            const text = getNodeText(ts, property.name, ast);\n                            if (text === 'type') {\n                                runtimeType = _getStartEnd(property.initializer);\n                            }\n                        }\n                    }\n                }\n                defineProp.push({\n                    localName,\n                    name: propName,\n                    type: node.typeArguments?.length ? _getStartEnd(node.typeArguments[0]) : undefined,\n                    runtimeType,\n                    defaultValue,\n                    required,\n                });\n            }\n            else if (vueCompilerOptions.macros.defineSlots.includes(callText)) {\n                slots.define = {\n                    ...parseDefineFunction(node),\n                    statement: getStatementRange(ts, parents, node, ast)\n                };\n                if (ts.isVariableDeclaration(parent)) {\n                    if (ts.isIdentifier(parent.name)) {\n                        slots.name = getNodeText(ts, parent.name, ast);\n                    }\n                    else {\n                        slots.isObjectBindingPattern = ts.isObjectBindingPattern(parent.name);\n                    }\n                }\n            }\n            else if (vueCompilerOptions.macros.defineEmits.includes(callText)) {\n                emits.define = {\n                    ...parseDefineFunction(node),\n                    statement: getStatementRange(ts, parents, node, ast)\n                };\n                if (ts.isVariableDeclaration(parent)) {\n                    emits.name = getNodeText(ts, parent.name, ast);\n                }\n                if (node.typeArguments?.length && ts.isTypeLiteralNode(node.typeArguments[0]) && node.typeArguments[0].members.at(0)) {\n                    for (const member of node.typeArguments[0].members) {\n                        if (ts.isCallSignatureDeclaration(member) && member.parameters[0].type && ts.isUnionTypeNode(member.parameters[0].type)) {\n                            emits.define.hasUnionTypeArg = true;\n                            return;\n                        }\n                    }\n                }\n            }\n            else if (vueCompilerOptions.macros.defineExpose.includes(callText)) {\n                expose.define = parseDefineFunction(node);\n            }\n            else if (vueCompilerOptions.macros.defineProps.includes(callText)) {\n                if (ts.isVariableDeclaration(parent)) {\n                    if (ts.isObjectBindingPattern(parent.name)) {\n                        props.destructured = new Set();\n                        const identifiers = (0, common_1.collectIdentifiers)(ts, parent.name, []);\n                        for (const [id, isRest] of identifiers) {\n                            const name = getNodeText(ts, id, ast);\n                            if (isRest) {\n                                props.destructuredRest = name;\n                            }\n                            else {\n                                props.destructured.add(name);\n                            }\n                        }\n                    }\n                    else {\n                        props.name = getNodeText(ts, parent.name, ast);\n                    }\n                }\n                props.define = {\n                    ...parseDefineFunction(node),\n                    statement: getStatementRange(ts, parents, node, ast),\n                };\n                if (node.arguments.length) {\n                    props.define.arg = _getStartEnd(node.arguments[0]);\n                }\n                if (node.typeArguments?.length) {\n                    props.define.typeArg = _getStartEnd(node.typeArguments[0]);\n                }\n            }\n            else if (vueCompilerOptions.macros.withDefaults.includes(callText)) {\n                props.withDefaults = _getStartEnd(node);\n                if (node.arguments.length >= 2) {\n                    const arg = node.arguments[1];\n                    props.withDefaults.arg = _getStartEnd(arg);\n                }\n                if (ts.isVariableDeclaration(parent)) {\n                    props.name = getNodeText(ts, parent.name, ast);\n                }\n            }\n            else if (vueCompilerOptions.macros.defineOptions.includes(callText)) {\n                if (node.arguments.length && ts.isObjectLiteralExpression(node.arguments[0])) {\n                    const obj = node.arguments[0];\n                    ts.forEachChild(obj, node => {\n                        if (ts.isPropertyAssignment(node) && ts.isIdentifier(node.name)) {\n                            const name = getNodeText(ts, node.name, ast);\n                            if (name === 'inheritAttrs') {\n                                options.inheritAttrs = getNodeText(ts, node.initializer, ast);\n                            }\n                        }\n                    });\n                    for (const prop of node.arguments[0].properties) {\n                        if ((ts.isPropertyAssignment(prop)) && getNodeText(ts, prop.name, ast) === 'name' && ts.isStringLiteral(prop.initializer)) {\n                            options.name = prop.initializer.text;\n                        }\n                    }\n                }\n            }\n            else if (vueCompilerOptions.composibles.useTemplateRef.includes(callText) && node.arguments.length && !node.typeArguments?.length) {\n                const define = parseDefineFunction(node);\n                let name;\n                if (ts.isVariableDeclaration(parent)) {\n                    name = getNodeText(ts, parent.name, ast);\n                }\n                templateRefs.push({\n                    name,\n                    define\n                });\n            }\n            else if (vueCompilerOptions.composibles.useCssModule.includes(callText)) {\n                const define = parseDefineFunction(node);\n                cssModules.push({\n                    define\n                });\n            }\n        }\n        ts.forEachChild(node, child => {\n            parents.push(node);\n            visitNode(child, parents);\n            parents.pop();\n        });\n    }\n}\nfunction parseBindingRanges(ts, sourceFile) {\n    const bindings = [];\n    ts.forEachChild(sourceFile, node => {\n        if (ts.isVariableStatement(node)) {\n            for (const node_2 of node.declarationList.declarations) {\n                const vars = _findBindingVars(node_2.name);\n                for (const _var of vars) {\n                    bindings.push(_var);\n                }\n            }\n        }\n        else if (ts.isFunctionDeclaration(node)) {\n            if (node.name && ts.isIdentifier(node.name)) {\n                bindings.push(_getStartEnd(node.name));\n            }\n        }\n        else if (ts.isClassDeclaration(node)) {\n            if (node.name) {\n                bindings.push(_getStartEnd(node.name));\n            }\n        }\n        else if (ts.isEnumDeclaration(node)) {\n            bindings.push(_getStartEnd(node.name));\n        }\n        if (ts.isImportDeclaration(node)) {\n            if (node.importClause && !node.importClause.isTypeOnly) {\n                if (node.importClause.name) {\n                    bindings.push(_getStartEnd(node.importClause.name));\n                }\n                if (node.importClause.namedBindings) {\n                    if (ts.isNamedImports(node.importClause.namedBindings)) {\n                        for (const element of node.importClause.namedBindings.elements) {\n                            if (element.isTypeOnly) {\n                                continue;\n                            }\n                            bindings.push(_getStartEnd(element.name));\n                        }\n                    }\n                    else if (ts.isNamespaceImport(node.importClause.namedBindings)) {\n                        bindings.push(_getStartEnd(node.importClause.namedBindings.name));\n                    }\n                }\n            }\n        }\n    });\n    return bindings;\n    function _getStartEnd(node) {\n        return getStartEnd(ts, node, sourceFile);\n    }\n    function _findBindingVars(left) {\n        return findBindingVars(ts, left, sourceFile);\n    }\n}\nfunction findBindingVars(ts, left, sourceFile) {\n    const vars = [];\n    worker(left);\n    return vars;\n    function worker(_node) {\n        if (ts.isIdentifier(_node)) {\n            vars.push(getStartEnd(ts, _node, sourceFile));\n        }\n        // { ? } = ...\n        // [ ? ] = ...\n        else if (ts.isObjectBindingPattern(_node) || ts.isArrayBindingPattern(_node)) {\n            for (const property of _node.elements) {\n                if (ts.isBindingElement(property)) {\n                    worker(property.name);\n                }\n            }\n        }\n        // { foo: ? } = ...\n        else if (ts.isPropertyAssignment(_node)) {\n            worker(_node.initializer);\n        }\n        // { foo } = ...\n        else if (ts.isShorthandPropertyAssignment(_node)) {\n            vars.push(getStartEnd(ts, _node.name, sourceFile));\n        }\n        // { ...? } = ...\n        // [ ...? ] = ...\n        else if (ts.isSpreadAssignment(_node) || ts.isSpreadElement(_node)) {\n            worker(_node.expression);\n        }\n    }\n}\nfunction getStartEnd(ts, node, sourceFile) {\n    return {\n        start: ts.getTokenPosOfNode(node, sourceFile),\n        end: node.end,\n    };\n}\nfunction getNodeText(ts, node, sourceFile) {\n    const { start, end } = getStartEnd(ts, node, sourceFile);\n    return sourceFile.text.substring(start, end);\n}\nfunction getStatementRange(ts, parents, node, sourceFile) {\n    let statementRange;\n    for (let i = parents.length - 1; i >= 0; i--) {\n        if (ts.isStatement(parents[i])) {\n            const statement = parents[i];\n            ts.forEachChild(statement, child => {\n                const range = getStartEnd(ts, child, sourceFile);\n                statementRange ??= range;\n                statementRange.end = range.end;\n            });\n            break;\n        }\n    }\n    if (!statementRange) {\n        statementRange = getStartEnd(ts, node, sourceFile);\n    }\n    return statementRange;\n}\n//# sourceMappingURL=scriptSetupRanges.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.variableNameRegex = exports.combineLastMapping = exports.endOfLine = exports.newLine = void 0;\nexports.conditionWrapWith = conditionWrapWith;\nexports.wrapWith = wrapWith;\nexports.collectVars = collectVars;\nexports.collectIdentifiers = collectIdentifiers;\nexports.createTsAst = createTsAst;\nexports.generateSfcBlockSection = generateSfcBlockSection;\nconst scriptSetupRanges_1 = require(\"../parsers/scriptSetupRanges\");\nexports.newLine = '\\n';\nexports.endOfLine = `;${exports.newLine}`;\nexports.combineLastMapping = { __combineLastMapping: true };\nexports.variableNameRegex = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\nfunction* conditionWrapWith(condition, startOffset, endOffset, features, ...wrapCodes) {\n    if (condition) {\n        yield* wrapWith(startOffset, endOffset, features, ...wrapCodes);\n    }\n    else {\n        for (const wrapCode of wrapCodes) {\n            yield wrapCode;\n        }\n    }\n}\nfunction* wrapWith(startOffset, endOffset, features, ...wrapCodes) {\n    yield ['', 'template', startOffset, features];\n    let offset = 1;\n    for (const wrapCode of wrapCodes) {\n        if (typeof wrapCode !== 'string') {\n            offset++;\n        }\n        yield wrapCode;\n    }\n    yield ['', 'template', endOffset, { __combineOffsetMapping: offset }];\n}\nfunction collectVars(ts, node, ast, results = []) {\n    const identifiers = collectIdentifiers(ts, node, []);\n    for (const [id] of identifiers) {\n        results.push((0, scriptSetupRanges_1.getNodeText)(ts, id, ast));\n    }\n    return results;\n}\nfunction collectIdentifiers(ts, node, results = [], isRest = false) {\n    if (ts.isIdentifier(node)) {\n        results.push([node, isRest]);\n    }\n    else if (ts.isObjectBindingPattern(node)) {\n        for (const el of node.elements) {\n            collectIdentifiers(ts, el.name, results, !!el.dotDotDotToken);\n        }\n    }\n    else if (ts.isArrayBindingPattern(node)) {\n        for (const el of node.elements) {\n            if (ts.isBindingElement(el)) {\n                collectIdentifiers(ts, el.name, results, !!el.dotDotDotToken);\n            }\n        }\n    }\n    else {\n        ts.forEachChild(node, node => collectIdentifiers(ts, node, results, false));\n    }\n    return results;\n}\nfunction createTsAst(ts, astHolder, text) {\n    if (astHolder.__volar_ast_text !== text) {\n        astHolder.__volar_ast_text = text;\n        astHolder.__volar_ast = ts.createSourceFile('/a.ts', text, 99);\n    }\n    return astHolder.__volar_ast;\n}\nfunction generateSfcBlockSection(block, start, end, features) {\n    return [\n        block.content.substring(start, end),\n        block.name,\n        start,\n        features,\n    ];\n}\n//# sourceMappingURL=common.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createTemplateCodegenContext = createTemplateCodegenContext;\nconst common_1 = require(\"../common\");\nconst _codeFeatures = {\n    all: {\n        verification: true,\n        completion: true,\n        semantic: true,\n        navigation: true,\n    },\n    verification: {\n        verification: true,\n    },\n    completion: {\n        completion: true,\n    },\n    additionalCompletion: {\n        completion: { isAdditional: true },\n    },\n    navigation: {\n        navigation: true,\n    },\n    navigationWithoutRename: {\n        navigation: {\n            shouldRename() {\n                return false;\n            },\n        },\n    },\n    navigationAndCompletion: {\n        navigation: true,\n        completion: true,\n    },\n    navigationAndAdditionalCompletion: {\n        navigation: true,\n        completion: { isAdditional: true },\n    },\n    withoutHighlight: {\n        semantic: { shouldHighlight: () => false },\n        verification: true,\n        navigation: true,\n        completion: true,\n    },\n    withoutHighlightAndCompletion: {\n        semantic: { shouldHighlight: () => false },\n        verification: true,\n        navigation: true,\n    },\n    withoutHighlightAndCompletionAndNavigation: {\n        semantic: { shouldHighlight: () => false },\n        verification: true,\n    },\n};\nfunction createTemplateCodegenContext(options) {\n    let ignoredError = false;\n    let expectErrorToken;\n    let variableId = 0;\n    const codeFeatures = new Proxy(_codeFeatures, {\n        get(target, key) {\n            const data = target[key];\n            if (data.verification) {\n                if (ignoredError) {\n                    return {\n                        ...data,\n                        verification: false,\n                    };\n                }\n                if (expectErrorToken) {\n                    const token = expectErrorToken;\n                    if (typeof data.verification !== 'object' || !data.verification.shouldReport) {\n                        return {\n                            ...data,\n                            verification: {\n                                shouldReport: () => {\n                                    token.errors++;\n                                    return false;\n                                },\n                            },\n                        };\n                    }\n                }\n            }\n            return data;\n        },\n    });\n    const localVars = new Map();\n    const accessExternalVariables = new Map();\n    const slots = [];\n    const dynamicSlots = [];\n    const hasSlotElements = new Set();\n    ;\n    const blockConditions = [];\n    const usedComponentCtxVars = new Set();\n    const scopedClasses = [];\n    const emptyClassOffsets = [];\n    const inlayHints = [];\n    const templateRefs = new Map();\n    return {\n        slots,\n        dynamicSlots,\n        codeFeatures,\n        accessExternalVariables,\n        hasSlotElements,\n        blockConditions,\n        usedComponentCtxVars,\n        scopedClasses,\n        emptyClassOffsets,\n        inlayHints,\n        hasSlot: false,\n        inheritedAttrVars: new Set(),\n        templateRefs,\n        singleRootElType: undefined,\n        singleRootNode: undefined,\n        accessExternalVariable(name, offset) {\n            let arr = accessExternalVariables.get(name);\n            if (!arr) {\n                accessExternalVariables.set(name, arr = new Set());\n            }\n            if (offset !== undefined) {\n                arr.add(offset);\n            }\n        },\n        hasLocalVariable: (name) => {\n            return !!localVars.get(name);\n        },\n        addLocalVariable: (name) => {\n            localVars.set(name, (localVars.get(name) ?? 0) + 1);\n        },\n        removeLocalVariable: (name) => {\n            localVars.set(name, localVars.get(name) - 1);\n        },\n        getInternalVariable: () => {\n            return `__VLS_${variableId++}`;\n        },\n        ignoreError: function* () {\n            if (!ignoredError) {\n                ignoredError = true;\n                yield `// @vue-ignore start${common_1.newLine}`;\n            }\n        },\n        expectError: function* (prevNode) {\n            if (!expectErrorToken) {\n                expectErrorToken = {\n                    errors: 0,\n                    node: prevNode,\n                };\n                yield `// @vue-expect-error start${common_1.newLine}`;\n            }\n        },\n        resetDirectiveComments: function* (endStr) {\n            if (expectErrorToken) {\n                const token = expectErrorToken;\n                yield* (0, common_1.wrapWith)(expectErrorToken.node.loc.start.offset, expectErrorToken.node.loc.end.offset, {\n                    verification: {\n                        shouldReport: () => token.errors === 0,\n                    },\n                }, `// @ts-expect-error __VLS_TS_EXPECT_ERROR`);\n                yield `${common_1.newLine}${common_1.endOfLine}`;\n                expectErrorToken = undefined;\n                yield `// @vue-expect-error ${endStr}${common_1.newLine}`;\n            }\n            if (ignoredError) {\n                ignoredError = false;\n                yield `// @vue-ignore ${endStr}${common_1.newLine}`;\n            }\n        },\n        generateAutoImportCompletion: function* () {\n            if (!options.edited) {\n                return;\n            }\n            const all = [...accessExternalVariables.entries()];\n            if (!all.some(([_, offsets]) => offsets.size)) {\n                return;\n            }\n            yield `// @ts-ignore${common_1.newLine}`; // #2304\n            yield `[`;\n            for (const [varName, offsets] of all) {\n                for (const offset of offsets) {\n                    if (options.scriptSetupBindingNames.has(varName)) {\n                        // #3409\n                        yield [\n                            varName,\n                            'template',\n                            offset,\n                            {\n                                ...codeFeatures.additionalCompletion,\n                                ...codeFeatures.withoutHighlightAndCompletionAndNavigation,\n                            },\n                        ];\n                    }\n                    else {\n                        yield [\n                            varName,\n                            'template',\n                            offset,\n                            codeFeatures.additionalCompletion,\n                        ];\n                    }\n                    yield `,`;\n                }\n                offsets.clear();\n            }\n            yield `]${common_1.endOfLine}`;\n        }\n    };\n}\n//# sourceMappingURL=context.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateCamelized = generateCamelized;\nconst shared_1 = require(\"@vue/shared\");\nconst common_1 = require(\"../common\");\nfunction* generateCamelized(code, offset, info) {\n    const parts = code.split('-');\n    for (let i = 0; i < parts.length; i++) {\n        const part = parts[i];\n        if (part !== '') {\n            if (i === 0) {\n                yield [\n                    part,\n                    'template',\n                    offset,\n                    info,\n                ];\n            }\n            else {\n                yield [\n                    (0, shared_1.capitalize)(part),\n                    'template',\n                    offset,\n                    common_1.combineLastMapping,\n                ];\n            }\n        }\n        offset += part.length + 1;\n    }\n}\n//# sourceMappingURL=camelized.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateInterpolation = generateInterpolation;\nexports.forEachInterpolationSegment = forEachInterpolationSegment;\nconst shared_1 = require(\"@vue/shared\");\nconst scriptSetupRanges_1 = require(\"../../parsers/scriptSetupRanges\");\nconst common_1 = require(\"../common\");\nfunction* generateInterpolation(options, ctx, _code, astHolder, start, data, prefix, suffix) {\n    const code = prefix + _code + suffix;\n    const ast = (0, common_1.createTsAst)(options.ts, astHolder, code);\n    for (let [section, offset, type] of forEachInterpolationSegment(options.ts, options.destructuredPropNames, options.templateRefNames, ctx, code, start !== undefined ? start - prefix.length : undefined, ast)) {\n        if (offset === undefined) {\n            yield section;\n        }\n        else {\n            offset -= prefix.length;\n            let addSuffix = '';\n            const overLength = offset + section.length - _code.length;\n            if (overLength > 0) {\n                addSuffix = section.substring(section.length - overLength);\n                section = section.substring(0, section.length - overLength);\n            }\n            if (offset < 0) {\n                yield section.substring(0, -offset);\n                section = section.substring(-offset);\n                offset = 0;\n            }\n            const shouldSkip = section.length === 0 && (type === 'startText' || type === 'endText');\n            if (!shouldSkip) {\n                if (start !== undefined\n                    && data) {\n                    yield [\n                        section,\n                        'template',\n                        start + offset,\n                        type === 'errorMappingOnly'\n                            ? ctx.codeFeatures.verification\n                            : typeof data === 'function' ? data(start + offset) : data,\n                    ];\n                }\n                else {\n                    yield section;\n                }\n            }\n            yield addSuffix;\n        }\n    }\n}\nfunction* forEachInterpolationSegment(ts, destructuredPropNames, templateRefNames, ctx, code, offset, ast) {\n    let ctxVars = [];\n    const varCb = (id, isShorthand) => {\n        const text = (0, scriptSetupRanges_1.getNodeText)(ts, id, ast);\n        if (ctx.hasLocalVariable(text) ||\n            // https://github.com/vuejs/core/blob/245230e135152900189f13a4281302de45fdcfaa/packages/compiler-core/src/transforms/transformExpression.ts#L342-L352\n            (0, shared_1.isGloballyWhitelisted)(text) ||\n            text === 'require' ||\n            text.startsWith('__VLS_')) {\n            // localVarOffsets.push(localVar.getStart(ast));\n        }\n        else {\n            ctxVars.push({\n                text,\n                isShorthand: isShorthand,\n                offset: (0, scriptSetupRanges_1.getStartEnd)(ts, id, ast).start,\n            });\n            if (destructuredPropNames?.has(text)) {\n                return;\n            }\n            if (offset !== undefined) {\n                ctx.accessExternalVariable(text, offset + (0, scriptSetupRanges_1.getStartEnd)(ts, id, ast).start);\n            }\n            else {\n                ctx.accessExternalVariable(text);\n            }\n        }\n    };\n    ts.forEachChild(ast, node => walkIdentifiers(ts, node, ast, varCb, ctx));\n    ctxVars = ctxVars.sort((a, b) => a.offset - b.offset);\n    if (ctxVars.length) {\n        if (ctxVars[0].isShorthand) {\n            yield [code.substring(0, ctxVars[0].offset + ctxVars[0].text.length), 0];\n            yield [': ', undefined];\n        }\n        else if (ctxVars[0].offset > 0) {\n            yield [code.substring(0, ctxVars[0].offset), 0, 'startText'];\n        }\n        for (let i = 0; i < ctxVars.length - 1; i++) {\n            const curVar = ctxVars[i];\n            const nextVar = ctxVars[i + 1];\n            yield* generateVar(code, destructuredPropNames, templateRefNames, curVar, nextVar);\n            if (nextVar.isShorthand) {\n                yield [code.substring(curVar.offset + curVar.text.length, nextVar.offset + nextVar.text.length), curVar.offset + curVar.text.length];\n                yield [': ', undefined];\n            }\n            else {\n                yield [code.substring(curVar.offset + curVar.text.length, nextVar.offset), curVar.offset + curVar.text.length];\n            }\n        }\n        const lastVar = ctxVars.at(-1);\n        yield* generateVar(code, destructuredPropNames, templateRefNames, lastVar);\n        if (lastVar.offset + lastVar.text.length < code.length) {\n            yield [code.substring(lastVar.offset + lastVar.text.length), lastVar.offset + lastVar.text.length, 'endText'];\n        }\n    }\n    else {\n        yield [code, 0];\n    }\n}\nfunction* generateVar(code, destructuredPropNames, templateRefNames, curVar, nextVar = curVar) {\n    // fix https://github.com/vuejs/language-tools/issues/1205\n    // fix https://github.com/vuejs/language-tools/issues/1264\n    yield ['', nextVar.offset, 'errorMappingOnly'];\n    const isDestructuredProp = destructuredPropNames?.has(curVar.text) ?? false;\n    const isTemplateRef = templateRefNames?.has(curVar.text) ?? false;\n    if (isTemplateRef) {\n        yield [`__VLS_unref(`, undefined];\n        yield [code.substring(curVar.offset, curVar.offset + curVar.text.length), curVar.offset];\n        yield [`)`, undefined];\n    }\n    else {\n        if (!isDestructuredProp) {\n            yield [`__VLS_ctx.`, undefined];\n        }\n        yield [code.substring(curVar.offset, curVar.offset + curVar.text.length), curVar.offset];\n    }\n}\nfunction walkIdentifiers(ts, node, ast, cb, ctx, blockVars = [], isRoot = true) {\n    if (ts.isIdentifier(node)) {\n        cb(node, false);\n    }\n    else if (ts.isShorthandPropertyAssignment(node)) {\n        cb(node.name, true);\n    }\n    else if (ts.isPropertyAccessExpression(node)) {\n        walkIdentifiers(ts, node.expression, ast, cb, ctx, blockVars, false);\n    }\n    else if (ts.isVariableDeclaration(node)) {\n        (0, common_1.collectVars)(ts, node.name, ast, blockVars);\n        for (const varName of blockVars) {\n            ctx.addLocalVariable(varName);\n        }\n        if (node.initializer) {\n            walkIdentifiers(ts, node.initializer, ast, cb, ctx, blockVars, false);\n        }\n    }\n    else if (ts.isArrowFunction(node) || ts.isFunctionExpression(node)) {\n        processFunction(ts, node, ast, cb, ctx);\n    }\n    else if (ts.isObjectLiteralExpression(node)) {\n        for (const prop of node.properties) {\n            if (ts.isPropertyAssignment(prop)) {\n                // fix https://github.com/vuejs/language-tools/issues/1176\n                if (ts.isComputedPropertyName(prop.name)) {\n                    walkIdentifiers(ts, prop.name.expression, ast, cb, ctx, blockVars, false);\n                }\n                walkIdentifiers(ts, prop.initializer, ast, cb, ctx, blockVars, false);\n            }\n            // fix https://github.com/vuejs/language-tools/issues/1156\n            else if (ts.isShorthandPropertyAssignment(prop)) {\n                walkIdentifiers(ts, prop, ast, cb, ctx, blockVars, false);\n            }\n            // fix https://github.com/vuejs/language-tools/issues/1148#issuecomment-1094378126\n            else if (ts.isSpreadAssignment(prop)) {\n                // TODO: cannot report \"Spread types may only be created from object types.ts(2698)\"\n                walkIdentifiers(ts, prop.expression, ast, cb, ctx, blockVars, false);\n            }\n            // fix https://github.com/vuejs/language-tools/issues/4604\n            else if (ts.isFunctionLike(prop) && prop.body) {\n                processFunction(ts, prop, ast, cb, ctx);\n            }\n        }\n    }\n    else if (ts.isTypeReferenceNode(node)) {\n        // fix https://github.com/vuejs/language-tools/issues/1422\n        ts.forEachChild(node, node => walkIdentifiersInTypeReference(ts, node, cb));\n    }\n    else {\n        const _blockVars = blockVars;\n        if (ts.isBlock(node)) {\n            blockVars = [];\n        }\n        ts.forEachChild(node, node => walkIdentifiers(ts, node, ast, cb, ctx, blockVars, false));\n        if (ts.isBlock(node)) {\n            for (const varName of blockVars) {\n                ctx.removeLocalVariable(varName);\n            }\n        }\n        blockVars = _blockVars;\n    }\n    if (isRoot) {\n        for (const varName of blockVars) {\n            ctx.removeLocalVariable(varName);\n        }\n    }\n}\nfunction processFunction(ts, node, ast, cb, ctx) {\n    const functionArgs = [];\n    for (const param of node.parameters) {\n        (0, common_1.collectVars)(ts, param.name, ast, functionArgs);\n        if (param.type) {\n            walkIdentifiers(ts, param.type, ast, cb, ctx);\n        }\n    }\n    for (const varName of functionArgs) {\n        ctx.addLocalVariable(varName);\n    }\n    if (node.body) {\n        walkIdentifiers(ts, node.body, ast, cb, ctx);\n    }\n    for (const varName of functionArgs) {\n        ctx.removeLocalVariable(varName);\n    }\n}\nfunction walkIdentifiersInTypeReference(ts, node, cb) {\n    if (ts.isTypeQueryNode(node) && ts.isIdentifier(node.exprName)) {\n        cb(node.exprName, false);\n    }\n    else {\n        ts.forEachChild(node, node => walkIdentifiersInTypeReference(ts, node, cb));\n    }\n}\n//# sourceMappingURL=interpolation.js.map", "'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n", "var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,(?!,).*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.binarySearch = void 0;\nfunction binarySearch(offsets, start) {\n    let low = 0;\n    let high = offsets.length - 1;\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const midValue = offsets[mid];\n        if (midValue < start) {\n            low = mid + 1;\n        }\n        else if (midValue > start) {\n            high = mid - 1;\n        }\n        else {\n            low = mid;\n            high = mid;\n            break;\n        }\n    }\n    return Math.max(Math.min(low, high, offsets.length - 1), 0);\n}\nexports.binarySearch = binarySearch;\n//# sourceMappingURL=binarySearch.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getStack = exports.track = exports.resetOffsetStack = exports.offsetStack = exports.setTracking = void 0;\nlet tracking = true;\nlet stackOffset = 0;\nfunction setTracking(value) {\n    tracking = value;\n}\nexports.setTracking = setTracking;\nfunction offsetStack() {\n    stackOffset++;\n}\nexports.offsetStack = offsetStack;\nfunction resetOffsetStack() {\n    stackOffset--;\n}\nexports.resetOffsetStack = resetOffsetStack;\nfunction track(segments, stacks = []) {\n    return [\n        new Proxy(segments, {\n            get(target, prop, receiver) {\n                if (tracking) {\n                    if (prop === 'push')\n                        return push;\n                    if (prop === 'pop')\n                        return pop;\n                    if (prop === 'shift')\n                        return shift;\n                    if (prop === 'unshift')\n                        return unshift;\n                    if (prop === 'splice')\n                        return splice;\n                    if (prop === 'sort')\n                        return sort;\n                    if (prop === 'reverse')\n                        return reverse;\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        }),\n        stacks,\n    ];\n    function push(...items) {\n        stacks.push({ stack: getStack(), length: items.length });\n        return segments.push(...items);\n    }\n    function pop() {\n        if (stacks.length) {\n            const last = stacks[stacks.length - 1];\n            if (last.length > 1) {\n                last.length--;\n            }\n            else {\n                stacks.pop();\n            }\n        }\n        return segments.pop();\n    }\n    function shift() {\n        if (stacks.length) {\n            const first = stacks[0];\n            if (first.length > 1) {\n                first.length--;\n            }\n            else {\n                stacks.shift();\n            }\n        }\n        return segments.shift();\n    }\n    function unshift(...items) {\n        stacks.unshift({ stack: getStack(), length: items.length });\n        return segments.unshift(...items);\n    }\n    function splice(start, deleteCount, ...items) {\n        if (deleteCount === undefined) {\n            deleteCount = segments.length - start;\n        }\n        let _stackStart = 0;\n        let operateIndex;\n        for (let i = 0; i < stacks.length; i++) {\n            const stack = stacks[i];\n            const stackStart = _stackStart;\n            const stackEnd = stackStart + stack.length;\n            _stackStart = stackEnd;\n            if (start >= stackStart) {\n                operateIndex = i + 1;\n                const originalLength = stack.length;\n                stack.length = start - stackStart;\n                stacks.splice(operateIndex, 0, { stack: stack.stack, length: originalLength - stack.length });\n                break;\n            }\n        }\n        if (operateIndex === undefined) {\n            throw new Error('Invalid splice operation');\n        }\n        let _deleteCount = deleteCount;\n        for (let i = operateIndex; i < stacks.length; i++) {\n            const stack = stacks[i];\n            while (_deleteCount > 0 && stack.length > 0) {\n                stack.length--;\n                _deleteCount--;\n            }\n            if (_deleteCount === 0) {\n                break;\n            }\n        }\n        stacks.splice(operateIndex, 0, { stack: getStack(), length: items.length });\n        return segments.splice(start, deleteCount, ...items);\n    }\n    function sort(compareFn) {\n        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });\n        return segments.sort(compareFn);\n    }\n    function reverse() {\n        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });\n        return segments.reverse();\n    }\n}\nexports.track = track;\nfunction getStack() {\n    const stack = new Error().stack;\n    let source = stack.split('\\n')[3 + stackOffset].trim();\n    if (source.endsWith(')')) {\n        source = source.slice(source.lastIndexOf('(') + 1, -1);\n    }\n    else {\n        source = source.slice(source.lastIndexOf(' ') + 1);\n    }\n    return source;\n}\nexports.getStack = getStack;\n//# sourceMappingURL=track.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.replaceRange = exports.replaceSourceRange = exports.replaceAll = exports.replace = exports.create = exports.toString = exports.getLength = void 0;\nconst binarySearch_1 = require(\"./binarySearch\");\nconst track_1 = require(\"./track\");\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./track\"), exports);\nfunction getLength(segments) {\n    let length = 0;\n    for (const segment of segments) {\n        length += typeof segment == 'string' ? segment.length : segment[0].length;\n    }\n    return length;\n}\nexports.getLength = getLength;\nfunction toString(segments) {\n    return segments.map(s => typeof s === 'string' ? s : s[0]).join('');\n}\nexports.toString = toString;\nfunction create(source) {\n    return [[source, undefined, 0]];\n}\nexports.create = create;\nfunction replace(segments, pattern, ...replacers) {\n    const str = toString(segments);\n    const match = str.match(pattern);\n    if (match && match.index !== undefined) {\n        const startOffset = match.index;\n        const endOffset = startOffset + match[0].length;\n        (0, track_1.offsetStack)();\n        replaceRange(segments, startOffset, endOffset, ...replacers.map(replacer => typeof replacer === 'function' ? replacer(match[0]) : replacer));\n        (0, track_1.resetOffsetStack)();\n    }\n}\nexports.replace = replace;\nfunction replaceAll(segments, pattern, ...replacers) {\n    const str = toString(segments);\n    const allMatch = str.matchAll(pattern);\n    let length = str.length;\n    let lengthDiff = 0;\n    for (const match of allMatch) {\n        if (match.index !== undefined) {\n            const startOffset = match.index + lengthDiff;\n            const endOffset = startOffset + match[0].length;\n            (0, track_1.offsetStack)();\n            replaceRange(segments, startOffset, endOffset, ...replacers.map(replacer => typeof replacer === 'function' ? replacer(match[0]) : replacer));\n            (0, track_1.resetOffsetStack)();\n            const newLength = getLength(segments);\n            lengthDiff += newLength - length;\n            length = newLength;\n        }\n    }\n}\nexports.replaceAll = replaceAll;\nfunction replaceSourceRange(segments, source, startOffset, endOffset, ...newSegments) {\n    for (const segment of segments) {\n        if (typeof segment === 'string') {\n            continue;\n        }\n        if (segment[1] === source) {\n            const segmentStart = segment[2];\n            const segmentEnd = segment[2] + segment[0].length;\n            if (segmentStart <= startOffset && segmentEnd >= endOffset) {\n                const inserts = [];\n                if (startOffset > segmentStart) {\n                    inserts.push(trimSegmentEnd(segment, startOffset - segmentStart));\n                }\n                for (const newSegment of newSegments) {\n                    inserts.push(newSegment);\n                }\n                if (endOffset < segmentEnd) {\n                    inserts.push(trimSegmentStart(segment, endOffset - segmentEnd));\n                }\n                combineStrings(inserts);\n                (0, track_1.offsetStack)();\n                segments.splice(segments.indexOf(segment), 1, ...inserts);\n                (0, track_1.resetOffsetStack)();\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.replaceSourceRange = replaceSourceRange;\nfunction replaceRange(segments, startOffset, endOffset, ...newSegments) {\n    const offsets = toOffsets(segments);\n    const startIndex = (0, binarySearch_1.binarySearch)(offsets, startOffset);\n    const endIndex = (0, binarySearch_1.binarySearch)(offsets, endOffset);\n    const startSegment = segments[startIndex];\n    const endSegment = segments[endIndex];\n    const startSegmentStart = offsets[startIndex];\n    const endSegmentStart = offsets[endIndex];\n    const endSegmentEnd = offsets[endIndex] + (typeof endSegment === 'string' ? endSegment.length : endSegment[0].length);\n    const inserts = [];\n    if (startOffset > startSegmentStart) {\n        inserts.push(trimSegmentEnd(startSegment, startOffset - startSegmentStart));\n    }\n    for (const newSegment of newSegments) {\n        inserts.push(newSegment);\n    }\n    if (endOffset < endSegmentEnd) {\n        inserts.push(trimSegmentStart(endSegment, endOffset - endSegmentStart));\n    }\n    combineStrings(inserts);\n    (0, track_1.offsetStack)();\n    segments.splice(startIndex, endIndex - startIndex + 1, ...inserts);\n    (0, track_1.resetOffsetStack)();\n}\nexports.replaceRange = replaceRange;\nfunction combineStrings(segments) {\n    for (let i = segments.length - 1; i >= 1; i--) {\n        if (typeof segments[i] === 'string' && typeof segments[i - 1] === 'string') {\n            segments[i - 1] = segments[i - 1] + segments[i];\n            (0, track_1.offsetStack)();\n            segments.splice(i, 1);\n            (0, track_1.resetOffsetStack)();\n        }\n    }\n}\nfunction trimSegmentEnd(segment, trimEnd) {\n    if (typeof segment === 'string') {\n        return segment.slice(0, trimEnd);\n    }\n    return [\n        segment[0].slice(0, trimEnd),\n        ...segment.slice(1),\n    ];\n}\nfunction trimSegmentStart(segment, trimStart) {\n    if (typeof segment === 'string') {\n        return segment.slice(trimStart);\n    }\n    if (trimStart < 0) {\n        trimStart += segment[0].length;\n    }\n    return [\n        segment[0].slice(trimStart),\n        segment[1],\n        segment[2] + trimStart,\n        ...segment.slice(3),\n    ];\n}\nfunction toOffsets(segments) {\n    const offsets = [];\n    let offset = 0;\n    for (const segment of segments) {\n        offsets.push(offset);\n        offset += typeof segment == 'string' ? segment.length : segment[0].length;\n    }\n    return offsets;\n}\n//# sourceMappingURL=index.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateElementEvents = generateElementEvents;\nexports.generateEventArg = generateEventArg;\nexports.generateEventExpression = generateEventExpression;\nexports.isCompoundExpression = isCompoundExpression;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst shared_1 = require(\"@vue/shared\");\nconst shared_2 = require(\"../../utils/shared\");\nconst common_1 = require(\"../common\");\nconst camelized_1 = require(\"./camelized\");\nconst interpolation_1 = require(\"./interpolation\");\nfunction* generateElementEvents(options, ctx, node, componentVar, componentInstanceVar, emitVar, eventsVar) {\n    let usedComponentEventsVar = false;\n    let propsVar;\n    for (const prop of node.props) {\n        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n            && prop.name === 'on'\n            && prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n            && !prop.arg.loc.source.startsWith('[')\n            && !prop.arg.loc.source.endsWith(']')) {\n            usedComponentEventsVar = true;\n            if (!propsVar) {\n                propsVar = ctx.getInternalVariable();\n                yield `let ${propsVar}!: __VLS_FunctionalComponentProps<typeof ${componentVar}, typeof ${componentInstanceVar}>${common_1.endOfLine}`;\n            }\n            const originalPropName = (0, shared_1.camelize)('on-' + prop.arg.loc.source);\n            const originalPropNameObjectKey = common_1.variableNameRegex.test(originalPropName)\n                ? originalPropName\n                : `'${originalPropName}'`;\n            yield `const ${ctx.getInternalVariable()}: `;\n            if (!options.vueCompilerOptions.strictTemplates) {\n                yield `Record<string, unknown> & `;\n            }\n            yield `(${common_1.newLine}`;\n            yield `__VLS_IsFunction<typeof ${propsVar}, '${originalPropName}'> extends true${common_1.newLine}`;\n            yield `? typeof ${propsVar}${common_1.newLine}`;\n            yield `: __VLS_IsFunction<typeof ${eventsVar}, '${prop.arg.loc.source}'> extends true${common_1.newLine}`;\n            yield `? {${common_1.newLine}`;\n            yield `/**__VLS_emit,${emitVar},${prop.arg.loc.source}*/${common_1.newLine}`;\n            yield `${originalPropNameObjectKey}?: typeof ${eventsVar}['${prop.arg.loc.source}']${common_1.newLine}`;\n            yield `}${common_1.newLine}`;\n            if (prop.arg.loc.source !== (0, shared_1.camelize)(prop.arg.loc.source)) {\n                yield `: __VLS_IsFunction<typeof ${eventsVar}, '${(0, shared_1.camelize)(prop.arg.loc.source)}'> extends true${common_1.newLine}`;\n                yield `? {${common_1.newLine}`;\n                yield `/**__VLS_emit,${emitVar},${(0, shared_1.camelize)(prop.arg.loc.source)}*/${common_1.newLine}`;\n                yield `${originalPropNameObjectKey}?: typeof ${eventsVar}['${(0, shared_1.camelize)(prop.arg.loc.source)}']${common_1.newLine}`;\n                yield `}${common_1.newLine}`;\n            }\n            yield `: typeof ${propsVar}${common_1.newLine}`;\n            yield `) = {${common_1.newLine}`;\n            yield* generateEventArg(ctx, prop.arg, true);\n            yield `: `;\n            yield* generateEventExpression(options, ctx, prop);\n            yield `}${common_1.endOfLine}`;\n        }\n    }\n    return usedComponentEventsVar;\n}\nconst eventArgFeatures = {\n    navigation: {\n        // @click-outside -> onClickOutside\n        resolveRenameNewName(newName) {\n            return (0, shared_1.camelize)('on-' + newName);\n        },\n        // onClickOutside -> @click-outside\n        resolveRenameEditText(newName) {\n            const hName = (0, shared_2.hyphenateAttr)(newName);\n            if ((0, shared_2.hyphenateAttr)(newName).startsWith('on-')) {\n                return (0, shared_1.camelize)(hName.slice('on-'.length));\n            }\n            return newName;\n        },\n    },\n};\nfunction* generateEventArg(ctx, arg, enableHover) {\n    const features = enableHover\n        ? {\n            ...ctx.codeFeatures.withoutHighlightAndCompletion,\n            ...eventArgFeatures,\n        }\n        : eventArgFeatures;\n    if (common_1.variableNameRegex.test((0, shared_1.camelize)(arg.loc.source))) {\n        yield ['', 'template', arg.loc.start.offset, features];\n        yield `on`;\n        yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(arg.loc.source), arg.loc.start.offset, common_1.combineLastMapping);\n    }\n    else {\n        yield* (0, common_1.wrapWith)(arg.loc.start.offset, arg.loc.end.offset, features, `'`, ['', 'template', arg.loc.start.offset, common_1.combineLastMapping], 'on', ...(0, camelized_1.generateCamelized)((0, shared_1.capitalize)(arg.loc.source), arg.loc.start.offset, common_1.combineLastMapping), `'`);\n    }\n}\nfunction* generateEventExpression(options, ctx, prop) {\n    if (prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n        let prefix = '(';\n        let suffix = ')';\n        let isFirstMapping = true;\n        const ast = (0, common_1.createTsAst)(options.ts, prop.exp, prop.exp.content);\n        const _isCompoundExpression = isCompoundExpression(options.ts, ast);\n        if (_isCompoundExpression) {\n            yield `(...[$event]) => {${common_1.newLine}`;\n            ctx.addLocalVariable('$event');\n            prefix = '';\n            suffix = '';\n            for (const blockCondition of ctx.blockConditions) {\n                prefix += `if (!(${blockCondition})) return${common_1.endOfLine}`;\n            }\n        }\n        yield* (0, interpolation_1.generateInterpolation)(options, ctx, prop.exp.content, prop.exp.loc, prop.exp.loc.start.offset, offset => {\n            if (_isCompoundExpression && isFirstMapping) {\n                isFirstMapping = false;\n                ctx.inlayHints.push({\n                    blockName: 'template',\n                    offset,\n                    setting: 'vue.inlayHints.inlineHandlerLeading',\n                    label: '$event =>',\n                    paddingRight: true,\n                    tooltip: [\n                        '`$event` is a hidden parameter, you can use it in this callback.',\n                        'To hide this hint, set `vue.inlayHints.inlineHandlerLeading` to `false` in IDE settings.',\n                        '[More info](https://github.com/vuejs/language-tools/issues/2445#issuecomment-1444771420)',\n                    ].join('\\n\\n'),\n                });\n            }\n            return ctx.codeFeatures.all;\n        }, prefix, suffix);\n        if (_isCompoundExpression) {\n            ctx.removeLocalVariable('$event');\n            yield common_1.endOfLine;\n            yield* ctx.generateAutoImportCompletion();\n            yield `}`;\n        }\n    }\n    else {\n        yield `() => {}`;\n    }\n}\nfunction isCompoundExpression(ts, ast) {\n    let result = true;\n    if (ast.statements.length === 0) {\n        result = false;\n    }\n    else if (ast.statements.length === 1) {\n        ts.forEachChild(ast, child_1 => {\n            if (ts.isExpressionStatement(child_1)) {\n                ts.forEachChild(child_1, child_2 => {\n                    if (ts.isArrowFunction(child_2)) {\n                        result = false;\n                    }\n                    else if (isPropertyAccessOrId(ts, child_2)) {\n                        result = false;\n                    }\n                });\n            }\n            else if (ts.isFunctionDeclaration(child_1)) {\n                result = false;\n            }\n        });\n    }\n    return result;\n}\nfunction isPropertyAccessOrId(ts, node) {\n    if (ts.isIdentifier(node)) {\n        return true;\n    }\n    if (ts.isPropertyAccessExpression(node)) {\n        return isPropertyAccessOrId(ts, node.expression);\n    }\n    return false;\n}\n//# sourceMappingURL=elementEvents.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateStringLiteralKey = generateStringLiteralKey;\nconst common_1 = require(\"../common\");\nfunction* generateStringLiteralKey(code, offset, info) {\n    if (offset === undefined || !info) {\n        yield `\"${code}\"`;\n    }\n    else {\n        yield* (0, common_1.wrapWith)(offset, offset + code.length, info, `\"`, [code, 'template', offset, common_1.combineLastMapping], `\"`);\n    }\n}\n//# sourceMappingURL=stringLiteralKey.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateObjectProperty = generateObjectProperty;\nconst shared_1 = require(\"@vue/shared\");\nconst common_1 = require(\"../common\");\nconst camelized_1 = require(\"./camelized\");\nconst interpolation_1 = require(\"./interpolation\");\nconst stringLiteralKey_1 = require(\"./stringLiteralKey\");\nfunction* generateObjectProperty(options, ctx, code, offset, features, astHolder, shouldCamelize = false, shouldBeConstant = false) {\n    if (code.startsWith('[') && code.endsWith(']') && astHolder) {\n        if (shouldBeConstant) {\n            yield* (0, interpolation_1.generateInterpolation)(options, ctx, code.slice(1, -1), astHolder, offset + 1, features, `[__VLS_tryAsConstant(`, `)]`);\n        }\n        else {\n            yield* (0, interpolation_1.generateInterpolation)(options, ctx, code, astHolder, offset, features, '', '');\n        }\n    }\n    else if (shouldCamelize) {\n        if (common_1.variableNameRegex.test((0, shared_1.camelize)(code))) {\n            yield* (0, camelized_1.generateCamelized)(code, offset, features);\n        }\n        else {\n            yield* (0, common_1.wrapWith)(offset, offset + code.length, features, `\"`, ...(0, camelized_1.generateCamelized)(code, offset, common_1.combineLastMapping), `\"`);\n        }\n    }\n    else {\n        if (common_1.variableNameRegex.test(code)) {\n            yield [code, 'template', offset, features];\n        }\n        else {\n            yield* (0, stringLiteralKey_1.generateStringLiteralKey)(code, offset, features);\n        }\n    }\n}\n//# sourceMappingURL=objectProperty.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createVBindShorthandInlayHintInfo = createVBindShorthandInlayHintInfo;\nfunction createVBindShorthandInlayHintInfo(loc, variableName) {\n    return {\n        blockName: 'template',\n        offset: loc.end.offset,\n        setting: 'vue.inlayHints.vBindShorthand',\n        label: `=\"${variableName}\"`,\n        tooltip: [\n            `This is a shorthand for \\`${loc.source}=\"${variableName}\"\\`.`,\n            'To hide this hint, set `vue.inlayHints.vBindShorthand` to `false` in IDE settings.',\n            '[More info](https://github.com/vuejs/core/pull/9451)',\n        ].join('\\n\\n'),\n    };\n}\n//# sourceMappingURL=inlayHints.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateElementProps = generateElementProps;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst shared_1 = require(\"@vue/shared\");\nconst minimatch_1 = require(\"minimatch\");\nconst muggle_string_1 = require(\"muggle-string\");\nconst shared_2 = require(\"../../utils/shared\");\nconst common_1 = require(\"../common\");\nconst camelized_1 = require(\"./camelized\");\nconst elementEvents_1 = require(\"./elementEvents\");\nconst interpolation_1 = require(\"./interpolation\");\nconst objectProperty_1 = require(\"./objectProperty\");\nconst inlayHints_1 = require(\"../inlayHints\");\nfunction* generateElementProps(options, ctx, node, props, enableCodeFeatures, propsFailedExps) {\n    const isComponent = node.tagType === CompilerDOM.ElementTypes.COMPONENT;\n    for (const prop of props) {\n        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n            && prop.name === 'on') {\n            if (prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n                && !prop.arg.loc.source.startsWith('[')\n                && !prop.arg.loc.source.endsWith(']')) {\n                if (!isComponent) {\n                    yield `...{ `;\n                    yield* (0, elementEvents_1.generateEventArg)(ctx, prop.arg, true);\n                    yield `: `;\n                    yield* (0, elementEvents_1.generateEventExpression)(options, ctx, prop);\n                    yield `}, `;\n                }\n                else {\n                    yield `...{ '${(0, shared_1.camelize)('on-' + prop.arg.loc.source)}': {} as any }, `;\n                }\n            }\n            else if (prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n                && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n                && prop.arg.loc.source.startsWith('[')\n                && prop.arg.loc.source.endsWith(']')) {\n                propsFailedExps?.push({ node: prop.arg, prefix: '(', suffix: ')' });\n                propsFailedExps?.push({ node: prop.exp, prefix: '() => {', suffix: '}' });\n            }\n            else if (!prop.arg\n                && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                propsFailedExps?.push({ node: prop.exp, prefix: '(', suffix: ')' });\n            }\n        }\n    }\n    for (const prop of props) {\n        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n            && ((prop.name === 'bind' && prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION)\n                || prop.name === 'model')\n            && (!prop.exp || prop.exp.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION)) {\n            let propName;\n            if (prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                propName = prop.arg.constType === CompilerDOM.ConstantTypes.CAN_STRINGIFY\n                    ? prop.arg.content\n                    : prop.arg.loc.source;\n            }\n            else {\n                propName = getModelValuePropName(node, options.vueCompilerOptions.target, options.vueCompilerOptions);\n            }\n            if (propName === undefined\n                || options.vueCompilerOptions.dataAttributes.some(pattern => (0, minimatch_1.minimatch)(propName, pattern))) {\n                if (prop.exp && prop.exp.constType !== CompilerDOM.ConstantTypes.CAN_STRINGIFY) {\n                    propsFailedExps?.push({ node: prop.exp, prefix: '(', suffix: ')' });\n                }\n                continue;\n            }\n            if (prop.modifiers.some(m => m.content === 'prop' || m.content === 'attr')) {\n                propName = propName.substring(1);\n            }\n            const shouldSpread = propName === 'style' || propName === 'class';\n            const shouldCamelize = isComponent\n                && (!prop.arg || (prop.arg.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && prop.arg.isStatic)) // isStatic\n                && (0, shared_2.hyphenateAttr)(propName) === propName\n                && !options.vueCompilerOptions.htmlAttributes.some(pattern => (0, minimatch_1.minimatch)(propName, pattern));\n            if (shouldSpread) {\n                yield `...{ `;\n            }\n            const codeInfo = ctx.codeFeatures.withoutHighlightAndCompletion;\n            const codes = (0, common_1.wrapWith)(prop.loc.start.offset, prop.loc.end.offset, ctx.codeFeatures.verification, ...(prop.arg\n                ? (0, objectProperty_1.generateObjectProperty)(options, ctx, propName, prop.arg.loc.start.offset, {\n                    ...codeInfo,\n                    verification: options.vueCompilerOptions.strictTemplates\n                        ? codeInfo.verification\n                        : {\n                            shouldReport(_source, code) {\n                                if (String(code) === '2353' || String(code) === '2561') {\n                                    return false;\n                                }\n                                return typeof codeInfo.verification === 'object'\n                                    ? codeInfo.verification.shouldReport?.(_source, code) ?? true\n                                    : true;\n                            },\n                        },\n                    navigation: codeInfo.navigation\n                        ? {\n                            resolveRenameNewName: shared_1.camelize,\n                            resolveRenameEditText: shouldCamelize ? shared_2.hyphenateAttr : undefined,\n                        }\n                        : false,\n                }, prop.loc.name_2 ?? (prop.loc.name_2 = {}), shouldCamelize)\n                : (0, common_1.wrapWith)(prop.loc.start.offset, prop.loc.start.offset + 'v-model'.length, ctx.codeFeatures.verification, propName)), `: (`, ...generatePropExp(options, ctx, prop, prop.exp, ctx.codeFeatures.all, prop.arg?.loc.start.offset === prop.exp?.loc.start.offset, enableCodeFeatures), `)`);\n            if (!enableCodeFeatures) {\n                yield (0, muggle_string_1.toString)([...codes]);\n            }\n            else {\n                yield* codes;\n            }\n            if (shouldSpread) {\n                yield ` }`;\n            }\n            yield `, `;\n        }\n        else if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE) {\n            if (options.vueCompilerOptions.dataAttributes.some(pattern => (0, minimatch_1.minimatch)(prop.name, pattern))\n                // Vue 2 Transition doesn't support \"persisted\" property but `@vue/compiler-dom always adds it (#3881)\n                || (options.vueCompilerOptions.target < 3\n                    && prop.name === 'persisted'\n                    && node.tag.toLowerCase() === 'transition')) {\n                continue;\n            }\n            const shouldSpread = prop.name === 'style' || prop.name === 'class';\n            const shouldCamelize = isComponent\n                && (0, shared_2.hyphenateAttr)(prop.name) === prop.name\n                && !options.vueCompilerOptions.htmlAttributes.some(pattern => (0, minimatch_1.minimatch)(prop.name, pattern));\n            if (shouldSpread) {\n                yield `...{ `;\n            }\n            const codeInfo = shouldCamelize\n                ? {\n                    ...ctx.codeFeatures.withoutHighlightAndCompletion,\n                    navigation: ctx.codeFeatures.withoutHighlightAndCompletion.navigation\n                        ? {\n                            resolveRenameNewName: shared_1.camelize,\n                            resolveRenameEditText: shared_2.hyphenateAttr,\n                        }\n                        : false,\n                }\n                : {\n                    ...ctx.codeFeatures.withoutHighlightAndCompletion,\n                };\n            if (!options.vueCompilerOptions.strictTemplates) {\n                const verification = codeInfo.verification;\n                codeInfo.verification = {\n                    shouldReport(_source, code) {\n                        if (String(code) === '2353' || String(code) === '2561') {\n                            return false;\n                        }\n                        return typeof verification === 'object'\n                            ? verification.shouldReport?.(_source, code) ?? true\n                            : true;\n                    },\n                };\n            }\n            const codes = (0, common_1.conditionWrapWith)(enableCodeFeatures, prop.loc.start.offset, prop.loc.end.offset, ctx.codeFeatures.verification, ...(0, objectProperty_1.generateObjectProperty)(options, ctx, prop.name, prop.loc.start.offset, codeInfo, prop.loc.name_1 ?? (prop.loc.name_1 = {}), shouldCamelize), `: (`, ...(prop.value\n                ? generateAttrValue(prop.value, ctx.codeFeatures.all)\n                : [`true`]), `)`);\n            if (!enableCodeFeatures) {\n                yield (0, muggle_string_1.toString)([...codes]);\n            }\n            else {\n                yield* codes;\n            }\n            if (shouldSpread) {\n                yield ` }`;\n            }\n            yield `, `;\n        }\n        else if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n            && prop.name === 'bind'\n            && !prop.arg\n            && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n            const codes = (0, common_1.conditionWrapWith)(enableCodeFeatures, prop.exp.loc.start.offset, prop.exp.loc.end.offset, ctx.codeFeatures.verification, `...`, ...(0, interpolation_1.generateInterpolation)(options, ctx, prop.exp.content, prop.exp.loc, prop.exp.loc.start.offset, ctx.codeFeatures.all, '(', ')'));\n            if (!enableCodeFeatures) {\n                yield (0, muggle_string_1.toString)([...codes]);\n            }\n            else {\n                yield* codes;\n            }\n            yield `, `;\n        }\n        else {\n            // comment this line to avoid affecting comments in prop expressions\n            // tsCodeGen.addText(\"/* \" + [prop.type, prop.name, prop.arg?.loc.source, prop.exp?.loc.source, prop.loc.source].join(\", \") + \" */ \");\n        }\n    }\n}\nfunction* generatePropExp(options, ctx, prop, exp, features, isShorthand, enableCodeFeatures) {\n    if (isShorthand && features.completion) {\n        features = {\n            ...features,\n            completion: undefined,\n        };\n    }\n    if (exp && exp.constType !== CompilerDOM.ConstantTypes.CAN_STRINGIFY) { // style='z-index: 2' will compile to {'z-index':'2'}\n        if (!isShorthand) { // vue 3.4+\n            yield* (0, interpolation_1.generateInterpolation)(options, ctx, exp.loc.source, exp.loc, exp.loc.start.offset, features, '(', ')');\n        }\n        else {\n            const propVariableName = (0, shared_1.camelize)(exp.loc.source);\n            if (common_1.variableNameRegex.test(propVariableName)) {\n                if (!ctx.hasLocalVariable(propVariableName)) {\n                    ctx.accessExternalVariable(propVariableName, exp.loc.start.offset);\n                    yield `__VLS_ctx.`;\n                }\n                yield* (0, camelized_1.generateCamelized)(exp.loc.source, exp.loc.start.offset, features);\n                if (enableCodeFeatures) {\n                    ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(prop.loc, propVariableName));\n                }\n            }\n        }\n    }\n    else {\n        yield `{}`;\n    }\n}\nfunction* generateAttrValue(attrNode, features) {\n    const char = attrNode.loc.source.startsWith(\"'\") ? \"'\" : '\"';\n    yield char;\n    let start = attrNode.loc.start.offset;\n    let end = attrNode.loc.end.offset;\n    let content = attrNode.loc.source;\n    if ((content.startsWith('\"') && content.endsWith('\"'))\n        || (content.startsWith(\"'\") && content.endsWith(\"'\"))) {\n        start++;\n        end--;\n        content = content.slice(1, -1);\n    }\n    if (needToUnicode(content)) {\n        yield* (0, common_1.wrapWith)(start, end, features, toUnicode(content));\n    }\n    else {\n        yield [content, 'template', start, features];\n    }\n    yield char;\n}\nfunction needToUnicode(str) {\n    return str.includes('\\\\') || str.includes('\\n');\n}\nfunction toUnicode(str) {\n    return str.split('').map(value => {\n        const temp = value.charCodeAt(0).toString(16).padStart(4, '0');\n        if (temp.length > 2) {\n            return '\\\\u' + temp;\n        }\n        return value;\n    }).join('');\n}\nfunction getModelValuePropName(node, vueVersion, vueCompilerOptions) {\n    for (const modelName in vueCompilerOptions.experimentalModelPropName) {\n        const tags = vueCompilerOptions.experimentalModelPropName[modelName];\n        for (const tag in tags) {\n            if (node.tag === tag || node.tag === (0, shared_2.hyphenateTag)(tag)) {\n                const v = tags[tag];\n                if (typeof v === 'object') {\n                    const arr = Array.isArray(v) ? v : [v];\n                    for (const attrs of arr) {\n                        let failed = false;\n                        for (const attr in attrs) {\n                            const attrNode = node.props.find(prop => prop.type === CompilerDOM.NodeTypes.ATTRIBUTE && prop.name === attr);\n                            if (!attrNode || attrNode.value?.content !== attrs[attr]) {\n                                failed = true;\n                                break;\n                            }\n                        }\n                        if (!failed) {\n                            // all match\n                            return modelName || undefined;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for (const modelName in vueCompilerOptions.experimentalModelPropName) {\n        const tags = vueCompilerOptions.experimentalModelPropName[modelName];\n        for (const tag in tags) {\n            if (node.tag === tag || node.tag === (0, shared_2.hyphenateTag)(tag)) {\n                const attrs = tags[tag];\n                if (attrs === true) {\n                    return modelName || undefined;\n                }\n            }\n        }\n    }\n    return vueVersion < 3 ? 'value' : 'modelValue';\n}\n//# sourceMappingURL=elementProps.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateSlotOutlet = generateSlotOutlet;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst common_1 = require(\"../common\");\nconst elementChildren_1 = require(\"./elementChildren\");\nconst elementProps_1 = require(\"./elementProps\");\nconst interpolation_1 = require(\"./interpolation\");\nconst inlayHints_1 = require(\"../inlayHints\");\nfunction* generateSlotOutlet(options, ctx, node, currentComponent, componentCtxVar) {\n    const startTagOffset = node.loc.start.offset + options.template.content.substring(node.loc.start.offset).indexOf(node.tag);\n    const varSlot = ctx.getInternalVariable();\n    const nameProp = node.props.find(prop => {\n        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE) {\n            return prop.name === 'name';\n        }\n        if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n            && prop.name === 'bind'\n            && prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n            return prop.arg.content === 'name';\n        }\n    });\n    if (options.hasDefineSlots) {\n        yield `__VLS_normalizeSlot(`;\n        yield* (0, common_1.wrapWith)(node.loc.start.offset, node.loc.end.offset, ctx.codeFeatures.verification, `${options.slotsAssignName ?? '__VLS_slots'}[`, ...(0, common_1.wrapWith)(node.loc.start.offset, node.loc.end.offset, ctx.codeFeatures.verification, nameProp?.type === CompilerDOM.NodeTypes.ATTRIBUTE && nameProp.value\n            ? `'${nameProp.value.content}'`\n            : nameProp?.type === CompilerDOM.NodeTypes.DIRECTIVE && nameProp.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n                ? nameProp.exp.content\n                : `('default' as const)`), `]`);\n        yield `)?.(`;\n        yield* (0, common_1.wrapWith)(startTagOffset, startTagOffset + node.tag.length, ctx.codeFeatures.verification, `{${common_1.newLine}`, ...(0, elementProps_1.generateElementProps)(options, ctx, node, node.props.filter(prop => prop !== nameProp), true), `}`);\n        yield `)${common_1.endOfLine}`;\n    }\n    else {\n        yield `var ${varSlot} = {${common_1.newLine}`;\n        yield* (0, elementProps_1.generateElementProps)(options, ctx, node, node.props.filter(prop => prop !== nameProp), true);\n        yield `}${common_1.endOfLine}`;\n        if (nameProp?.type === CompilerDOM.NodeTypes.ATTRIBUTE\n            && nameProp.value) {\n            ctx.slots.push({\n                name: nameProp.value.content,\n                loc: nameProp.loc.start.offset + nameProp.loc.source.indexOf(nameProp.value.content, nameProp.name.length),\n                tagRange: [startTagOffset, startTagOffset + node.tag.length],\n                varName: varSlot,\n                nodeLoc: node.loc,\n            });\n        }\n        else if (nameProp?.type === CompilerDOM.NodeTypes.DIRECTIVE\n            && nameProp.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n            const isShortHand = nameProp.arg?.loc.start.offset === nameProp.exp.loc.start.offset;\n            if (isShortHand) {\n                ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(nameProp.exp.loc, 'name'));\n            }\n            const slotExpVar = ctx.getInternalVariable();\n            yield `var ${slotExpVar} = `;\n            yield* (0, interpolation_1.generateInterpolation)(options, ctx, nameProp.exp.content, nameProp.exp, nameProp.exp.loc.start.offset, ctx.codeFeatures.all, '(', ')');\n            yield ` as const${common_1.endOfLine}`;\n            ctx.dynamicSlots.push({\n                expVar: slotExpVar,\n                varName: varSlot,\n            });\n        }\n        else {\n            ctx.slots.push({\n                name: 'default',\n                tagRange: [startTagOffset, startTagOffset + node.tag.length],\n                varName: varSlot,\n                nodeLoc: node.loc,\n            });\n        }\n    }\n    yield* ctx.generateAutoImportCompletion();\n    yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node, currentComponent, componentCtxVar);\n}\n//# sourceMappingURL=slotOutlet.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateVFor = generateVFor;\nexports.parseVForNode = parseVForNode;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst common_1 = require(\"../common\");\nconst interpolation_1 = require(\"./interpolation\");\nconst templateChild_1 = require(\"./templateChild\");\nfunction* generateVFor(options, ctx, node, currentComponent, componentCtxVar) {\n    const { source } = node.parseResult;\n    const { leftExpressionRange, leftExpressionText } = parseVForNode(node);\n    const forBlockVars = [];\n    yield `for (const [`;\n    if (leftExpressionRange && leftExpressionText) {\n        const collectAst = (0, common_1.createTsAst)(options.ts, node.parseResult, `const [${leftExpressionText}]`);\n        (0, common_1.collectVars)(options.ts, collectAst, collectAst, forBlockVars);\n        yield [\n            leftExpressionText,\n            'template',\n            leftExpressionRange.start,\n            ctx.codeFeatures.all,\n        ];\n    }\n    yield `] of `;\n    if (source.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n        yield `__VLS_getVForSourceType(`;\n        yield* (0, interpolation_1.generateInterpolation)(options, ctx, source.content, source.loc, source.loc.start.offset, ctx.codeFeatures.all, '(', ')');\n        yield `!)`; // #3102\n    }\n    else {\n        yield `{} as any`;\n    }\n    yield `) {${common_1.newLine}`;\n    for (const varName of forBlockVars) {\n        ctx.addLocalVariable(varName);\n    }\n    let isFragment = true;\n    for (const argument of node.codegenNode?.children.arguments ?? []) {\n        if (argument.type === CompilerDOM.NodeTypes.JS_FUNCTION_EXPRESSION\n            && argument.returns?.type === CompilerDOM.NodeTypes.VNODE_CALL\n            && argument.returns?.props?.type === CompilerDOM.NodeTypes.JS_OBJECT_EXPRESSION) {\n            if (argument.returns.tag !== CompilerDOM.FRAGMENT) {\n                isFragment = false;\n                continue;\n            }\n            for (const prop of argument.returns.props.properties) {\n                if (prop.value.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n                    && !prop.value.isStatic) {\n                    yield* (0, interpolation_1.generateInterpolation)(options, ctx, prop.value.content, prop.value.loc, prop.value.loc.start.offset, ctx.codeFeatures.all, '(', ')');\n                    yield common_1.endOfLine;\n                }\n            }\n        }\n    }\n    if (isFragment) {\n        yield* ctx.resetDirectiveComments('end of v-for start');\n    }\n    let prev;\n    for (const childNode of node.children) {\n        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, childNode, currentComponent, prev, componentCtxVar, true);\n        prev = childNode;\n    }\n    for (const varName of forBlockVars) {\n        ctx.removeLocalVariable(varName);\n    }\n    yield* ctx.generateAutoImportCompletion();\n    yield `}${common_1.newLine}`;\n}\nfunction parseVForNode(node) {\n    const { value, key, index } = node.parseResult;\n    const leftExpressionRange = (value || key || index)\n        ? {\n            start: (value ?? key ?? index).loc.start.offset,\n            end: (index ?? key ?? value).loc.end.offset,\n        }\n        : undefined;\n    const leftExpressionText = leftExpressionRange\n        ? node.loc.source.substring(leftExpressionRange.start - node.loc.start.offset, leftExpressionRange.end - node.loc.start.offset)\n        : undefined;\n    return {\n        leftExpressionRange,\n        leftExpressionText,\n    };\n}\n//# sourceMappingURL=vFor.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateVIf = generateVIf;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst muggle_string_1 = require(\"muggle-string\");\nconst common_1 = require(\"../common\");\nconst interpolation_1 = require(\"./interpolation\");\nconst templateChild_1 = require(\"./templateChild\");\nfunction* generateVIf(options, ctx, node, currentComponent, componentCtxVar) {\n    let originalBlockConditionsLength = ctx.blockConditions.length;\n    for (let i = 0; i < node.branches.length; i++) {\n        const branch = node.branches[i];\n        if (i === 0) {\n            yield `if `;\n        }\n        else if (branch.condition) {\n            yield `else if `;\n        }\n        else {\n            yield `else `;\n        }\n        let addedBlockCondition = false;\n        if (branch.condition?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n            const codes = [\n                ...(0, interpolation_1.generateInterpolation)(options, ctx, branch.condition.content, branch.condition.loc, branch.condition.loc.start.offset, ctx.codeFeatures.all, '(', ')'),\n            ];\n            for (const code of codes) {\n                yield code;\n            }\n            ctx.blockConditions.push((0, muggle_string_1.toString)(codes));\n            addedBlockCondition = true;\n            yield ` `;\n        }\n        yield `{${common_1.newLine}`;\n        if (isFragment(node)) {\n            yield* ctx.resetDirectiveComments('end of v-if start');\n        }\n        let prev;\n        for (const childNode of branch.children) {\n            yield* (0, templateChild_1.generateTemplateChild)(options, ctx, childNode, currentComponent, prev, componentCtxVar);\n            prev = childNode;\n        }\n        yield* ctx.generateAutoImportCompletion();\n        yield `}${common_1.newLine}`;\n        if (addedBlockCondition) {\n            ctx.blockConditions[ctx.blockConditions.length - 1] = `!(${ctx.blockConditions[ctx.blockConditions.length - 1]})`;\n        }\n    }\n    ctx.blockConditions.length = originalBlockConditionsLength;\n}\nfunction isFragment(node) {\n    return node.codegenNode\n        && 'consequent' in node.codegenNode\n        && 'tag' in node.codegenNode.consequent\n        && node.codegenNode.consequent.tag === CompilerDOM.FRAGMENT;\n}\n//# sourceMappingURL=vIf.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateTemplateChild = generateTemplateChild;\nexports.getVForNode = getVForNode;\nexports.parseInterpolationNode = parseInterpolationNode;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst common_1 = require(\"../common\");\nconst element_1 = require(\"./element\");\nconst interpolation_1 = require(\"./interpolation\");\nconst slotOutlet_1 = require(\"./slotOutlet\");\nconst vFor_1 = require(\"./vFor\");\nconst vIf_1 = require(\"./vIf\");\n// @ts-ignore\nconst transformContext = {\n    onError: () => { },\n    helperString: str => str.toString(),\n    replaceNode: () => { },\n    cacheHandlers: false,\n    prefixIdentifiers: false,\n    scopes: {\n        vFor: 0,\n        vOnce: 0,\n        vPre: 0,\n        vSlot: 0,\n    },\n    expressionPlugins: ['typescript'],\n};\nfunction* generateTemplateChild(options, ctx, node, currentComponent, prevNode, componentCtxVar, isVForChild = false) {\n    if (prevNode?.type === CompilerDOM.NodeTypes.COMMENT) {\n        const commentText = prevNode.content.trim().split(' ')[0];\n        if (commentText.match(/^@vue-skip\\b[\\s\\S]*/)) {\n            yield `// @vue-skip${common_1.newLine}`;\n            return;\n        }\n        else if (commentText.match(/^@vue-ignore\\b[\\s\\S]*/)) {\n            yield* ctx.ignoreError();\n        }\n        else if (commentText.match(/^@vue-expect-error\\b[\\s\\S]*/)) {\n            yield* ctx.expectError(prevNode);\n        }\n    }\n    const shouldInheritRootNodeAttrs = options.inheritAttrs;\n    const cur = node;\n    if (cur.codegenNode?.type === CompilerDOM.NodeTypes.JS_CACHE_EXPRESSION) {\n        cur.codegenNode = cur.codegenNode.value;\n    }\n    if (node.type === CompilerDOM.NodeTypes.ROOT) {\n        let prev;\n        if (shouldInheritRootNodeAttrs && node.children.length === 1 && node.children[0].type === CompilerDOM.NodeTypes.ELEMENT) {\n            ctx.singleRootNode = node.children[0];\n        }\n        for (const childNode of node.children) {\n            yield* generateTemplateChild(options, ctx, childNode, currentComponent, prev, componentCtxVar);\n            prev = childNode;\n        }\n        yield* ctx.resetDirectiveComments('end of root');\n    }\n    else if (node.type === CompilerDOM.NodeTypes.ELEMENT) {\n        const vForNode = getVForNode(node);\n        const vIfNode = getVIfNode(node);\n        if (vForNode) {\n            yield* (0, vFor_1.generateVFor)(options, ctx, vForNode, currentComponent, componentCtxVar);\n        }\n        else if (vIfNode) {\n            yield* (0, vIf_1.generateVIf)(options, ctx, vIfNode, currentComponent, componentCtxVar);\n        }\n        else {\n            if (node.tagType === CompilerDOM.ElementTypes.SLOT) {\n                yield* (0, slotOutlet_1.generateSlotOutlet)(options, ctx, node, currentComponent, componentCtxVar);\n            }\n            else if (node.tagType === CompilerDOM.ElementTypes.ELEMENT\n                || node.tagType === CompilerDOM.ElementTypes.TEMPLATE) {\n                yield* (0, element_1.generateElement)(options, ctx, node, currentComponent, componentCtxVar, isVForChild);\n            }\n            else {\n                yield* (0, element_1.generateComponent)(options, ctx, node, currentComponent);\n            }\n        }\n    }\n    else if (node.type === CompilerDOM.NodeTypes.TEXT_CALL) {\n        // {{ var }}\n        yield* generateTemplateChild(options, ctx, node.content, currentComponent, undefined, componentCtxVar);\n    }\n    else if (node.type === CompilerDOM.NodeTypes.COMPOUND_EXPRESSION) {\n        // {{ ... }} {{ ... }}\n        for (const childNode of node.children) {\n            if (typeof childNode === 'object') {\n                yield* generateTemplateChild(options, ctx, childNode, currentComponent, undefined, componentCtxVar);\n            }\n        }\n    }\n    else if (node.type === CompilerDOM.NodeTypes.INTERPOLATION) {\n        // {{ ... }}\n        const [content, start] = parseInterpolationNode(node, options.template.content);\n        yield* (0, interpolation_1.generateInterpolation)(options, ctx, content, node.content.loc, start, ctx.codeFeatures.all, `(`, `)${common_1.endOfLine}`);\n        yield* ctx.resetDirectiveComments('end of INTERPOLATION');\n    }\n    else if (node.type === CompilerDOM.NodeTypes.IF) {\n        // v-if / v-else-if / v-else\n        yield* (0, vIf_1.generateVIf)(options, ctx, node, currentComponent, componentCtxVar);\n    }\n    else if (node.type === CompilerDOM.NodeTypes.FOR) {\n        // v-for\n        yield* (0, vFor_1.generateVFor)(options, ctx, node, currentComponent, componentCtxVar);\n    }\n    else if (node.type === CompilerDOM.NodeTypes.TEXT) {\n        // not needed progress\n    }\n}\n// TODO: track https://github.com/vuejs/vue-next/issues/3498\nfunction getVForNode(node) {\n    const forDirective = node.props.find((prop) => prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n        && prop.name === 'for');\n    if (forDirective) {\n        let forNode;\n        CompilerDOM.processFor(node, forDirective, transformContext, _forNode => {\n            forNode = { ..._forNode };\n            return undefined;\n        });\n        if (forNode) {\n            forNode.children = [{\n                    ...node,\n                    props: node.props.filter(prop => prop !== forDirective),\n                }];\n            return forNode;\n        }\n    }\n}\nfunction getVIfNode(node) {\n    const forDirective = node.props.find((prop) => prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n        && prop.name === 'if');\n    if (forDirective) {\n        let ifNode;\n        CompilerDOM.processIf(node, forDirective, transformContext, _ifNode => {\n            ifNode = { ..._ifNode };\n            return undefined;\n        });\n        if (ifNode) {\n            for (const branch of ifNode.branches) {\n                branch.children = [{\n                        ...node,\n                        props: node.props.filter(prop => prop !== forDirective),\n                    }];\n            }\n            return ifNode;\n        }\n    }\n}\nfunction parseInterpolationNode(node, template) {\n    let content = node.content.loc.source;\n    let start = node.content.loc.start.offset;\n    let leftCharacter;\n    let rightCharacter;\n    // fix https://github.com/vuejs/language-tools/issues/1787\n    while ((leftCharacter = template.substring(start - 1, start)).trim() === '' && leftCharacter.length) {\n        start--;\n        content = leftCharacter + content;\n    }\n    while ((rightCharacter = template.substring(start + content.length, start + content.length + 1)).trim() === '' && rightCharacter.length) {\n        content = content + rightCharacter;\n    }\n    return [\n        content,\n        start,\n    ];\n}\n//# sourceMappingURL=templateChild.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateElementChildren = generateElementChildren;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst common_1 = require(\"../common\");\nconst templateChild_1 = require(\"./templateChild\");\nfunction* generateElementChildren(options, ctx, node, currentComponent, componentCtxVar) {\n    yield* ctx.resetDirectiveComments('end of element children start');\n    let prev;\n    for (const childNode of node.children) {\n        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, childNode, currentComponent, prev, componentCtxVar);\n        prev = childNode;\n    }\n    yield* ctx.generateAutoImportCompletion();\n    // fix https://github.com/vuejs/language-tools/issues/932\n    if (componentCtxVar\n        && !ctx.hasSlotElements.has(node)\n        && node.children.length\n        && node.tagType !== CompilerDOM.ElementTypes.ELEMENT\n        && node.tagType !== CompilerDOM.ElementTypes.TEMPLATE) {\n        ctx.usedComponentCtxVars.add(componentCtxVar);\n        yield `__VLS_nonNullable(${componentCtxVar}.slots).`;\n        yield* (0, common_1.wrapWith)(node.children[0].loc.start.offset, node.children[node.children.length - 1].loc.end.offset, ctx.codeFeatures.navigation, `default`);\n        yield common_1.endOfLine;\n    }\n}\n//# sourceMappingURL=elementChildren.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateElementDirectives = generateElementDirectives;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst shared_1 = require(\"@vue/shared\");\nconst shared_2 = require(\"../../utils/shared\");\nconst common_1 = require(\"../common\");\nconst camelized_1 = require(\"./camelized\");\nconst interpolation_1 = require(\"./interpolation\");\nconst objectProperty_1 = require(\"./objectProperty\");\nconst stringLiteralKey_1 = require(\"./stringLiteralKey\");\nfunction* generateElementDirectives(options, ctx, node) {\n    for (const prop of node.props) {\n        if (prop.type !== CompilerDOM.NodeTypes.DIRECTIVE\n            || prop.name === 'slot'\n            || prop.name === 'on'\n            || prop.name === 'model'\n            || prop.name === 'bind'\n            || prop.name === 'scope'\n            || prop.name === 'data') {\n            continue;\n        }\n        ctx.accessExternalVariable((0, shared_1.camelize)('v-' + prop.name), prop.loc.start.offset);\n        yield* (0, common_1.wrapWith)(prop.loc.start.offset, prop.loc.end.offset, ctx.codeFeatures.verification, `__VLS_asFunctionalDirective(`, ...generateIdentifier(ctx, prop), `)(null!, { ...__VLS_directiveBindingRestFields, `, ...generateArg(options, ctx, prop), ...generateModifiers(options, ctx, prop), ...generateValue(options, ctx, prop), `}, null!, null!)`);\n        yield common_1.endOfLine;\n    }\n}\nfunction* generateIdentifier(ctx, prop) {\n    const rawName = 'v-' + prop.name;\n    yield* (0, common_1.wrapWith)(prop.loc.start.offset, prop.loc.start.offset + rawName.length, ctx.codeFeatures.verification, `__VLS_directives.`, ...(0, camelized_1.generateCamelized)(rawName, prop.loc.start.offset, {\n        ...ctx.codeFeatures.all,\n        verification: false,\n        completion: {\n            // fix https://github.com/vuejs/language-tools/issues/1905\n            isAdditional: true,\n        },\n        navigation: {\n            resolveRenameNewName: shared_1.camelize,\n            resolveRenameEditText: getPropRenameApply(prop.name),\n        },\n    }));\n}\nfunction* generateArg(options, ctx, prop) {\n    const { arg } = prop;\n    if (arg?.type !== CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n        return;\n    }\n    const startOffset = arg.loc.start.offset + arg.loc.source.indexOf(arg.content);\n    yield* (0, common_1.wrapWith)(startOffset, startOffset + arg.content.length, ctx.codeFeatures.verification, 'arg');\n    yield ': ';\n    if (arg.isStatic) {\n        yield* (0, stringLiteralKey_1.generateStringLiteralKey)(arg.content, startOffset, ctx.codeFeatures.withoutHighlight);\n    }\n    else {\n        yield* (0, interpolation_1.generateInterpolation)(options, ctx, arg.content, arg.loc, startOffset, ctx.codeFeatures.all, '(', ')');\n    }\n    yield ', ';\n}\nfunction* generateModifiers(options, ctx, prop) {\n    if (options.vueCompilerOptions.target < 3.5) {\n        return;\n    }\n    yield 'modifiers: { ';\n    for (const mod of prop.modifiers) {\n        yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, mod.content, mod.loc.start.offset, ctx.codeFeatures.withoutHighlight);\n        yield ': true, ';\n    }\n    yield '}, ';\n}\nfunction* generateValue(options, ctx, prop) {\n    if (prop.exp?.type !== CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n        return;\n    }\n    yield* (0, common_1.wrapWith)(prop.exp.loc.start.offset, prop.exp.loc.end.offset, ctx.codeFeatures.verification, 'value');\n    yield ': ';\n    yield* (0, common_1.wrapWith)(prop.exp.loc.start.offset, prop.exp.loc.end.offset, ctx.codeFeatures.verification, ...(0, interpolation_1.generateInterpolation)(options, ctx, prop.exp.content, prop.exp.loc, prop.exp.loc.start.offset, ctx.codeFeatures.all, '(', ')'));\n}\nfunction getPropRenameApply(oldName) {\n    return oldName === (0, shared_2.hyphenateAttr)(oldName) ? shared_2.hyphenateAttr : undefined;\n}\n//# sourceMappingURL=elementDirectives.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generatePropertyAccess = generatePropertyAccess;\nconst common_1 = require(\"../common\");\nconst interpolation_1 = require(\"./interpolation\");\nconst stringLiteralKey_1 = require(\"./stringLiteralKey\");\nfunction* generatePropertyAccess(options, ctx, code, offset, features, astHolder) {\n    if (!options.compilerOptions.noPropertyAccessFromIndexSignature && common_1.variableNameRegex.test(code)) {\n        yield `.`;\n        yield offset !== undefined && features\n            ? [code, 'template', offset, features]\n            : code;\n    }\n    else if (code.startsWith('[') && code.endsWith(']')) {\n        yield* (0, interpolation_1.generateInterpolation)(options, ctx, code, astHolder, offset, features, '', '');\n    }\n    else {\n        yield `[`;\n        yield* (0, stringLiteralKey_1.generateStringLiteralKey)(code, offset, features);\n        yield `]`;\n    }\n}\n//# sourceMappingURL=propertyAccess.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateComponent = generateComponent;\nexports.generateElement = generateElement;\nexports.getCanonicalComponentName = getCanonicalComponentName;\nexports.getPossibleOriginalComponentNames = getPossibleOriginalComponentNames;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst shared_1 = require(\"@vue/shared\");\nconst shared_2 = require(\"../../utils/shared\");\nconst common_1 = require(\"../common\");\nconst camelized_1 = require(\"./camelized\");\nconst elementChildren_1 = require(\"./elementChildren\");\nconst elementDirectives_1 = require(\"./elementDirectives\");\nconst elementEvents_1 = require(\"./elementEvents\");\nconst elementProps_1 = require(\"./elementProps\");\nconst interpolation_1 = require(\"./interpolation\");\nconst propertyAccess_1 = require(\"./propertyAccess\");\nconst templateChild_1 = require(\"./templateChild\");\nconst objectProperty_1 = require(\"./objectProperty\");\nconst inlayHints_1 = require(\"../inlayHints\");\nconst scriptSetupRanges_1 = require(\"../../parsers/scriptSetupRanges\");\nconst colonReg = /:/g;\nfunction* generateComponent(options, ctx, node, currentComponent) {\n    const startTagOffset = node.loc.start.offset + options.template.content.substring(node.loc.start.offset).indexOf(node.tag);\n    const endTagOffset = !node.isSelfClosing && options.template.lang === 'html' ? node.loc.start.offset + node.loc.source.lastIndexOf(node.tag) : undefined;\n    const tagOffsets = endTagOffset !== undefined && endTagOffset > startTagOffset\n        ? [startTagOffset, endTagOffset]\n        : [startTagOffset];\n    const propsFailedExps = [];\n    const possibleOriginalNames = getPossibleOriginalComponentNames(node.tag, true);\n    const matchImportName = possibleOriginalNames.find(name => options.scriptSetupImportComponentNames.has(name));\n    const var_originalComponent = matchImportName ?? ctx.getInternalVariable();\n    const var_functionalComponent = ctx.getInternalVariable();\n    const var_componentInstance = ctx.getInternalVariable();\n    const var_componentEmit = ctx.getInternalVariable();\n    const var_componentEvents = ctx.getInternalVariable();\n    const var_defineComponentCtx = ctx.getInternalVariable();\n    const isComponentTag = node.tag.toLowerCase() === 'component';\n    let props = node.props;\n    let dynamicTagInfo;\n    if (isComponentTag) {\n        for (const prop of node.props) {\n            if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n                && prop.name === 'bind'\n                && prop.arg?.loc.source === 'is'\n                && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                if (prop.arg.loc.end.offset === prop.exp.loc.end.offset) {\n                    ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(prop.exp.loc, 'is'));\n                }\n                dynamicTagInfo = {\n                    tag: prop.exp.content,\n                    offsets: [prop.exp.loc.start.offset, undefined],\n                    astHolder: prop.exp.loc,\n                };\n                props = props.filter(p => p !== prop);\n                break;\n            }\n        }\n    }\n    else if (node.tag.includes('.')) {\n        // namespace tag\n        dynamicTagInfo = {\n            tag: node.tag,\n            offsets: [startTagOffset, endTagOffset],\n            astHolder: node.loc,\n        };\n    }\n    if (matchImportName) {\n        // hover, renaming / find references support\n        yield `// @ts-ignore${common_1.newLine}`; // #2304\n        yield `[`;\n        for (const tagOffset of tagOffsets) {\n            if (var_originalComponent === node.tag) {\n                yield [\n                    var_originalComponent,\n                    'template',\n                    tagOffset,\n                    ctx.codeFeatures.withoutHighlightAndCompletion,\n                ];\n            }\n            else {\n                yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(node.tag), tagOffset, {\n                    ...ctx.codeFeatures.withoutHighlightAndCompletion,\n                    navigation: {\n                        resolveRenameNewName: camelizeComponentName,\n                        resolveRenameEditText: getTagRenameApply(node.tag),\n                    },\n                });\n            }\n            yield `,`;\n        }\n        yield `]${common_1.endOfLine}`;\n    }\n    else if (dynamicTagInfo) {\n        yield `const ${var_originalComponent} = (`;\n        yield* (0, interpolation_1.generateInterpolation)(options, ctx, dynamicTagInfo.tag, dynamicTagInfo.astHolder, dynamicTagInfo.offsets[0], ctx.codeFeatures.all, '(', ')');\n        if (dynamicTagInfo.offsets[1] !== undefined) {\n            yield `,`;\n            yield* (0, interpolation_1.generateInterpolation)(options, ctx, dynamicTagInfo.tag, dynamicTagInfo.astHolder, dynamicTagInfo.offsets[1], {\n                ...ctx.codeFeatures.all,\n                completion: false,\n            }, '(', ')');\n        }\n        yield `)${common_1.endOfLine}`;\n    }\n    else if (!isComponentTag) {\n        yield `const ${var_originalComponent} = __VLS_resolvedLocalAndGlobalComponents.`;\n        yield* generateCanonicalComponentName(node.tag, startTagOffset, {\n            // with hover support\n            ...ctx.codeFeatures.withoutHighlightAndCompletionAndNavigation,\n            ...ctx.codeFeatures.verification,\n        });\n        yield `${common_1.endOfLine}`;\n        const camelizedTag = (0, shared_1.camelize)(node.tag);\n        if (common_1.variableNameRegex.test(camelizedTag)) {\n            // renaming / find references support\n            yield `/** @type { [`;\n            for (const tagOffset of tagOffsets) {\n                for (const shouldCapitalize of (node.tag[0] === node.tag[0].toUpperCase() ? [false] : [true, false])) {\n                    const expectName = shouldCapitalize ? (0, shared_1.capitalize)(camelizedTag) : camelizedTag;\n                    yield `typeof __VLS_components.`;\n                    yield* (0, camelized_1.generateCamelized)(shouldCapitalize ? (0, shared_1.capitalize)(node.tag) : node.tag, tagOffset, {\n                        navigation: {\n                            resolveRenameNewName: node.tag !== expectName ? camelizeComponentName : undefined,\n                            resolveRenameEditText: getTagRenameApply(node.tag),\n                        },\n                    });\n                    yield `, `;\n                }\n            }\n            yield `] } */${common_1.newLine}`;\n            // auto import support\n            if (options.edited) {\n                yield `// @ts-ignore${common_1.newLine}`; // #2304\n                yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(node.tag), startTagOffset, {\n                    completion: {\n                        isAdditional: true,\n                        onlyImport: true,\n                    },\n                });\n                yield `${common_1.endOfLine}`;\n            }\n        }\n    }\n    else {\n        yield `const ${var_originalComponent} = {} as any${common_1.endOfLine}`;\n    }\n    yield `// @ts-ignore${common_1.newLine}`;\n    yield `const ${var_functionalComponent} = __VLS_asFunctionalComponent(${var_originalComponent}, new ${var_originalComponent}({`;\n    yield* (0, elementProps_1.generateElementProps)(options, ctx, node, props, false);\n    yield `}))${common_1.endOfLine}`;\n    yield `const ${var_componentInstance} = ${var_functionalComponent}(`;\n    yield* (0, common_1.wrapWith)(startTagOffset, startTagOffset + node.tag.length, ctx.codeFeatures.verification, `{`, ...(0, elementProps_1.generateElementProps)(options, ctx, node, props, true, propsFailedExps), `}`);\n    yield `, ...__VLS_functionalComponentArgsRest(${var_functionalComponent}))${common_1.endOfLine}`;\n    currentComponent = node;\n    for (const failedExp of propsFailedExps) {\n        yield* (0, interpolation_1.generateInterpolation)(options, ctx, failedExp.node.loc.source, failedExp.node.loc, failedExp.node.loc.start.offset, ctx.codeFeatures.all, failedExp.prefix, failedExp.suffix);\n        yield common_1.endOfLine;\n    }\n    const [refName, offset] = yield* generateVScope(options, ctx, node, props);\n    const isRootNode = node === ctx.singleRootNode;\n    if (refName || isRootNode) {\n        const varName = ctx.getInternalVariable();\n        ctx.usedComponentCtxVars.add(var_defineComponentCtx);\n        yield `var ${varName} = {} as (Parameters<NonNullable<typeof ${var_defineComponentCtx}['expose']>>[0] | null)`;\n        if (node.codegenNode?.type === CompilerDOM.NodeTypes.VNODE_CALL\n            && node.codegenNode.props?.type === CompilerDOM.NodeTypes.JS_OBJECT_EXPRESSION\n            && node.codegenNode.props.properties.some(({ key }) => key.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && key.content === 'ref_for')) {\n            yield `[]`;\n        }\n        yield `${common_1.endOfLine}`;\n        if (refName) {\n            ctx.templateRefs.set(refName, [varName, offset]);\n        }\n        if (isRootNode) {\n            ctx.singleRootElType = `NonNullable<typeof ${varName}>['$el']`;\n        }\n    }\n    const usedComponentEventsVar = yield* (0, elementEvents_1.generateElementEvents)(options, ctx, node, var_functionalComponent, var_componentInstance, var_componentEmit, var_componentEvents);\n    if (usedComponentEventsVar) {\n        ctx.usedComponentCtxVars.add(var_defineComponentCtx);\n        yield `let ${var_componentEmit}!: typeof ${var_defineComponentCtx}.emit${common_1.endOfLine}`;\n        yield `let ${var_componentEvents}!: __VLS_NormalizeEmits<typeof ${var_componentEmit}>${common_1.endOfLine}`;\n    }\n    if (options.vueCompilerOptions.fallthroughAttributes\n        && (node.props.some(prop => prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === 'bind' && prop.exp?.loc.source === '$attrs')\n            || node === ctx.singleRootNode)) {\n        const varAttrs = ctx.getInternalVariable();\n        ctx.inheritedAttrVars.add(varAttrs);\n        yield `var ${varAttrs}!: Parameters<typeof ${var_functionalComponent}>[0];\\n`;\n    }\n    const slotDir = node.props.find(p => p.type === CompilerDOM.NodeTypes.DIRECTIVE && p.name === 'slot');\n    if (slotDir) {\n        yield* generateComponentSlot(options, ctx, node, slotDir, currentComponent, var_defineComponentCtx);\n    }\n    else {\n        yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node, currentComponent, var_defineComponentCtx);\n    }\n    if (ctx.usedComponentCtxVars.has(var_defineComponentCtx)) {\n        yield `var ${var_defineComponentCtx}!: __VLS_PickFunctionalComponentCtx<typeof ${var_originalComponent}, typeof ${var_componentInstance}>${common_1.endOfLine}`;\n    }\n}\nfunction* generateElement(options, ctx, node, currentComponent, componentCtxVar, isVForChild) {\n    const startTagOffset = node.loc.start.offset + options.template.content.substring(node.loc.start.offset).indexOf(node.tag);\n    const endTagOffset = !node.isSelfClosing && options.template.lang === 'html'\n        ? node.loc.start.offset + node.loc.source.lastIndexOf(node.tag)\n        : undefined;\n    const propsFailedExps = [];\n    yield `__VLS_elementAsFunction(__VLS_intrinsicElements`;\n    yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, node.tag, startTagOffset, ctx.codeFeatures.withoutHighlightAndCompletion);\n    if (endTagOffset !== undefined) {\n        yield `, __VLS_intrinsicElements`;\n        yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, node.tag, endTagOffset, ctx.codeFeatures.withoutHighlightAndCompletion);\n    }\n    yield `)(`;\n    yield* (0, common_1.wrapWith)(startTagOffset, startTagOffset + node.tag.length, ctx.codeFeatures.verification, `{`, ...(0, elementProps_1.generateElementProps)(options, ctx, node, node.props, true, propsFailedExps), `}`);\n    yield `)${common_1.endOfLine}`;\n    for (const failedExp of propsFailedExps) {\n        yield* (0, interpolation_1.generateInterpolation)(options, ctx, failedExp.node.loc.source, failedExp.node.loc, failedExp.node.loc.start.offset, ctx.codeFeatures.all, failedExp.prefix, failedExp.suffix);\n        yield common_1.endOfLine;\n    }\n    const [refName, offset] = yield* generateVScope(options, ctx, node, node.props);\n    if (refName) {\n        let refValue = `__VLS_nativeElements['${node.tag}']`;\n        if (isVForChild) {\n            refValue = `[${refValue}]`;\n        }\n        ctx.templateRefs.set(refName, [refValue, offset]);\n    }\n    if (ctx.singleRootNode === node) {\n        ctx.singleRootElType = `typeof __VLS_nativeElements['${node.tag}']`;\n    }\n    const slotDir = node.props.find(p => p.type === CompilerDOM.NodeTypes.DIRECTIVE && p.name === 'slot');\n    if (slotDir && componentCtxVar) {\n        yield* generateComponentSlot(options, ctx, node, slotDir, currentComponent, componentCtxVar);\n    }\n    else {\n        yield* (0, elementChildren_1.generateElementChildren)(options, ctx, node, currentComponent, componentCtxVar);\n    }\n    if (options.vueCompilerOptions.fallthroughAttributes\n        && (node.props.some(prop => prop.type === CompilerDOM.NodeTypes.DIRECTIVE && prop.name === 'bind' && prop.exp?.loc.source === '$attrs')\n            || node === ctx.singleRootNode)) {\n        ctx.inheritedAttrVars.add(`__VLS_intrinsicElements.${node.tag}`);\n    }\n}\nfunction* generateVScope(options, ctx, node, props) {\n    const vScope = props.find(prop => prop.type === CompilerDOM.NodeTypes.DIRECTIVE && (prop.name === 'scope' || prop.name === 'data'));\n    let inScope = false;\n    let originalConditionsNum = ctx.blockConditions.length;\n    if (vScope?.type === CompilerDOM.NodeTypes.DIRECTIVE && vScope.exp) {\n        const scopeVar = ctx.getInternalVariable();\n        const condition = `__VLS_withScope(__VLS_ctx, ${scopeVar})`;\n        yield `const ${scopeVar} = `;\n        yield [\n            vScope.exp.loc.source,\n            'template',\n            vScope.exp.loc.start.offset,\n            ctx.codeFeatures.all,\n        ];\n        yield common_1.endOfLine;\n        yield `if (${condition}) {${common_1.newLine}`;\n        ctx.blockConditions.push(condition);\n        inScope = true;\n    }\n    yield* (0, elementDirectives_1.generateElementDirectives)(options, ctx, node);\n    const [refName, offset] = yield* generateReferencesForElements(options, ctx, node); // <el ref=\"foo\" />\n    yield* generateReferencesForScopedCssClasses(options, ctx, node);\n    if (inScope) {\n        yield `}${common_1.newLine}`;\n        ctx.blockConditions.length = originalConditionsNum;\n    }\n    return [refName, offset];\n}\nfunction getCanonicalComponentName(tagText) {\n    return common_1.variableNameRegex.test(tagText)\n        ? tagText\n        : (0, shared_1.capitalize)((0, shared_1.camelize)(tagText.replace(colonReg, '-')));\n}\nfunction getPossibleOriginalComponentNames(tagText, deduplicate) {\n    const name1 = (0, shared_1.capitalize)((0, shared_1.camelize)(tagText));\n    const name2 = (0, shared_1.camelize)(tagText);\n    const name3 = tagText;\n    const names = [name1];\n    if (!deduplicate || name2 !== name1) {\n        names.push(name2);\n    }\n    if (!deduplicate || name3 !== name2) {\n        names.push(name3);\n    }\n    return names;\n}\nfunction* generateCanonicalComponentName(tagText, offset, features) {\n    if (common_1.variableNameRegex.test(tagText)) {\n        yield [tagText, 'template', offset, features];\n    }\n    else {\n        yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(tagText.replace(colonReg, '-')), offset, features);\n    }\n}\nfunction* generateComponentSlot(options, ctx, node, slotDir, currentComponent, componentCtxVar) {\n    yield `{${common_1.newLine}`;\n    ctx.usedComponentCtxVars.add(componentCtxVar);\n    if (currentComponent) {\n        ctx.hasSlotElements.add(currentComponent);\n    }\n    const slotBlockVars = [];\n    yield `const {`;\n    if (slotDir?.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && slotDir.arg.content) {\n        yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, slotDir.arg.loc.source, slotDir.arg.loc.start.offset, slotDir.arg.isStatic ? ctx.codeFeatures.withoutHighlight : ctx.codeFeatures.all, slotDir.arg.loc, false, true);\n        yield ': __VLS_thisSlot';\n    }\n    else {\n        yield `default: `;\n        yield* (0, common_1.wrapWith)(slotDir.loc.start.offset, slotDir.loc.start.offset + (slotDir.loc.source.startsWith('#')\n            ? '#'.length\n            : slotDir.loc.source.startsWith('v-slot:')\n                ? 'v-slot:'.length\n                : 0), ctx.codeFeatures.withoutHighlightAndCompletion, `__VLS_thisSlot`);\n    }\n    yield `} = __VLS_nonNullable(${componentCtxVar}.slots)${common_1.endOfLine}`;\n    if (slotDir?.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n        const slotAst = (0, common_1.createTsAst)(options.ts, slotDir, `(${slotDir.exp.content}) => {}`);\n        (0, common_1.collectVars)(options.ts, slotAst, slotAst, slotBlockVars);\n        if (!slotDir.exp.content.includes(':')) {\n            yield `const [`;\n            yield [\n                slotDir.exp.content,\n                'template',\n                slotDir.exp.loc.start.offset,\n                ctx.codeFeatures.all,\n            ];\n            yield `] = __VLS_getSlotParams(__VLS_thisSlot)${common_1.endOfLine}`;\n        }\n        else {\n            yield `const `;\n            yield [\n                slotDir.exp.content,\n                'template',\n                slotDir.exp.loc.start.offset,\n                ctx.codeFeatures.all,\n            ];\n            yield ` = __VLS_getSlotParam(__VLS_thisSlot)${common_1.endOfLine}`;\n        }\n    }\n    for (const varName of slotBlockVars) {\n        ctx.addLocalVariable(varName);\n    }\n    yield* ctx.resetDirectiveComments('end of slot children start');\n    let prev;\n    for (const childNode of node.children) {\n        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, childNode, currentComponent, prev, componentCtxVar);\n        prev = childNode;\n    }\n    for (const varName of slotBlockVars) {\n        ctx.removeLocalVariable(varName);\n    }\n    let isStatic = true;\n    if (slotDir?.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n        isStatic = slotDir.arg.isStatic;\n    }\n    if (isStatic && slotDir && !slotDir.arg) {\n        yield `__VLS_nonNullable(${componentCtxVar}.slots)['`;\n        yield [\n            '',\n            'template',\n            slotDir.loc.start.offset + (slotDir.loc.source.startsWith('#')\n                ? '#'.length : slotDir.loc.source.startsWith('v-slot:')\n                ? 'v-slot:'.length\n                : 0),\n            ctx.codeFeatures.completion,\n        ];\n        yield `'/* empty slot name completion */]${common_1.newLine}`;\n    }\n    yield* ctx.generateAutoImportCompletion();\n    yield `}${common_1.newLine}`;\n}\nfunction* generateReferencesForElements(options, ctx, node) {\n    for (const prop of node.props) {\n        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE\n            && prop.name === 'ref'\n            && prop.value) {\n            const [content, startOffset] = normalizeAttributeValue(prop.value);\n            yield `// @ts-ignore navigation for \\`const ${content} = ref()\\`${common_1.newLine}`;\n            yield `__VLS_ctx`;\n            yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, content, startOffset, ctx.codeFeatures.navigation, prop.value.loc);\n            yield common_1.endOfLine;\n            if (common_1.variableNameRegex.test(content)) {\n                ctx.accessExternalVariable(content, startOffset);\n            }\n            return [content, startOffset];\n        }\n    }\n    return [];\n}\nfunction* generateReferencesForScopedCssClasses(options, ctx, node) {\n    for (const prop of node.props) {\n        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE\n            && prop.name === 'class'\n            && prop.value) {\n            if (options.template.lang === 'pug') {\n                const getClassOffset = Reflect.get(prop.value.loc.start, 'getClassOffset');\n                const content = prop.value.loc.source.slice(1, -1);\n                let startOffset = 1;\n                for (const className of content.split(' ')) {\n                    if (className) {\n                        ctx.scopedClasses.push({\n                            source: 'template',\n                            className,\n                            offset: getClassOffset(startOffset),\n                        });\n                    }\n                    startOffset += className.length + 1;\n                }\n            }\n            else {\n                let isWrapped = false;\n                const [content, startOffset] = normalizeAttributeValue(prop.value);\n                if (content) {\n                    const classes = collectClasses(content, startOffset + (isWrapped ? 1 : 0));\n                    ctx.scopedClasses.push(...classes);\n                }\n                else {\n                    ctx.emptyClassOffsets.push(startOffset);\n                }\n            }\n        }\n        else if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n            && prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n            && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n            && prop.arg.content === 'class') {\n            const content = '`${' + prop.exp.content + '}`';\n            const startOffset = prop.exp.loc.start.offset - 3;\n            const { ts } = options;\n            const ast = ts.createSourceFile('', content, 99);\n            const literals = [];\n            ts.forEachChild(ast, node => {\n                if (!ts.isExpressionStatement(node) ||\n                    !isTemplateExpression(node.expression)) {\n                    return;\n                }\n                const expression = node.expression.templateSpans[0].expression;\n                if (ts.isStringLiteralLike(expression)) {\n                    literals.push(expression);\n                }\n                if (ts.isArrayLiteralExpression(expression)) {\n                    walkArrayLiteral(expression);\n                }\n                if (ts.isObjectLiteralExpression(expression)) {\n                    walkObjectLiteral(expression);\n                }\n            });\n            for (const literal of literals) {\n                const classes = collectClasses(literal.text, literal.end - literal.text.length - 1 + startOffset);\n                ctx.scopedClasses.push(...classes);\n            }\n            function walkArrayLiteral(node) {\n                const { elements } = node;\n                for (const element of elements) {\n                    if (ts.isStringLiteralLike(element)) {\n                        literals.push(element);\n                    }\n                    else if (ts.isObjectLiteralExpression(element)) {\n                        walkObjectLiteral(element);\n                    }\n                }\n            }\n            function walkObjectLiteral(node) {\n                const { properties } = node;\n                for (const property of properties) {\n                    if (ts.isPropertyAssignment(property)) {\n                        const { name } = property;\n                        if (ts.isIdentifier(name)) {\n                            walkIdentifier(name);\n                        }\n                        else if (ts.isStringLiteral(name)) {\n                            literals.push(name);\n                        }\n                        else if (ts.isComputedPropertyName(name)) {\n                            const { expression } = name;\n                            if (ts.isStringLiteralLike(expression)) {\n                                literals.push(expression);\n                            }\n                        }\n                    }\n                    else if (ts.isShorthandPropertyAssignment(property)) {\n                        walkIdentifier(property.name);\n                    }\n                }\n            }\n            function walkIdentifier(node) {\n                const text = (0, scriptSetupRanges_1.getNodeText)(ts, node, ast);\n                ctx.scopedClasses.push({\n                    source: 'template',\n                    className: text,\n                    offset: node.end - text.length + startOffset\n                });\n            }\n        }\n    }\n}\nfunction camelizeComponentName(newName) {\n    return (0, shared_1.camelize)('-' + newName);\n}\nfunction getTagRenameApply(oldName) {\n    return oldName === (0, shared_2.hyphenateTag)(oldName) ? shared_2.hyphenateTag : undefined;\n}\nfunction normalizeAttributeValue(node) {\n    let offset = node.loc.start.offset;\n    let content = node.loc.source;\n    if ((content.startsWith(`'`) && content.endsWith(`'`))\n        || (content.startsWith(`\"`) && content.endsWith(`\"`))) {\n        offset++;\n        content = content.slice(1, -1);\n    }\n    return [content, offset];\n}\nfunction collectClasses(content, startOffset = 0) {\n    const classes = [];\n    let currentClassName = '';\n    let offset = 0;\n    for (const char of (content + ' ')) {\n        if (char.trim() === '') {\n            if (currentClassName !== '') {\n                classes.push({\n                    source: 'template',\n                    className: currentClassName,\n                    offset: offset + startOffset\n                });\n                offset += currentClassName.length;\n                currentClassName = '';\n            }\n            offset += char.length;\n        }\n        else {\n            currentClassName += char;\n        }\n    }\n    return classes;\n}\n// isTemplateExpression is missing in tsc\nfunction isTemplateExpression(node) {\n    return node.kind === 228;\n}\n//# sourceMappingURL=element.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateStyleScopedClasses = generateStyleScopedClasses;\nconst common_1 = require(\"../common\");\nfunction* generateStyleScopedClasses(ctx, withDot = false) {\n    for (const offset of ctx.emptyClassOffsets) {\n        yield `__VLS_styleScopedClasses['`;\n        yield [\n            '',\n            'template',\n            offset,\n            ctx.codeFeatures.additionalCompletion,\n        ];\n        yield `']${common_1.endOfLine}`;\n    }\n    for (const { source, className, offset } of ctx.scopedClasses) {\n        yield `__VLS_styleScopedClasses[`;\n        yield [\n            '',\n            source,\n            offset - (withDot ? 1 : 0),\n            ctx.codeFeatures.navigation,\n        ];\n        yield `'`;\n        // fix https://github.com/vuejs/language-tools/issues/4537\n        yield* escapeString(source, className, offset, ['\\\\', '\\'']);\n        yield `'`;\n        yield [\n            '',\n            source,\n            offset + className.length,\n            ctx.codeFeatures.navigationWithoutRename,\n        ];\n        yield `]${common_1.endOfLine}`;\n    }\n    yield common_1.newLine;\n    function* escapeString(source, className, offset, escapeTargets) {\n        let count = 0;\n        const currentEscapeTargets = [...escapeTargets];\n        const firstEscapeTarget = currentEscapeTargets.shift();\n        const splitted = className.split(firstEscapeTarget);\n        for (let i = 0; i < splitted.length; i++) {\n            const part = splitted[i];\n            const partLength = part.length;\n            if (escapeTargets.length > 0) {\n                yield* escapeString(source, part, offset + count, [...currentEscapeTargets]);\n            }\n            else {\n                yield [\n                    part,\n                    source,\n                    offset + count,\n                    ctx.codeFeatures.navigationAndAdditionalCompletion,\n                ];\n            }\n            if (i !== splitted.length - 1) {\n                yield '\\\\';\n                yield [\n                    firstEscapeTarget,\n                    source,\n                    offset + count + partLength,\n                    ctx.codeFeatures.navigationAndAdditionalCompletion,\n                ];\n                count += partLength + 1;\n            }\n            else {\n                count += partLength;\n            }\n        }\n    }\n}\n//# sourceMappingURL=styleScopedClasses.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateTemplate = generateTemplate;\nexports.forEachElementNode = forEachElementNode;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst common_1 = require(\"../common\");\nconst context_1 = require(\"./context\");\nconst element_1 = require(\"./element\");\nconst objectProperty_1 = require(\"./objectProperty\");\nconst stringLiteralKey_1 = require(\"./stringLiteralKey\");\nconst templateChild_1 = require(\"./templateChild\");\nconst styleScopedClasses_1 = require(\"./styleScopedClasses\");\nfunction* generateTemplate(options) {\n    const ctx = (0, context_1.createTemplateCodegenContext)(options);\n    if (options.slotsAssignName) {\n        ctx.addLocalVariable(options.slotsAssignName);\n    }\n    if (options.propsAssignName) {\n        ctx.addLocalVariable(options.propsAssignName);\n    }\n    ctx.addLocalVariable('$el');\n    ctx.addLocalVariable('$refs');\n    yield* generatePreResolveComponents(options);\n    if (options.template.ast) {\n        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, options.template.ast, undefined, undefined, undefined);\n    }\n    yield* (0, styleScopedClasses_1.generateStyleScopedClasses)(ctx);\n    if (!options.hasDefineSlots) {\n        yield `var __VLS_slots!:`;\n        yield* generateSlotsType(options, ctx);\n        yield common_1.endOfLine;\n    }\n    yield* ctx.generateAutoImportCompletion();\n    yield* generateInheritedAttrs(ctx);\n    yield* generateRefs(ctx);\n    yield* generateRootEl(ctx);\n    return ctx;\n}\nfunction* generateSlotsType(options, ctx) {\n    for (const { expVar, varName } of ctx.dynamicSlots) {\n        ctx.hasSlot = true;\n        yield `Partial<Record<NonNullable<typeof ${expVar}>, (_: typeof ${varName}) => any>> &${common_1.newLine}`;\n    }\n    yield `{${common_1.newLine}`;\n    for (const slot of ctx.slots) {\n        ctx.hasSlot = true;\n        if (slot.name && slot.loc !== undefined) {\n            yield* (0, objectProperty_1.generateObjectProperty)(options, ctx, slot.name, slot.loc, ctx.codeFeatures.withoutHighlightAndCompletion, slot.nodeLoc);\n        }\n        else {\n            yield* (0, common_1.wrapWith)(slot.tagRange[0], slot.tagRange[1], ctx.codeFeatures.withoutHighlightAndCompletion, `default`);\n        }\n        yield `?(_: typeof ${slot.varName}): any,${common_1.newLine}`;\n    }\n    yield `}`;\n}\nfunction* generateInheritedAttrs(ctx) {\n    yield 'var __VLS_inheritedAttrs!: {}';\n    for (const varName of ctx.inheritedAttrVars) {\n        yield ` & typeof ${varName}`;\n    }\n    yield common_1.endOfLine;\n}\nfunction* generateRefs(ctx) {\n    yield `const __VLS_refs = {${common_1.newLine}`;\n    for (const [name, [varName, offset]] of ctx.templateRefs) {\n        yield* (0, stringLiteralKey_1.generateStringLiteralKey)(name, offset, ctx.codeFeatures.navigationAndCompletion);\n        yield `: ${varName},${common_1.newLine}`;\n    }\n    yield `}${common_1.endOfLine}`;\n    yield `var $refs!: typeof __VLS_refs${common_1.endOfLine}`;\n}\nfunction* generateRootEl(ctx) {\n    if (ctx.singleRootElType) {\n        yield `var $el!: ${ctx.singleRootElType}${common_1.endOfLine}`;\n    }\n    else {\n        yield `var $el!: any${common_1.endOfLine}`;\n    }\n}\nfunction* generatePreResolveComponents(options) {\n    yield `let __VLS_resolvedLocalAndGlobalComponents!: Required<{}`;\n    if (options.template.ast) {\n        const components = new Set();\n        for (const node of forEachElementNode(options.template.ast)) {\n            if (node.tagType === CompilerDOM.ElementTypes.COMPONENT\n                && node.tag.toLowerCase() !== 'component'\n                && !node.tag.includes('.') // namespace tag \n            ) {\n                if (components.has(node.tag)) {\n                    continue;\n                }\n                components.add(node.tag);\n                yield common_1.newLine;\n                yield ` & __VLS_WithComponent<'${(0, element_1.getCanonicalComponentName)(node.tag)}', typeof __VLS_localComponents, `;\n                yield (0, element_1.getPossibleOriginalComponentNames)(node.tag, false)\n                    .map(name => `\"${name}\"`)\n                    .join(', ');\n                yield `>`;\n            }\n        }\n    }\n    yield `>${common_1.endOfLine}`;\n}\nfunction* forEachElementNode(node) {\n    if (node.type === CompilerDOM.NodeTypes.ROOT) {\n        for (const child of node.children) {\n            yield* forEachElementNode(child);\n        }\n    }\n    else if (node.type === CompilerDOM.NodeTypes.ELEMENT) {\n        const patchForNode = (0, templateChild_1.getVForNode)(node);\n        if (patchForNode) {\n            yield* forEachElementNode(patchForNode);\n        }\n        else {\n            yield node;\n            for (const child of node.children) {\n                yield* forEachElementNode(child);\n            }\n        }\n    }\n    else if (node.type === CompilerDOM.NodeTypes.IF) {\n        // v-if / v-else-if / v-else\n        for (let i = 0; i < node.branches.length; i++) {\n            const branch = node.branches[i];\n            for (const childNode of branch.children) {\n                yield* forEachElementNode(childNode);\n            }\n        }\n    }\n    else if (node.type === CompilerDOM.NodeTypes.FOR) {\n        // v-for\n        for (const child of node.children) {\n            yield* forEachElementNode(child);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.binarySearch = binarySearch;\nfunction binarySearch(values, searchValue) {\n    let low = 0;\n    let high = values.length - 1;\n    let match;\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const midValue = values[mid];\n        if (midValue < searchValue) {\n            low = mid + 1;\n        }\n        else if (midValue > searchValue) {\n            high = mid - 1;\n        }\n        else {\n            low = mid;\n            high = mid;\n            match = mid;\n            break;\n        }\n    }\n    const finalLow = Math.max(Math.min(low, high, values.length - 1), 0);\n    const finalHigh = Math.min(Math.max(low, high, 0), values.length - 1);\n    return { low: finalLow, high: finalHigh, match };\n}\n//# sourceMappingURL=binarySearch.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.translateOffset = translateOffset;\nlet warned = false;\nfunction translateOffset(start, fromOffsets, toOffsets, fromLengths, toLengths = fromLengths) {\n    const isSorted = fromOffsets.every((value, index) => index === 0 || fromOffsets[index - 1] <= value);\n    if (!isSorted) {\n        for (let i = 0; i < fromOffsets.length; i++) {\n            const fromOffset = fromOffsets[i];\n            const fromLength = fromLengths[i];\n            if (start >= fromOffset && start <= fromOffset + fromLength) {\n                const toLength = toLengths[i];\n                const toOffset = toOffsets[i];\n                let rangeOffset = Math.min(start - fromOffset, toLength);\n                return toOffset + rangeOffset;\n            }\n        }\n        if (!warned) {\n            warned = true;\n            console.warn('fromOffsets should be sorted in ascending order');\n        }\n    }\n    let low = 0;\n    let high = fromOffsets.length - 1;\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const fromOffset = fromOffsets[mid];\n        const fromLength = fromLengths[mid];\n        if (start >= fromOffset && start <= fromOffset + fromLength) {\n            const toLength = toLengths[mid];\n            const toOffset = toOffsets[mid];\n            let rangeOffset = Math.min(start - fromOffset, toLength);\n            return toOffset + rangeOffset;\n        }\n        else if (start < fromOffset) {\n            high = mid - 1;\n        }\n        else {\n            low = mid + 1;\n        }\n    }\n}\n//# sourceMappingURL=translateOffset.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceMap = void 0;\nconst binarySearch_1 = require(\"./binarySearch\");\nconst translateOffset_1 = require(\"./translateOffset\");\nclass SourceMap {\n    constructor(mappings) {\n        this.mappings = mappings;\n    }\n    toSourceRange(generatedStart, generatedEnd, fallbackToAnyMatch, filter) {\n        return this.findMatchingStartEnd(generatedStart, generatedEnd, fallbackToAnyMatch, 'generatedOffsets', filter);\n    }\n    toGeneratedRange(sourceStart, sourceEnd, fallbackToAnyMatch, filter) {\n        return this.findMatchingStartEnd(sourceStart, sourceEnd, fallbackToAnyMatch, 'sourceOffsets', filter);\n    }\n    toSourceLocation(generatedOffset, filter) {\n        return this.findMatchingOffsets(generatedOffset, 'generatedOffsets', filter);\n    }\n    toGeneratedLocation(sourceOffset, filter) {\n        return this.findMatchingOffsets(sourceOffset, 'sourceOffsets', filter);\n    }\n    *findMatchingOffsets(offset, fromRange, filter) {\n        const memo = this.getMemoBasedOnRange(fromRange);\n        if (memo.offsets.length === 0) {\n            return;\n        }\n        const { low: start, high: end } = (0, binarySearch_1.binarySearch)(memo.offsets, offset);\n        const skip = new Set();\n        const toRange = fromRange == 'sourceOffsets' ? 'generatedOffsets' : 'sourceOffsets';\n        for (let i = start; i <= end; i++) {\n            for (const mapping of memo.mappings[i]) {\n                if (skip.has(mapping)) {\n                    continue;\n                }\n                skip.add(mapping);\n                if (filter && !filter(mapping.data)) {\n                    continue;\n                }\n                const mapped = (0, translateOffset_1.translateOffset)(offset, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));\n                if (mapped !== undefined) {\n                    yield [mapped, mapping];\n                }\n            }\n        }\n    }\n    *findMatchingStartEnd(start, end, fallbackToAnyMatch, fromRange, filter) {\n        const toRange = fromRange == 'sourceOffsets' ? 'generatedOffsets' : 'sourceOffsets';\n        const mappedStarts = [];\n        let hadMatch = false;\n        for (const [mappedStart, mapping] of this.findMatchingOffsets(start, fromRange)) {\n            if (filter && !filter(mapping.data)) {\n                continue;\n            }\n            mappedStarts.push([mappedStart, mapping]);\n            const mappedEnd = (0, translateOffset_1.translateOffset)(end, mapping[fromRange], mapping[toRange], getLengths(mapping, fromRange), getLengths(mapping, toRange));\n            if (mappedEnd !== undefined) {\n                hadMatch = true;\n                yield [mappedStart, mappedEnd, mapping, mapping];\n            }\n        }\n        if (!hadMatch && fallbackToAnyMatch) {\n            for (const [mappedStart, mappingStart] of mappedStarts) {\n                for (const [mappedEnd, mappingEnd] of this.findMatchingOffsets(end, fromRange)) {\n                    if (filter && !filter(mappingEnd.data) || mappedEnd < mappedStart) {\n                        continue;\n                    }\n                    yield [mappedStart, mappedEnd, mappingStart, mappingEnd];\n                    break;\n                }\n                ;\n            }\n        }\n    }\n    getMemoBasedOnRange(fromRange) {\n        return fromRange === 'sourceOffsets'\n            ? this.sourceCodeOffsetsMemo ??= this.createMemo('sourceOffsets')\n            : this.generatedCodeOffsetsMemo ??= this.createMemo('generatedOffsets');\n    }\n    createMemo(key) {\n        const offsetsSet = new Set();\n        for (const mapping of this.mappings) {\n            for (let i = 0; i < mapping[key].length; i++) {\n                offsetsSet.add(mapping[key][i]);\n                offsetsSet.add(mapping[key][i] + getLengths(mapping, key)[i]);\n            }\n        }\n        const offsets = [...offsetsSet].sort((a, b) => a - b);\n        const mappings = offsets.map(() => new Set());\n        for (const mapping of this.mappings) {\n            for (let i = 0; i < mapping[key].length; i++) {\n                const startIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i]).match;\n                const endIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i] + getLengths(mapping, key)[i]).match;\n                for (let i = startIndex; i <= endIndex; i++) {\n                    mappings[i].add(mapping);\n                }\n            }\n        }\n        return { offsets, mappings };\n    }\n}\nexports.SourceMap = SourceMap;\nfunction getLengths(mapping, key) {\n    return key == 'sourceOffsets' ? mapping.lengths : mapping.generatedLengths ?? mapping.lengths;\n}\n//# sourceMappingURL=sourceMap.js.map", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/sourceMap\"), exports);\n__exportStar(require(\"./lib/translateOffset\"), exports);\n//# sourceMappingURL=index.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHoverEnabled = isHoverEnabled;\nexports.isInlayHintsEnabled = isInlayHintsEnabled;\nexports.isCodeLensEnabled = isCodeLensEnabled;\nexports.isMonikerEnabled = isMonikerEnabled;\nexports.isInlineValueEnabled = isInlineValueEnabled;\nexports.isSemanticTokensEnabled = isSemanticTokensEnabled;\nexports.isCallHierarchyEnabled = isCallHierarchyEnabled;\nexports.isTypeHierarchyEnabled = isTypeHierarchyEnabled;\nexports.isRenameEnabled = isRenameEnabled;\nexports.isDefinitionEnabled = isDefinitionEnabled;\nexports.isTypeDefinitionEnabled = isTypeDefinitionEnabled;\nexports.isReferencesEnabled = isReferencesEnabled;\nexports.isImplementationEnabled = isImplementationEnabled;\nexports.isHighlightEnabled = isHighlightEnabled;\nexports.isSymbolsEnabled = isSymbolsEnabled;\nexports.isFoldingRangesEnabled = isFoldingRangesEnabled;\nexports.isSelectionRangesEnabled = isSelectionRangesEnabled;\nexports.isLinkedEditingEnabled = isLinkedEditingEnabled;\nexports.isColorEnabled = isColorEnabled;\nexports.isDocumentLinkEnabled = isDocumentLinkEnabled;\nexports.isDiagnosticsEnabled = isDiagnosticsEnabled;\nexports.isCodeActionsEnabled = isCodeActionsEnabled;\nexports.isFormattingEnabled = isFormattingEnabled;\nexports.isCompletionEnabled = isCompletionEnabled;\nexports.isAutoInsertEnabled = isAutoInsertEnabled;\nexports.isSignatureHelpEnabled = isSignatureHelpEnabled;\nexports.shouldReportDiagnostics = shouldReportDiagnostics;\nexports.resolveRenameNewName = resolveRenameNewName;\nexports.resolveRenameEditText = resolveRenameEditText;\nexports.findOverlapCodeRange = findOverlapCodeRange;\nfunction isHoverEnabled(info) {\n    return !!info.semantic;\n}\nfunction isInlayHintsEnabled(info) {\n    return !!info.semantic;\n}\nfunction isCodeLensEnabled(info) {\n    return !!info.semantic;\n}\nfunction isMonikerEnabled(info) {\n    return !!info.semantic;\n}\nfunction isInlineValueEnabled(info) {\n    return !!info.semantic;\n}\nfunction isSemanticTokensEnabled(info) {\n    return typeof info.semantic === 'object'\n        ? info.semantic.shouldHighlight?.() ?? true\n        : !!info.semantic;\n}\nfunction isCallHierarchyEnabled(info) {\n    return !!info.navigation;\n}\nfunction isTypeHierarchyEnabled(info) {\n    return !!info.navigation;\n}\nfunction isRenameEnabled(info) {\n    return typeof info.navigation === 'object'\n        ? info.navigation.shouldRename?.() ?? true\n        : !!info.navigation;\n}\nfunction isDefinitionEnabled(info) {\n    return !!info.navigation;\n}\nfunction isTypeDefinitionEnabled(info) {\n    return !!info.navigation;\n}\nfunction isReferencesEnabled(info) {\n    return !!info.navigation;\n}\nfunction isImplementationEnabled(info) {\n    return !!info.navigation;\n}\nfunction isHighlightEnabled(info) {\n    return typeof info.navigation === 'object'\n        ? info.navigation.shouldHighlight?.() ?? true\n        : !!info.navigation;\n}\nfunction isSymbolsEnabled(info) {\n    return !!info.structure;\n}\nfunction isFoldingRangesEnabled(info) {\n    return !!info.structure;\n}\nfunction isSelectionRangesEnabled(info) {\n    return !!info.structure;\n}\nfunction isLinkedEditingEnabled(info) {\n    return !!info.structure;\n}\nfunction isColorEnabled(info) {\n    return !!info.structure;\n}\nfunction isDocumentLinkEnabled(info) {\n    return !!info.structure;\n}\nfunction isDiagnosticsEnabled(info) {\n    return !!info.verification;\n}\nfunction isCodeActionsEnabled(info) {\n    return !!info.verification;\n}\nfunction isFormattingEnabled(info) {\n    return !!info.format;\n}\nfunction isCompletionEnabled(info) {\n    return !!info.completion;\n}\nfunction isAutoInsertEnabled(info) {\n    return !!info.completion;\n}\nfunction isSignatureHelpEnabled(info) {\n    return !!info.completion;\n}\n// should...\nfunction shouldReportDiagnostics(info, source, code) {\n    return typeof info.verification === 'object'\n        ? info.verification.shouldReport?.(source, code) ?? true\n        : !!info.verification;\n}\n//  resolve...\nfunction resolveRenameNewName(newName, info) {\n    return typeof info.navigation === 'object'\n        ? info.navigation.resolveRenameNewName?.(newName) ?? newName\n        : newName;\n}\nfunction resolveRenameEditText(text, info) {\n    return typeof info.navigation === 'object'\n        ? info.navigation.resolveRenameEditText?.(text) ?? text\n        : text;\n}\nfunction findOverlapCodeRange(start, end, map, filter) {\n    let mappedStart;\n    let mappedEnd;\n    for (const [mapped, mapping] of map.toGeneratedLocation(start)) {\n        if (filter(mapping.data)) {\n            mappedStart = mapped;\n            break;\n        }\n    }\n    for (const [mapped, mapping] of map.toGeneratedLocation(end)) {\n        if (filter(mapping.data)) {\n            mappedEnd = mapped;\n            break;\n        }\n    }\n    if (mappedStart === undefined || mappedEnd === undefined) {\n        for (const mapping of map.mappings) {\n            if (filter(mapping.data)) {\n                const mappingStart = mapping.sourceOffsets[0];\n                const mappingEnd = mapping.sourceOffsets[mapping.sourceOffsets.length - 1] + mapping.lengths[mapping.lengths.length - 1];\n                const overlap = getOverlapRange(start, end, mappingStart, mappingEnd);\n                if (overlap) {\n                    const curMappedStart = (overlap.start - mappingStart) + mapping.generatedOffsets[0];\n                    const lastGeneratedLength = (mapping.generatedLengths ?? mapping.lengths)[mapping.generatedOffsets.length - 1];\n                    const curMappedEndOffset = Math.min(overlap.end - mapping.sourceOffsets[mapping.sourceOffsets.length - 1], lastGeneratedLength);\n                    const curMappedEnd = mapping.generatedOffsets[mapping.generatedOffsets.length - 1] + curMappedEndOffset;\n                    mappedStart = mappedStart === undefined ? curMappedStart : Math.min(mappedStart, curMappedStart);\n                    mappedEnd = mappedEnd === undefined ? curMappedEnd : Math.max(mappedEnd, curMappedEnd);\n                }\n            }\n        }\n    }\n    if (mappedStart !== undefined && mappedEnd !== undefined) {\n        return {\n            start: mappedStart,\n            end: mappedEnd,\n        };\n    }\n}\nfunction getOverlapRange(range1Start, range1End, range2Start, range2End) {\n    const start = Math.max(range1Start, range2Start);\n    const end = Math.min(range1End, range2End);\n    if (start > end) {\n        return undefined;\n    }\n    return {\n        start,\n        end,\n    };\n}\n//# sourceMappingURL=editor.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedCodeMap = void 0;\nconst source_map_1 = require(\"@volar/source-map\");\nclass LinkedCodeMap extends source_map_1.SourceMap {\n    *getLinkedOffsets(start) {\n        for (const mapped of this.toGeneratedLocation(start)) {\n            yield mapped[0];\n        }\n        for (const mapped of this.toSourceLocation(start)) {\n            yield mapped[0];\n        }\n    }\n}\nexports.LinkedCodeMap = LinkedCodeMap;\n//# sourceMappingURL=linkedCodeMap.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileMap = void 0;\nclass FileMap extends Map {\n    constructor(caseSensitive) {\n        super();\n        this.caseSensitive = caseSensitive;\n        this.originalFileNames = new Map();\n    }\n    keys() {\n        return this.originalFileNames.values();\n    }\n    get(key) {\n        return super.get(this.normalizeId(key));\n    }\n    has(key) {\n        return super.has(this.normalizeId(key));\n    }\n    set(key, value) {\n        this.originalFileNames.set(this.normalizeId(key), key);\n        return super.set(this.normalizeId(key), value);\n    }\n    delete(key) {\n        this.originalFileNames.delete(this.normalizeId(key));\n        return super.delete(this.normalizeId(key));\n    }\n    clear() {\n        this.originalFileNames.clear();\n        return super.clear();\n    }\n    normalizeId(id) {\n        return this.caseSensitive ? id : id.toLowerCase();\n    }\n}\nexports.FileMap = FileMap;\n//# sourceMappingURL=utils.js.map", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultMapperFactory = exports.SourceMap = void 0;\nexports.createLanguage = createLanguage;\nexports.forEachEmbeddedCode = forEachEmbeddedCode;\nvar source_map_1 = require(\"@volar/source-map\");\nObject.defineProperty(exports, \"SourceMap\", { enumerable: true, get: function () { return source_map_1.SourceMap; } });\n__exportStar(require(\"./lib/editor\"), exports);\n__exportStar(require(\"./lib/linkedCodeMap\"), exports);\n__exportStar(require(\"./lib/types\"), exports);\n__exportStar(require(\"./lib/utils\"), exports);\nconst source_map_2 = require(\"@volar/source-map\");\nconst linkedCodeMap_1 = require(\"./lib/linkedCodeMap\");\nconst defaultMapperFactory = mappings => new source_map_2.SourceMap(mappings);\nexports.defaultMapperFactory = defaultMapperFactory;\nfunction createLanguage(plugins, scriptRegistry, sync, onAssociationDirty) {\n    const virtualCodeToSourceScriptMap = new WeakMap();\n    const virtualCodeToSourceMap = new WeakMap();\n    const virtualCodeToLinkedCodeMap = new WeakMap();\n    const language = {\n        mapperFactory: exports.defaultMapperFactory,\n        plugins,\n        scripts: {\n            fromVirtualCode(virtualCode) {\n                return virtualCodeToSourceScriptMap.get(virtualCode);\n            },\n            get(id, includeFsFiles = true, shouldRegister = false) {\n                sync(id, includeFsFiles, shouldRegister);\n                const result = scriptRegistry.get(id);\n                // The sync function provider may not always call the set function due to caching, so it is necessary to explicitly check isAssociationDirty.\n                if (result?.isAssociationDirty) {\n                    this.set(id, result.snapshot, result.languageId);\n                }\n                return scriptRegistry.get(id);\n            },\n            set(id, snapshot, languageId, _plugins = plugins) {\n                if (!languageId) {\n                    for (const plugin of plugins) {\n                        languageId = plugin.getLanguageId?.(id);\n                        if (languageId) {\n                            break;\n                        }\n                    }\n                }\n                if (!languageId) {\n                    console.warn(`languageId not found for ${id}`);\n                    return;\n                }\n                let associatedOnly = false;\n                for (const plugin of plugins) {\n                    if (plugin.isAssociatedFileOnly?.(id, languageId)) {\n                        associatedOnly = true;\n                        break;\n                    }\n                }\n                if (scriptRegistry.has(id)) {\n                    const sourceScript = scriptRegistry.get(id);\n                    if (sourceScript.languageId !== languageId || sourceScript.associatedOnly !== associatedOnly) {\n                        this.delete(id);\n                        triggerTargetsDirty(sourceScript);\n                        return this.set(id, snapshot, languageId);\n                    }\n                    else if (associatedOnly) {\n                        if (sourceScript.snapshot !== snapshot) {\n                            sourceScript.snapshot = snapshot;\n                            triggerTargetsDirty(sourceScript);\n                        }\n                    }\n                    else if (sourceScript.isAssociationDirty || sourceScript.snapshot !== snapshot) {\n                        if (sourceScript.snapshot !== snapshot) {\n                            sourceScript.snapshot = snapshot;\n                            triggerTargetsDirty(sourceScript);\n                        }\n                        const codegenCtx = prepareCreateVirtualCode(sourceScript);\n                        if (sourceScript.generated) {\n                            const { updateVirtualCode, createVirtualCode } = sourceScript.generated.languagePlugin;\n                            const newVirtualCode = updateVirtualCode\n                                ? updateVirtualCode(id, sourceScript.generated.root, snapshot, codegenCtx)\n                                : createVirtualCode?.(id, languageId, snapshot, codegenCtx);\n                            if (newVirtualCode) {\n                                sourceScript.generated.root = newVirtualCode;\n                                sourceScript.generated.embeddedCodes.clear();\n                                for (const code of forEachEmbeddedCode(sourceScript.generated.root)) {\n                                    virtualCodeToSourceScriptMap.set(code, sourceScript);\n                                    sourceScript.generated.embeddedCodes.set(code.id, code);\n                                }\n                                return sourceScript;\n                            }\n                            else {\n                                this.delete(id);\n                                return;\n                            }\n                        }\n                    }\n                    else {\n                        // not changed\n                        return sourceScript;\n                    }\n                }\n                else {\n                    // created\n                    const sourceScript = {\n                        id: id,\n                        languageId,\n                        snapshot,\n                        associatedIds: new Set(),\n                        targetIds: new Set(),\n                        associatedOnly\n                    };\n                    scriptRegistry.set(id, sourceScript);\n                    if (associatedOnly) {\n                        return sourceScript;\n                    }\n                    for (const languagePlugin of _plugins) {\n                        const virtualCode = languagePlugin.createVirtualCode?.(id, languageId, snapshot, prepareCreateVirtualCode(sourceScript));\n                        if (virtualCode) {\n                            sourceScript.generated = {\n                                root: virtualCode,\n                                languagePlugin,\n                                embeddedCodes: new Map(),\n                            };\n                            for (const code of forEachEmbeddedCode(virtualCode)) {\n                                virtualCodeToSourceScriptMap.set(code, sourceScript);\n                                sourceScript.generated.embeddedCodes.set(code.id, code);\n                            }\n                            break;\n                        }\n                    }\n                    return sourceScript;\n                }\n            },\n            delete(id) {\n                const sourceScript = scriptRegistry.get(id);\n                if (sourceScript) {\n                    sourceScript.generated?.languagePlugin.disposeVirtualCode?.(id, sourceScript.generated.root);\n                    scriptRegistry.delete(id);\n                    triggerTargetsDirty(sourceScript);\n                }\n            },\n        },\n        maps: {\n            get(virtualCode, sourceScript) {\n                let mapCache = virtualCodeToSourceMap.get(virtualCode.snapshot);\n                if (!mapCache) {\n                    virtualCodeToSourceMap.set(virtualCode.snapshot, mapCache = new WeakMap());\n                }\n                if (!mapCache.has(sourceScript.snapshot)) {\n                    const mappings = virtualCode.associatedScriptMappings?.get(sourceScript.id) ?? virtualCode.mappings;\n                    mapCache.set(sourceScript.snapshot, language.mapperFactory(mappings));\n                }\n                return mapCache.get(sourceScript.snapshot);\n            },\n            *forEach(virtualCode) {\n                const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);\n                yield [\n                    sourceScript,\n                    this.get(virtualCode, sourceScript),\n                ];\n                if (virtualCode.associatedScriptMappings) {\n                    for (const [relatedScriptId] of virtualCode.associatedScriptMappings) {\n                        const relatedSourceScript = scriptRegistry.get(relatedScriptId);\n                        if (relatedSourceScript) {\n                            yield [\n                                relatedSourceScript,\n                                this.get(virtualCode, relatedSourceScript),\n                            ];\n                        }\n                    }\n                }\n            },\n        },\n        linkedCodeMaps: {\n            get(virtualCode) {\n                const sourceScript = virtualCodeToSourceScriptMap.get(virtualCode);\n                let mapCache = virtualCodeToLinkedCodeMap.get(virtualCode.snapshot);\n                if (mapCache?.[0] !== sourceScript.snapshot) {\n                    virtualCodeToLinkedCodeMap.set(virtualCode.snapshot, mapCache = [\n                        sourceScript.snapshot,\n                        virtualCode.linkedCodeMappings\n                            ? new linkedCodeMap_1.LinkedCodeMap(virtualCode.linkedCodeMappings)\n                            : undefined,\n                    ]);\n                }\n                return mapCache[1];\n            },\n        },\n    };\n    return language;\n    function triggerTargetsDirty(sourceScript) {\n        sourceScript.targetIds.forEach(id => {\n            const sourceScript = scriptRegistry.get(id);\n            if (sourceScript) {\n                sourceScript.isAssociationDirty = true;\n                onAssociationDirty?.(sourceScript.id);\n            }\n        });\n    }\n    function prepareCreateVirtualCode(sourceScript) {\n        for (const id of sourceScript.associatedIds) {\n            scriptRegistry.get(id)?.targetIds.delete(sourceScript.id);\n        }\n        sourceScript.associatedIds.clear();\n        sourceScript.isAssociationDirty = false;\n        return {\n            getAssociatedScript(id) {\n                sync(id, true, true);\n                const relatedSourceScript = scriptRegistry.get(id);\n                if (relatedSourceScript) {\n                    relatedSourceScript.targetIds.add(sourceScript.id);\n                    sourceScript.associatedIds.add(relatedSourceScript.id);\n                }\n                return relatedSourceScript;\n            },\n        };\n    }\n}\nfunction* forEachEmbeddedCode(virtualCode) {\n    yield virtualCode;\n    if (virtualCode.embeddedCodes) {\n        for (const embeddedCode of virtualCode.embeddedCodes) {\n            yield* forEachEmbeddedCode(embeddedCode);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sfcBlockReg = /\\<(script|style)\\b([\\s\\S]*?)\\>([\\s\\S]*?)\\<\\/\\1\\>/g;\nconst langReg = /\\blang\\s*=\\s*(['\\\"]?)(\\S*)\\b\\1/;\nconst plugin = ({ vueCompilerOptions }) => {\n    return {\n        version: 2.1,\n        getLanguageId(fileName) {\n            if (vueCompilerOptions.petiteVueExtensions.some(ext => fileName.endsWith(ext))) {\n                return 'html';\n            }\n        },\n        isValidFile(_fileName, languageId) {\n            return languageId === 'html';\n        },\n        parseSFC2(fileName, languageId, content) {\n            if (languageId !== 'html') {\n                return;\n            }\n            let sfc = {\n                descriptor: {\n                    filename: fileName,\n                    source: content,\n                    template: null,\n                    script: null,\n                    scriptSetup: null,\n                    styles: [],\n                    customBlocks: [],\n                    cssVars: [],\n                    shouldForceReload: () => false,\n                    slotted: false,\n                },\n                errors: [],\n            };\n            let templateContent = content;\n            for (const match of content.matchAll(sfcBlockReg)) {\n                const matchText = match[0];\n                const tag = match[1];\n                const attrs = match[2];\n                const lang = attrs.match(langReg)?.[2];\n                const content = match[3];\n                const contentStart = match.index + matchText.indexOf(content);\n                if (tag === 'style') {\n                    sfc.descriptor.styles.push({\n                        attrs: {},\n                        content,\n                        loc: {\n                            start: { column: -1, line: -1, offset: contentStart },\n                            end: { column: -1, line: -1, offset: contentStart + content.length },\n                            source: content,\n                        },\n                        type: 'style',\n                        lang,\n                    });\n                }\n                // ignore `<script src=\"...\">`\n                else if (tag === 'script' && attrs.indexOf('src=') === -1) {\n                    let type = attrs.indexOf('type=') >= 0 ? 'scriptSetup' : 'script';\n                    sfc.descriptor[type] = {\n                        attrs: {},\n                        content,\n                        loc: {\n                            start: { column: -1, line: -1, offset: contentStart },\n                            end: { column: -1, line: -1, offset: contentStart + content.length },\n                            source: content,\n                        },\n                        type: 'script',\n                        lang,\n                    };\n                }\n                templateContent = templateContent.substring(0, match.index) + ' '.repeat(matchText.length) + templateContent.substring(match.index + matchText.length);\n            }\n            sfc.descriptor.template = {\n                attrs: {},\n                content: templateContent,\n                loc: {\n                    start: { column: -1, line: -1, offset: 0 },\n                    end: { column: -1, line: -1, offset: templateContent.length },\n                    source: templateContent,\n                },\n                type: 'template',\n                ast: {},\n            };\n            return sfc;\n        }\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=file-html.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildMappings = buildMappings;\nfunction buildMappings(chunks) {\n    let length = 0;\n    const mappings = [];\n    for (const segment of chunks) {\n        if (typeof segment === 'string') {\n            length += segment.length;\n        }\n        else {\n            mappings.push({\n                sourceOffsets: [segment[2]],\n                generatedOffsets: [length],\n                lengths: [segment[0].length],\n                data: segment[3],\n            });\n            length += segment[0].length;\n        }\n    }\n    return mappings;\n}\n//# sourceMappingURL=buildMappings.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = parse;\nconst compiler = require(\"@vue/compiler-dom\");\nfunction parse(source) {\n    const errors = [];\n    const ast = compiler.parse(source, {\n        // there are no components at SFC parsing level\n        isNativeTag: () => true,\n        // preserve all whitespaces\n        isPreTag: () => true,\n        parseMode: 'sfc',\n        onError: e => {\n            errors.push(e);\n        },\n        comments: true,\n    });\n    const descriptor = {\n        filename: 'anonymous.vue',\n        source,\n        template: null,\n        script: null,\n        scriptSetup: null,\n        styles: [],\n        customBlocks: [],\n        cssVars: [],\n        slotted: false,\n        shouldForceReload: () => false,\n    };\n    ast.children.forEach(node => {\n        if (node.type !== compiler.NodeTypes.ELEMENT) {\n            return;\n        }\n        switch (node.tag) {\n            case 'template':\n                descriptor.template = createBlock(node, source);\n                break;\n            case 'script':\n                const scriptBlock = createBlock(node, source);\n                const isSetup = !!scriptBlock.attrs.setup;\n                if (isSetup && !descriptor.scriptSetup) {\n                    descriptor.scriptSetup = scriptBlock;\n                    break;\n                }\n                if (!isSetup && !descriptor.script) {\n                    descriptor.script = scriptBlock;\n                    break;\n                }\n                break;\n            case 'style':\n                const styleBlock = createBlock(node, source);\n                descriptor.styles.push(styleBlock);\n                break;\n            default:\n                descriptor.customBlocks.push(createBlock(node, source));\n                break;\n        }\n    });\n    return {\n        descriptor,\n        errors,\n    };\n}\nfunction createBlock(node, source) {\n    const type = node.tag;\n    let { start, end } = node.loc;\n    let content = '';\n    if (node.children.length) {\n        start = node.children[0].loc.start;\n        end = node.children[node.children.length - 1].loc.end;\n        content = source.slice(start.offset, end.offset);\n    }\n    else {\n        const offset = node.loc.source.indexOf(`</`);\n        if (offset > -1) {\n            start = {\n                line: start.line,\n                column: start.column + offset,\n                offset: start.offset + offset\n            };\n        }\n        end = Object.assign({}, start);\n    }\n    const loc = {\n        source: content,\n        start,\n        end\n    };\n    const attrs = {};\n    const block = {\n        type,\n        content,\n        loc,\n        attrs\n    };\n    node.props.forEach(p => {\n        if (p.type === compiler.NodeTypes.ATTRIBUTE) {\n            attrs[p.name] = p.value ? p.value.content || true : true;\n            if (p.name === 'lang') {\n                block.lang = p.value && p.value.content;\n            }\n            else if (p.name === 'src') {\n                block.src = p.value && p.value.content;\n            }\n            else if (type === 'style') {\n                if (p.name === 'scoped') {\n                    block.scoped = true;\n                }\n                else if (p.name === 'module') {\n                    block.module = {\n                        name: p.value?.content ?? '$style',\n                        offset: p.value?.content ? p.value?.loc.start.offset - node.loc.start.offset : undefined\n                    };\n                }\n            }\n            else if (type === 'script' && p.name === 'setup') {\n                block.setup = attrs.setup;\n            }\n        }\n    });\n    return block;\n}\n//# sourceMappingURL=parseSfc.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst language_core_1 = require(\"@volar/language-core\");\nconst muggle_string_1 = require(\"muggle-string\");\nconst buildMappings_1 = require(\"../utils/buildMappings\");\nconst parseSfc_1 = require(\"../utils/parseSfc\");\nconst codeblockReg = /(`{3,})[\\s\\S]+?\\1/g;\nconst inlineCodeblockReg = /`[^\\n`]+?`/g;\nconst scriptSetupReg = /\\\\\\<[\\s\\S]+?\\>\\n?/g;\nconst sfcBlockReg = /\\<(script|style)\\b[\\s\\S]*?\\>([\\s\\S]*?)\\<\\/\\1\\>/g;\nconst angleBracketReg = /\\<\\S*\\:\\S*\\>/g;\nconst linkReg = /\\[[\\s\\S]*?\\]\\([\\s\\S]*?\\)/g;\nconst codeSnippetImportReg = /^\\s*<<<\\s*.+/gm;\nconst plugin = ({ vueCompilerOptions }) => {\n    return {\n        version: 2.1,\n        getLanguageId(fileName) {\n            if (vueCompilerOptions.vitePressExtensions.some(ext => fileName.endsWith(ext))) {\n                return 'markdown';\n            }\n        },\n        isValidFile(_fileName, languageId) {\n            return languageId === 'markdown';\n        },\n        parseSFC2(_fileName, languageId, content) {\n            if (languageId !== 'markdown') {\n                return;\n            }\n            content = content\n                // code block\n                .replace(codeblockReg, (match, quotes) => quotes + ' '.repeat(match.length - quotes.length * 2) + quotes)\n                // inline code block\n                .replace(inlineCodeblockReg, match => `\\`${' '.repeat(match.length - 2)}\\``)\n                // # \\<script setup>\n                .replace(scriptSetupReg, match => ' '.repeat(match.length))\n                // <<< https://vitepress.dev/guide/markdown#import-code-snippets\n                .replace(codeSnippetImportReg, match => ' '.repeat(match.length));\n            const codes = [];\n            for (const match of content.matchAll(sfcBlockReg)) {\n                if (match.index !== undefined) {\n                    const matchText = match[0];\n                    codes.push([matchText, undefined, match.index]);\n                    codes.push('\\n\\n');\n                    content = content.substring(0, match.index) + ' '.repeat(matchText.length) + content.substring(match.index + matchText.length);\n                }\n            }\n            content = content\n                // angle bracket: <http://foo.com>\n                .replace(angleBracketReg, match => ' '.repeat(match.length))\n                // [foo](http://foo.com)\n                .replace(linkReg, match => ' '.repeat(match.length));\n            codes.push('<template>\\n');\n            codes.push([content, undefined, 0]);\n            codes.push('\\n</template>');\n            const file2VueSourceMap = (0, language_core_1.defaultMapperFactory)((0, buildMappings_1.buildMappings)(codes));\n            const sfc = (0, parseSfc_1.parse)((0, muggle_string_1.toString)(codes));\n            if (sfc.descriptor.template) {\n                sfc.descriptor.template.lang = 'md';\n                transformRange(sfc.descriptor.template);\n            }\n            if (sfc.descriptor.script) {\n                transformRange(sfc.descriptor.script);\n            }\n            if (sfc.descriptor.scriptSetup) {\n                transformRange(sfc.descriptor.scriptSetup);\n            }\n            for (const style of sfc.descriptor.styles) {\n                transformRange(style);\n            }\n            for (const customBlock of sfc.descriptor.customBlocks) {\n                transformRange(customBlock);\n            }\n            return sfc;\n            function transformRange(block) {\n                const { start, end } = block.loc;\n                const startOffset = start.offset;\n                const endOffset = end.offset;\n                start.offset = -1;\n                end.offset = -1;\n                for (const [offset] of file2VueSourceMap.toSourceLocation(startOffset)) {\n                    start.offset = offset;\n                    break;\n                }\n                for (const [offset] of file2VueSourceMap.toSourceLocation(endOffset)) {\n                    end.offset = offset;\n                    break;\n                }\n            }\n        }\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=file-md.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parseSfc_1 = require(\"../utils/parseSfc\");\nconst plugin = ({ vueCompilerOptions }) => {\n    return {\n        version: 2.1,\n        getLanguageId(fileName) {\n            if (vueCompilerOptions.extensions.some(ext => fileName.endsWith(ext))) {\n                return 'vue';\n            }\n        },\n        isValidFile(_fileName, languageId) {\n            return languageId === 'vue';\n        },\n        parseSFC2(_fileName, languageId, content) {\n            if (languageId !== 'vue') {\n                return;\n            }\n            return (0, parseSfc_1.parse)(content);\n        },\n        updateSFC(sfc, change) {\n            const blocks = [\n                sfc.descriptor.template,\n                sfc.descriptor.script,\n                sfc.descriptor.scriptSetup,\n                ...sfc.descriptor.styles,\n                ...sfc.descriptor.customBlocks,\n            ].filter((block) => !!block);\n            const hitBlock = blocks.find(block => change.start >= block.loc.start.offset && change.end <= block.loc.end.offset);\n            if (!hitBlock) {\n                return;\n            }\n            const oldContent = hitBlock.content;\n            const newContent = hitBlock.content =\n                hitBlock.content.substring(0, change.start - hitBlock.loc.start.offset)\n                    + change.newText\n                    + hitBlock.content.substring(change.end - hitBlock.loc.start.offset);\n            // #3449\n            const endTagRegex = new RegExp(`</\\\\s*${hitBlock.type}\\\\s*>`);\n            const insertedEndTag = !!oldContent.match(endTagRegex) !== !!newContent.match(endTagRegex);\n            if (insertedEndTag) {\n                return;\n            }\n            const lengthDiff = change.newText.length - (change.end - change.start);\n            for (const block of blocks) {\n                if (block.loc.start.offset > change.end) {\n                    block.loc.start.offset += lengthDiff;\n                }\n                if (block.loc.end.offset >= change.end) {\n                    block.loc.end.offset += lengthDiff;\n                }\n            }\n            return sfc;\n        },\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=file-vue.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.allCodeFeatures = void 0;\nexports.allCodeFeatures = {\n    verification: true,\n    completion: true,\n    semantic: true,\n    navigation: true,\n    structure: true,\n    format: true,\n};\n//# sourceMappingURL=shared.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst muggle_string_1 = require(\"muggle-string\");\nconst shared_1 = require(\"./shared\");\nconst plugin = () => {\n    return {\n        version: 2.1,\n        getEmbeddedCodes() {\n            return [{\n                    id: 'root_tags',\n                    lang: 'vue-root-tags',\n                }];\n        },\n        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {\n            if (embeddedFile.id === 'root_tags') {\n                embeddedFile.content.push([sfc.content, undefined, 0, shared_1.allCodeFeatures]);\n                for (const block of [\n                    sfc.script,\n                    sfc.scriptSetup,\n                    sfc.template,\n                    ...sfc.styles,\n                    ...sfc.customBlocks,\n                ]) {\n                    if (!block) {\n                        continue;\n                    }\n                    let content = block.content;\n                    if (content.endsWith('\\r\\n')) {\n                        content = content.slice(0, -2);\n                    }\n                    else if (content.endsWith('\\n')) {\n                        content = content.slice(0, -1);\n                    }\n                    const offset = content.lastIndexOf('\\n') + 1;\n                    // fix folding range end position failed to mapping\n                    (0, muggle_string_1.replaceSourceRange)(embeddedFile.content, undefined, block.startTagEnd, block.endTagStart, sfc.content.substring(block.startTagEnd, block.startTagEnd + offset), [\n                        '',\n                        undefined,\n                        block.startTagEnd + offset,\n                        { structure: true },\n                    ], sfc.content.substring(block.startTagEnd + offset, block.endTagStart));\n                }\n            }\n            else {\n                embeddedFile.parentCodeId ??= 'root_tags';\n            }\n        },\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=vue-root-tags.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst plugin = ({ modules }) => {\n    return {\n        version: 2.1,\n        compileSFCScript(lang, script) {\n            if (lang === 'js' || lang === 'ts' || lang === 'jsx' || lang === 'tsx') {\n                const ts = modules.typescript;\n                return ts.createSourceFile('test.' + lang, script, 99);\n            }\n        },\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=vue-script-js.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shared_1 = require(\"./shared\");\nconst plugin = () => {\n    return {\n        version: 2.1,\n        getEmbeddedCodes(_fileName, sfc) {\n            return sfc.customBlocks.map((customBlock, i) => ({\n                id: 'custom_block_' + i,\n                lang: customBlock.lang,\n            }));\n        },\n        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {\n            if (embeddedFile.id.startsWith('custom_block_')) {\n                const index = parseInt(embeddedFile.id.slice('custom_block_'.length));\n                const customBlock = sfc.customBlocks[index];\n                embeddedFile.content.push([\n                    customBlock.content,\n                    customBlock.name,\n                    0,\n                    shared_1.allCodeFeatures,\n                ]);\n            }\n        },\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=vue-sfc-customblocks.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst plugin = () => {\n    return {\n        version: 2.1,\n        getEmbeddedCodes(_fileName, sfc) {\n            const names = [];\n            if (sfc.script) {\n                names.push({ id: 'script_raw', lang: sfc.script.lang });\n            }\n            if (sfc.scriptSetup) {\n                names.push({ id: 'scriptsetup_raw', lang: sfc.scriptSetup.lang });\n            }\n            return names;\n        },\n        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {\n            const script = embeddedFile.id === 'script_raw' ? sfc.script\n                : embeddedFile.id === 'scriptsetup_raw' ? sfc.scriptSetup\n                    : undefined;\n            if (script) {\n                embeddedFile.content.push([\n                    script.content,\n                    script.name,\n                    0,\n                    {\n                        structure: true,\n                        format: true,\n                    },\n                ]);\n            }\n        },\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=vue-sfc-scripts.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shared_1 = require(\"./shared\");\nconst plugin = () => {\n    return {\n        version: 2.1,\n        getEmbeddedCodes(_fileName, sfc) {\n            const result = [];\n            for (let i = 0; i < sfc.styles.length; i++) {\n                const style = sfc.styles[i];\n                if (style) {\n                    result.push({\n                        id: 'style_' + i,\n                        lang: style.lang,\n                    });\n                    if (style.cssVars.length) {\n                        result.push({\n                            id: 'style_' + i + '_inline_ts',\n                            lang: 'ts',\n                        });\n                    }\n                }\n            }\n            return result;\n        },\n        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {\n            if (embeddedFile.id.startsWith('style_')) {\n                const index = parseInt(embeddedFile.id.split('_')[1]);\n                const style = sfc.styles[index];\n                if (embeddedFile.id.endsWith('_inline_ts')) {\n                    embeddedFile.parentCodeId = 'style_' + index;\n                    for (const cssVar of style.cssVars) {\n                        embeddedFile.content.push('(', [\n                            cssVar.text,\n                            style.name,\n                            cssVar.offset,\n                            shared_1.allCodeFeatures,\n                        ], ');\\n');\n                    }\n                }\n                else {\n                    embeddedFile.content.push([\n                        style.content,\n                        style.name,\n                        0,\n                        shared_1.allCodeFeatures,\n                    ]);\n                }\n            }\n        },\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=vue-sfc-styles.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shared_1 = require(\"./shared\");\nconst plugin = () => {\n    return {\n        version: 2.1,\n        getEmbeddedCodes(_fileName, sfc) {\n            if (sfc.template?.lang === 'html') {\n                return [{\n                        id: 'template',\n                        lang: sfc.template.lang,\n                    }];\n            }\n            return [];\n        },\n        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {\n            if (embeddedFile.id === 'template' && sfc.template?.lang === 'html') {\n                embeddedFile.content.push([\n                    sfc.template.content,\n                    sfc.template.name,\n                    0,\n                    shared_1.allCodeFeatures,\n                ]);\n            }\n        },\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=vue-sfc-template.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shouldAddSuffix = /(?<=<[^>/]+)$/;\nconst plugin = ({ modules }) => {\n    return {\n        version: 2.1,\n        compileSFCTemplate(lang, template, options) {\n            if (lang === 'html' || lang === 'md') {\n                const compiler = modules['@vue/compiler-dom'];\n                let addedSuffix = false;\n                // #4583\n                if (shouldAddSuffix.test(template)) {\n                    template += '>';\n                    addedSuffix = true;\n                }\n                const result = compiler.compile(template, {\n                    ...options,\n                    comments: true,\n                });\n                // @ts-expect-error\n                result.__addedSuffix = addedSuffix;\n                return result;\n            }\n        },\n        updateSFCTemplate(oldResult, change) {\n            oldResult.code = oldResult.code.slice(0, change.start)\n                + change.newText\n                + oldResult.code.slice(change.end);\n            // @ts-expect-error\n            if (oldResult.__addedSuffix) {\n                const originalTemplate = oldResult.code.slice(0, -1); // remove added '>'\n                if (!shouldAddSuffix.test(originalTemplate)) {\n                    return undefined;\n                }\n            }\n            const CompilerDOM = modules['@vue/compiler-dom'];\n            const lengthDiff = change.newText.length - (change.end - change.start);\n            let hitNodes = [];\n            if (tryUpdateNode(oldResult.ast) && hitNodes.length) {\n                hitNodes = hitNodes.sort((a, b) => a.loc.source.length - b.loc.source.length);\n                const hitNode = hitNodes[0];\n                if (hitNode.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                    return oldResult;\n                }\n            }\n            function tryUpdateNode(node) {\n                if (withinChangeRange(node.loc)) {\n                    hitNodes.push(node);\n                }\n                if (tryUpdateNodeLoc(node.loc)) {\n                    if (node.type === CompilerDOM.NodeTypes.ROOT) {\n                        for (const child of node.children) {\n                            if (!tryUpdateNode(child)) {\n                                return false;\n                            }\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.ELEMENT) {\n                        if (withinChangeRange(node.loc)) {\n                            // if not self closing, should not hit tag name\n                            const start = node.loc.start.offset + 2;\n                            const end = node.loc.start.offset + node.loc.source.lastIndexOf('</');\n                            if (!withinChangeRange({ start: { offset: start }, end: { offset: end }, source: '' })) {\n                                return false;\n                            }\n                        }\n                        for (const prop of node.props) {\n                            if (!tryUpdateNode(prop)) {\n                                return false;\n                            }\n                        }\n                        for (const child of node.children) {\n                            if (!tryUpdateNode(child)) {\n                                return false;\n                            }\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.ATTRIBUTE) {\n                        if (node.value && !tryUpdateNode(node.value)) {\n                            return false;\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.DIRECTIVE) {\n                        if (node.arg && withinChangeRange(node.arg.loc) && node.name === 'slot') {\n                            return false;\n                        }\n                        if (node.exp && withinChangeRange(node.exp.loc) && node.name === 'for') { // #2266\n                            return false;\n                        }\n                        if (node.arg && !tryUpdateNode(node.arg)) {\n                            return false;\n                        }\n                        if (node.exp && !tryUpdateNode(node.exp)) {\n                            return false;\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.TEXT_CALL) {\n                        if (!tryUpdateNode(node.content)) {\n                            return false;\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.COMPOUND_EXPRESSION) {\n                        for (const childNode of node.children) {\n                            if (typeof childNode === 'object') {\n                                if (!tryUpdateNode(childNode)) {\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.IF) {\n                        for (const branch of node.branches) {\n                            if (branch.condition && !tryUpdateNode(branch.condition)) {\n                                return false;\n                            }\n                            for (const child of branch.children) {\n                                if (!tryUpdateNode(child)) {\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.FOR) {\n                        for (const child of [\n                            node.parseResult.source,\n                            node.parseResult.value,\n                            node.parseResult.key,\n                            node.parseResult.index,\n                        ]) {\n                            if (child) {\n                                if (!tryUpdateNode(child)) {\n                                    return false;\n                                }\n                                if (child.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                                    const content = child.content.trim();\n                                    if (content.startsWith('(') || content.endsWith(')')) {\n                                        return false;\n                                    }\n                                }\n                            }\n                        }\n                        for (const child of node.children) {\n                            if (!tryUpdateNode(child)) {\n                                return false;\n                            }\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.INTERPOLATION) {\n                        if (!tryUpdateNode(node.content)) {\n                            return false;\n                        }\n                    }\n                    else if (node.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                        if (withinChangeRange(node.loc)) { // TODO: review this (slot name?)\n                            if (node.isStatic) {\n                                return false;\n                            }\n                            else {\n                                node.content = node.loc.source;\n                            }\n                        }\n                    }\n                    return true;\n                }\n                return false;\n            }\n            function tryUpdateNodeLoc(loc) {\n                delete loc.__endOffset;\n                if (withinChangeRange(loc)) {\n                    loc.source =\n                        loc.source.substring(0, change.start - loc.start.offset)\n                            + change.newText\n                            + loc.source.substring(change.end - loc.start.offset);\n                    loc.__endOffset = loc.end.offset;\n                    loc.end.offset += lengthDiff;\n                    return true;\n                }\n                else if (change.end <= loc.start.offset) {\n                    loc.__endOffset = loc.end.offset;\n                    loc.start.offset += lengthDiff;\n                    loc.end.offset += lengthDiff;\n                    return true;\n                }\n                else if (change.start >= loc.end.offset) {\n                    return true; // no need update\n                }\n                return false;\n            }\n            function withinChangeRange(loc) {\n                const originalLocEnd = loc.__endOffset ?? loc.end.offset;\n                return change.start >= loc.start.offset && change.end <= originalLocEnd;\n            }\n        },\n    };\n};\nexports.default = plugin;\n//# sourceMappingURL=vue-template-html.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst template_1 = require(\"../codegen/template\");\nconst shared_1 = require(\"./shared\");\nconst codeFeatures = {\n    ...shared_1.allCodeFeatures,\n    format: false,\n    structure: false,\n};\nconst plugin = () => {\n    return {\n        version: 2.1,\n        getEmbeddedCodes(_fileName, sfc) {\n            if (!sfc.template?.ast) {\n                return [];\n            }\n            return [{ id: 'template_inline_css', lang: 'css' }];\n        },\n        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {\n            if (embeddedFile.id !== 'template_inline_css' || !sfc.template?.ast) {\n                return;\n            }\n            embeddedFile.parentCodeId = 'template';\n            embeddedFile.content.push(...generate(sfc.template.ast));\n        },\n    };\n};\nexports.default = plugin;\nfunction* generate(templateAst) {\n    for (const node of (0, template_1.forEachElementNode)(templateAst)) {\n        for (const prop of node.props) {\n            if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE\n                && prop.name === 'bind'\n                && prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n                && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n                && prop.arg.content === 'style'\n                && prop.exp.constType === CompilerDOM.ConstantTypes.CAN_STRINGIFY) {\n                const endCrt = prop.arg.loc.source[prop.arg.loc.source.length - 1]; // \" | '\n                const start = prop.arg.loc.source.indexOf(endCrt) + 1;\n                const end = prop.arg.loc.source.lastIndexOf(endCrt);\n                const content = prop.arg.loc.source.substring(start, end);\n                yield `x { `;\n                yield [\n                    content,\n                    'template',\n                    prop.arg.loc.start.offset + start,\n                    codeFeatures,\n                ];\n                yield ` }\\n`;\n            }\n        }\n    }\n}\n//# sourceMappingURL=vue-template-inline-css.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = require(\"../codegen/common\");\nconst elementEvents_1 = require(\"../codegen/template/elementEvents\");\nconst templateChild_1 = require(\"../codegen/template/templateChild\");\nconst vFor_1 = require(\"../codegen/template/vFor\");\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst codeFeatures = {\n    format: true,\n};\nconst formatBrackets = {\n    normal: ['`${', '}`;'],\n    if: ['if (', ') { }'],\n    for: ['for (', ') { }'],\n    // fix https://github.com/vuejs/language-tools/issues/3572\n    params: ['(', ') => {};'],\n    // fix https://github.com/vuejs/language-tools/issues/1210\n    // fix https://github.com/vuejs/language-tools/issues/2305\n    curly: ['0 +', '+ 0;'],\n    event: ['() => ', ';'],\n};\nconst plugin = ctx => {\n    const parseds = new WeakMap();\n    return {\n        version: 2.1,\n        getEmbeddedCodes(_fileName, sfc) {\n            if (!sfc.template?.ast) {\n                return [];\n            }\n            const parsed = parse(sfc);\n            parseds.set(sfc, parsed);\n            const result = [];\n            for (const [id] of parsed) {\n                result.push({ id, lang: 'ts' });\n            }\n            return result;\n        },\n        resolveEmbeddedCode(_fileName, sfc, embeddedFile) {\n            // access template content to watch change\n            (() => sfc.template?.content)();\n            const parsed = parseds.get(sfc);\n            if (parsed) {\n                const codes = parsed.get(embeddedFile.id);\n                if (codes) {\n                    embeddedFile.content.push(...codes);\n                    embeddedFile.parentCodeId = 'template';\n                }\n            }\n        },\n    };\n    function parse(sfc) {\n        const data = new Map();\n        if (!sfc.template?.ast) {\n            return data;\n        }\n        const templateContent = sfc.template.content;\n        let i = 0;\n        sfc.template.ast.children.forEach(visit);\n        return data;\n        function visit(node) {\n            if (node.type === CompilerDOM.NodeTypes.ELEMENT) {\n                for (const prop of node.props) {\n                    if (prop.type !== CompilerDOM.NodeTypes.DIRECTIVE) {\n                        continue;\n                    }\n                    const isShorthand = prop.arg?.loc.start.offset === prop.exp?.loc.start.offset; // vue 3.4+\n                    if (isShorthand) {\n                        continue;\n                    }\n                    if (prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION && !prop.arg.isStatic) {\n                        addFormatCodes(prop.arg.content, prop.arg.loc.start.offset, formatBrackets.normal);\n                    }\n                    if (prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION\n                        && prop.exp.constType !== CompilerDOM.ConstantTypes.CAN_STRINGIFY // style='z-index: 2' will compile to {'z-index':'2'}\n                    ) {\n                        if (prop.name === 'on' && prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                            const ast = (0, common_1.createTsAst)(ctx.modules.typescript, prop.exp, prop.exp.content);\n                            addFormatCodes(prop.exp.content, prop.exp.loc.start.offset, (0, elementEvents_1.isCompoundExpression)(ctx.modules.typescript, ast)\n                                ? formatBrackets.event\n                                : formatBrackets.normal);\n                        }\n                        else {\n                            addFormatCodes(prop.exp.content, prop.exp.loc.start.offset, formatBrackets.normal);\n                        }\n                    }\n                }\n                for (const child of node.children) {\n                    visit(child);\n                }\n            }\n            else if (node.type === CompilerDOM.NodeTypes.IF) {\n                for (let i = 0; i < node.branches.length; i++) {\n                    const branch = node.branches[i];\n                    if (branch.condition?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                        addFormatCodes(branch.condition.content, branch.condition.loc.start.offset, formatBrackets.if);\n                    }\n                    for (const childNode of branch.children) {\n                        visit(childNode);\n                    }\n                }\n            }\n            else if (node.type === CompilerDOM.NodeTypes.FOR) {\n                const { leftExpressionRange, leftExpressionText } = (0, vFor_1.parseVForNode)(node);\n                const { source } = node.parseResult;\n                if (leftExpressionRange && leftExpressionText && source.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {\n                    const start = leftExpressionRange.start;\n                    const end = source.loc.start.offset + source.content.length;\n                    addFormatCodes(templateContent.substring(start, end), start, formatBrackets.for);\n                }\n                for (const child of node.children) {\n                    visit(child);\n                }\n            }\n            else if (node.type === CompilerDOM.NodeTypes.TEXT_CALL) {\n                // {{ var }}\n                visit(node.content);\n            }\n            else if (node.type === CompilerDOM.NodeTypes.COMPOUND_EXPRESSION) {\n                // {{ ... }} {{ ... }}\n                for (const childNode of node.children) {\n                    if (typeof childNode === 'object') {\n                        visit(childNode);\n                    }\n                }\n            }\n            else if (node.type === CompilerDOM.NodeTypes.INTERPOLATION) {\n                // {{ ... }}\n                const [content, start] = (0, templateChild_1.parseInterpolationNode)(node, templateContent);\n                const lines = content.split('\\n');\n                addFormatCodes(content, start, lines.length <= 1 ? formatBrackets.curly : [\n                    lines[0].trim() === '' ? '(' : formatBrackets.curly[0],\n                    lines[lines.length - 1].trim() === '' ? ');' : formatBrackets.curly[1],\n                ]);\n            }\n        }\n        function addFormatCodes(code, offset, wrapper) {\n            const id = 'template_inline_ts_' + i++;\n            data.set(id, [\n                wrapper[0],\n                [\n                    code,\n                    'template',\n                    offset,\n                    codeFeatures,\n                ],\n                wrapper[1],\n            ]);\n        }\n    }\n};\nexports.default = plugin;\n//# sourceMappingURL=vue-template-inline-ts.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriber = exports.Dependency = exports.Link = exports.System = void 0;\nexports.startBatch = startBatch;\nexports.endBatch = endBatch;\nvar System;\n(function (System) {\n    System.activeSub = undefined;\n    System.activeTrackId = 0;\n    System.batchDepth = 0;\n    System.lastTrackId = 0;\n    System.queuedEffects = undefined;\n    System.queuedEffectsTail = undefined;\n})(System || (exports.System = System = {}));\nfunction startBatch() {\n    System.batchDepth++;\n}\nfunction endBatch() {\n    System.batchDepth--;\n    if (System.batchDepth === 0) {\n        while (System.queuedEffects !== undefined) {\n            const effect = System.queuedEffects;\n            const queuedNext = System.queuedEffects.nextNotify;\n            if (queuedNext !== undefined) {\n                System.queuedEffects.nextNotify = undefined;\n                System.queuedEffects = queuedNext;\n            }\n            else {\n                System.queuedEffects = undefined;\n                System.queuedEffectsTail = undefined;\n            }\n            effect.notify();\n        }\n    }\n}\nvar Link;\n(function (Link) {\n    let pool = undefined;\n    function get(dep, sub, nextDep) {\n        if (pool !== undefined) {\n            const newLink = pool;\n            pool = newLink.nextDep;\n            newLink.nextDep = nextDep;\n            newLink.dep = dep;\n            newLink.sub = sub;\n            newLink.trackId = sub.trackId;\n            return newLink;\n        }\n        else {\n            return {\n                dep,\n                sub,\n                trackId: sub.trackId,\n                nextDep: nextDep,\n                prevSub: undefined,\n                nextSub: undefined,\n            };\n        }\n    }\n    Link.get = get;\n    function release(link) {\n        const dep = link.dep;\n        const nextSub = link.nextSub;\n        const prevSub = link.prevSub;\n        if (nextSub !== undefined) {\n            nextSub.prevSub = prevSub;\n        }\n        if (prevSub !== undefined) {\n            prevSub.nextSub = nextSub;\n        }\n        if (nextSub === undefined) {\n            dep.subsTail = prevSub;\n        }\n        if (prevSub === undefined) {\n            dep.subs = nextSub;\n        }\n        // @ts-expect-error\n        link.dep = undefined;\n        // @ts-expect-error\n        link.sub = undefined;\n        link.prevSub = undefined;\n        link.nextSub = undefined;\n        link.nextDep = pool;\n        pool = link;\n    }\n    Link.release = release;\n})(Link || (exports.Link = Link = {}));\nvar Dependency;\n(function (Dependency) {\n    const system = System;\n    /**\n     * @deprecated Use `startTrack` instead.\n     */\n    function linkSubscriber(dep, sub) {\n        return link(dep, sub);\n    }\n    Dependency.linkSubscriber = linkSubscriber;\n    function link(dep, sub) {\n        const depsTail = sub.depsTail;\n        const old = depsTail !== undefined\n            ? depsTail.nextDep\n            : sub.deps;\n        if (old === undefined || old.dep !== dep) {\n            const newLink = Link.get(dep, sub, old);\n            if (depsTail === undefined) {\n                sub.deps = newLink;\n            }\n            else {\n                depsTail.nextDep = newLink;\n            }\n            if (dep.subs === undefined) {\n                dep.subs = newLink;\n            }\n            else {\n                const oldTail = dep.subsTail;\n                newLink.prevSub = oldTail;\n                oldTail.nextSub = newLink;\n            }\n            sub.depsTail = newLink;\n            dep.subsTail = newLink;\n        }\n        else {\n            old.trackId = sub.trackId;\n            sub.depsTail = old;\n        }\n    }\n    Dependency.link = link;\n    function propagate(subs) {\n        let link = subs;\n        let dep = subs.dep;\n        let dirtyLevel = 3 /* DirtyLevels.Dirty */;\n        let remainingQuantity = 0;\n        do {\n            if (link !== undefined) {\n                const sub = link.sub;\n                const subTrackId = sub.trackId;\n                if (subTrackId > 0) {\n                    if (subTrackId === link.trackId) {\n                        const subDirtyLevel = sub.dirtyLevel;\n                        if (subDirtyLevel < dirtyLevel) {\n                            sub.dirtyLevel = dirtyLevel;\n                            if (subDirtyLevel === 0 /* DirtyLevels.None */) {\n                                sub.canPropagate = true;\n                                if ('subs' in sub && sub.subs !== undefined) {\n                                    sub.depsTail.nextDep = link;\n                                    dep = sub;\n                                    link = sub.subs;\n                                    if ('notify' in sub) {\n                                        dirtyLevel = 1 /* DirtyLevels.SideEffectsOnly */;\n                                    }\n                                    else {\n                                        dirtyLevel = 2 /* DirtyLevels.MaybeDirty */;\n                                    }\n                                    remainingQuantity++;\n                                    continue;\n                                }\n                            }\n                        }\n                    }\n                }\n                else if (subTrackId === -link.trackId) {\n                    const subDirtyLevel = sub.dirtyLevel;\n                    const notDirty = subDirtyLevel === 0 /* DirtyLevels.None */;\n                    if (subDirtyLevel < dirtyLevel) {\n                        sub.dirtyLevel = dirtyLevel;\n                    }\n                    if (notDirty || sub.canPropagate) {\n                        if (!notDirty) {\n                            sub.canPropagate = false;\n                        }\n                        if ('subs' in sub && sub.subs !== undefined) {\n                            sub.depsTail.nextDep = link;\n                            dep = sub;\n                            link = sub.subs;\n                            if ('notify' in sub) {\n                                dirtyLevel = 1 /* DirtyLevels.SideEffectsOnly */;\n                            }\n                            else {\n                                dirtyLevel = 2 /* DirtyLevels.MaybeDirty */;\n                            }\n                            remainingQuantity++;\n                            continue;\n                        }\n                        else if ('notify' in sub) {\n                            const queuedEffectsTail = system.queuedEffectsTail;\n                            if (queuedEffectsTail !== undefined) {\n                                queuedEffectsTail.nextNotify = sub;\n                            }\n                            else {\n                                system.queuedEffects = sub;\n                            }\n                            system.queuedEffectsTail = sub;\n                        }\n                    }\n                }\n                link = link.nextSub;\n                continue;\n            }\n            if (remainingQuantity !== 0) {\n                const depsTail = dep.depsTail;\n                const prevLink = depsTail.nextDep;\n                const prevSub = prevLink.sub;\n                depsTail.nextDep = undefined;\n                dep = prevLink.dep;\n                link = prevLink.nextSub;\n                remainingQuantity--;\n                if (remainingQuantity === 0) {\n                    dirtyLevel = 3 /* DirtyLevels.Dirty */;\n                }\n                else if ('notify' in dep) {\n                    dirtyLevel = 1 /* DirtyLevels.SideEffectsOnly */;\n                }\n                else {\n                    dirtyLevel = 2 /* DirtyLevels.MaybeDirty */;\n                }\n                if ('notify' in prevSub) {\n                    const queuedEffectsTail = system.queuedEffectsTail;\n                    if (queuedEffectsTail !== undefined) {\n                        queuedEffectsTail.nextNotify = prevSub;\n                    }\n                    else {\n                        system.queuedEffects = prevSub;\n                    }\n                    system.queuedEffectsTail = prevSub;\n                }\n                continue;\n            }\n            break;\n        } while (true);\n    }\n    Dependency.propagate = propagate;\n})(Dependency || (exports.Dependency = Dependency = {}));\nvar Subscriber;\n(function (Subscriber) {\n    const system = System;\n    function resolveMaybeDirty(sub, depth = 0) {\n        let link = sub.deps;\n        while (link !== undefined) {\n            const dep = link.dep;\n            if ('update' in dep) {\n                let dirtyLevel = dep.dirtyLevel;\n                if (dirtyLevel === 2 /* DirtyLevels.MaybeDirty */) {\n                    if (depth >= 4) {\n                        resolveMaybeDirtyNonRecursive(dep);\n                    }\n                    else {\n                        resolveMaybeDirty(dep, depth + 1);\n                    }\n                    dirtyLevel = dep.dirtyLevel;\n                }\n                if (dirtyLevel === 3 /* DirtyLevels.Dirty */) {\n                    dep.update();\n                    if (sub.dirtyLevel === 3 /* DirtyLevels.Dirty */) {\n                        break;\n                    }\n                }\n            }\n            link = link.nextDep;\n        }\n        if (sub.dirtyLevel === 2 /* DirtyLevels.MaybeDirty */) {\n            sub.dirtyLevel = 0 /* DirtyLevels.None */;\n        }\n    }\n    Subscriber.resolveMaybeDirty = resolveMaybeDirty;\n    function resolveMaybeDirtyNonRecursive(sub) {\n        let link = sub.deps;\n        let remaining = 0;\n        do {\n            if (link !== undefined) {\n                const dep = link.dep;\n                if ('update' in dep) {\n                    const depDirtyLevel = dep.dirtyLevel;\n                    if (depDirtyLevel === 2 /* DirtyLevels.MaybeDirty */) {\n                        dep.subs.prevSub = link;\n                        sub = dep;\n                        link = dep.deps;\n                        remaining++;\n                        continue;\n                    }\n                    else if (depDirtyLevel === 3 /* DirtyLevels.Dirty */) {\n                        dep.update();\n                        if (sub.dirtyLevel === 3 /* DirtyLevels.Dirty */) {\n                            if (remaining !== 0) {\n                                const subSubs = sub.subs;\n                                const prevLink = subSubs.prevSub;\n                                sub.update();\n                                subSubs.prevSub = undefined;\n                                sub = prevLink.sub;\n                                link = prevLink.nextDep;\n                                remaining--;\n                                continue;\n                            }\n                            break;\n                        }\n                    }\n                }\n                link = link.nextDep;\n                continue;\n            }\n            const dirtyLevel = sub.dirtyLevel;\n            if (dirtyLevel === 2 /* DirtyLevels.MaybeDirty */) {\n                sub.dirtyLevel = 0 /* DirtyLevels.None */;\n                if (remaining !== 0) {\n                    const subSubs = sub.subs;\n                    const prevLink = subSubs.prevSub;\n                    subSubs.prevSub = undefined;\n                    sub = prevLink.sub;\n                    link = prevLink.nextDep;\n                    remaining--;\n                    continue;\n                }\n            }\n            else if (remaining !== 0) {\n                if (dirtyLevel === 3 /* DirtyLevels.Dirty */) {\n                    sub.update();\n                }\n                const subSubs = sub.subs;\n                const prevLink = subSubs.prevSub;\n                subSubs.prevSub = undefined;\n                sub = prevLink.sub;\n                link = prevLink.nextDep;\n                remaining--;\n                continue;\n            }\n            break;\n        } while (true);\n    }\n    Subscriber.resolveMaybeDirtyNonRecursive = resolveMaybeDirtyNonRecursive;\n    /**\n     * @deprecated Use `startTrack` instead.\n     */\n    function startTrackDependencies(sub) {\n        return startTrack(sub);\n    }\n    Subscriber.startTrackDependencies = startTrackDependencies;\n    /**\n     * @deprecated Use `endTrack` instead.\n     */\n    function endTrackDependencies(sub, prevSub) {\n        return endTrack(sub, prevSub);\n    }\n    Subscriber.endTrackDependencies = endTrackDependencies;\n    function startTrack(sub) {\n        const newTrackId = system.lastTrackId + 1;\n        const prevSub = system.activeSub;\n        system.activeSub = sub;\n        system.activeTrackId = newTrackId;\n        system.lastTrackId = newTrackId;\n        sub.depsTail = undefined;\n        sub.trackId = newTrackId;\n        sub.dirtyLevel = 0 /* DirtyLevels.None */;\n        return prevSub;\n    }\n    Subscriber.startTrack = startTrack;\n    function endTrack(sub, prevSub) {\n        if (prevSub !== undefined) {\n            system.activeSub = prevSub;\n            system.activeTrackId = prevSub.trackId;\n        }\n        else {\n            system.activeSub = undefined;\n            system.activeTrackId = 0;\n        }\n        const depsTail = sub.depsTail;\n        if (depsTail !== undefined) {\n            if (depsTail.nextDep !== undefined) {\n                clearTrack(depsTail.nextDep);\n                depsTail.nextDep = undefined;\n            }\n        }\n        else if (sub.deps !== undefined) {\n            clearTrack(sub.deps);\n            sub.deps = undefined;\n        }\n        sub.trackId = -sub.trackId;\n    }\n    Subscriber.endTrack = endTrack;\n    function clearTrack(link) {\n        do {\n            const dep = link.dep;\n            const nextDep = link.nextDep;\n            Link.release(link);\n            if (dep.subs === undefined && 'deps' in dep) {\n                if ('notify' in dep) {\n                    dep.dirtyLevel = 0 /* DirtyLevels.None */;\n                }\n                else {\n                    dep.dirtyLevel = 3 /* DirtyLevels.Dirty */;\n                }\n                if (dep.deps !== undefined) {\n                    link = dep.deps;\n                    dep.depsTail.nextDep = nextDep;\n                    dep.deps = undefined;\n                    dep.depsTail = undefined;\n                    continue;\n                }\n            }\n            link = nextDep;\n        } while (link !== undefined);\n    }\n    Subscriber.clearTrack = clearTrack;\n})(Subscriber || (exports.Subscriber = Subscriber = {}));\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Computed = void 0;\nexports.computed = computed;\nconst system_js_1 = require(\"./system.js\");\nfunction computed(getter) {\n    return new Computed(getter);\n}\nclass Computed {\n    constructor(getter) {\n        this.getter = getter;\n        this.cachedValue = undefined;\n        // Dependency\n        this.subs = undefined;\n        this.subsTail = undefined;\n        // Subscriber\n        this.deps = undefined;\n        this.depsTail = undefined;\n        this.trackId = 0;\n        this.dirtyLevel = 3 /* DirtyLevels.Dirty */;\n        this.canPropagate = false;\n    }\n    get() {\n        let dirtyLevel = this.dirtyLevel;\n        if (dirtyLevel === 2 /* DirtyLevels.MaybeDirty */) {\n            system_js_1.Subscriber.resolveMaybeDirty(this);\n            dirtyLevel = this.dirtyLevel;\n        }\n        if (dirtyLevel >= 3 /* DirtyLevels.Dirty */) {\n            this.update();\n        }\n        const activeTrackId = system_js_1.System.activeTrackId;\n        if (activeTrackId !== 0) {\n            const subsTail = this.subsTail;\n            if (subsTail === undefined || subsTail.trackId !== activeTrackId) {\n                system_js_1.Dependency.link(this, system_js_1.System.activeSub);\n            }\n        }\n        return this.cachedValue;\n    }\n    update() {\n        const prevSub = system_js_1.Subscriber.startTrack(this);\n        const oldValue = this.cachedValue;\n        let newValue;\n        try {\n            newValue = this.getter(oldValue);\n        }\n        finally {\n            system_js_1.Subscriber.endTrack(this, prevSub);\n        }\n        if (oldValue !== newValue) {\n            this.cachedValue = newValue;\n            const subs = this.subs;\n            if (subs !== undefined) {\n                system_js_1.Dependency.propagate(subs);\n            }\n        }\n    }\n}\nexports.Computed = Computed;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EffectScope = exports.activeEffectScope = void 0;\nexports.effectScope = effectScope;\nconst system_js_1 = require(\"./system.js\");\nexports.activeEffectScope = undefined;\nfunction effectScope() {\n    return new EffectScope();\n}\nclass EffectScope {\n    constructor() {\n        // Subscriber\n        this.deps = undefined;\n        this.depsTail = undefined;\n        this.trackId = -(++system_js_1.System.lastTrackId);\n        this.dirtyLevel = 0 /* DirtyLevels.None */;\n        this.canPropagate = false;\n    }\n    notify() {\n        if (this.dirtyLevel !== 0 /* DirtyLevels.None */) {\n            this.dirtyLevel = 0 /* DirtyLevels.None */;\n            let link = this.deps;\n            while (link !== undefined) {\n                const dep = link.dep;\n                if ('notify' in dep) {\n                    dep.notify();\n                }\n                link = link.nextDep;\n            }\n        }\n    }\n    run(fn) {\n        const prevSub = exports.activeEffectScope;\n        exports.activeEffectScope = this;\n        this.trackId = Math.abs(this.trackId);\n        try {\n            return fn();\n        }\n        finally {\n            exports.activeEffectScope = prevSub;\n            this.trackId = -Math.abs(this.trackId);\n        }\n    }\n    stop() {\n        if (this.deps !== undefined) {\n            system_js_1.Subscriber.clearTrack(this.deps);\n            this.deps = undefined;\n            this.depsTail = undefined;\n        }\n        this.dirtyLevel = 0 /* DirtyLevels.None */;\n    }\n}\nexports.EffectScope = EffectScope;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Effect = void 0;\nexports.effect = effect;\nconst effectScope_js_1 = require(\"./effectScope.js\");\nconst system_js_1 = require(\"./system.js\");\nfunction effect(fn) {\n    const e = new Effect(fn);\n    e.run();\n    return e;\n}\nclass Effect {\n    constructor(fn) {\n        this.fn = fn;\n        this.nextNotify = undefined;\n        // Dependency\n        this.subs = undefined;\n        this.subsTail = undefined;\n        // Subscriber\n        this.deps = undefined;\n        this.depsTail = undefined;\n        this.trackId = 0;\n        this.dirtyLevel = 3 /* DirtyLevels.Dirty */;\n        this.canPropagate = false;\n        const activeTrackId = system_js_1.System.activeTrackId;\n        if (activeTrackId !== 0) {\n            system_js_1.Dependency.link(this, system_js_1.System.activeSub);\n            return;\n        }\n        if (effectScope_js_1.activeEffectScope !== undefined) {\n            const subsTail = this.subsTail;\n            if (subsTail === undefined || subsTail.trackId !== effectScope_js_1.activeEffectScope.trackId) {\n                system_js_1.Dependency.link(this, effectScope_js_1.activeEffectScope);\n            }\n        }\n    }\n    notify() {\n        let dirtyLevel = this.dirtyLevel;\n        if (dirtyLevel > 0 /* DirtyLevels.None */) {\n            if (dirtyLevel === 2 /* DirtyLevels.MaybeDirty */) {\n                system_js_1.Subscriber.resolveMaybeDirty(this);\n                dirtyLevel = this.dirtyLevel;\n            }\n            if (dirtyLevel === 3 /* DirtyLevels.Dirty */) {\n                this.run();\n            }\n            else {\n                this.dirtyLevel = 0 /* DirtyLevels.None */;\n                let link = this.deps;\n                while (link !== undefined) {\n                    const dep = link.dep;\n                    if ('notify' in dep) {\n                        dep.notify();\n                    }\n                    link = link.nextDep;\n                }\n            }\n        }\n    }\n    run() {\n        const prevSub = system_js_1.Subscriber.startTrack(this);\n        try {\n            return this.fn();\n        }\n        finally {\n            system_js_1.Subscriber.endTrack(this, prevSub);\n        }\n    }\n    stop() {\n        if (this.deps !== undefined) {\n            system_js_1.Subscriber.clearTrack(this.deps);\n            this.deps = undefined;\n            this.depsTail = undefined;\n        }\n        this.dirtyLevel = 3 /* DirtyLevels.Dirty */;\n    }\n}\nexports.Effect = Effect;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Signal = void 0;\nexports.signal = signal;\nconst system_js_1 = require(\"./system.js\");\nfunction signal(oldValue) {\n    return new Signal(oldValue);\n}\nclass Signal {\n    constructor(currentValue) {\n        this.currentValue = currentValue;\n        // Dependency\n        this.subs = undefined;\n        this.subsTail = undefined;\n    }\n    get() {\n        const activeTrackId = system_js_1.System.activeTrackId;\n        if (activeTrackId !== 0) {\n            const subsTail = this.subsTail;\n            if (subsTail === undefined || subsTail.trackId !== activeTrackId) {\n                system_js_1.Dependency.link(this, system_js_1.System.activeSub);\n            }\n        }\n        return this.currentValue;\n    }\n    set(value) {\n        if (this.currentValue !== (this.currentValue = value)) {\n            const subs = this.subs;\n            if (subs !== undefined) {\n                (0, system_js_1.startBatch)();\n                system_js_1.Dependency.propagate(subs);\n                (0, system_js_1.endBatch)();\n            }\n        }\n    }\n}\nexports.Signal = Signal;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computedArray = computedArray;\nconst index_js_1 = require(\"../index.js\");\nfunction computedArray(arr, getGetter) {\n    const length = (0, index_js_1.computed)(() => arr.get().length);\n    const keys = (0, index_js_1.computed)(() => {\n        const keys = [];\n        for (let i = 0; i < length.get(); i++) {\n            keys.push(String(i));\n        }\n        return keys;\n    });\n    const items = (0, index_js_1.computed)((array) => {\n        array ??= [];\n        while (array.length < length.get()) {\n            const index = array.length;\n            const item = (0, index_js_1.computed)(() => arr.get()[index]);\n            array.push((0, index_js_1.computed)(getGetter(item, index)));\n        }\n        if (array.length > length.get()) {\n            array.length = length.get();\n        }\n        return array;\n    });\n    return new Proxy({}, {\n        get(_, p, receiver) {\n            if (p === 'length') {\n                return length.get();\n            }\n            if (typeof p === 'string' && !isNaN(Number(p))) {\n                return items.get()[Number(p)]?.get();\n            }\n            return Reflect.get(items.get(), p, receiver);\n        },\n        has(_, p) {\n            return Reflect.has(items.get(), p);\n        },\n        ownKeys() {\n            return keys.get();\n        },\n    });\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computedSet = computedSet;\nconst index_js_1 = require(\"../index.js\");\nfunction computedSet(source) {\n    return (0, index_js_1.computed)((oldValue) => {\n        const newValue = source.get();\n        if (oldValue?.size === newValue.size && [...oldValue].every(c => newValue.has(c))) {\n            return oldValue;\n        }\n        return newValue;\n    });\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EqualityComputed = void 0;\nexports.equalityComputed = equalityComputed;\nconst index_js_1 = require(\"../index.js\");\nfunction equalityComputed(getter) {\n    return new EqualityComputed(getter);\n}\nclass EqualityComputed extends index_js_1.Computed {\n    constructor(getter) {\n        super(oldValue => {\n            const newValue = getter();\n            if (this.equals(oldValue, newValue)) {\n                return oldValue;\n            }\n            return newValue;\n        });\n    }\n    equals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (a === null || b === null || typeof a !== typeof b) {\n            return false;\n        }\n        if (typeof a === 'object') {\n            if (Array.isArray(a) && Array.isArray(b)) {\n                if (a.length !== b.length) {\n                    return false;\n                }\n                for (let i = 0; i < a.length; i++) {\n                    if (!this.equals(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            if (!Array.isArray(a) && !Array.isArray(b)) {\n                for (const key in a) {\n                    if (a.hasOwnProperty(key)) {\n                        if (!b.hasOwnProperty(key) || !this.equals(a[key], b[key])) {\n                            return false;\n                        }\n                    }\n                }\n                for (const key in b) {\n                    if (b.hasOwnProperty(key) && !a.hasOwnProperty(key)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false; // One is array and the other is not\n        }\n        return false;\n    }\n}\nexports.EqualityComputed = EqualityComputed;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./computedArray.js\"), exports);\n__exportStar(require(\"./computedSet.js\"), exports);\n__exportStar(require(\"./equalityComputed.js\"), exports);\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Unstable = void 0;\n__exportStar(require(\"./computed.js\"), exports);\n__exportStar(require(\"./effect.js\"), exports);\n__exportStar(require(\"./effectScope.js\"), exports);\n__exportStar(require(\"./signal.js\"), exports);\n__exportStar(require(\"./system.js\"), exports);\nexports.Unstable = require(\"./unstable/index.js\");\n", "// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateComponent = generateComponent;\nexports.generateComponentSetupReturns = generateComponentSetupReturns;\nexports.generateEmitsOption = generateEmitsOption;\nexports.generatePropsOption = generatePropsOption;\nconst common_1 = require(\"../common\");\nconst index_1 = require(\"./index\");\nfunction* generateComponent(options, ctx, scriptSetup, scriptSetupRanges) {\n    if (options.sfc.script && options.scriptRanges?.exportDefault && options.scriptRanges.exportDefault.expression.start !== options.scriptRanges.exportDefault.args.start) {\n        // use defineComponent() from user space code if it exist\n        yield (0, common_1.generateSfcBlockSection)(options.sfc.script, options.scriptRanges.exportDefault.expression.start, options.scriptRanges.exportDefault.args.start, index_1.codeFeatures.all);\n        yield `{${common_1.newLine}`;\n    }\n    else {\n        yield `(await import('${options.vueCompilerOptions.lib}')).defineComponent({${common_1.newLine}`;\n    }\n    yield `setup() {${common_1.newLine}`;\n    yield `return {${common_1.newLine}`;\n    if (ctx.bypassDefineComponent) {\n        yield* generateComponentSetupReturns(scriptSetupRanges);\n    }\n    if (scriptSetupRanges.expose.define) {\n        yield `...__VLS_exposed,${common_1.newLine}`;\n    }\n    yield `}${common_1.endOfLine}`;\n    yield `},${common_1.newLine}`;\n    if (!ctx.bypassDefineComponent) {\n        const emitOptionCodes = [...generateEmitsOption(options, scriptSetupRanges)];\n        for (const code of emitOptionCodes) {\n            yield code;\n        }\n        yield* generatePropsOption(options, ctx, scriptSetup, scriptSetupRanges, !!emitOptionCodes.length, true);\n    }\n    if (options.sfc.script && options.scriptRanges?.exportDefault?.args) {\n        const { args } = options.scriptRanges.exportDefault;\n        yield (0, common_1.generateSfcBlockSection)(options.sfc.script, args.start + 1, args.end - 1, index_1.codeFeatures.all);\n    }\n    if (options.vueCompilerOptions.target >= 3.5 && scriptSetupRanges.templateRefs.length) {\n        yield `__typeRefs: {} as __VLS_TemplateResult['refs'],${common_1.newLine}`;\n    }\n    if (options.vueCompilerOptions.target >= 3.5 && options.templateCodegen?.singleRootElType) {\n        yield `__typeEl: {} as __VLS_TemplateResult['rootEl'],${common_1.newLine}`;\n    }\n    yield `})`;\n}\nfunction* generateComponentSetupReturns(scriptSetupRanges) {\n    // fill $props\n    if (scriptSetupRanges.props.define) {\n        // NOTE: defineProps is inaccurate for $props\n        yield `$props: __VLS_makeOptional(${scriptSetupRanges.props.name ?? `__VLS_props`}),${common_1.newLine}`;\n        yield `...${scriptSetupRanges.props.name ?? `__VLS_props`},${common_1.newLine}`;\n    }\n    // fill $emit\n    if (scriptSetupRanges.emits.define) {\n        yield `$emit: ${scriptSetupRanges.emits.name ?? '__VLS_emit'},${common_1.newLine}`;\n    }\n}\nfunction* generateEmitsOption(options, scriptSetupRanges) {\n    const codes = [];\n    if (scriptSetupRanges.defineProp.some(p => p.isModel)) {\n        codes.push({\n            optionExp: `{} as __VLS_NormalizeEmits<typeof __VLS_modelEmit>`,\n            typeOptionType: `__VLS_ModelEmit`,\n        });\n    }\n    if (scriptSetupRanges.emits.define) {\n        const { typeArg, hasUnionTypeArg } = scriptSetupRanges.emits.define;\n        codes.push({\n            optionExp: `{} as __VLS_NormalizeEmits<typeof ${scriptSetupRanges.emits.name ?? '__VLS_emit'}>`,\n            typeOptionType: typeArg && !hasUnionTypeArg\n                ? `__VLS_Emit`\n                : undefined,\n        });\n    }\n    if (options.vueCompilerOptions.target >= 3.5 && codes.every(code => code.typeOptionType)) {\n        if (codes.length === 1) {\n            yield `__typeEmits: {} as `;\n            yield codes[0].typeOptionType;\n            yield `,${common_1.newLine}`;\n        }\n        else if (codes.length >= 2) {\n            yield `__typeEmits: {} as `;\n            yield codes[0].typeOptionType;\n            for (let i = 1; i < codes.length; i++) {\n                yield ` & `;\n                yield codes[i].typeOptionType;\n            }\n            yield `,${common_1.newLine}`;\n        }\n    }\n    else if (codes.every(code => code.optionExp)) {\n        if (codes.length === 1) {\n            yield `emits: `;\n            yield codes[0].optionExp;\n            yield `,${common_1.newLine}`;\n        }\n        else if (codes.length >= 2) {\n            yield `emits: {${common_1.newLine}`;\n            for (const code of codes) {\n                yield `...`;\n                yield code.optionExp;\n                yield `,${common_1.newLine}`;\n            }\n            yield `},${common_1.newLine}`;\n        }\n    }\n}\nfunction* generatePropsOption(options, ctx, scriptSetup, scriptSetupRanges, hasEmitsOption, inheritAttrs) {\n    const codes = [];\n    if (ctx.generatedPropsType) {\n        codes.push({\n            optionExp: [\n                `{} as `,\n                scriptSetupRanges.props.withDefaults?.arg ? `${ctx.localTypes.WithDefaults}<` : '',\n                `${ctx.localTypes.TypePropsToOption}<__VLS_PublicProps>`,\n                scriptSetupRanges.props.withDefaults?.arg ? `, typeof __VLS_withDefaultsArg>` : '',\n            ].join(''),\n            typeOptionExp: `{} as __VLS_PublicProps`,\n        });\n    }\n    if (scriptSetupRanges.props.define?.arg) {\n        const { arg } = scriptSetupRanges.props.define;\n        codes.push({\n            optionExp: (0, common_1.generateSfcBlockSection)(scriptSetup, arg.start, arg.end, index_1.codeFeatures.navigation),\n            typeOptionExp: undefined,\n        });\n    }\n    if (inheritAttrs && options.templateCodegen?.inheritedAttrVars.size) {\n        let attrsType = `__VLS_TemplateResult['attrs']`;\n        if (hasEmitsOption) {\n            attrsType = `Omit<${attrsType}, \\`on\\${string}\\`>`;\n        }\n        const propsType = `__VLS_PickNotAny<${ctx.localTypes.OmitIndexSignature}<${attrsType}>, {}>`;\n        const optionType = `${ctx.localTypes.TypePropsToOption}<${propsType}>`;\n        codes.unshift({\n            optionExp: codes.length\n                ? `{} as ${optionType}`\n                // workaround for https://github.com/vuejs/core/pull/7419\n                : `{} as keyof ${propsType} extends never ? never: ${optionType}`,\n            typeOptionExp: `{} as ${attrsType}`,\n        });\n    }\n    const useTypeOption = options.vueCompilerOptions.target >= 3.5 && codes.every(code => code.typeOptionExp);\n    const useOption = !useTypeOption || scriptSetupRanges.props.withDefaults;\n    if (useTypeOption) {\n        if (codes.length === 1) {\n            yield `__typeProps: `;\n            yield codes[0].typeOptionExp;\n            yield `,${common_1.newLine}`;\n        }\n        else if (codes.length >= 2) {\n            yield `__typeProps: {${common_1.newLine}`;\n            for (const { typeOptionExp } of codes) {\n                yield `...`;\n                yield typeOptionExp;\n                yield `,${common_1.newLine}`;\n            }\n            yield `},${common_1.newLine}`;\n        }\n    }\n    if (useOption) {\n        if (codes.length === 1) {\n            yield `props: `;\n            yield codes[0].optionExp;\n            yield `,${common_1.newLine}`;\n        }\n        else if (codes.length >= 2) {\n            yield `props: {${common_1.newLine}`;\n            for (const { optionExp } of codes) {\n                yield `...`;\n                yield optionExp;\n                yield `,${common_1.newLine}`;\n            }\n            yield `},${common_1.newLine}`;\n        }\n    }\n}\n//# sourceMappingURL=component.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateTemplateDirectives = generateTemplateDirectives;\nexports.generateTemplate = generateTemplate;\nexports.generateCssClassProperty = generateCssClassProperty;\nexports.getTemplateUsageVars = getTemplateUsageVars;\nconst path = require(\"path-browserify\");\nconst shared_1 = require(\"../../utils/shared\");\nconst common_1 = require(\"../common\");\nconst context_1 = require(\"../template/context\");\nconst interpolation_1 = require(\"../template/interpolation\");\nconst styleScopedClasses_1 = require(\"../template/styleScopedClasses\");\nconst index_1 = require(\"./index\");\nfunction* generateTemplateCtx(options) {\n    const exps = [];\n    exps.push(`{} as InstanceType<__VLS_PickNotAny<typeof __VLS_self, new () => {}>>`);\n    if (options.vueCompilerOptions.petiteVueExtensions.some(ext => options.fileName.endsWith(ext))) {\n        exps.push(`globalThis`);\n    }\n    if (options.sfc.styles.some(style => style.module)) {\n        exps.push(`{} as __VLS_StyleModules`);\n    }\n    yield `const __VLS_ctx = `;\n    if (exps.length === 1) {\n        yield exps[0];\n        yield `${common_1.endOfLine}`;\n    }\n    else {\n        yield `{${common_1.newLine}`;\n        for (const exp of exps) {\n            yield `...`;\n            yield exp;\n            yield `,${common_1.newLine}`;\n        }\n        yield `}${common_1.endOfLine}`;\n    }\n}\nfunction* generateTemplateComponents(options) {\n    const exps = [];\n    if (options.sfc.script && options.scriptRanges?.exportDefault?.componentsOption) {\n        const { componentsOption } = options.scriptRanges.exportDefault;\n        exps.push([\n            options.sfc.script.content.substring(componentsOption.start, componentsOption.end),\n            'script',\n            componentsOption.start,\n            index_1.codeFeatures.navigation,\n        ]);\n    }\n    let nameType;\n    if (options.sfc.script && options.scriptRanges?.exportDefault?.nameOption) {\n        const { nameOption } = options.scriptRanges.exportDefault;\n        nameType = options.sfc.script.content.substring(nameOption.start, nameOption.end);\n    }\n    else if (options.sfc.scriptSetup) {\n        const baseName = path.basename(options.fileName);\n        nameType = `'${options.scriptSetupRanges?.options.name ?? baseName.substring(0, baseName.lastIndexOf('.'))}'`;\n    }\n    if (nameType) {\n        exps.push(`{} as {\n\t\t\t[K in ${nameType}]: typeof __VLS_self\n\t\t\t\t& (new () => {\n\t\t\t\t\t${(0, shared_1.getSlotsPropertyName)(options.vueCompilerOptions.target)}: typeof ${options.scriptSetupRanges?.slots?.name ?? '__VLS_slots'}\n\t\t\t\t})\n\t\t}`);\n    }\n    exps.push(`{} as NonNullable<typeof __VLS_self extends { components: infer C } ? C : {}>`);\n    exps.push(`__VLS_ctx`);\n    yield `const __VLS_localComponents = {${common_1.newLine}`;\n    for (const type of exps) {\n        yield `...`;\n        yield type;\n        yield `,${common_1.newLine}`;\n    }\n    yield `}${common_1.endOfLine}`;\n    yield `let __VLS_components!: typeof __VLS_localComponents & __VLS_GlobalComponents${common_1.endOfLine}`;\n}\nfunction* generateTemplateDirectives(options) {\n    const exps = [];\n    if (options.sfc.script && options.scriptRanges?.exportDefault?.directivesOption) {\n        const { directivesOption } = options.scriptRanges.exportDefault;\n        exps.push([\n            options.sfc.script.content.substring(directivesOption.start, directivesOption.end),\n            'script',\n            directivesOption.start,\n            index_1.codeFeatures.navigation,\n        ]);\n    }\n    exps.push(`{} as NonNullable<typeof __VLS_self extends { directives: infer D } ? D : {}>`);\n    exps.push(`__VLS_ctx`);\n    yield `const __VLS_localDirectives = {${common_1.newLine}`;\n    for (const type of exps) {\n        yield `...`;\n        yield type;\n        yield `,${common_1.newLine}`;\n    }\n    yield `}${common_1.endOfLine}`;\n    yield `let __VLS_directives!: typeof __VLS_localDirectives & __VLS_GlobalDirectives${common_1.endOfLine}`;\n}\nfunction* generateTemplate(options, ctx) {\n    ctx.generatedTemplate = true;\n    const templateCodegenCtx = (0, context_1.createTemplateCodegenContext)({\n        scriptSetupBindingNames: new Set(),\n        edited: options.edited,\n    });\n    yield* generateTemplateCtx(options);\n    yield* generateTemplateComponents(options);\n    yield* generateTemplateDirectives(options);\n    yield* generateTemplateBody(options, templateCodegenCtx);\n    return templateCodegenCtx;\n}\nfunction* generateTemplateBody(options, templateCodegenCtx) {\n    const firstClasses = new Set();\n    yield `let __VLS_styleScopedClasses!: {}`;\n    for (let i = 0; i < options.sfc.styles.length; i++) {\n        const style = options.sfc.styles[i];\n        const option = options.vueCompilerOptions.experimentalResolveStyleCssClasses;\n        if (option === 'always' || (option === 'scoped' && style.scoped)) {\n            for (const className of style.classNames) {\n                if (firstClasses.has(className.text)) {\n                    templateCodegenCtx.scopedClasses.push({\n                        source: 'style_' + i,\n                        className: className.text.slice(1),\n                        offset: className.offset + 1\n                    });\n                    continue;\n                }\n                firstClasses.add(className.text);\n                yield* generateCssClassProperty(i, className.text, className.offset, 'boolean', true);\n            }\n        }\n    }\n    yield common_1.endOfLine;\n    yield* (0, styleScopedClasses_1.generateStyleScopedClasses)(templateCodegenCtx, true);\n    yield* generateCssVars(options, templateCodegenCtx);\n    if (options.templateCodegen) {\n        for (const code of options.templateCodegen.codes) {\n            yield code;\n        }\n    }\n    else {\n        yield `// no template${common_1.newLine}`;\n        if (!options.scriptSetupRanges?.slots.define) {\n            yield `const __VLS_slots = {}${common_1.endOfLine}`;\n        }\n        yield `const __VLS_inheritedAttrs = {}${common_1.endOfLine}`;\n        yield `const $refs = {}${common_1.endOfLine}`;\n        yield `const $el = {} as any${common_1.endOfLine}`;\n    }\n    yield `return {${common_1.newLine}`;\n    yield `\tattrs: {} as Partial<typeof __VLS_inheritedAttrs>,${common_1.newLine}`;\n    yield `\tslots: ${options.scriptSetupRanges?.slots.name ?? '__VLS_slots'},${common_1.newLine}`;\n    yield `\trefs: $refs,${common_1.newLine}`;\n    yield `\trootEl: $el,${common_1.newLine}`;\n    yield `}${common_1.endOfLine}`;\n}\nfunction* generateCssClassProperty(styleIndex, classNameWithDot, offset, propertyType, optional) {\n    yield `${common_1.newLine} & { `;\n    yield [\n        '',\n        'style_' + styleIndex,\n        offset,\n        index_1.codeFeatures.navigation,\n    ];\n    yield `'`;\n    yield [\n        classNameWithDot.substring(1),\n        'style_' + styleIndex,\n        offset + 1,\n        index_1.codeFeatures.navigation,\n    ];\n    yield `'`;\n    yield [\n        '',\n        'style_' + styleIndex,\n        offset + classNameWithDot.length,\n        index_1.codeFeatures.navigationWithoutRename,\n    ];\n    yield `${optional ? '?' : ''}: ${propertyType}`;\n    yield ` }`;\n}\nfunction* generateCssVars(options, ctx) {\n    if (!options.sfc.styles.length) {\n        return;\n    }\n    yield `// CSS variable injection ${common_1.newLine}`;\n    for (const style of options.sfc.styles) {\n        for (const cssBind of style.cssVars) {\n            for (const [segment, offset, onlyError] of (0, interpolation_1.forEachInterpolationSegment)(options.ts, undefined, undefined, ctx, cssBind.text, cssBind.offset, options.ts.createSourceFile('/a.txt', cssBind.text, 99))) {\n                if (offset === undefined) {\n                    yield segment;\n                }\n                else {\n                    yield [\n                        segment,\n                        style.name,\n                        cssBind.offset + offset,\n                        onlyError\n                            ? index_1.codeFeatures.navigation\n                            : index_1.codeFeatures.all,\n                    ];\n                }\n            }\n            yield common_1.endOfLine;\n        }\n    }\n    yield `// CSS variable injection end ${common_1.newLine}`;\n}\nfunction getTemplateUsageVars(options, ctx) {\n    const usageVars = new Set();\n    const components = new Set(options.sfc.template?.ast?.components);\n    if (options.templateCodegen) {\n        // fix import components unused report\n        for (const varName of ctx.bindingNames) {\n            if (components.has(varName) || components.has((0, shared_1.hyphenateTag)(varName))) {\n                usageVars.add(varName);\n            }\n        }\n        for (const component of components) {\n            if (component.indexOf('.') >= 0) {\n                usageVars.add(component.split('.')[0]);\n            }\n        }\n        for (const [varName] of options.templateCodegen.accessExternalVariables) {\n            usageVars.add(varName);\n        }\n    }\n    return usageVars;\n}\n//# sourceMappingURL=template.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateComponentSelf = generateComponentSelf;\nconst path = require(\"path-browserify\");\nconst common_1 = require(\"../common\");\nconst component_1 = require(\"./component\");\nconst index_1 = require(\"./index\");\nconst template_1 = require(\"./template\");\nfunction* generateComponentSelf(options, ctx, templateCodegenCtx) {\n    if (options.sfc.scriptSetup && options.scriptSetupRanges) {\n        yield `const __VLS_self = (await import('${options.vueCompilerOptions.lib}')).defineComponent({${common_1.newLine}`;\n        yield `setup() {${common_1.newLine}`;\n        yield `return {${common_1.newLine}`;\n        if (ctx.bypassDefineComponent) {\n            yield* (0, component_1.generateComponentSetupReturns)(options.scriptSetupRanges);\n        }\n        // bindings\n        const templateUsageVars = (0, template_1.getTemplateUsageVars)(options, ctx);\n        for (const [content, bindings] of [\n            [options.sfc.scriptSetup.content, options.scriptSetupRanges.bindings],\n            options.sfc.script && options.scriptRanges\n                ? [options.sfc.script.content, options.scriptRanges.bindings]\n                : ['', []],\n        ]) {\n            for (const expose of bindings) {\n                const varName = content.substring(expose.start, expose.end);\n                if (!templateUsageVars.has(varName) && !templateCodegenCtx.accessExternalVariables.has(varName)) {\n                    continue;\n                }\n                const templateOffset = options.getGeneratedLength();\n                yield `${varName}: ${varName} as typeof `;\n                const scriptOffset = options.getGeneratedLength();\n                yield `${varName},${common_1.newLine}`;\n                options.linkedCodeMappings.push({\n                    sourceOffsets: [scriptOffset],\n                    generatedOffsets: [templateOffset],\n                    lengths: [varName.length],\n                    data: undefined,\n                });\n            }\n        }\n        yield `}${common_1.endOfLine}`; // return {\n        yield `},${common_1.newLine}`; // setup() {\n        if (options.sfc.scriptSetup && options.scriptSetupRanges && !ctx.bypassDefineComponent) {\n            const emitOptionCodes = [...(0, component_1.generateEmitsOption)(options, options.scriptSetupRanges)];\n            for (const code of emitOptionCodes) {\n                yield code;\n            }\n            yield* (0, component_1.generatePropsOption)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges, !!emitOptionCodes.length, false);\n        }\n        if (options.sfc.script && options.scriptRanges?.exportDefault?.args) {\n            const { args } = options.scriptRanges.exportDefault;\n            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, args.start + 1, args.end - 1, index_1.codeFeatures.all);\n        }\n        yield `})${common_1.endOfLine}`; // defineComponent {\n    }\n    else if (options.sfc.script) {\n        yield `let __VLS_self!: typeof import('./${path.basename(options.fileName)}').default${common_1.endOfLine}`;\n    }\n    else {\n        yield `const __VLS_self = (await import('${options.vueCompilerOptions.lib}')).defineComponent({})${common_1.endOfLine}`;\n    }\n}\n//# sourceMappingURL=componentSelf.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLocalTypesGenerator = getLocalTypesGenerator;\nconst shared_1 = require(\"../utils/shared\");\nconst common_1 = require(\"./common\");\nfunction getLocalTypesGenerator(compilerOptions, vueCompilerOptions) {\n    const used = new Set();\n    const OmitKeepDiscriminatedUnion = defineHelper(`__VLS_OmitKeepDiscriminatedUnion`, () => `\ntype __VLS_OmitKeepDiscriminatedUnion<T, K extends keyof any> = T extends any\n\t? Pick<T, Exclude<keyof T, K>>\n\t: never;\n`.trimStart());\n    const WithDefaults = defineHelper(`__VLS_WithDefaults`, () => `\ntype __VLS_WithDefaults<P, D> = {\n\t[K in keyof Pick<P, keyof P>]: K extends keyof D\n\t\t? ${PrettifyLocal.name}<P[K] & { default: D[K]}>\n\t\t: P[K]\n};\n`.trimStart());\n    const PrettifyLocal = defineHelper(`__VLS_PrettifyLocal`, () => `type __VLS_PrettifyLocal<T> = { [K in keyof T]: T[K]; } & {}${common_1.endOfLine}`);\n    const WithTemplateSlots = defineHelper(`__VLS_WithTemplateSlots`, () => `\ntype __VLS_WithTemplateSlots<T, S> = T & {\n\tnew(): {\n\t\t${(0, shared_1.getSlotsPropertyName)(vueCompilerOptions.target)}: S;\n\t\t${vueCompilerOptions.jsxSlots ? `$props: ${PropsChildren.name}<S>;` : ''}\n\t}\n};\n`.trimStart());\n    const PropsChildren = defineHelper(`__VLS_PropsChildren`, () => `\ntype __VLS_PropsChildren<S> = {\n\t[K in keyof (\n\t\tboolean extends (\n\t\t\t// @ts-ignore\n\t\t\tJSX.ElementChildrenAttribute extends never\n\t\t\t\t? true\n\t\t\t\t: false\n\t\t)\n\t\t\t? never\n\t\t\t// @ts-ignore\n\t\t\t: JSX.ElementChildrenAttribute\n\t)]?: S;\n};\n`.trimStart());\n    const TypePropsToOption = defineHelper(`__VLS_TypePropsToOption`, () => compilerOptions.exactOptionalPropertyTypes ?\n        `\ntype __VLS_TypePropsToOption<T> = {\n\t[K in keyof T]-?: {} extends Pick<T, K>\n\t\t? { type: import('${vueCompilerOptions.lib}').PropType<T[K]> }\n\t\t: { type: import('${vueCompilerOptions.lib}').PropType<T[K]>, required: true }\n};\n`.trimStart() :\n        `\ntype __VLS_NonUndefinedable<T> = T extends undefined ? never : T;\ntype __VLS_TypePropsToOption<T> = {\n\t[K in keyof T]-?: {} extends Pick<T, K>\n\t\t? { type: import('${vueCompilerOptions.lib}').PropType<__VLS_NonUndefinedable<T[K]>> }\n\t\t: { type: import('${vueCompilerOptions.lib}').PropType<T[K]>, required: true }\n};\n`.trimStart());\n    const OmitIndexSignature = defineHelper(`__VLS_OmitIndexSignature`, () => `type __VLS_OmitIndexSignature<T> = { [K in keyof T as {} extends Record<K, unknown> ? never : K]: T[K]; }${common_1.endOfLine}`);\n    const helpers = {\n        [PrettifyLocal.name]: PrettifyLocal,\n        [OmitKeepDiscriminatedUnion.name]: OmitKeepDiscriminatedUnion,\n        [WithDefaults.name]: WithDefaults,\n        [WithTemplateSlots.name]: WithTemplateSlots,\n        [PropsChildren.name]: PropsChildren,\n        [TypePropsToOption.name]: TypePropsToOption,\n        [OmitIndexSignature.name]: OmitIndexSignature,\n    };\n    used.clear();\n    return {\n        generate,\n        getUsedNames() {\n            return used;\n        },\n        get PrettifyLocal() { return PrettifyLocal.name; },\n        get OmitKeepDiscriminatedUnion() { return OmitKeepDiscriminatedUnion.name; },\n        get WithDefaults() { return WithDefaults.name; },\n        get WithTemplateSlots() { return WithTemplateSlots.name; },\n        get PropsChildren() { return PropsChildren.name; },\n        get TypePropsToOption() { return TypePropsToOption.name; },\n        get OmitIndexSignature() { return OmitIndexSignature.name; },\n    };\n    function* generate(names) {\n        const generated = new Set();\n        while (names.length) {\n            used.clear();\n            for (const name of names) {\n                if (generated.has(name)) {\n                    continue;\n                }\n                const helper = helpers[name];\n                yield helper.generate();\n                generated.add(name);\n            }\n            names = [...used].filter(name => !generated.has(name));\n        }\n    }\n    function defineHelper(name, generate) {\n        return {\n            get name() {\n                used.add(name);\n                return name;\n            },\n            generate,\n        };\n    }\n}\n//# sourceMappingURL=localTypes.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createScriptCodegenContext = createScriptCodegenContext;\nconst localTypes_1 = require(\"../localTypes\");\nfunction createScriptCodegenContext(options) {\n    const localTypes = (0, localTypes_1.getLocalTypesGenerator)(options.compilerOptions, options.vueCompilerOptions);\n    const inlayHints = [];\n    return {\n        generatedTemplate: false,\n        generatedPropsType: false,\n        scriptSetupGeneratedOffset: undefined,\n        bypassDefineComponent: options.lang === 'js' || options.lang === 'jsx',\n        bindingNames: new Set([\n            ...options.scriptRanges?.bindings.map(range => options.sfc.script.content.substring(range.start, range.end)) ?? [],\n            ...options.scriptSetupRanges?.bindings.map(range => options.sfc.scriptSetup.content.substring(range.start, range.end)) ?? [],\n        ]),\n        localTypes,\n        inlayHints,\n    };\n}\n//# sourceMappingURL=context.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateScriptSetupImports = generateScriptSetupImports;\nexports.generateScriptSetup = generateScriptSetup;\nconst common_1 = require(\"../common\");\nconst component_1 = require(\"./component\");\nconst componentSelf_1 = require(\"./componentSelf\");\nconst index_1 = require(\"./index\");\nconst template_1 = require(\"./template\");\nfunction* generateScriptSetupImports(scriptSetup, scriptSetupRanges) {\n    yield [\n        scriptSetup.content.substring(0, Math.max(scriptSetupRanges.importSectionEndOffset, scriptSetupRanges.leadingCommentEndOffset)),\n        'scriptSetup',\n        0,\n        index_1.codeFeatures.all,\n    ];\n    yield common_1.newLine;\n}\nfunction* generateScriptSetup(options, ctx, scriptSetup, scriptSetupRanges) {\n    const definePropMirrors = new Map();\n    if (scriptSetup.generic) {\n        if (!options.scriptRanges?.exportDefault) {\n            if (options.sfc.scriptSetup) {\n                // #4569\n                yield [\n                    '',\n                    'scriptSetup',\n                    options.sfc.scriptSetup.content.length,\n                    index_1.codeFeatures.verification,\n                ];\n            }\n            yield `export default `;\n        }\n        yield `(<`;\n        yield [\n            scriptSetup.generic,\n            scriptSetup.name,\n            scriptSetup.genericOffset,\n            index_1.codeFeatures.all,\n        ];\n        if (!scriptSetup.generic.endsWith(`,`)) {\n            yield `,`;\n        }\n        yield `>(${common_1.newLine}`\n            + `\t__VLS_props: NonNullable<Awaited<typeof __VLS_setup>>['props'],${common_1.newLine}`\n            + `\t__VLS_ctx?: ${ctx.localTypes.PrettifyLocal}<Pick<NonNullable<Awaited<typeof __VLS_setup>>, 'attrs' | 'emit' | 'slots'>>,${common_1.newLine}` // use __VLS_Prettify for less dts code\n            + `\t__VLS_expose?: NonNullable<Awaited<typeof __VLS_setup>>['expose'],${common_1.newLine}`\n            + `\t__VLS_setup = (async () => {${common_1.newLine}`;\n        yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, undefined, definePropMirrors);\n        const emitTypes = [];\n        if (scriptSetupRanges.emits.define) {\n            emitTypes.push(`typeof ${scriptSetupRanges.emits.name ?? '__VLS_emit'}`);\n        }\n        if (scriptSetupRanges.defineProp.some(p => p.isModel)) {\n            emitTypes.push(`typeof __VLS_modelEmit`);\n        }\n        yield `\t\treturn {} as {${common_1.newLine}`\n            + `\t\t\tprops: ${ctx.localTypes.PrettifyLocal}<typeof __VLS_functionalComponentProps & __VLS_TemplateResult['attrs'] & __VLS_PublicProps> & __VLS_BuiltInPublicProps,${common_1.newLine}`\n            + `\t\t\texpose(exposed: import('${options.vueCompilerOptions.lib}').ShallowUnwrapRef<${scriptSetupRanges.expose.define ? 'typeof __VLS_exposed' : '{}'}>): void,${common_1.newLine}`\n            + `\t\t\tattrs: any,${common_1.newLine}`\n            + `\t\t\tslots: __VLS_TemplateResult['slots'],${common_1.newLine}`\n            + `\t\t\temit: ${emitTypes.length ? emitTypes.join(' & ') : `{}`},${common_1.newLine}`\n            + `\t\t}${common_1.endOfLine}`;\n        yield `\t})(),${common_1.newLine}`; // __VLS_setup = (async () => {\n        yield `) => ({} as import('${options.vueCompilerOptions.lib}').VNode & { __ctx?: Awaited<typeof __VLS_setup> }))`;\n    }\n    else if (!options.sfc.script) {\n        // no script block, generate script setup code at root\n        yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, 'export default', definePropMirrors);\n    }\n    else {\n        if (!options.scriptRanges?.exportDefault) {\n            yield `export default `;\n        }\n        yield `await (async () => {${common_1.newLine}`;\n        yield* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, 'return', definePropMirrors);\n        yield `})()`;\n    }\n    if (ctx.scriptSetupGeneratedOffset !== undefined) {\n        for (const defineProp of scriptSetupRanges.defineProp) {\n            if (!defineProp.localName) {\n                continue;\n            }\n            const [_, localName] = getPropAndLocalName(scriptSetup, defineProp);\n            const propMirror = definePropMirrors.get(localName);\n            if (propMirror !== undefined) {\n                options.linkedCodeMappings.push({\n                    sourceOffsets: [defineProp.localName.start + ctx.scriptSetupGeneratedOffset],\n                    generatedOffsets: [propMirror],\n                    lengths: [defineProp.localName.end - defineProp.localName.start],\n                    data: undefined,\n                });\n            }\n        }\n    }\n}\nfunction* generateSetupFunction(options, ctx, scriptSetup, scriptSetupRanges, syntax, definePropMirrors) {\n    if (options.vueCompilerOptions.target >= 3.3) {\n        yield `const { `;\n        for (const macro of Object.keys(options.vueCompilerOptions.macros)) {\n            if (!ctx.bindingNames.has(macro) && macro !== 'templateRef') {\n                yield macro + `, `;\n            }\n        }\n        yield `} = await import('${options.vueCompilerOptions.lib}')${common_1.endOfLine}`;\n    }\n    ctx.scriptSetupGeneratedOffset = options.getGeneratedLength() - scriptSetupRanges.importSectionEndOffset;\n    let setupCodeModifies = [];\n    if (scriptSetupRanges.props.define) {\n        setupCodeModifies.push(...generateDefineWithType(scriptSetup, scriptSetupRanges.props.name, scriptSetupRanges.props.define, scriptSetupRanges.props.withDefaults ?? scriptSetupRanges.props.define, '__VLS_props', '__VLS_Props'));\n    }\n    if (scriptSetupRanges.slots.define) {\n        if (scriptSetupRanges.slots.isObjectBindingPattern) {\n            setupCodeModifies.push([\n                [`__VLS_slots;\\nconst __VLS_slots = `],\n                scriptSetupRanges.slots.define.start,\n                scriptSetupRanges.slots.define.start,\n            ]);\n        }\n        else if (!scriptSetupRanges.slots.name) {\n            setupCodeModifies.push([[`const __VLS_slots = `], scriptSetupRanges.slots.define.start, scriptSetupRanges.slots.define.start]);\n        }\n    }\n    if (scriptSetupRanges.emits.define) {\n        setupCodeModifies.push(...generateDefineWithType(scriptSetup, scriptSetupRanges.emits.name, scriptSetupRanges.emits.define, scriptSetupRanges.emits.define, '__VLS_emit', '__VLS_Emit'));\n    }\n    if (scriptSetupRanges.expose.define) {\n        if (scriptSetupRanges.expose.define?.typeArg) {\n            setupCodeModifies.push([\n                [\n                    `let __VLS_exposed!: `,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.expose.define.typeArg.start, scriptSetupRanges.expose.define.typeArg.end, index_1.codeFeatures.navigation),\n                    `${common_1.endOfLine}`,\n                ],\n                scriptSetupRanges.expose.define.start,\n                scriptSetupRanges.expose.define.start,\n            ]);\n        }\n        else if (scriptSetupRanges.expose.define?.arg) {\n            setupCodeModifies.push([\n                [\n                    `const __VLS_exposed = `,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.expose.define.arg.start, scriptSetupRanges.expose.define.arg.end, index_1.codeFeatures.navigation),\n                    `${common_1.endOfLine}`,\n                ],\n                scriptSetupRanges.expose.define.start,\n                scriptSetupRanges.expose.define.start,\n            ]);\n        }\n        else {\n            setupCodeModifies.push([\n                [`const __VLS_exposed = {}${common_1.endOfLine}`],\n                scriptSetupRanges.expose.define.start,\n                scriptSetupRanges.expose.define.start,\n            ]);\n        }\n    }\n    if (scriptSetupRanges.cssModules.length) {\n        for (const { define } of scriptSetupRanges.cssModules) {\n            setupCodeModifies.push([\n                [`(`],\n                define.start,\n                define.start\n            ], [\n                define.arg ? [\n                    ` as Omit<__VLS_StyleModules, '$style'>[`,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, define.arg.start, define.arg.end, index_1.codeFeatures.all),\n                    `])`\n                ] : [\n                    ` as __VLS_StyleModules[`,\n                    ['', scriptSetup.name, define.exp.start, index_1.codeFeatures.verification],\n                    `'$style'`,\n                    ['', scriptSetup.name, define.exp.end, index_1.codeFeatures.verification],\n                    `])`\n                ],\n                define.end,\n                define.end\n            ]);\n        }\n    }\n    const isTs = options.lang !== 'js' && options.lang !== 'jsx';\n    for (const { define } of scriptSetupRanges.templateRefs) {\n        if (!define.arg) {\n            continue;\n        }\n        if (isTs) {\n            setupCodeModifies.push([\n                [\n                    `<__VLS_TemplateResult['refs'][`,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, define.arg.start, define.arg.end, index_1.codeFeatures.navigation),\n                    `], keyof __VLS_TemplateResult['refs']>`\n                ],\n                define.exp.end,\n                define.exp.end\n            ]);\n        }\n        else {\n            setupCodeModifies.push([\n                [`(`],\n                define.start,\n                define.start\n            ], [\n                [\n                    ` as __VLS_UseTemplateRef<__VLS_TemplateResult['refs'][`,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, define.arg.start, define.arg.end, index_1.codeFeatures.navigation),\n                    `]>)`\n                ],\n                define.end,\n                define.end\n            ]);\n        }\n    }\n    setupCodeModifies = setupCodeModifies.sort((a, b) => a[1] - b[1]);\n    let nextStart = scriptSetupRanges.importSectionEndOffset;\n    for (const [codes, start, end] of setupCodeModifies) {\n        yield (0, common_1.generateSfcBlockSection)(scriptSetup, nextStart, start, index_1.codeFeatures.all);\n        for (const code of codes) {\n            yield code;\n        }\n        nextStart = end;\n    }\n    yield (0, common_1.generateSfcBlockSection)(scriptSetup, nextStart, scriptSetup.content.length, index_1.codeFeatures.all);\n    yield* (0, index_1.generateScriptSectionPartiallyEnding)(scriptSetup.name, scriptSetup.content.length, '#3632/scriptSetup.vue');\n    if (scriptSetupRanges.props.define?.typeArg && scriptSetupRanges.props.withDefaults?.arg) {\n        // fix https://github.com/vuejs/language-tools/issues/1187\n        yield `const __VLS_withDefaultsArg = (function <T>(t: T) { return t })(`;\n        yield (0, common_1.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.props.withDefaults.arg.start, scriptSetupRanges.props.withDefaults.arg.end, index_1.codeFeatures.navigation);\n        yield `)${common_1.endOfLine}`;\n    }\n    yield* generateComponentProps(options, ctx, scriptSetup, scriptSetupRanges, definePropMirrors);\n    yield* generateModelEmit(scriptSetup, scriptSetupRanges);\n    yield `function __VLS_template() {${common_1.newLine}`;\n    const templateCodegenCtx = yield* (0, template_1.generateTemplate)(options, ctx);\n    yield `}${common_1.endOfLine}`;\n    yield* (0, componentSelf_1.generateComponentSelf)(options, ctx, templateCodegenCtx);\n    yield `type __VLS_TemplateResult = ReturnType<typeof __VLS_template>${common_1.endOfLine}`;\n    if (syntax) {\n        if (!options.vueCompilerOptions.skipTemplateCodegen && (options.templateCodegen?.hasSlot || scriptSetupRanges?.slots.define)) {\n            yield `const __VLS_component = `;\n            yield* (0, component_1.generateComponent)(options, ctx, scriptSetup, scriptSetupRanges);\n            yield common_1.endOfLine;\n            yield `${syntax} `;\n            yield `{} as ${ctx.localTypes.WithTemplateSlots}<typeof __VLS_component, __VLS_TemplateResult['slots']>${common_1.endOfLine}`;\n        }\n        else {\n            yield `${syntax} `;\n            yield* (0, component_1.generateComponent)(options, ctx, scriptSetup, scriptSetupRanges);\n            yield common_1.endOfLine;\n        }\n    }\n}\nfunction* generateDefineWithType(scriptSetup, name, define, expression, defaultName, typeName) {\n    const { statement, typeArg } = define;\n    if (typeArg) {\n        yield [[\n                `type ${typeName} = `,\n                (0, common_1.generateSfcBlockSection)(scriptSetup, typeArg.start, typeArg.end, index_1.codeFeatures.all),\n                common_1.endOfLine,\n            ], statement.start, statement.start];\n        yield [[typeName], typeArg.start, typeArg.end];\n    }\n    if (!name) {\n        if (statement.start === expression.start && statement.end === expression.end) {\n            yield [[`const ${defaultName} = `], expression.start, expression.start];\n        }\n        else if (typeArg) {\n            yield [[\n                    `const ${defaultName} = `,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, expression.start, typeArg.start, index_1.codeFeatures.all)\n                ], statement.start, typeArg.start];\n            yield [[\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, typeArg.end, expression.end, index_1.codeFeatures.all),\n                    common_1.endOfLine,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, statement.start, expression.start, index_1.codeFeatures.all),\n                    defaultName\n                ], typeArg.end, expression.end];\n        }\n        else {\n            yield [[\n                    `const ${defaultName} = `,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, expression.start, expression.end, index_1.codeFeatures.all),\n                    common_1.endOfLine,\n                    (0, common_1.generateSfcBlockSection)(scriptSetup, statement.start, expression.start, index_1.codeFeatures.all),\n                    defaultName\n                ], statement.start, expression.end];\n        }\n    }\n}\nfunction* generateComponentProps(options, ctx, scriptSetup, scriptSetupRanges, definePropMirrors) {\n    yield `const __VLS_fnComponent = (await import('${options.vueCompilerOptions.lib}')).defineComponent({${common_1.newLine}`;\n    if (scriptSetupRanges.props.define?.arg) {\n        yield `props: `;\n        yield (0, common_1.generateSfcBlockSection)(scriptSetup, scriptSetupRanges.props.define.arg.start, scriptSetupRanges.props.define.arg.end, index_1.codeFeatures.navigation);\n        yield `,${common_1.newLine}`;\n    }\n    yield* (0, component_1.generateEmitsOption)(options, scriptSetupRanges);\n    yield `})${common_1.endOfLine}`;\n    yield `type __VLS_BuiltInPublicProps = ${options.vueCompilerOptions.target >= 3.4\n        ? `import('${options.vueCompilerOptions.lib}').PublicProps;`\n        : options.vueCompilerOptions.target >= 3.0\n            ? `import('${options.vueCompilerOptions.lib}').VNodeProps\n\t\t\t\t\t& import('${options.vueCompilerOptions.lib}').AllowedComponentProps\n\t\t\t\t\t& import('${options.vueCompilerOptions.lib}').ComponentCustomProps;`\n            : `globalThis.JSX.IntrinsicAttributes;`}`;\n    yield common_1.endOfLine;\n    yield `let __VLS_functionalComponentProps!: `;\n    yield `${ctx.localTypes.OmitKeepDiscriminatedUnion}<InstanceType<typeof __VLS_fnComponent>['$props'], keyof __VLS_BuiltInPublicProps>`;\n    yield common_1.endOfLine;\n    if (scriptSetupRanges.defineProp.length) {\n        yield `const __VLS_defaults = {${common_1.newLine}`;\n        for (const defineProp of scriptSetupRanges.defineProp) {\n            if (defineProp.defaultValue) {\n                const [propName, localName] = getPropAndLocalName(scriptSetup, defineProp);\n                if (defineProp.name || defineProp.isModel) {\n                    yield propName;\n                }\n                else if (defineProp.localName) {\n                    yield localName;\n                }\n                else {\n                    continue;\n                }\n                yield `: `;\n                yield getRangeName(scriptSetup, defineProp.defaultValue);\n                yield `,${common_1.newLine}`;\n            }\n        }\n        yield `}${common_1.endOfLine}`;\n    }\n    yield `type __VLS_PublicProps = `;\n    if (scriptSetupRanges.slots.define && options.vueCompilerOptions.jsxSlots) {\n        if (ctx.generatedPropsType) {\n            yield ` & `;\n        }\n        ctx.generatedPropsType = true;\n        yield `${ctx.localTypes.PropsChildren}<typeof __VLS_slots>`;\n    }\n    if (scriptSetupRanges.defineProp.length) {\n        if (ctx.generatedPropsType) {\n            yield ` & `;\n        }\n        ctx.generatedPropsType = true;\n        yield `{${common_1.newLine}`;\n        for (const defineProp of scriptSetupRanges.defineProp) {\n            const [propName, localName] = getPropAndLocalName(scriptSetup, defineProp);\n            if (defineProp.isModel && !defineProp.name) {\n                yield propName;\n            }\n            else if (defineProp.name) {\n                // renaming support\n                yield (0, common_1.generateSfcBlockSection)(scriptSetup, defineProp.name.start, defineProp.name.end, index_1.codeFeatures.navigation);\n            }\n            else if (defineProp.localName) {\n                definePropMirrors.set(localName, options.getGeneratedLength());\n                yield localName;\n            }\n            else {\n                continue;\n            }\n            yield defineProp.required\n                ? `: `\n                : `?: `;\n            yield* generateDefinePropType(scriptSetup, propName, localName, defineProp);\n            yield `,${common_1.newLine}`;\n            if (defineProp.modifierType) {\n                let propModifierName = 'modelModifiers';\n                if (defineProp.name) {\n                    propModifierName = `${getRangeName(scriptSetup, defineProp.name, true)}Modifiers`;\n                }\n                const modifierType = getRangeName(scriptSetup, defineProp.modifierType);\n                definePropMirrors.set(propModifierName, options.getGeneratedLength());\n                yield `${propModifierName}?: Record<${modifierType}, true>,${common_1.endOfLine}`;\n            }\n        }\n        yield `}`;\n    }\n    if (scriptSetupRanges.props.define?.typeArg) {\n        if (ctx.generatedPropsType) {\n            yield ` & `;\n        }\n        ctx.generatedPropsType = true;\n        yield `__VLS_Props`;\n    }\n    if (!ctx.generatedPropsType) {\n        yield `{}`;\n    }\n    yield common_1.endOfLine;\n}\nfunction* generateModelEmit(scriptSetup, scriptSetupRanges) {\n    const defineModels = scriptSetupRanges.defineProp.filter(p => p.isModel);\n    if (defineModels.length) {\n        yield `type __VLS_ModelEmit = {${common_1.newLine}`;\n        for (const defineModel of defineModels) {\n            const [propName, localName] = getPropAndLocalName(scriptSetup, defineModel);\n            yield `'update:${propName}': [value:`;\n            yield* generateDefinePropType(scriptSetup, propName, localName, defineModel);\n            yield `]${common_1.endOfLine}`;\n        }\n        yield `}${common_1.endOfLine}`;\n        yield `const __VLS_modelEmit = defineEmits<__VLS_ModelEmit>()${common_1.endOfLine}`;\n    }\n}\nfunction* generateDefinePropType(scriptSetup, propName, localName, defineProp) {\n    if (defineProp.type) {\n        // Infer from defineProp<T>\n        yield getRangeName(scriptSetup, defineProp.type);\n    }\n    else if (defineProp.runtimeType && localName) {\n        // Infer from actual prop declaration code \n        yield `typeof ${localName}['value']`;\n    }\n    else if (defineProp.defaultValue && propName) {\n        // Infer from defineProp({default: T})\n        yield `typeof __VLS_defaults['${propName}']`;\n    }\n    else {\n        yield `any`;\n    }\n}\nfunction getPropAndLocalName(scriptSetup, defineProp) {\n    const localName = defineProp.localName\n        ? getRangeName(scriptSetup, defineProp.localName)\n        : undefined;\n    let propName = defineProp.name\n        ? getRangeName(scriptSetup, defineProp.name)\n        : defineProp.isModel\n            ? 'modelValue'\n            : localName;\n    if (defineProp.name) {\n        propName = propName.replace(/['\"]+/g, '');\n    }\n    return [propName, localName];\n}\nfunction getRangeName(scriptSetup, range, unwrap = false) {\n    const offset = unwrap ? 1 : 0;\n    return scriptSetup.content.substring(range.start + offset, range.end - offset);\n}\n//# sourceMappingURL=scriptSetup.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateSrc = generateSrc;\nconst common_1 = require(\"../common\");\nconst index_1 = require(\"./index\");\nfunction* generateSrc(script, src) {\n    if (src.endsWith('.d.ts')) {\n        src = src.substring(0, src.length - '.d.ts'.length);\n    }\n    else if (src.endsWith('.ts')) {\n        src = src.substring(0, src.length - '.ts'.length);\n    }\n    else if (src.endsWith('.tsx')) {\n        src = src.substring(0, src.length - '.tsx'.length) + '.jsx';\n    }\n    if (!src.endsWith('.js') && !src.endsWith('.jsx')) {\n        src = src + '.js';\n    }\n    yield `export * from `;\n    yield [\n        `'${src}'`,\n        'script',\n        script.srcOffset - 1,\n        {\n            ...index_1.codeFeatures.all,\n            navigation: src === script.src\n                ? true\n                : {\n                    shouldRename: () => false,\n                    resolveRenameEditText(newName) {\n                        if (newName.endsWith('.jsx') || newName.endsWith('.js')) {\n                            newName = newName.split('.').slice(0, -1).join('.');\n                        }\n                        if (script?.src?.endsWith('.d.ts')) {\n                            newName = newName + '.d.ts';\n                        }\n                        else if (script?.src?.endsWith('.ts')) {\n                            newName = newName + '.ts';\n                        }\n                        else if (script?.src?.endsWith('.tsx')) {\n                            newName = newName + '.tsx';\n                        }\n                        return newName;\n                    },\n                },\n        },\n    ];\n    yield common_1.endOfLine;\n    yield `export { default } from '${src}'${common_1.endOfLine}`;\n}\n//# sourceMappingURL=src.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateStyleModulesType = generateStyleModulesType;\nconst index_1 = require(\"./index\");\nconst template_1 = require(\"./template\");\nconst common_1 = require(\"../common\");\nfunction* generateStyleModulesType(options, ctx) {\n    const styles = options.sfc.styles.map((style, i) => [style, i]).filter(([style]) => style.module);\n    if (!styles.length && !options.scriptSetupRanges?.cssModules.length) {\n        return;\n    }\n    yield `type __VLS_StyleModules = {${common_1.newLine}`;\n    for (const [style, i] of styles) {\n        const { name, offset } = style.module;\n        if (offset) {\n            yield [\n                name,\n                'main',\n                offset + 1,\n                index_1.codeFeatures.all\n            ];\n        }\n        else {\n            yield name;\n        }\n        yield `: Record<string, string> & ${ctx.localTypes.PrettifyLocal}<{}`;\n        for (const className of style.classNames) {\n            yield* (0, template_1.generateCssClassProperty)(i, className.text, className.offset, 'string', false);\n        }\n        yield `>${common_1.endOfLine}`;\n    }\n    yield `}${common_1.endOfLine}`;\n}\n//# sourceMappingURL=styleModulesType.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.codeFeatures = void 0;\nexports.generateScript = generateScript;\nexports.generateScriptSectionPartiallyEnding = generateScriptSectionPartiallyEnding;\nconst path = require(\"path-browserify\");\nconst common_1 = require(\"../common\");\nconst globalTypes_1 = require(\"../globalTypes\");\nconst componentSelf_1 = require(\"./componentSelf\");\nconst context_1 = require(\"./context\");\nconst scriptSetup_1 = require(\"./scriptSetup\");\nconst src_1 = require(\"./src\");\nconst styleModulesType_1 = require(\"./styleModulesType\");\nconst template_1 = require(\"./template\");\nexports.codeFeatures = {\n    all: {\n        verification: true,\n        completion: true,\n        semantic: true,\n        navigation: true,\n    },\n    none: {},\n    verification: {\n        verification: true,\n    },\n    navigation: {\n        navigation: true,\n    },\n    navigationWithoutRename: {\n        navigation: {\n            shouldRename() {\n                return false;\n            },\n        },\n    },\n};\nfunction* generateScript(options) {\n    const ctx = (0, context_1.createScriptCodegenContext)(options);\n    if (options.vueCompilerOptions.__setupedGlobalTypes) {\n        const globalTypes = options.vueCompilerOptions.__setupedGlobalTypes;\n        if (typeof globalTypes === 'object') {\n            let relativePath = path.relative(path.dirname(options.fileName), globalTypes.absolutePath);\n            if (relativePath !== globalTypes.absolutePath && !relativePath.startsWith('./') && !relativePath.startsWith('../')) {\n                relativePath = './' + relativePath;\n            }\n            yield `/// <reference types=\"${relativePath}\" />${common_1.newLine}`;\n        }\n        else {\n            yield `/// <reference types=\".vue-global-types/${options.vueCompilerOptions.lib}_${options.vueCompilerOptions.target}_${options.vueCompilerOptions.strictTemplates}.d.ts\" />${common_1.newLine}`;\n        }\n    }\n    else {\n        yield `/* placeholder */`;\n    }\n    if (options.sfc.script?.src) {\n        yield* (0, src_1.generateSrc)(options.sfc.script, options.sfc.script.src);\n    }\n    if (options.sfc.script && options.scriptRanges) {\n        const { exportDefault, classBlockEnd } = options.scriptRanges;\n        const isExportRawObject = exportDefault\n            && options.sfc.script.content[exportDefault.expression.start] === '{';\n        if (options.sfc.scriptSetup && options.scriptSetupRanges) {\n            yield* (0, scriptSetup_1.generateScriptSetupImports)(options.sfc.scriptSetup, options.scriptSetupRanges);\n            yield* generateDefineProp(options, options.sfc.scriptSetup);\n            if (exportDefault) {\n                yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, exportDefault.expression.start, exports.codeFeatures.all);\n                yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);\n                yield (0, common_1.generateSfcBlockSection)(options.sfc.script, exportDefault.expression.end, options.sfc.script.content.length, exports.codeFeatures.all);\n            }\n            else {\n                yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, options.sfc.script.content.length, exports.codeFeatures.all);\n                yield* generateScriptSectionPartiallyEnding(options.sfc.script.name, options.sfc.script.content.length, '#3632/both.vue');\n                yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);\n            }\n        }\n        else if (exportDefault && isExportRawObject && options.vueCompilerOptions.optionsWrapper.length) {\n            ctx.inlayHints.push({\n                blockName: options.sfc.script.name,\n                offset: exportDefault.expression.start,\n                setting: 'vue.inlayHints.optionsWrapper',\n                label: options.vueCompilerOptions.optionsWrapper.length\n                    ? options.vueCompilerOptions.optionsWrapper[0]\n                    : '[Missing optionsWrapper[0]]',\n                tooltip: [\n                    'This is virtual code that is automatically wrapped for type support, it does not affect your runtime behavior, you can customize it via `vueCompilerOptions.optionsWrapper` option in tsconfig / jsconfig.',\n                    'To hide it, you can set `\"vue.inlayHints.optionsWrapper\": false` in IDE settings.',\n                ].join('\\n\\n'),\n            }, {\n                blockName: options.sfc.script.name,\n                offset: exportDefault.expression.end,\n                setting: 'vue.inlayHints.optionsWrapper',\n                label: options.vueCompilerOptions.optionsWrapper.length >= 2\n                    ? options.vueCompilerOptions.optionsWrapper[1]\n                    : '[Missing optionsWrapper[1]]',\n            });\n            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, exportDefault.expression.start, exports.codeFeatures.all);\n            yield options.vueCompilerOptions.optionsWrapper[0];\n            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, exportDefault.expression.start, exportDefault.expression.end, exports.codeFeatures.all);\n            yield options.vueCompilerOptions.optionsWrapper[1];\n            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, exportDefault.expression.end, options.sfc.script.content.length, exports.codeFeatures.all);\n        }\n        else if (classBlockEnd !== undefined) {\n            if (options.vueCompilerOptions.skipTemplateCodegen) {\n                yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, options.sfc.script.content.length, exports.codeFeatures.all);\n            }\n            else {\n                yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, classBlockEnd, exports.codeFeatures.all);\n                yield `__VLS_template = () => {${common_1.newLine}`;\n                const templateCodegenCtx = yield* (0, template_1.generateTemplate)(options, ctx);\n                yield* (0, componentSelf_1.generateComponentSelf)(options, ctx, templateCodegenCtx);\n                yield `}${common_1.endOfLine}`;\n                yield (0, common_1.generateSfcBlockSection)(options.sfc.script, classBlockEnd, options.sfc.script.content.length, exports.codeFeatures.all);\n            }\n        }\n        else {\n            yield (0, common_1.generateSfcBlockSection)(options.sfc.script, 0, options.sfc.script.content.length, exports.codeFeatures.all);\n        }\n    }\n    else if (options.sfc.scriptSetup && options.scriptSetupRanges) {\n        yield* (0, scriptSetup_1.generateScriptSetupImports)(options.sfc.scriptSetup, options.scriptSetupRanges);\n        yield* generateDefineProp(options, options.sfc.scriptSetup);\n        yield* (0, scriptSetup_1.generateScriptSetup)(options, ctx, options.sfc.scriptSetup, options.scriptSetupRanges);\n    }\n    if (options.sfc.script) {\n        yield* generateScriptSectionPartiallyEnding(options.sfc.script.name, options.sfc.script.content.length, '#3632/script.vue');\n    }\n    if (options.sfc.scriptSetup) {\n        yield* generateScriptSectionPartiallyEnding(options.sfc.scriptSetup.name, options.sfc.scriptSetup.content.length, '#4569/main.vue');\n    }\n    if (!ctx.generatedTemplate) {\n        yield `function __VLS_template() {${common_1.newLine}`;\n        const templateCodegenCtx = yield* (0, template_1.generateTemplate)(options, ctx);\n        yield `}${common_1.endOfLine}`;\n        yield* (0, componentSelf_1.generateComponentSelf)(options, ctx, templateCodegenCtx);\n    }\n    // #4788\n    yield* (0, styleModulesType_1.generateStyleModulesType)(options, ctx);\n    if (options.edited) {\n        yield `type __VLS_IntrinsicElementsCompletion = __VLS_IntrinsicElements${common_1.endOfLine}`;\n    }\n    yield* ctx.localTypes.generate([...ctx.localTypes.getUsedNames()]);\n    if (options.appendGlobalTypes) {\n        yield (0, globalTypes_1.generateGlobalTypes)(options.vueCompilerOptions.lib, options.vueCompilerOptions.target, options.vueCompilerOptions.strictTemplates);\n    }\n    if (options.sfc.scriptSetup) {\n        yield ['', 'scriptSetup', options.sfc.scriptSetup.content.length, exports.codeFeatures.verification];\n    }\n    return ctx;\n}\nfunction* generateScriptSectionPartiallyEnding(source, end, mark) {\n    yield `;`;\n    yield ['', source, end, exports.codeFeatures.verification];\n    yield `/* PartiallyEnd: ${mark} */${common_1.newLine}`;\n}\nfunction* generateDefineProp(options, scriptSetup) {\n    const definePropProposalA = scriptSetup.content.trimStart().startsWith('// @experimentalDefinePropProposal=kevinEdition') || options.vueCompilerOptions.experimentalDefinePropProposal === 'kevinEdition';\n    const definePropProposalB = scriptSetup.content.trimStart().startsWith('// @experimentalDefinePropProposal=johnsonEdition') || options.vueCompilerOptions.experimentalDefinePropProposal === 'johnsonEdition';\n    if (definePropProposalA || definePropProposalB) {\n        yield `type __VLS_PropOptions<T> = Exclude<import('${options.vueCompilerOptions.lib}').Prop<T>, import('${options.vueCompilerOptions.lib}').PropType<T>>${common_1.endOfLine}`;\n        if (definePropProposalA) {\n            yield `declare function defineProp<T>(name: string, options: ({ required: true } | { default: T }) & __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T>${common_1.endOfLine}`;\n            yield `declare function defineProp<T>(name?: string, options?: __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T | undefined>${common_1.endOfLine}`;\n        }\n        if (definePropProposalB) {\n            yield `declare function defineProp<T>(value: T | (() => T), required?: boolean, options?: __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T>${common_1.endOfLine}`;\n            yield `declare function defineProp<T>(value: T | (() => T) | undefined, required: true, options?: __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T>${common_1.endOfLine}`;\n            yield `declare function defineProp<T>(value?: T | (() => T), required?: boolean, options?: __VLS_PropOptions<T>): import('${options.vueCompilerOptions.lib}').ComputedRef<T | undefined>${common_1.endOfLine}`;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseScriptRanges = parseScriptRanges;\nconst scriptSetupRanges_1 = require(\"./scriptSetupRanges\");\nfunction parseScriptRanges(ts, ast, hasScriptSetup, withNode) {\n    let exportDefault;\n    let classBlockEnd;\n    const bindings = hasScriptSetup ? (0, scriptSetupRanges_1.parseBindingRanges)(ts, ast) : [];\n    ts.forEachChild(ast, raw => {\n        if (ts.isExportAssignment(raw)) {\n            let node = raw;\n            while (isAsExpression(node.expression) || ts.isParenthesizedExpression(node.expression)) { // fix https://github.com/vuejs/language-tools/issues/1882\n                node = node.expression;\n            }\n            let obj;\n            if (ts.isObjectLiteralExpression(node.expression)) {\n                obj = node.expression;\n            }\n            else if (ts.isCallExpression(node.expression) && node.expression.arguments.length) {\n                const arg0 = node.expression.arguments[0];\n                if (ts.isObjectLiteralExpression(arg0)) {\n                    obj = arg0;\n                }\n            }\n            if (obj) {\n                let componentsOptionNode;\n                let directivesOptionNode;\n                let nameOptionNode;\n                let inheritAttrsOption;\n                ts.forEachChild(obj, node => {\n                    if (ts.isPropertyAssignment(node) && ts.isIdentifier(node.name)) {\n                        const name = (0, scriptSetupRanges_1.getNodeText)(ts, node.name, ast);\n                        if (name === 'components' && ts.isObjectLiteralExpression(node.initializer)) {\n                            componentsOptionNode = node.initializer;\n                        }\n                        else if (name === 'directives' && ts.isObjectLiteralExpression(node.initializer)) {\n                            directivesOptionNode = node.initializer;\n                        }\n                        else if (name === 'name') {\n                            nameOptionNode = node.initializer;\n                        }\n                        else if (name === 'inheritAttrs') {\n                            inheritAttrsOption = (0, scriptSetupRanges_1.getNodeText)(ts, node.initializer, ast);\n                        }\n                    }\n                });\n                exportDefault = {\n                    ..._getStartEnd(raw),\n                    expression: _getStartEnd(node.expression),\n                    args: _getStartEnd(obj),\n                    argsNode: withNode ? obj : undefined,\n                    componentsOption: componentsOptionNode ? _getStartEnd(componentsOptionNode) : undefined,\n                    componentsOptionNode: withNode ? componentsOptionNode : undefined,\n                    directivesOption: directivesOptionNode ? _getStartEnd(directivesOptionNode) : undefined,\n                    nameOption: nameOptionNode ? _getStartEnd(nameOptionNode) : undefined,\n                    inheritAttrsOption,\n                };\n            }\n        }\n        if (ts.isClassDeclaration(raw)\n            && raw.modifiers?.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword)\n            && raw.modifiers?.some(mod => mod.kind === ts.SyntaxKind.DefaultKeyword)) {\n            classBlockEnd = raw.end - 1;\n        }\n    });\n    return {\n        exportDefault,\n        classBlockEnd,\n        bindings,\n    };\n    function _getStartEnd(node) {\n        return (0, scriptSetupRanges_1.getStartEnd)(ts, node, ast);\n    }\n    // isAsExpression is missing in tsc\n    function isAsExpression(node) {\n        return node.kind === ts.SyntaxKind.AsExpression;\n    }\n}\n//# sourceMappingURL=scriptRanges.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tsCodegen = void 0;\nconst alien_signals_1 = require(\"alien-signals\");\nconst script_1 = require(\"../codegen/script\");\nconst template_1 = require(\"../codegen/template\");\nconst scriptRanges_1 = require(\"../parsers/scriptRanges\");\nconst scriptSetupRanges_1 = require(\"../parsers/scriptSetupRanges\");\nexports.tsCodegen = new WeakMap();\nconst fileEditTimes = new Map();\nconst plugin = ctx => {\n    let appendedGlobalTypes = false;\n    return {\n        version: 2.1,\n        requiredCompilerOptions: [\n            'noPropertyAccessFromIndexSignature',\n            'exactOptionalPropertyTypes',\n        ],\n        getEmbeddedCodes(fileName, sfc) {\n            const tsx = useTsx(fileName, sfc);\n            const files = [];\n            if (['js', 'ts', 'jsx', 'tsx'].includes(tsx.lang.get())) {\n                files.push({ id: 'script_' + tsx.lang.get(), lang: tsx.lang.get() });\n            }\n            return files;\n        },\n        resolveEmbeddedCode(fileName, sfc, embeddedFile) {\n            const _tsx = useTsx(fileName, sfc);\n            if (/script_(js|jsx|ts|tsx)/.test(embeddedFile.id)) {\n                const tsx = _tsx.generatedScript.get();\n                if (tsx) {\n                    const content = [...tsx.codes];\n                    embeddedFile.content = content;\n                    embeddedFile.linkedCodeMappings = [...tsx.linkedCodeMappings];\n                }\n            }\n        },\n    };\n    function useTsx(fileName, sfc) {\n        if (!exports.tsCodegen.has(sfc)) {\n            let appendGlobalTypes = false;\n            if (!ctx.vueCompilerOptions.__setupedGlobalTypes && !appendedGlobalTypes) {\n                appendGlobalTypes = true;\n                appendedGlobalTypes = true;\n            }\n            exports.tsCodegen.set(sfc, createTsx(fileName, sfc, ctx, appendGlobalTypes));\n        }\n        return exports.tsCodegen.get(sfc);\n    }\n};\nexports.default = plugin;\nfunction createTsx(fileName, _sfc, ctx, appendGlobalTypes) {\n    const ts = ctx.modules.typescript;\n    const lang = (0, alien_signals_1.computed)(() => {\n        return !_sfc.script && !_sfc.scriptSetup ? 'ts'\n            : _sfc.scriptSetup && _sfc.scriptSetup.lang !== 'js' ? _sfc.scriptSetup.lang\n                : _sfc.script && _sfc.script.lang !== 'js' ? _sfc.script.lang\n                    : 'js';\n    });\n    const scriptRanges = (0, alien_signals_1.computed)(() => _sfc.script\n        ? (0, scriptRanges_1.parseScriptRanges)(ts, _sfc.script.ast, !!_sfc.scriptSetup, false)\n        : undefined);\n    const scriptSetupRanges = (0, alien_signals_1.computed)(() => _sfc.scriptSetup\n        ? (0, scriptSetupRanges_1.parseScriptSetupRanges)(ts, _sfc.scriptSetup.ast, ctx.vueCompilerOptions)\n        : undefined);\n    const generatedTemplate = (0, alien_signals_1.computed)(() => {\n        if (ctx.vueCompilerOptions.skipTemplateCodegen || !_sfc.template) {\n            return;\n        }\n        const codes = [];\n        const codegen = (0, template_1.generateTemplate)({\n            ts,\n            compilerOptions: ctx.compilerOptions,\n            vueCompilerOptions: ctx.vueCompilerOptions,\n            template: _sfc.template,\n            edited: ctx.vueCompilerOptions.__test || (fileEditTimes.get(fileName) ?? 0) >= 2,\n            scriptSetupBindingNames: scriptSetupBindingNames.get(),\n            scriptSetupImportComponentNames: scriptSetupImportComponentNames.get(),\n            destructuredPropNames: destructuredPropNames.get(),\n            templateRefNames: templateRefNames.get(),\n            hasDefineSlots: hasDefineSlots.get(),\n            slotsAssignName: slotsAssignName.get(),\n            propsAssignName: propsAssignName.get(),\n            inheritAttrs: inheritAttrs.get(),\n        });\n        let current = codegen.next();\n        while (!current.done) {\n            const code = current.value;\n            codes.push(code);\n            current = codegen.next();\n        }\n        return {\n            ...current.value,\n            codes: codes,\n        };\n    });\n    const scriptSetupBindingNames = (0, alien_signals_1.computed)(oldNames => {\n        const newNames = new Set();\n        const bindings = scriptSetupRanges.get()?.bindings;\n        if (_sfc.scriptSetup && bindings) {\n            for (const binding of bindings) {\n                newNames.add(_sfc.scriptSetup?.content.substring(binding.start, binding.end));\n            }\n        }\n        if (newNames && oldNames && twoSetsEqual(newNames, oldNames)) {\n            return oldNames;\n        }\n        return newNames;\n    });\n    const scriptSetupImportComponentNames = (0, alien_signals_1.computed)(oldNames => {\n        const newNames = scriptSetupRanges.get()?.importComponentNames ?? new Set();\n        if (oldNames && twoSetsEqual(newNames, oldNames)) {\n            return oldNames;\n        }\n        return newNames;\n    });\n    const destructuredPropNames = (0, alien_signals_1.computed)(oldNames => {\n        const newNames = scriptSetupRanges.get()?.props.destructured ?? new Set();\n        const rest = scriptSetupRanges.get()?.props.destructuredRest;\n        if (rest) {\n            newNames.add(rest);\n        }\n        if (oldNames && twoSetsEqual(newNames, oldNames)) {\n            return oldNames;\n        }\n        return newNames;\n    });\n    const templateRefNames = (0, alien_signals_1.computed)(oldNames => {\n        const newNames = new Set(scriptSetupRanges.get()?.templateRefs\n            .map(({ name }) => name)\n            .filter(name => name !== undefined));\n        if (oldNames && twoSetsEqual(newNames, oldNames)) {\n            return oldNames;\n        }\n        return newNames;\n    });\n    const hasDefineSlots = (0, alien_signals_1.computed)(() => !!scriptSetupRanges.get()?.slots.define);\n    const slotsAssignName = (0, alien_signals_1.computed)(() => scriptSetupRanges.get()?.slots.name);\n    const propsAssignName = (0, alien_signals_1.computed)(() => scriptSetupRanges.get()?.props.name);\n    const inheritAttrs = (0, alien_signals_1.computed)(() => {\n        const value = scriptSetupRanges.get()?.options.inheritAttrs ?? scriptRanges.get()?.exportDefault?.inheritAttrsOption;\n        return value !== 'false';\n    });\n    const generatedScript = (0, alien_signals_1.computed)(() => {\n        const codes = [];\n        const linkedCodeMappings = [];\n        let generatedLength = 0;\n        const codegen = (0, script_1.generateScript)({\n            ts,\n            fileName,\n            sfc: _sfc,\n            lang: lang.get(),\n            scriptRanges: scriptRanges.get(),\n            scriptSetupRanges: scriptSetupRanges.get(),\n            templateCodegen: generatedTemplate.get(),\n            compilerOptions: ctx.compilerOptions,\n            vueCompilerOptions: ctx.vueCompilerOptions,\n            edited: ctx.vueCompilerOptions.__test || (fileEditTimes.get(fileName) ?? 0) >= 2,\n            getGeneratedLength: () => generatedLength,\n            linkedCodeMappings,\n            appendGlobalTypes,\n        });\n        fileEditTimes.set(fileName, (fileEditTimes.get(fileName) ?? 0) + 1);\n        let current = codegen.next();\n        while (!current.done) {\n            const code = current.value;\n            codes.push(code);\n            generatedLength += typeof code === 'string'\n                ? code.length\n                : code[0].length;\n            current = codegen.next();\n        }\n        return {\n            ...current.value,\n            codes,\n            linkedCodeMappings,\n        };\n    });\n    return {\n        scriptRanges,\n        scriptSetupRanges,\n        lang,\n        generatedScript,\n        generatedTemplate,\n    };\n}\nfunction twoSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const file of a) {\n        if (!b.has(file)) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=vue-tsx.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validVersions = void 0;\nexports.validVersions = [2, 2.1];\n//# sourceMappingURL=types.js.map", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createPlugins = createPlugins;\nconst file_html_1 = require(\"./plugins/file-html\");\nconst file_md_1 = require(\"./plugins/file-md\");\nconst file_vue_1 = require(\"./plugins/file-vue\");\nconst vue_root_tags_1 = require(\"./plugins/vue-root-tags\");\nconst vue_script_js_1 = require(\"./plugins/vue-script-js\");\nconst vue_sfc_customblocks_1 = require(\"./plugins/vue-sfc-customblocks\");\nconst vue_sfc_scripts_1 = require(\"./plugins/vue-sfc-scripts\");\nconst vue_sfc_styles_1 = require(\"./plugins/vue-sfc-styles\");\nconst vue_sfc_template_1 = require(\"./plugins/vue-sfc-template\");\nconst vue_template_html_1 = require(\"./plugins/vue-template-html\");\nconst vue_template_inline_css_1 = require(\"./plugins/vue-template-inline-css\");\nconst vue_template_inline_ts_1 = require(\"./plugins/vue-template-inline-ts\");\nconst vue_tsx_1 = require(\"./plugins/vue-tsx\");\nconst types_1 = require(\"./types\");\n__exportStar(require(\"./plugins/shared\"), exports);\nfunction createPlugins(pluginContext) {\n    const plugins = [\n        file_vue_1.default,\n        file_md_1.default,\n        file_html_1.default,\n        vue_root_tags_1.default,\n        vue_script_js_1.default,\n        vue_template_html_1.default,\n        vue_template_inline_css_1.default,\n        vue_template_inline_ts_1.default,\n        vue_sfc_styles_1.default,\n        vue_sfc_customblocks_1.default,\n        vue_sfc_scripts_1.default,\n        vue_sfc_template_1.default,\n        vue_tsx_1.default,\n        ...pluginContext.vueCompilerOptions.plugins,\n    ];\n    const pluginInstances = plugins\n        .flatMap(plugin => {\n        try {\n            const instance = plugin(pluginContext);\n            const moduleName = plugin.__moduleName;\n            if (Array.isArray(instance)) {\n                for (let i = 0; i < instance.length; i++) {\n                    instance[i].name ??= `${moduleName} (${i})`;\n                }\n            }\n            else {\n                instance.name ??= moduleName;\n            }\n            return instance;\n        }\n        catch (err) {\n            console.warn('[Vue] Failed to create plugin', err);\n        }\n    })\n        .filter(plugin => !!plugin)\n        .sort((a, b) => {\n        const aOrder = a.order ?? 0;\n        const bOrder = b.order ?? 0;\n        return aOrder - bOrder;\n    });\n    return pluginInstances.filter(plugin => {\n        if (!types_1.validVersions.includes(plugin.version)) {\n            console.warn(`[Vue] Plugin ${plugin.name} is not compatible with the current Vue language tools version. (version: ${plugin.version}, supported versions: ${JSON.stringify(types_1.validVersions)})`);\n            return false;\n        }\n        return true;\n    });\n}\n//# sourceMappingURL=plugins.js.map", "var splitRE = /\\r?\\n/g\nvar emptyRE = /^\\s*$/\nvar needFixRE = /^(\\r?\\n)*[\\t\\s]/\n\nmodule.exports = function deindent (str) {\n  if (!needFixRE.test(str)) {\n    return str\n  }\n  var lines = str.split(splitRE)\n  var min = Infinity\n  var type, cur, c\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i]\n    if (!emptyRE.test(line)) {\n      if (!type) {\n        c = line.charAt(0)\n        if (c === ' ' || c === '\\t') {\n          type = c\n          cur = count(line, type)\n          if (cur < min) {\n            min = cur\n          }\n        } else {\n          return str\n        }\n      } else {\n        cur = count(line, type)\n        if (cur < min) {\n          min = cur\n        }\n      }\n    }\n  }\n  return lines.map(function (line) {\n    return line.slice(min)\n  }).join('\\n')\n}\n\nfunction count (line, type) {\n  var i = 0\n  while (line.charAt(i) === type) {\n    i++\n  }\n  return i\n}\n", "/*! https://mths.be/he v1.2.0 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// All astral symbols.\n\tvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t// All ASCII symbols (not just printable ASCII) except those listed in the\n\t// first column of the overrides table.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\n\tvar regexAsciiWhitelist = /[\\x01-\\x7F]/g;\n\t// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or\n\t// code points listed in the first column of the overrides table on\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.\n\tvar regexBmpWhitelist = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g;\n\n\tvar regexEncodeNonAscii = /<\\u20D2|=\\u20E5|>\\u20D2|\\u205F\\u200A|\\u219D\\u0338|\\u2202\\u0338|\\u2220\\u20D2|\\u2229\\uFE00|\\u222A\\uFE00|\\u223C\\u20D2|\\u223D\\u0331|\\u223E\\u0333|\\u2242\\u0338|\\u224B\\u0338|\\u224D\\u20D2|\\u224E\\u0338|\\u224F\\u0338|\\u2250\\u0338|\\u2261\\u20E5|\\u2264\\u20D2|\\u2265\\u20D2|\\u2266\\u0338|\\u2267\\u0338|\\u2268\\uFE00|\\u2269\\uFE00|\\u226A\\u0338|\\u226A\\u20D2|\\u226B\\u0338|\\u226B\\u20D2|\\u227F\\u0338|\\u2282\\u20D2|\\u2283\\u20D2|\\u228A\\uFE00|\\u228B\\uFE00|\\u228F\\u0338|\\u2290\\u0338|\\u2293\\uFE00|\\u2294\\uFE00|\\u22B4\\u20D2|\\u22B5\\u20D2|\\u22D8\\u0338|\\u22D9\\u0338|\\u22DA\\uFE00|\\u22DB\\uFE00|\\u22F5\\u0338|\\u22F9\\u0338|\\u2933\\u0338|\\u29CF\\u0338|\\u29D0\\u0338|\\u2A6D\\u0338|\\u2A70\\u0338|\\u2A7D\\u0338|\\u2A7E\\u0338|\\u2AA1\\u0338|\\u2AA2\\u0338|\\u2AAC\\uFE00|\\u2AAD\\uFE00|\\u2AAF\\u0338|\\u2AB0\\u0338|\\u2AC5\\u0338|\\u2AC6\\u0338|\\u2ACB\\uFE00|\\u2ACC\\uFE00|\\u2AFD\\u20E5|[\\xA0-\\u0113\\u0116-\\u0122\\u0124-\\u012B\\u012E-\\u014D\\u0150-\\u017E\\u0192\\u01B5\\u01F5\\u0237\\u02C6\\u02C7\\u02D8-\\u02DD\\u0311\\u0391-\\u03A1\\u03A3-\\u03A9\\u03B1-\\u03C9\\u03D1\\u03D2\\u03D5\\u03D6\\u03DC\\u03DD\\u03F0\\u03F1\\u03F5\\u03F6\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E\\u045F\\u2002-\\u2005\\u2007-\\u2010\\u2013-\\u2016\\u2018-\\u201A\\u201C-\\u201E\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203A\\u203E\\u2041\\u2043\\u2044\\u204F\\u2057\\u205F-\\u2063\\u20AC\\u20DB\\u20DC\\u2102\\u2105\\u210A-\\u2113\\u2115-\\u211E\\u2122\\u2124\\u2127-\\u2129\\u212C\\u212D\\u212F-\\u2131\\u2133-\\u2138\\u2145-\\u2148\\u2153-\\u215E\\u2190-\\u219B\\u219D-\\u21A7\\u21A9-\\u21AE\\u21B0-\\u21B3\\u21B5-\\u21B7\\u21BA-\\u21DB\\u21DD\\u21E4\\u21E5\\u21F5\\u21FD-\\u2205\\u2207-\\u2209\\u220B\\u220C\\u220F-\\u2214\\u2216-\\u2218\\u221A\\u221D-\\u2238\\u223A-\\u2257\\u2259\\u225A\\u225C\\u225F-\\u2262\\u2264-\\u228B\\u228D-\\u229B\\u229D-\\u22A5\\u22A7-\\u22B0\\u22B2-\\u22BB\\u22BD-\\u22DB\\u22DE-\\u22E3\\u22E6-\\u22F7\\u22F9-\\u22FE\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231C-\\u231F\\u2322\\u2323\\u232D\\u232E\\u2336\\u233D\\u233F\\u237C\\u23B0\\u23B1\\u23B4-\\u23B6\\u23DC-\\u23DF\\u23E2\\u23E7\\u2423\\u24C8\\u2500\\u2502\\u250C\\u2510\\u2514\\u2518\\u251C\\u2524\\u252C\\u2534\\u253C\\u2550-\\u256C\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25A1\\u25AA\\u25AB\\u25AD\\u25AE\\u25B1\\u25B3-\\u25B5\\u25B8\\u25B9\\u25BD-\\u25BF\\u25C2\\u25C3\\u25CA\\u25CB\\u25EC\\u25EF\\u25F8-\\u25FC\\u2605\\u2606\\u260E\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266A\\u266D-\\u266F\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u27C8\\u27C9\\u27E6-\\u27ED\\u27F5-\\u27FA\\u27FC\\u27FF\\u2902-\\u2905\\u290C-\\u2913\\u2916\\u2919-\\u2920\\u2923-\\u292A\\u2933\\u2935-\\u2939\\u293C\\u293D\\u2945\\u2948-\\u294B\\u294E-\\u2976\\u2978\\u2979\\u297B-\\u297F\\u2985\\u2986\\u298B-\\u2996\\u299A\\u299C\\u299D\\u29A4-\\u29B7\\u29B9\\u29BB\\u29BC\\u29BE-\\u29C5\\u29C9\\u29CD-\\u29D0\\u29DC-\\u29DE\\u29E3-\\u29E5\\u29EB\\u29F4\\u29F6\\u2A00-\\u2A02\\u2A04\\u2A06\\u2A0C\\u2A0D\\u2A10-\\u2A17\\u2A22-\\u2A27\\u2A29\\u2A2A\\u2A2D-\\u2A31\\u2A33-\\u2A3C\\u2A3F\\u2A40\\u2A42-\\u2A4D\\u2A50\\u2A53-\\u2A58\\u2A5A-\\u2A5D\\u2A5F\\u2A66\\u2A6A\\u2A6D-\\u2A75\\u2A77-\\u2A9A\\u2A9D-\\u2AA2\\u2AA4-\\u2AB0\\u2AB3-\\u2AC8\\u2ACB\\u2ACC\\u2ACF-\\u2ADB\\u2AE4\\u2AE6-\\u2AE9\\u2AEB-\\u2AF3\\u2AFD\\uFB00-\\uFB04]|\\uD835[\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDD6B]/g;\n\tvar encodeMap = {'\\xAD':'shy','\\u200C':'zwnj','\\u200D':'zwj','\\u200E':'lrm','\\u2063':'ic','\\u2062':'it','\\u2061':'af','\\u200F':'rlm','\\u200B':'ZeroWidthSpace','\\u2060':'NoBreak','\\u0311':'DownBreve','\\u20DB':'tdot','\\u20DC':'DotDot','\\t':'Tab','\\n':'NewLine','\\u2008':'puncsp','\\u205F':'MediumSpace','\\u2009':'thinsp','\\u200A':'hairsp','\\u2004':'emsp13','\\u2002':'ensp','\\u2005':'emsp14','\\u2003':'emsp','\\u2007':'numsp','\\xA0':'nbsp','\\u205F\\u200A':'ThickSpace','\\u203E':'oline','_':'lowbar','\\u2010':'dash','\\u2013':'ndash','\\u2014':'mdash','\\u2015':'horbar',',':'comma',';':'semi','\\u204F':'bsemi',':':'colon','\\u2A74':'Colone','!':'excl','\\xA1':'iexcl','?':'quest','\\xBF':'iquest','.':'period','\\u2025':'nldr','\\u2026':'mldr','\\xB7':'middot','\\'':'apos','\\u2018':'lsquo','\\u2019':'rsquo','\\u201A':'sbquo','\\u2039':'lsaquo','\\u203A':'rsaquo','\"':'quot','\\u201C':'ldquo','\\u201D':'rdquo','\\u201E':'bdquo','\\xAB':'laquo','\\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\\u2308':'lceil','\\u2309':'rceil','\\u230A':'lfloor','\\u230B':'rfloor','\\u2985':'lopar','\\u2986':'ropar','\\u298B':'lbrke','\\u298C':'rbrke','\\u298D':'lbrkslu','\\u298E':'rbrksld','\\u298F':'lbrksld','\\u2990':'rbrkslu','\\u2991':'langd','\\u2992':'rangd','\\u2993':'lparlt','\\u2994':'rpargt','\\u2995':'gtlPar','\\u2996':'ltrPar','\\u27E6':'lobrk','\\u27E7':'robrk','\\u27E8':'lang','\\u27E9':'rang','\\u27EA':'Lang','\\u27EB':'Rang','\\u27EC':'loang','\\u27ED':'roang','\\u2772':'lbbrk','\\u2773':'rbbrk','\\u2016':'Vert','\\xA7':'sect','\\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\\u2030':'permil','\\u2031':'pertenk','\\u2020':'dagger','\\u2021':'Dagger','\\u2022':'bull','\\u2043':'hybull','\\u2032':'prime','\\u2033':'Prime','\\u2034':'tprime','\\u2057':'qprime','\\u2035':'bprime','\\u2041':'caret','`':'grave','\\xB4':'acute','\\u02DC':'tilde','^':'Hat','\\xAF':'macr','\\u02D8':'breve','\\u02D9':'dot','\\xA8':'die','\\u02DA':'ring','\\u02DD':'dblac','\\xB8':'cedil','\\u02DB':'ogon','\\u02C6':'circ','\\u02C7':'caron','\\xB0':'deg','\\xA9':'copy','\\xAE':'reg','\\u2117':'copysr','\\u2118':'wp','\\u211E':'rx','\\u2127':'mho','\\u2129':'iiota','\\u2190':'larr','\\u219A':'nlarr','\\u2192':'rarr','\\u219B':'nrarr','\\u2191':'uarr','\\u2193':'darr','\\u2194':'harr','\\u21AE':'nharr','\\u2195':'varr','\\u2196':'nwarr','\\u2197':'nearr','\\u2198':'searr','\\u2199':'swarr','\\u219D':'rarrw','\\u219D\\u0338':'nrarrw','\\u219E':'Larr','\\u219F':'Uarr','\\u21A0':'Rarr','\\u21A1':'Darr','\\u21A2':'larrtl','\\u21A3':'rarrtl','\\u21A4':'mapstoleft','\\u21A5':'mapstoup','\\u21A6':'map','\\u21A7':'mapstodown','\\u21A9':'larrhk','\\u21AA':'rarrhk','\\u21AB':'larrlp','\\u21AC':'rarrlp','\\u21AD':'harrw','\\u21B0':'lsh','\\u21B1':'rsh','\\u21B2':'ldsh','\\u21B3':'rdsh','\\u21B5':'crarr','\\u21B6':'cularr','\\u21B7':'curarr','\\u21BA':'olarr','\\u21BB':'orarr','\\u21BC':'lharu','\\u21BD':'lhard','\\u21BE':'uharr','\\u21BF':'uharl','\\u21C0':'rharu','\\u21C1':'rhard','\\u21C2':'dharr','\\u21C3':'dharl','\\u21C4':'rlarr','\\u21C5':'udarr','\\u21C6':'lrarr','\\u21C7':'llarr','\\u21C8':'uuarr','\\u21C9':'rrarr','\\u21CA':'ddarr','\\u21CB':'lrhar','\\u21CC':'rlhar','\\u21D0':'lArr','\\u21CD':'nlArr','\\u21D1':'uArr','\\u21D2':'rArr','\\u21CF':'nrArr','\\u21D3':'dArr','\\u21D4':'iff','\\u21CE':'nhArr','\\u21D5':'vArr','\\u21D6':'nwArr','\\u21D7':'neArr','\\u21D8':'seArr','\\u21D9':'swArr','\\u21DA':'lAarr','\\u21DB':'rAarr','\\u21DD':'zigrarr','\\u21E4':'larrb','\\u21E5':'rarrb','\\u21F5':'duarr','\\u21FD':'loarr','\\u21FE':'roarr','\\u21FF':'hoarr','\\u2200':'forall','\\u2201':'comp','\\u2202':'part','\\u2202\\u0338':'npart','\\u2203':'exist','\\u2204':'nexist','\\u2205':'empty','\\u2207':'Del','\\u2208':'in','\\u2209':'notin','\\u220B':'ni','\\u220C':'notni','\\u03F6':'bepsi','\\u220F':'prod','\\u2210':'coprod','\\u2211':'sum','+':'plus','\\xB1':'pm','\\xF7':'div','\\xD7':'times','<':'lt','\\u226E':'nlt','<\\u20D2':'nvlt','=':'equals','\\u2260':'ne','=\\u20E5':'bne','\\u2A75':'Equal','>':'gt','\\u226F':'ngt','>\\u20D2':'nvgt','\\xAC':'not','|':'vert','\\xA6':'brvbar','\\u2212':'minus','\\u2213':'mp','\\u2214':'plusdo','\\u2044':'frasl','\\u2216':'setmn','\\u2217':'lowast','\\u2218':'compfn','\\u221A':'Sqrt','\\u221D':'prop','\\u221E':'infin','\\u221F':'angrt','\\u2220':'ang','\\u2220\\u20D2':'nang','\\u2221':'angmsd','\\u2222':'angsph','\\u2223':'mid','\\u2224':'nmid','\\u2225':'par','\\u2226':'npar','\\u2227':'and','\\u2228':'or','\\u2229':'cap','\\u2229\\uFE00':'caps','\\u222A':'cup','\\u222A\\uFE00':'cups','\\u222B':'int','\\u222C':'Int','\\u222D':'tint','\\u2A0C':'qint','\\u222E':'oint','\\u222F':'Conint','\\u2230':'Cconint','\\u2231':'cwint','\\u2232':'cwconint','\\u2233':'awconint','\\u2234':'there4','\\u2235':'becaus','\\u2236':'ratio','\\u2237':'Colon','\\u2238':'minusd','\\u223A':'mDDot','\\u223B':'homtht','\\u223C':'sim','\\u2241':'nsim','\\u223C\\u20D2':'nvsim','\\u223D':'bsim','\\u223D\\u0331':'race','\\u223E':'ac','\\u223E\\u0333':'acE','\\u223F':'acd','\\u2240':'wr','\\u2242':'esim','\\u2242\\u0338':'nesim','\\u2243':'sime','\\u2244':'nsime','\\u2245':'cong','\\u2247':'ncong','\\u2246':'simne','\\u2248':'ap','\\u2249':'nap','\\u224A':'ape','\\u224B':'apid','\\u224B\\u0338':'napid','\\u224C':'bcong','\\u224D':'CupCap','\\u226D':'NotCupCap','\\u224D\\u20D2':'nvap','\\u224E':'bump','\\u224E\\u0338':'nbump','\\u224F':'bumpe','\\u224F\\u0338':'nbumpe','\\u2250':'doteq','\\u2250\\u0338':'nedot','\\u2251':'eDot','\\u2252':'efDot','\\u2253':'erDot','\\u2254':'colone','\\u2255':'ecolon','\\u2256':'ecir','\\u2257':'cire','\\u2259':'wedgeq','\\u225A':'veeeq','\\u225C':'trie','\\u225F':'equest','\\u2261':'equiv','\\u2262':'nequiv','\\u2261\\u20E5':'bnequiv','\\u2264':'le','\\u2270':'nle','\\u2264\\u20D2':'nvle','\\u2265':'ge','\\u2271':'nge','\\u2265\\u20D2':'nvge','\\u2266':'lE','\\u2266\\u0338':'nlE','\\u2267':'gE','\\u2267\\u0338':'ngE','\\u2268\\uFE00':'lvnE','\\u2268':'lnE','\\u2269':'gnE','\\u2269\\uFE00':'gvnE','\\u226A':'ll','\\u226A\\u0338':'nLtv','\\u226A\\u20D2':'nLt','\\u226B':'gg','\\u226B\\u0338':'nGtv','\\u226B\\u20D2':'nGt','\\u226C':'twixt','\\u2272':'lsim','\\u2274':'nlsim','\\u2273':'gsim','\\u2275':'ngsim','\\u2276':'lg','\\u2278':'ntlg','\\u2277':'gl','\\u2279':'ntgl','\\u227A':'pr','\\u2280':'npr','\\u227B':'sc','\\u2281':'nsc','\\u227C':'prcue','\\u22E0':'nprcue','\\u227D':'sccue','\\u22E1':'nsccue','\\u227E':'prsim','\\u227F':'scsim','\\u227F\\u0338':'NotSucceedsTilde','\\u2282':'sub','\\u2284':'nsub','\\u2282\\u20D2':'vnsub','\\u2283':'sup','\\u2285':'nsup','\\u2283\\u20D2':'vnsup','\\u2286':'sube','\\u2288':'nsube','\\u2287':'supe','\\u2289':'nsupe','\\u228A\\uFE00':'vsubne','\\u228A':'subne','\\u228B\\uFE00':'vsupne','\\u228B':'supne','\\u228D':'cupdot','\\u228E':'uplus','\\u228F':'sqsub','\\u228F\\u0338':'NotSquareSubset','\\u2290':'sqsup','\\u2290\\u0338':'NotSquareSuperset','\\u2291':'sqsube','\\u22E2':'nsqsube','\\u2292':'sqsupe','\\u22E3':'nsqsupe','\\u2293':'sqcap','\\u2293\\uFE00':'sqcaps','\\u2294':'sqcup','\\u2294\\uFE00':'sqcups','\\u2295':'oplus','\\u2296':'ominus','\\u2297':'otimes','\\u2298':'osol','\\u2299':'odot','\\u229A':'ocir','\\u229B':'oast','\\u229D':'odash','\\u229E':'plusb','\\u229F':'minusb','\\u22A0':'timesb','\\u22A1':'sdotb','\\u22A2':'vdash','\\u22AC':'nvdash','\\u22A3':'dashv','\\u22A4':'top','\\u22A5':'bot','\\u22A7':'models','\\u22A8':'vDash','\\u22AD':'nvDash','\\u22A9':'Vdash','\\u22AE':'nVdash','\\u22AA':'Vvdash','\\u22AB':'VDash','\\u22AF':'nVDash','\\u22B0':'prurel','\\u22B2':'vltri','\\u22EA':'nltri','\\u22B3':'vrtri','\\u22EB':'nrtri','\\u22B4':'ltrie','\\u22EC':'nltrie','\\u22B4\\u20D2':'nvltrie','\\u22B5':'rtrie','\\u22ED':'nrtrie','\\u22B5\\u20D2':'nvrtrie','\\u22B6':'origof','\\u22B7':'imof','\\u22B8':'mumap','\\u22B9':'hercon','\\u22BA':'intcal','\\u22BB':'veebar','\\u22BD':'barvee','\\u22BE':'angrtvb','\\u22BF':'lrtri','\\u22C0':'Wedge','\\u22C1':'Vee','\\u22C2':'xcap','\\u22C3':'xcup','\\u22C4':'diam','\\u22C5':'sdot','\\u22C6':'Star','\\u22C7':'divonx','\\u22C8':'bowtie','\\u22C9':'ltimes','\\u22CA':'rtimes','\\u22CB':'lthree','\\u22CC':'rthree','\\u22CD':'bsime','\\u22CE':'cuvee','\\u22CF':'cuwed','\\u22D0':'Sub','\\u22D1':'Sup','\\u22D2':'Cap','\\u22D3':'Cup','\\u22D4':'fork','\\u22D5':'epar','\\u22D6':'ltdot','\\u22D7':'gtdot','\\u22D8':'Ll','\\u22D8\\u0338':'nLl','\\u22D9':'Gg','\\u22D9\\u0338':'nGg','\\u22DA\\uFE00':'lesg','\\u22DA':'leg','\\u22DB':'gel','\\u22DB\\uFE00':'gesl','\\u22DE':'cuepr','\\u22DF':'cuesc','\\u22E6':'lnsim','\\u22E7':'gnsim','\\u22E8':'prnsim','\\u22E9':'scnsim','\\u22EE':'vellip','\\u22EF':'ctdot','\\u22F0':'utdot','\\u22F1':'dtdot','\\u22F2':'disin','\\u22F3':'isinsv','\\u22F4':'isins','\\u22F5':'isindot','\\u22F5\\u0338':'notindot','\\u22F6':'notinvc','\\u22F7':'notinvb','\\u22F9':'isinE','\\u22F9\\u0338':'notinE','\\u22FA':'nisd','\\u22FB':'xnis','\\u22FC':'nis','\\u22FD':'notnivc','\\u22FE':'notnivb','\\u2305':'barwed','\\u2306':'Barwed','\\u230C':'drcrop','\\u230D':'dlcrop','\\u230E':'urcrop','\\u230F':'ulcrop','\\u2310':'bnot','\\u2312':'profline','\\u2313':'profsurf','\\u2315':'telrec','\\u2316':'target','\\u231C':'ulcorn','\\u231D':'urcorn','\\u231E':'dlcorn','\\u231F':'drcorn','\\u2322':'frown','\\u2323':'smile','\\u232D':'cylcty','\\u232E':'profalar','\\u2336':'topbot','\\u233D':'ovbar','\\u233F':'solbar','\\u237C':'angzarr','\\u23B0':'lmoust','\\u23B1':'rmoust','\\u23B4':'tbrk','\\u23B5':'bbrk','\\u23B6':'bbrktbrk','\\u23DC':'OverParenthesis','\\u23DD':'UnderParenthesis','\\u23DE':'OverBrace','\\u23DF':'UnderBrace','\\u23E2':'trpezium','\\u23E7':'elinters','\\u2423':'blank','\\u2500':'boxh','\\u2502':'boxv','\\u250C':'boxdr','\\u2510':'boxdl','\\u2514':'boxur','\\u2518':'boxul','\\u251C':'boxvr','\\u2524':'boxvl','\\u252C':'boxhd','\\u2534':'boxhu','\\u253C':'boxvh','\\u2550':'boxH','\\u2551':'boxV','\\u2552':'boxdR','\\u2553':'boxDr','\\u2554':'boxDR','\\u2555':'boxdL','\\u2556':'boxDl','\\u2557':'boxDL','\\u2558':'boxuR','\\u2559':'boxUr','\\u255A':'boxUR','\\u255B':'boxuL','\\u255C':'boxUl','\\u255D':'boxUL','\\u255E':'boxvR','\\u255F':'boxVr','\\u2560':'boxVR','\\u2561':'boxvL','\\u2562':'boxVl','\\u2563':'boxVL','\\u2564':'boxHd','\\u2565':'boxhD','\\u2566':'boxHD','\\u2567':'boxHu','\\u2568':'boxhU','\\u2569':'boxHU','\\u256A':'boxvH','\\u256B':'boxVh','\\u256C':'boxVH','\\u2580':'uhblk','\\u2584':'lhblk','\\u2588':'block','\\u2591':'blk14','\\u2592':'blk12','\\u2593':'blk34','\\u25A1':'squ','\\u25AA':'squf','\\u25AB':'EmptyVerySmallSquare','\\u25AD':'rect','\\u25AE':'marker','\\u25B1':'fltns','\\u25B3':'xutri','\\u25B4':'utrif','\\u25B5':'utri','\\u25B8':'rtrif','\\u25B9':'rtri','\\u25BD':'xdtri','\\u25BE':'dtrif','\\u25BF':'dtri','\\u25C2':'ltrif','\\u25C3':'ltri','\\u25CA':'loz','\\u25CB':'cir','\\u25EC':'tridot','\\u25EF':'xcirc','\\u25F8':'ultri','\\u25F9':'urtri','\\u25FA':'lltri','\\u25FB':'EmptySmallSquare','\\u25FC':'FilledSmallSquare','\\u2605':'starf','\\u2606':'star','\\u260E':'phone','\\u2640':'female','\\u2642':'male','\\u2660':'spades','\\u2663':'clubs','\\u2665':'hearts','\\u2666':'diams','\\u266A':'sung','\\u2713':'check','\\u2717':'cross','\\u2720':'malt','\\u2736':'sext','\\u2758':'VerticalSeparator','\\u27C8':'bsolhsub','\\u27C9':'suphsol','\\u27F5':'xlarr','\\u27F6':'xrarr','\\u27F7':'xharr','\\u27F8':'xlArr','\\u27F9':'xrArr','\\u27FA':'xhArr','\\u27FC':'xmap','\\u27FF':'dzigrarr','\\u2902':'nvlArr','\\u2903':'nvrArr','\\u2904':'nvHarr','\\u2905':'Map','\\u290C':'lbarr','\\u290D':'rbarr','\\u290E':'lBarr','\\u290F':'rBarr','\\u2910':'RBarr','\\u2911':'DDotrahd','\\u2912':'UpArrowBar','\\u2913':'DownArrowBar','\\u2916':'Rarrtl','\\u2919':'latail','\\u291A':'ratail','\\u291B':'lAtail','\\u291C':'rAtail','\\u291D':'larrfs','\\u291E':'rarrfs','\\u291F':'larrbfs','\\u2920':'rarrbfs','\\u2923':'nwarhk','\\u2924':'nearhk','\\u2925':'searhk','\\u2926':'swarhk','\\u2927':'nwnear','\\u2928':'toea','\\u2929':'tosa','\\u292A':'swnwar','\\u2933':'rarrc','\\u2933\\u0338':'nrarrc','\\u2935':'cudarrr','\\u2936':'ldca','\\u2937':'rdca','\\u2938':'cudarrl','\\u2939':'larrpl','\\u293C':'curarrm','\\u293D':'cularrp','\\u2945':'rarrpl','\\u2948':'harrcir','\\u2949':'Uarrocir','\\u294A':'lurdshar','\\u294B':'ldrushar','\\u294E':'LeftRightVector','\\u294F':'RightUpDownVector','\\u2950':'DownLeftRightVector','\\u2951':'LeftUpDownVector','\\u2952':'LeftVectorBar','\\u2953':'RightVectorBar','\\u2954':'RightUpVectorBar','\\u2955':'RightDownVectorBar','\\u2956':'DownLeftVectorBar','\\u2957':'DownRightVectorBar','\\u2958':'LeftUpVectorBar','\\u2959':'LeftDownVectorBar','\\u295A':'LeftTeeVector','\\u295B':'RightTeeVector','\\u295C':'RightUpTeeVector','\\u295D':'RightDownTeeVector','\\u295E':'DownLeftTeeVector','\\u295F':'DownRightTeeVector','\\u2960':'LeftUpTeeVector','\\u2961':'LeftDownTeeVector','\\u2962':'lHar','\\u2963':'uHar','\\u2964':'rHar','\\u2965':'dHar','\\u2966':'luruhar','\\u2967':'ldrdhar','\\u2968':'ruluhar','\\u2969':'rdldhar','\\u296A':'lharul','\\u296B':'llhard','\\u296C':'rharul','\\u296D':'lrhard','\\u296E':'udhar','\\u296F':'duhar','\\u2970':'RoundImplies','\\u2971':'erarr','\\u2972':'simrarr','\\u2973':'larrsim','\\u2974':'rarrsim','\\u2975':'rarrap','\\u2976':'ltlarr','\\u2978':'gtrarr','\\u2979':'subrarr','\\u297B':'suplarr','\\u297C':'lfisht','\\u297D':'rfisht','\\u297E':'ufisht','\\u297F':'dfisht','\\u299A':'vzigzag','\\u299C':'vangrt','\\u299D':'angrtvbd','\\u29A4':'ange','\\u29A5':'range','\\u29A6':'dwangle','\\u29A7':'uwangle','\\u29A8':'angmsdaa','\\u29A9':'angmsdab','\\u29AA':'angmsdac','\\u29AB':'angmsdad','\\u29AC':'angmsdae','\\u29AD':'angmsdaf','\\u29AE':'angmsdag','\\u29AF':'angmsdah','\\u29B0':'bemptyv','\\u29B1':'demptyv','\\u29B2':'cemptyv','\\u29B3':'raemptyv','\\u29B4':'laemptyv','\\u29B5':'ohbar','\\u29B6':'omid','\\u29B7':'opar','\\u29B9':'operp','\\u29BB':'olcross','\\u29BC':'odsold','\\u29BE':'olcir','\\u29BF':'ofcir','\\u29C0':'olt','\\u29C1':'ogt','\\u29C2':'cirscir','\\u29C3':'cirE','\\u29C4':'solb','\\u29C5':'bsolb','\\u29C9':'boxbox','\\u29CD':'trisb','\\u29CE':'rtriltri','\\u29CF':'LeftTriangleBar','\\u29CF\\u0338':'NotLeftTriangleBar','\\u29D0':'RightTriangleBar','\\u29D0\\u0338':'NotRightTriangleBar','\\u29DC':'iinfin','\\u29DD':'infintie','\\u29DE':'nvinfin','\\u29E3':'eparsl','\\u29E4':'smeparsl','\\u29E5':'eqvparsl','\\u29EB':'lozf','\\u29F4':'RuleDelayed','\\u29F6':'dsol','\\u2A00':'xodot','\\u2A01':'xoplus','\\u2A02':'xotime','\\u2A04':'xuplus','\\u2A06':'xsqcup','\\u2A0D':'fpartint','\\u2A10':'cirfnint','\\u2A11':'awint','\\u2A12':'rppolint','\\u2A13':'scpolint','\\u2A14':'npolint','\\u2A15':'pointint','\\u2A16':'quatint','\\u2A17':'intlarhk','\\u2A22':'pluscir','\\u2A23':'plusacir','\\u2A24':'simplus','\\u2A25':'plusdu','\\u2A26':'plussim','\\u2A27':'plustwo','\\u2A29':'mcomma','\\u2A2A':'minusdu','\\u2A2D':'loplus','\\u2A2E':'roplus','\\u2A2F':'Cross','\\u2A30':'timesd','\\u2A31':'timesbar','\\u2A33':'smashp','\\u2A34':'lotimes','\\u2A35':'rotimes','\\u2A36':'otimesas','\\u2A37':'Otimes','\\u2A38':'odiv','\\u2A39':'triplus','\\u2A3A':'triminus','\\u2A3B':'tritime','\\u2A3C':'iprod','\\u2A3F':'amalg','\\u2A40':'capdot','\\u2A42':'ncup','\\u2A43':'ncap','\\u2A44':'capand','\\u2A45':'cupor','\\u2A46':'cupcap','\\u2A47':'capcup','\\u2A48':'cupbrcap','\\u2A49':'capbrcup','\\u2A4A':'cupcup','\\u2A4B':'capcap','\\u2A4C':'ccups','\\u2A4D':'ccaps','\\u2A50':'ccupssm','\\u2A53':'And','\\u2A54':'Or','\\u2A55':'andand','\\u2A56':'oror','\\u2A57':'orslope','\\u2A58':'andslope','\\u2A5A':'andv','\\u2A5B':'orv','\\u2A5C':'andd','\\u2A5D':'ord','\\u2A5F':'wedbar','\\u2A66':'sdote','\\u2A6A':'simdot','\\u2A6D':'congdot','\\u2A6D\\u0338':'ncongdot','\\u2A6E':'easter','\\u2A6F':'apacir','\\u2A70':'apE','\\u2A70\\u0338':'napE','\\u2A71':'eplus','\\u2A72':'pluse','\\u2A73':'Esim','\\u2A77':'eDDot','\\u2A78':'equivDD','\\u2A79':'ltcir','\\u2A7A':'gtcir','\\u2A7B':'ltquest','\\u2A7C':'gtquest','\\u2A7D':'les','\\u2A7D\\u0338':'nles','\\u2A7E':'ges','\\u2A7E\\u0338':'nges','\\u2A7F':'lesdot','\\u2A80':'gesdot','\\u2A81':'lesdoto','\\u2A82':'gesdoto','\\u2A83':'lesdotor','\\u2A84':'gesdotol','\\u2A85':'lap','\\u2A86':'gap','\\u2A87':'lne','\\u2A88':'gne','\\u2A89':'lnap','\\u2A8A':'gnap','\\u2A8B':'lEg','\\u2A8C':'gEl','\\u2A8D':'lsime','\\u2A8E':'gsime','\\u2A8F':'lsimg','\\u2A90':'gsiml','\\u2A91':'lgE','\\u2A92':'glE','\\u2A93':'lesges','\\u2A94':'gesles','\\u2A95':'els','\\u2A96':'egs','\\u2A97':'elsdot','\\u2A98':'egsdot','\\u2A99':'el','\\u2A9A':'eg','\\u2A9D':'siml','\\u2A9E':'simg','\\u2A9F':'simlE','\\u2AA0':'simgE','\\u2AA1':'LessLess','\\u2AA1\\u0338':'NotNestedLessLess','\\u2AA2':'GreaterGreater','\\u2AA2\\u0338':'NotNestedGreaterGreater','\\u2AA4':'glj','\\u2AA5':'gla','\\u2AA6':'ltcc','\\u2AA7':'gtcc','\\u2AA8':'lescc','\\u2AA9':'gescc','\\u2AAA':'smt','\\u2AAB':'lat','\\u2AAC':'smte','\\u2AAC\\uFE00':'smtes','\\u2AAD':'late','\\u2AAD\\uFE00':'lates','\\u2AAE':'bumpE','\\u2AAF':'pre','\\u2AAF\\u0338':'npre','\\u2AB0':'sce','\\u2AB0\\u0338':'nsce','\\u2AB3':'prE','\\u2AB4':'scE','\\u2AB5':'prnE','\\u2AB6':'scnE','\\u2AB7':'prap','\\u2AB8':'scap','\\u2AB9':'prnap','\\u2ABA':'scnap','\\u2ABB':'Pr','\\u2ABC':'Sc','\\u2ABD':'subdot','\\u2ABE':'supdot','\\u2ABF':'subplus','\\u2AC0':'supplus','\\u2AC1':'submult','\\u2AC2':'supmult','\\u2AC3':'subedot','\\u2AC4':'supedot','\\u2AC5':'subE','\\u2AC5\\u0338':'nsubE','\\u2AC6':'supE','\\u2AC6\\u0338':'nsupE','\\u2AC7':'subsim','\\u2AC8':'supsim','\\u2ACB\\uFE00':'vsubnE','\\u2ACB':'subnE','\\u2ACC\\uFE00':'vsupnE','\\u2ACC':'supnE','\\u2ACF':'csub','\\u2AD0':'csup','\\u2AD1':'csube','\\u2AD2':'csupe','\\u2AD3':'subsup','\\u2AD4':'supsub','\\u2AD5':'subsub','\\u2AD6':'supsup','\\u2AD7':'suphsub','\\u2AD8':'supdsub','\\u2AD9':'forkv','\\u2ADA':'topfork','\\u2ADB':'mlcp','\\u2AE4':'Dashv','\\u2AE6':'Vdashl','\\u2AE7':'Barv','\\u2AE8':'vBar','\\u2AE9':'vBarv','\\u2AEB':'Vbar','\\u2AEC':'Not','\\u2AED':'bNot','\\u2AEE':'rnmid','\\u2AEF':'cirmid','\\u2AF0':'midcir','\\u2AF1':'topcir','\\u2AF2':'nhpar','\\u2AF3':'parsim','\\u2AFD':'parsl','\\u2AFD\\u20E5':'nparsl','\\u266D':'flat','\\u266E':'natur','\\u266F':'sharp','\\xA4':'curren','\\xA2':'cent','$':'dollar','\\xA3':'pound','\\xA5':'yen','\\u20AC':'euro','\\xB9':'sup1','\\xBD':'half','\\u2153':'frac13','\\xBC':'frac14','\\u2155':'frac15','\\u2159':'frac16','\\u215B':'frac18','\\xB2':'sup2','\\u2154':'frac23','\\u2156':'frac25','\\xB3':'sup3','\\xBE':'frac34','\\u2157':'frac35','\\u215C':'frac38','\\u2158':'frac45','\\u215A':'frac56','\\u215D':'frac58','\\u215E':'frac78','\\uD835\\uDCB6':'ascr','\\uD835\\uDD52':'aopf','\\uD835\\uDD1E':'afr','\\uD835\\uDD38':'Aopf','\\uD835\\uDD04':'Afr','\\uD835\\uDC9C':'Ascr','\\xAA':'ordf','\\xE1':'aacute','\\xC1':'Aacute','\\xE0':'agrave','\\xC0':'Agrave','\\u0103':'abreve','\\u0102':'Abreve','\\xE2':'acirc','\\xC2':'Acirc','\\xE5':'aring','\\xC5':'angst','\\xE4':'auml','\\xC4':'Auml','\\xE3':'atilde','\\xC3':'Atilde','\\u0105':'aogon','\\u0104':'Aogon','\\u0101':'amacr','\\u0100':'Amacr','\\xE6':'aelig','\\xC6':'AElig','\\uD835\\uDCB7':'bscr','\\uD835\\uDD53':'bopf','\\uD835\\uDD1F':'bfr','\\uD835\\uDD39':'Bopf','\\u212C':'Bscr','\\uD835\\uDD05':'Bfr','\\uD835\\uDD20':'cfr','\\uD835\\uDCB8':'cscr','\\uD835\\uDD54':'copf','\\u212D':'Cfr','\\uD835\\uDC9E':'Cscr','\\u2102':'Copf','\\u0107':'cacute','\\u0106':'Cacute','\\u0109':'ccirc','\\u0108':'Ccirc','\\u010D':'ccaron','\\u010C':'Ccaron','\\u010B':'cdot','\\u010A':'Cdot','\\xE7':'ccedil','\\xC7':'Ccedil','\\u2105':'incare','\\uD835\\uDD21':'dfr','\\u2146':'dd','\\uD835\\uDD55':'dopf','\\uD835\\uDCB9':'dscr','\\uD835\\uDC9F':'Dscr','\\uD835\\uDD07':'Dfr','\\u2145':'DD','\\uD835\\uDD3B':'Dopf','\\u010F':'dcaron','\\u010E':'Dcaron','\\u0111':'dstrok','\\u0110':'Dstrok','\\xF0':'eth','\\xD0':'ETH','\\u2147':'ee','\\u212F':'escr','\\uD835\\uDD22':'efr','\\uD835\\uDD56':'eopf','\\u2130':'Escr','\\uD835\\uDD08':'Efr','\\uD835\\uDD3C':'Eopf','\\xE9':'eacute','\\xC9':'Eacute','\\xE8':'egrave','\\xC8':'Egrave','\\xEA':'ecirc','\\xCA':'Ecirc','\\u011B':'ecaron','\\u011A':'Ecaron','\\xEB':'euml','\\xCB':'Euml','\\u0117':'edot','\\u0116':'Edot','\\u0119':'eogon','\\u0118':'Eogon','\\u0113':'emacr','\\u0112':'Emacr','\\uD835\\uDD23':'ffr','\\uD835\\uDD57':'fopf','\\uD835\\uDCBB':'fscr','\\uD835\\uDD09':'Ffr','\\uD835\\uDD3D':'Fopf','\\u2131':'Fscr','\\uFB00':'fflig','\\uFB03':'ffilig','\\uFB04':'ffllig','\\uFB01':'filig','fj':'fjlig','\\uFB02':'fllig','\\u0192':'fnof','\\u210A':'gscr','\\uD835\\uDD58':'gopf','\\uD835\\uDD24':'gfr','\\uD835\\uDCA2':'Gscr','\\uD835\\uDD3E':'Gopf','\\uD835\\uDD0A':'Gfr','\\u01F5':'gacute','\\u011F':'gbreve','\\u011E':'Gbreve','\\u011D':'gcirc','\\u011C':'Gcirc','\\u0121':'gdot','\\u0120':'Gdot','\\u0122':'Gcedil','\\uD835\\uDD25':'hfr','\\u210E':'planckh','\\uD835\\uDCBD':'hscr','\\uD835\\uDD59':'hopf','\\u210B':'Hscr','\\u210C':'Hfr','\\u210D':'Hopf','\\u0125':'hcirc','\\u0124':'Hcirc','\\u210F':'hbar','\\u0127':'hstrok','\\u0126':'Hstrok','\\uD835\\uDD5A':'iopf','\\uD835\\uDD26':'ifr','\\uD835\\uDCBE':'iscr','\\u2148':'ii','\\uD835\\uDD40':'Iopf','\\u2110':'Iscr','\\u2111':'Im','\\xED':'iacute','\\xCD':'Iacute','\\xEC':'igrave','\\xCC':'Igrave','\\xEE':'icirc','\\xCE':'Icirc','\\xEF':'iuml','\\xCF':'Iuml','\\u0129':'itilde','\\u0128':'Itilde','\\u0130':'Idot','\\u012F':'iogon','\\u012E':'Iogon','\\u012B':'imacr','\\u012A':'Imacr','\\u0133':'ijlig','\\u0132':'IJlig','\\u0131':'imath','\\uD835\\uDCBF':'jscr','\\uD835\\uDD5B':'jopf','\\uD835\\uDD27':'jfr','\\uD835\\uDCA5':'Jscr','\\uD835\\uDD0D':'Jfr','\\uD835\\uDD41':'Jopf','\\u0135':'jcirc','\\u0134':'Jcirc','\\u0237':'jmath','\\uD835\\uDD5C':'kopf','\\uD835\\uDCC0':'kscr','\\uD835\\uDD28':'kfr','\\uD835\\uDCA6':'Kscr','\\uD835\\uDD42':'Kopf','\\uD835\\uDD0E':'Kfr','\\u0137':'kcedil','\\u0136':'Kcedil','\\uD835\\uDD29':'lfr','\\uD835\\uDCC1':'lscr','\\u2113':'ell','\\uD835\\uDD5D':'lopf','\\u2112':'Lscr','\\uD835\\uDD0F':'Lfr','\\uD835\\uDD43':'Lopf','\\u013A':'lacute','\\u0139':'Lacute','\\u013E':'lcaron','\\u013D':'Lcaron','\\u013C':'lcedil','\\u013B':'Lcedil','\\u0142':'lstrok','\\u0141':'Lstrok','\\u0140':'lmidot','\\u013F':'Lmidot','\\uD835\\uDD2A':'mfr','\\uD835\\uDD5E':'mopf','\\uD835\\uDCC2':'mscr','\\uD835\\uDD10':'Mfr','\\uD835\\uDD44':'Mopf','\\u2133':'Mscr','\\uD835\\uDD2B':'nfr','\\uD835\\uDD5F':'nopf','\\uD835\\uDCC3':'nscr','\\u2115':'Nopf','\\uD835\\uDCA9':'Nscr','\\uD835\\uDD11':'Nfr','\\u0144':'nacute','\\u0143':'Nacute','\\u0148':'ncaron','\\u0147':'Ncaron','\\xF1':'ntilde','\\xD1':'Ntilde','\\u0146':'ncedil','\\u0145':'Ncedil','\\u2116':'numero','\\u014B':'eng','\\u014A':'ENG','\\uD835\\uDD60':'oopf','\\uD835\\uDD2C':'ofr','\\u2134':'oscr','\\uD835\\uDCAA':'Oscr','\\uD835\\uDD12':'Ofr','\\uD835\\uDD46':'Oopf','\\xBA':'ordm','\\xF3':'oacute','\\xD3':'Oacute','\\xF2':'ograve','\\xD2':'Ograve','\\xF4':'ocirc','\\xD4':'Ocirc','\\xF6':'ouml','\\xD6':'Ouml','\\u0151':'odblac','\\u0150':'Odblac','\\xF5':'otilde','\\xD5':'Otilde','\\xF8':'oslash','\\xD8':'Oslash','\\u014D':'omacr','\\u014C':'Omacr','\\u0153':'oelig','\\u0152':'OElig','\\uD835\\uDD2D':'pfr','\\uD835\\uDCC5':'pscr','\\uD835\\uDD61':'popf','\\u2119':'Popf','\\uD835\\uDD13':'Pfr','\\uD835\\uDCAB':'Pscr','\\uD835\\uDD62':'qopf','\\uD835\\uDD2E':'qfr','\\uD835\\uDCC6':'qscr','\\uD835\\uDCAC':'Qscr','\\uD835\\uDD14':'Qfr','\\u211A':'Qopf','\\u0138':'kgreen','\\uD835\\uDD2F':'rfr','\\uD835\\uDD63':'ropf','\\uD835\\uDCC7':'rscr','\\u211B':'Rscr','\\u211C':'Re','\\u211D':'Ropf','\\u0155':'racute','\\u0154':'Racute','\\u0159':'rcaron','\\u0158':'Rcaron','\\u0157':'rcedil','\\u0156':'Rcedil','\\uD835\\uDD64':'sopf','\\uD835\\uDCC8':'sscr','\\uD835\\uDD30':'sfr','\\uD835\\uDD4A':'Sopf','\\uD835\\uDD16':'Sfr','\\uD835\\uDCAE':'Sscr','\\u24C8':'oS','\\u015B':'sacute','\\u015A':'Sacute','\\u015D':'scirc','\\u015C':'Scirc','\\u0161':'scaron','\\u0160':'Scaron','\\u015F':'scedil','\\u015E':'Scedil','\\xDF':'szlig','\\uD835\\uDD31':'tfr','\\uD835\\uDCC9':'tscr','\\uD835\\uDD65':'topf','\\uD835\\uDCAF':'Tscr','\\uD835\\uDD17':'Tfr','\\uD835\\uDD4B':'Topf','\\u0165':'tcaron','\\u0164':'Tcaron','\\u0163':'tcedil','\\u0162':'Tcedil','\\u2122':'trade','\\u0167':'tstrok','\\u0166':'Tstrok','\\uD835\\uDCCA':'uscr','\\uD835\\uDD66':'uopf','\\uD835\\uDD32':'ufr','\\uD835\\uDD4C':'Uopf','\\uD835\\uDD18':'Ufr','\\uD835\\uDCB0':'Uscr','\\xFA':'uacute','\\xDA':'Uacute','\\xF9':'ugrave','\\xD9':'Ugrave','\\u016D':'ubreve','\\u016C':'Ubreve','\\xFB':'ucirc','\\xDB':'Ucirc','\\u016F':'uring','\\u016E':'Uring','\\xFC':'uuml','\\xDC':'Uuml','\\u0171':'udblac','\\u0170':'Udblac','\\u0169':'utilde','\\u0168':'Utilde','\\u0173':'uogon','\\u0172':'Uogon','\\u016B':'umacr','\\u016A':'Umacr','\\uD835\\uDD33':'vfr','\\uD835\\uDD67':'vopf','\\uD835\\uDCCB':'vscr','\\uD835\\uDD19':'Vfr','\\uD835\\uDD4D':'Vopf','\\uD835\\uDCB1':'Vscr','\\uD835\\uDD68':'wopf','\\uD835\\uDCCC':'wscr','\\uD835\\uDD34':'wfr','\\uD835\\uDCB2':'Wscr','\\uD835\\uDD4E':'Wopf','\\uD835\\uDD1A':'Wfr','\\u0175':'wcirc','\\u0174':'Wcirc','\\uD835\\uDD35':'xfr','\\uD835\\uDCCD':'xscr','\\uD835\\uDD69':'xopf','\\uD835\\uDD4F':'Xopf','\\uD835\\uDD1B':'Xfr','\\uD835\\uDCB3':'Xscr','\\uD835\\uDD36':'yfr','\\uD835\\uDCCE':'yscr','\\uD835\\uDD6A':'yopf','\\uD835\\uDCB4':'Yscr','\\uD835\\uDD1C':'Yfr','\\uD835\\uDD50':'Yopf','\\xFD':'yacute','\\xDD':'Yacute','\\u0177':'ycirc','\\u0176':'Ycirc','\\xFF':'yuml','\\u0178':'Yuml','\\uD835\\uDCCF':'zscr','\\uD835\\uDD37':'zfr','\\uD835\\uDD6B':'zopf','\\u2128':'Zfr','\\u2124':'Zopf','\\uD835\\uDCB5':'Zscr','\\u017A':'zacute','\\u0179':'Zacute','\\u017E':'zcaron','\\u017D':'Zcaron','\\u017C':'zdot','\\u017B':'Zdot','\\u01B5':'imped','\\xFE':'thorn','\\xDE':'THORN','\\u0149':'napos','\\u03B1':'alpha','\\u0391':'Alpha','\\u03B2':'beta','\\u0392':'Beta','\\u03B3':'gamma','\\u0393':'Gamma','\\u03B4':'delta','\\u0394':'Delta','\\u03B5':'epsi','\\u03F5':'epsiv','\\u0395':'Epsilon','\\u03DD':'gammad','\\u03DC':'Gammad','\\u03B6':'zeta','\\u0396':'Zeta','\\u03B7':'eta','\\u0397':'Eta','\\u03B8':'theta','\\u03D1':'thetav','\\u0398':'Theta','\\u03B9':'iota','\\u0399':'Iota','\\u03BA':'kappa','\\u03F0':'kappav','\\u039A':'Kappa','\\u03BB':'lambda','\\u039B':'Lambda','\\u03BC':'mu','\\xB5':'micro','\\u039C':'Mu','\\u03BD':'nu','\\u039D':'Nu','\\u03BE':'xi','\\u039E':'Xi','\\u03BF':'omicron','\\u039F':'Omicron','\\u03C0':'pi','\\u03D6':'piv','\\u03A0':'Pi','\\u03C1':'rho','\\u03F1':'rhov','\\u03A1':'Rho','\\u03C3':'sigma','\\u03A3':'Sigma','\\u03C2':'sigmaf','\\u03C4':'tau','\\u03A4':'Tau','\\u03C5':'upsi','\\u03A5':'Upsilon','\\u03D2':'Upsi','\\u03C6':'phi','\\u03D5':'phiv','\\u03A6':'Phi','\\u03C7':'chi','\\u03A7':'Chi','\\u03C8':'psi','\\u03A8':'Psi','\\u03C9':'omega','\\u03A9':'ohm','\\u0430':'acy','\\u0410':'Acy','\\u0431':'bcy','\\u0411':'Bcy','\\u0432':'vcy','\\u0412':'Vcy','\\u0433':'gcy','\\u0413':'Gcy','\\u0453':'gjcy','\\u0403':'GJcy','\\u0434':'dcy','\\u0414':'Dcy','\\u0452':'djcy','\\u0402':'DJcy','\\u0435':'iecy','\\u0415':'IEcy','\\u0451':'iocy','\\u0401':'IOcy','\\u0454':'jukcy','\\u0404':'Jukcy','\\u0436':'zhcy','\\u0416':'ZHcy','\\u0437':'zcy','\\u0417':'Zcy','\\u0455':'dscy','\\u0405':'DScy','\\u0438':'icy','\\u0418':'Icy','\\u0456':'iukcy','\\u0406':'Iukcy','\\u0457':'yicy','\\u0407':'YIcy','\\u0439':'jcy','\\u0419':'Jcy','\\u0458':'jsercy','\\u0408':'Jsercy','\\u043A':'kcy','\\u041A':'Kcy','\\u045C':'kjcy','\\u040C':'KJcy','\\u043B':'lcy','\\u041B':'Lcy','\\u0459':'ljcy','\\u0409':'LJcy','\\u043C':'mcy','\\u041C':'Mcy','\\u043D':'ncy','\\u041D':'Ncy','\\u045A':'njcy','\\u040A':'NJcy','\\u043E':'ocy','\\u041E':'Ocy','\\u043F':'pcy','\\u041F':'Pcy','\\u0440':'rcy','\\u0420':'Rcy','\\u0441':'scy','\\u0421':'Scy','\\u0442':'tcy','\\u0422':'Tcy','\\u045B':'tshcy','\\u040B':'TSHcy','\\u0443':'ucy','\\u0423':'Ucy','\\u045E':'ubrcy','\\u040E':'Ubrcy','\\u0444':'fcy','\\u0424':'Fcy','\\u0445':'khcy','\\u0425':'KHcy','\\u0446':'tscy','\\u0426':'TScy','\\u0447':'chcy','\\u0427':'CHcy','\\u045F':'dzcy','\\u040F':'DZcy','\\u0448':'shcy','\\u0428':'SHcy','\\u0449':'shchcy','\\u0429':'SHCHcy','\\u044A':'hardcy','\\u042A':'HARDcy','\\u044B':'ycy','\\u042B':'Ycy','\\u044C':'softcy','\\u042C':'SOFTcy','\\u044D':'ecy','\\u042D':'Ecy','\\u044E':'yucy','\\u042E':'YUcy','\\u044F':'yacy','\\u042F':'YAcy','\\u2135':'aleph','\\u2136':'beth','\\u2137':'gimel','\\u2138':'daleth'};\n\n\tvar regexEscape = /[\"&'<>`]/g;\n\tvar escapeMap = {\n\t\t'\"': '&quot;',\n\t\t'&': '&amp;',\n\t\t'\\'': '&#x27;',\n\t\t'<': '&lt;',\n\t\t// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the\n\t\t// following is not strictly necessary unless its part of a tag or an\n\t\t// unquoted attribute value. Were only escaping it to support those\n\t\t// situations, and for XML support.\n\t\t'>': '&gt;',\n\t\t// In Internet Explorer  8, the backtick character can be used\n\t\t// to break out of (un)quoted attribute values or HTML comments.\n\t\t// See http://html5sec.org/#102, http://html5sec.org/#108, and\n\t\t// http://html5sec.org/#133.\n\t\t'`': '&#x60;'\n\t};\n\n\tvar regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;\n\tvar regexInvalidRawCodePoint = /[\\0-\\x08\\x0B\\x0E-\\x1F\\x7F-\\x9F\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\tvar regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;\n\tvar decodeMap = {'aacute':'\\xE1','Aacute':'\\xC1','abreve':'\\u0103','Abreve':'\\u0102','ac':'\\u223E','acd':'\\u223F','acE':'\\u223E\\u0333','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','acy':'\\u0430','Acy':'\\u0410','aelig':'\\xE6','AElig':'\\xC6','af':'\\u2061','afr':'\\uD835\\uDD1E','Afr':'\\uD835\\uDD04','agrave':'\\xE0','Agrave':'\\xC0','alefsym':'\\u2135','aleph':'\\u2135','alpha':'\\u03B1','Alpha':'\\u0391','amacr':'\\u0101','Amacr':'\\u0100','amalg':'\\u2A3F','amp':'&','AMP':'&','and':'\\u2227','And':'\\u2A53','andand':'\\u2A55','andd':'\\u2A5C','andslope':'\\u2A58','andv':'\\u2A5A','ang':'\\u2220','ange':'\\u29A4','angle':'\\u2220','angmsd':'\\u2221','angmsdaa':'\\u29A8','angmsdab':'\\u29A9','angmsdac':'\\u29AA','angmsdad':'\\u29AB','angmsdae':'\\u29AC','angmsdaf':'\\u29AD','angmsdag':'\\u29AE','angmsdah':'\\u29AF','angrt':'\\u221F','angrtvb':'\\u22BE','angrtvbd':'\\u299D','angsph':'\\u2222','angst':'\\xC5','angzarr':'\\u237C','aogon':'\\u0105','Aogon':'\\u0104','aopf':'\\uD835\\uDD52','Aopf':'\\uD835\\uDD38','ap':'\\u2248','apacir':'\\u2A6F','ape':'\\u224A','apE':'\\u2A70','apid':'\\u224B','apos':'\\'','ApplyFunction':'\\u2061','approx':'\\u2248','approxeq':'\\u224A','aring':'\\xE5','Aring':'\\xC5','ascr':'\\uD835\\uDCB6','Ascr':'\\uD835\\uDC9C','Assign':'\\u2254','ast':'*','asymp':'\\u2248','asympeq':'\\u224D','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','awconint':'\\u2233','awint':'\\u2A11','backcong':'\\u224C','backepsilon':'\\u03F6','backprime':'\\u2035','backsim':'\\u223D','backsimeq':'\\u22CD','Backslash':'\\u2216','Barv':'\\u2AE7','barvee':'\\u22BD','barwed':'\\u2305','Barwed':'\\u2306','barwedge':'\\u2305','bbrk':'\\u23B5','bbrktbrk':'\\u23B6','bcong':'\\u224C','bcy':'\\u0431','Bcy':'\\u0411','bdquo':'\\u201E','becaus':'\\u2235','because':'\\u2235','Because':'\\u2235','bemptyv':'\\u29B0','bepsi':'\\u03F6','bernou':'\\u212C','Bernoullis':'\\u212C','beta':'\\u03B2','Beta':'\\u0392','beth':'\\u2136','between':'\\u226C','bfr':'\\uD835\\uDD1F','Bfr':'\\uD835\\uDD05','bigcap':'\\u22C2','bigcirc':'\\u25EF','bigcup':'\\u22C3','bigodot':'\\u2A00','bigoplus':'\\u2A01','bigotimes':'\\u2A02','bigsqcup':'\\u2A06','bigstar':'\\u2605','bigtriangledown':'\\u25BD','bigtriangleup':'\\u25B3','biguplus':'\\u2A04','bigvee':'\\u22C1','bigwedge':'\\u22C0','bkarow':'\\u290D','blacklozenge':'\\u29EB','blacksquare':'\\u25AA','blacktriangle':'\\u25B4','blacktriangledown':'\\u25BE','blacktriangleleft':'\\u25C2','blacktriangleright':'\\u25B8','blank':'\\u2423','blk12':'\\u2592','blk14':'\\u2591','blk34':'\\u2593','block':'\\u2588','bne':'=\\u20E5','bnequiv':'\\u2261\\u20E5','bnot':'\\u2310','bNot':'\\u2AED','bopf':'\\uD835\\uDD53','Bopf':'\\uD835\\uDD39','bot':'\\u22A5','bottom':'\\u22A5','bowtie':'\\u22C8','boxbox':'\\u29C9','boxdl':'\\u2510','boxdL':'\\u2555','boxDl':'\\u2556','boxDL':'\\u2557','boxdr':'\\u250C','boxdR':'\\u2552','boxDr':'\\u2553','boxDR':'\\u2554','boxh':'\\u2500','boxH':'\\u2550','boxhd':'\\u252C','boxhD':'\\u2565','boxHd':'\\u2564','boxHD':'\\u2566','boxhu':'\\u2534','boxhU':'\\u2568','boxHu':'\\u2567','boxHU':'\\u2569','boxminus':'\\u229F','boxplus':'\\u229E','boxtimes':'\\u22A0','boxul':'\\u2518','boxuL':'\\u255B','boxUl':'\\u255C','boxUL':'\\u255D','boxur':'\\u2514','boxuR':'\\u2558','boxUr':'\\u2559','boxUR':'\\u255A','boxv':'\\u2502','boxV':'\\u2551','boxvh':'\\u253C','boxvH':'\\u256A','boxVh':'\\u256B','boxVH':'\\u256C','boxvl':'\\u2524','boxvL':'\\u2561','boxVl':'\\u2562','boxVL':'\\u2563','boxvr':'\\u251C','boxvR':'\\u255E','boxVr':'\\u255F','boxVR':'\\u2560','bprime':'\\u2035','breve':'\\u02D8','Breve':'\\u02D8','brvbar':'\\xA6','bscr':'\\uD835\\uDCB7','Bscr':'\\u212C','bsemi':'\\u204F','bsim':'\\u223D','bsime':'\\u22CD','bsol':'\\\\','bsolb':'\\u29C5','bsolhsub':'\\u27C8','bull':'\\u2022','bullet':'\\u2022','bump':'\\u224E','bumpe':'\\u224F','bumpE':'\\u2AAE','bumpeq':'\\u224F','Bumpeq':'\\u224E','cacute':'\\u0107','Cacute':'\\u0106','cap':'\\u2229','Cap':'\\u22D2','capand':'\\u2A44','capbrcup':'\\u2A49','capcap':'\\u2A4B','capcup':'\\u2A47','capdot':'\\u2A40','CapitalDifferentialD':'\\u2145','caps':'\\u2229\\uFE00','caret':'\\u2041','caron':'\\u02C7','Cayleys':'\\u212D','ccaps':'\\u2A4D','ccaron':'\\u010D','Ccaron':'\\u010C','ccedil':'\\xE7','Ccedil':'\\xC7','ccirc':'\\u0109','Ccirc':'\\u0108','Cconint':'\\u2230','ccups':'\\u2A4C','ccupssm':'\\u2A50','cdot':'\\u010B','Cdot':'\\u010A','cedil':'\\xB8','Cedilla':'\\xB8','cemptyv':'\\u29B2','cent':'\\xA2','centerdot':'\\xB7','CenterDot':'\\xB7','cfr':'\\uD835\\uDD20','Cfr':'\\u212D','chcy':'\\u0447','CHcy':'\\u0427','check':'\\u2713','checkmark':'\\u2713','chi':'\\u03C7','Chi':'\\u03A7','cir':'\\u25CB','circ':'\\u02C6','circeq':'\\u2257','circlearrowleft':'\\u21BA','circlearrowright':'\\u21BB','circledast':'\\u229B','circledcirc':'\\u229A','circleddash':'\\u229D','CircleDot':'\\u2299','circledR':'\\xAE','circledS':'\\u24C8','CircleMinus':'\\u2296','CirclePlus':'\\u2295','CircleTimes':'\\u2297','cire':'\\u2257','cirE':'\\u29C3','cirfnint':'\\u2A10','cirmid':'\\u2AEF','cirscir':'\\u29C2','ClockwiseContourIntegral':'\\u2232','CloseCurlyDoubleQuote':'\\u201D','CloseCurlyQuote':'\\u2019','clubs':'\\u2663','clubsuit':'\\u2663','colon':':','Colon':'\\u2237','colone':'\\u2254','Colone':'\\u2A74','coloneq':'\\u2254','comma':',','commat':'@','comp':'\\u2201','compfn':'\\u2218','complement':'\\u2201','complexes':'\\u2102','cong':'\\u2245','congdot':'\\u2A6D','Congruent':'\\u2261','conint':'\\u222E','Conint':'\\u222F','ContourIntegral':'\\u222E','copf':'\\uD835\\uDD54','Copf':'\\u2102','coprod':'\\u2210','Coproduct':'\\u2210','copy':'\\xA9','COPY':'\\xA9','copysr':'\\u2117','CounterClockwiseContourIntegral':'\\u2233','crarr':'\\u21B5','cross':'\\u2717','Cross':'\\u2A2F','cscr':'\\uD835\\uDCB8','Cscr':'\\uD835\\uDC9E','csub':'\\u2ACF','csube':'\\u2AD1','csup':'\\u2AD0','csupe':'\\u2AD2','ctdot':'\\u22EF','cudarrl':'\\u2938','cudarrr':'\\u2935','cuepr':'\\u22DE','cuesc':'\\u22DF','cularr':'\\u21B6','cularrp':'\\u293D','cup':'\\u222A','Cup':'\\u22D3','cupbrcap':'\\u2A48','cupcap':'\\u2A46','CupCap':'\\u224D','cupcup':'\\u2A4A','cupdot':'\\u228D','cupor':'\\u2A45','cups':'\\u222A\\uFE00','curarr':'\\u21B7','curarrm':'\\u293C','curlyeqprec':'\\u22DE','curlyeqsucc':'\\u22DF','curlyvee':'\\u22CE','curlywedge':'\\u22CF','curren':'\\xA4','curvearrowleft':'\\u21B6','curvearrowright':'\\u21B7','cuvee':'\\u22CE','cuwed':'\\u22CF','cwconint':'\\u2232','cwint':'\\u2231','cylcty':'\\u232D','dagger':'\\u2020','Dagger':'\\u2021','daleth':'\\u2138','darr':'\\u2193','dArr':'\\u21D3','Darr':'\\u21A1','dash':'\\u2010','dashv':'\\u22A3','Dashv':'\\u2AE4','dbkarow':'\\u290F','dblac':'\\u02DD','dcaron':'\\u010F','Dcaron':'\\u010E','dcy':'\\u0434','Dcy':'\\u0414','dd':'\\u2146','DD':'\\u2145','ddagger':'\\u2021','ddarr':'\\u21CA','DDotrahd':'\\u2911','ddotseq':'\\u2A77','deg':'\\xB0','Del':'\\u2207','delta':'\\u03B4','Delta':'\\u0394','demptyv':'\\u29B1','dfisht':'\\u297F','dfr':'\\uD835\\uDD21','Dfr':'\\uD835\\uDD07','dHar':'\\u2965','dharl':'\\u21C3','dharr':'\\u21C2','DiacriticalAcute':'\\xB4','DiacriticalDot':'\\u02D9','DiacriticalDoubleAcute':'\\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\\u02DC','diam':'\\u22C4','diamond':'\\u22C4','Diamond':'\\u22C4','diamondsuit':'\\u2666','diams':'\\u2666','die':'\\xA8','DifferentialD':'\\u2146','digamma':'\\u03DD','disin':'\\u22F2','div':'\\xF7','divide':'\\xF7','divideontimes':'\\u22C7','divonx':'\\u22C7','djcy':'\\u0452','DJcy':'\\u0402','dlcorn':'\\u231E','dlcrop':'\\u230D','dollar':'$','dopf':'\\uD835\\uDD55','Dopf':'\\uD835\\uDD3B','dot':'\\u02D9','Dot':'\\xA8','DotDot':'\\u20DC','doteq':'\\u2250','doteqdot':'\\u2251','DotEqual':'\\u2250','dotminus':'\\u2238','dotplus':'\\u2214','dotsquare':'\\u22A1','doublebarwedge':'\\u2306','DoubleContourIntegral':'\\u222F','DoubleDot':'\\xA8','DoubleDownArrow':'\\u21D3','DoubleLeftArrow':'\\u21D0','DoubleLeftRightArrow':'\\u21D4','DoubleLeftTee':'\\u2AE4','DoubleLongLeftArrow':'\\u27F8','DoubleLongLeftRightArrow':'\\u27FA','DoubleLongRightArrow':'\\u27F9','DoubleRightArrow':'\\u21D2','DoubleRightTee':'\\u22A8','DoubleUpArrow':'\\u21D1','DoubleUpDownArrow':'\\u21D5','DoubleVerticalBar':'\\u2225','downarrow':'\\u2193','Downarrow':'\\u21D3','DownArrow':'\\u2193','DownArrowBar':'\\u2913','DownArrowUpArrow':'\\u21F5','DownBreve':'\\u0311','downdownarrows':'\\u21CA','downharpoonleft':'\\u21C3','downharpoonright':'\\u21C2','DownLeftRightVector':'\\u2950','DownLeftTeeVector':'\\u295E','DownLeftVector':'\\u21BD','DownLeftVectorBar':'\\u2956','DownRightTeeVector':'\\u295F','DownRightVector':'\\u21C1','DownRightVectorBar':'\\u2957','DownTee':'\\u22A4','DownTeeArrow':'\\u21A7','drbkarow':'\\u2910','drcorn':'\\u231F','drcrop':'\\u230C','dscr':'\\uD835\\uDCB9','Dscr':'\\uD835\\uDC9F','dscy':'\\u0455','DScy':'\\u0405','dsol':'\\u29F6','dstrok':'\\u0111','Dstrok':'\\u0110','dtdot':'\\u22F1','dtri':'\\u25BF','dtrif':'\\u25BE','duarr':'\\u21F5','duhar':'\\u296F','dwangle':'\\u29A6','dzcy':'\\u045F','DZcy':'\\u040F','dzigrarr':'\\u27FF','eacute':'\\xE9','Eacute':'\\xC9','easter':'\\u2A6E','ecaron':'\\u011B','Ecaron':'\\u011A','ecir':'\\u2256','ecirc':'\\xEA','Ecirc':'\\xCA','ecolon':'\\u2255','ecy':'\\u044D','Ecy':'\\u042D','eDDot':'\\u2A77','edot':'\\u0117','eDot':'\\u2251','Edot':'\\u0116','ee':'\\u2147','efDot':'\\u2252','efr':'\\uD835\\uDD22','Efr':'\\uD835\\uDD08','eg':'\\u2A9A','egrave':'\\xE8','Egrave':'\\xC8','egs':'\\u2A96','egsdot':'\\u2A98','el':'\\u2A99','Element':'\\u2208','elinters':'\\u23E7','ell':'\\u2113','els':'\\u2A95','elsdot':'\\u2A97','emacr':'\\u0113','Emacr':'\\u0112','empty':'\\u2205','emptyset':'\\u2205','EmptySmallSquare':'\\u25FB','emptyv':'\\u2205','EmptyVerySmallSquare':'\\u25AB','emsp':'\\u2003','emsp13':'\\u2004','emsp14':'\\u2005','eng':'\\u014B','ENG':'\\u014A','ensp':'\\u2002','eogon':'\\u0119','Eogon':'\\u0118','eopf':'\\uD835\\uDD56','Eopf':'\\uD835\\uDD3C','epar':'\\u22D5','eparsl':'\\u29E3','eplus':'\\u2A71','epsi':'\\u03B5','epsilon':'\\u03B5','Epsilon':'\\u0395','epsiv':'\\u03F5','eqcirc':'\\u2256','eqcolon':'\\u2255','eqsim':'\\u2242','eqslantgtr':'\\u2A96','eqslantless':'\\u2A95','Equal':'\\u2A75','equals':'=','EqualTilde':'\\u2242','equest':'\\u225F','Equilibrium':'\\u21CC','equiv':'\\u2261','equivDD':'\\u2A78','eqvparsl':'\\u29E5','erarr':'\\u2971','erDot':'\\u2253','escr':'\\u212F','Escr':'\\u2130','esdot':'\\u2250','esim':'\\u2242','Esim':'\\u2A73','eta':'\\u03B7','Eta':'\\u0397','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','euro':'\\u20AC','excl':'!','exist':'\\u2203','Exists':'\\u2203','expectation':'\\u2130','exponentiale':'\\u2147','ExponentialE':'\\u2147','fallingdotseq':'\\u2252','fcy':'\\u0444','Fcy':'\\u0424','female':'\\u2640','ffilig':'\\uFB03','fflig':'\\uFB00','ffllig':'\\uFB04','ffr':'\\uD835\\uDD23','Ffr':'\\uD835\\uDD09','filig':'\\uFB01','FilledSmallSquare':'\\u25FC','FilledVerySmallSquare':'\\u25AA','fjlig':'fj','flat':'\\u266D','fllig':'\\uFB02','fltns':'\\u25B1','fnof':'\\u0192','fopf':'\\uD835\\uDD57','Fopf':'\\uD835\\uDD3D','forall':'\\u2200','ForAll':'\\u2200','fork':'\\u22D4','forkv':'\\u2AD9','Fouriertrf':'\\u2131','fpartint':'\\u2A0D','frac12':'\\xBD','frac13':'\\u2153','frac14':'\\xBC','frac15':'\\u2155','frac16':'\\u2159','frac18':'\\u215B','frac23':'\\u2154','frac25':'\\u2156','frac34':'\\xBE','frac35':'\\u2157','frac38':'\\u215C','frac45':'\\u2158','frac56':'\\u215A','frac58':'\\u215D','frac78':'\\u215E','frasl':'\\u2044','frown':'\\u2322','fscr':'\\uD835\\uDCBB','Fscr':'\\u2131','gacute':'\\u01F5','gamma':'\\u03B3','Gamma':'\\u0393','gammad':'\\u03DD','Gammad':'\\u03DC','gap':'\\u2A86','gbreve':'\\u011F','Gbreve':'\\u011E','Gcedil':'\\u0122','gcirc':'\\u011D','Gcirc':'\\u011C','gcy':'\\u0433','Gcy':'\\u0413','gdot':'\\u0121','Gdot':'\\u0120','ge':'\\u2265','gE':'\\u2267','gel':'\\u22DB','gEl':'\\u2A8C','geq':'\\u2265','geqq':'\\u2267','geqslant':'\\u2A7E','ges':'\\u2A7E','gescc':'\\u2AA9','gesdot':'\\u2A80','gesdoto':'\\u2A82','gesdotol':'\\u2A84','gesl':'\\u22DB\\uFE00','gesles':'\\u2A94','gfr':'\\uD835\\uDD24','Gfr':'\\uD835\\uDD0A','gg':'\\u226B','Gg':'\\u22D9','ggg':'\\u22D9','gimel':'\\u2137','gjcy':'\\u0453','GJcy':'\\u0403','gl':'\\u2277','gla':'\\u2AA5','glE':'\\u2A92','glj':'\\u2AA4','gnap':'\\u2A8A','gnapprox':'\\u2A8A','gne':'\\u2A88','gnE':'\\u2269','gneq':'\\u2A88','gneqq':'\\u2269','gnsim':'\\u22E7','gopf':'\\uD835\\uDD58','Gopf':'\\uD835\\uDD3E','grave':'`','GreaterEqual':'\\u2265','GreaterEqualLess':'\\u22DB','GreaterFullEqual':'\\u2267','GreaterGreater':'\\u2AA2','GreaterLess':'\\u2277','GreaterSlantEqual':'\\u2A7E','GreaterTilde':'\\u2273','gscr':'\\u210A','Gscr':'\\uD835\\uDCA2','gsim':'\\u2273','gsime':'\\u2A8E','gsiml':'\\u2A90','gt':'>','Gt':'\\u226B','GT':'>','gtcc':'\\u2AA7','gtcir':'\\u2A7A','gtdot':'\\u22D7','gtlPar':'\\u2995','gtquest':'\\u2A7C','gtrapprox':'\\u2A86','gtrarr':'\\u2978','gtrdot':'\\u22D7','gtreqless':'\\u22DB','gtreqqless':'\\u2A8C','gtrless':'\\u2277','gtrsim':'\\u2273','gvertneqq':'\\u2269\\uFE00','gvnE':'\\u2269\\uFE00','Hacek':'\\u02C7','hairsp':'\\u200A','half':'\\xBD','hamilt':'\\u210B','hardcy':'\\u044A','HARDcy':'\\u042A','harr':'\\u2194','hArr':'\\u21D4','harrcir':'\\u2948','harrw':'\\u21AD','Hat':'^','hbar':'\\u210F','hcirc':'\\u0125','Hcirc':'\\u0124','hearts':'\\u2665','heartsuit':'\\u2665','hellip':'\\u2026','hercon':'\\u22B9','hfr':'\\uD835\\uDD25','Hfr':'\\u210C','HilbertSpace':'\\u210B','hksearow':'\\u2925','hkswarow':'\\u2926','hoarr':'\\u21FF','homtht':'\\u223B','hookleftarrow':'\\u21A9','hookrightarrow':'\\u21AA','hopf':'\\uD835\\uDD59','Hopf':'\\u210D','horbar':'\\u2015','HorizontalLine':'\\u2500','hscr':'\\uD835\\uDCBD','Hscr':'\\u210B','hslash':'\\u210F','hstrok':'\\u0127','Hstrok':'\\u0126','HumpDownHump':'\\u224E','HumpEqual':'\\u224F','hybull':'\\u2043','hyphen':'\\u2010','iacute':'\\xED','Iacute':'\\xCD','ic':'\\u2063','icirc':'\\xEE','Icirc':'\\xCE','icy':'\\u0438','Icy':'\\u0418','Idot':'\\u0130','iecy':'\\u0435','IEcy':'\\u0415','iexcl':'\\xA1','iff':'\\u21D4','ifr':'\\uD835\\uDD26','Ifr':'\\u2111','igrave':'\\xEC','Igrave':'\\xCC','ii':'\\u2148','iiiint':'\\u2A0C','iiint':'\\u222D','iinfin':'\\u29DC','iiota':'\\u2129','ijlig':'\\u0133','IJlig':'\\u0132','Im':'\\u2111','imacr':'\\u012B','Imacr':'\\u012A','image':'\\u2111','ImaginaryI':'\\u2148','imagline':'\\u2110','imagpart':'\\u2111','imath':'\\u0131','imof':'\\u22B7','imped':'\\u01B5','Implies':'\\u21D2','in':'\\u2208','incare':'\\u2105','infin':'\\u221E','infintie':'\\u29DD','inodot':'\\u0131','int':'\\u222B','Int':'\\u222C','intcal':'\\u22BA','integers':'\\u2124','Integral':'\\u222B','intercal':'\\u22BA','Intersection':'\\u22C2','intlarhk':'\\u2A17','intprod':'\\u2A3C','InvisibleComma':'\\u2063','InvisibleTimes':'\\u2062','iocy':'\\u0451','IOcy':'\\u0401','iogon':'\\u012F','Iogon':'\\u012E','iopf':'\\uD835\\uDD5A','Iopf':'\\uD835\\uDD40','iota':'\\u03B9','Iota':'\\u0399','iprod':'\\u2A3C','iquest':'\\xBF','iscr':'\\uD835\\uDCBE','Iscr':'\\u2110','isin':'\\u2208','isindot':'\\u22F5','isinE':'\\u22F9','isins':'\\u22F4','isinsv':'\\u22F3','isinv':'\\u2208','it':'\\u2062','itilde':'\\u0129','Itilde':'\\u0128','iukcy':'\\u0456','Iukcy':'\\u0406','iuml':'\\xEF','Iuml':'\\xCF','jcirc':'\\u0135','Jcirc':'\\u0134','jcy':'\\u0439','Jcy':'\\u0419','jfr':'\\uD835\\uDD27','Jfr':'\\uD835\\uDD0D','jmath':'\\u0237','jopf':'\\uD835\\uDD5B','Jopf':'\\uD835\\uDD41','jscr':'\\uD835\\uDCBF','Jscr':'\\uD835\\uDCA5','jsercy':'\\u0458','Jsercy':'\\u0408','jukcy':'\\u0454','Jukcy':'\\u0404','kappa':'\\u03BA','Kappa':'\\u039A','kappav':'\\u03F0','kcedil':'\\u0137','Kcedil':'\\u0136','kcy':'\\u043A','Kcy':'\\u041A','kfr':'\\uD835\\uDD28','Kfr':'\\uD835\\uDD0E','kgreen':'\\u0138','khcy':'\\u0445','KHcy':'\\u0425','kjcy':'\\u045C','KJcy':'\\u040C','kopf':'\\uD835\\uDD5C','Kopf':'\\uD835\\uDD42','kscr':'\\uD835\\uDCC0','Kscr':'\\uD835\\uDCA6','lAarr':'\\u21DA','lacute':'\\u013A','Lacute':'\\u0139','laemptyv':'\\u29B4','lagran':'\\u2112','lambda':'\\u03BB','Lambda':'\\u039B','lang':'\\u27E8','Lang':'\\u27EA','langd':'\\u2991','langle':'\\u27E8','lap':'\\u2A85','Laplacetrf':'\\u2112','laquo':'\\xAB','larr':'\\u2190','lArr':'\\u21D0','Larr':'\\u219E','larrb':'\\u21E4','larrbfs':'\\u291F','larrfs':'\\u291D','larrhk':'\\u21A9','larrlp':'\\u21AB','larrpl':'\\u2939','larrsim':'\\u2973','larrtl':'\\u21A2','lat':'\\u2AAB','latail':'\\u2919','lAtail':'\\u291B','late':'\\u2AAD','lates':'\\u2AAD\\uFE00','lbarr':'\\u290C','lBarr':'\\u290E','lbbrk':'\\u2772','lbrace':'{','lbrack':'[','lbrke':'\\u298B','lbrksld':'\\u298F','lbrkslu':'\\u298D','lcaron':'\\u013E','Lcaron':'\\u013D','lcedil':'\\u013C','Lcedil':'\\u013B','lceil':'\\u2308','lcub':'{','lcy':'\\u043B','Lcy':'\\u041B','ldca':'\\u2936','ldquo':'\\u201C','ldquor':'\\u201E','ldrdhar':'\\u2967','ldrushar':'\\u294B','ldsh':'\\u21B2','le':'\\u2264','lE':'\\u2266','LeftAngleBracket':'\\u27E8','leftarrow':'\\u2190','Leftarrow':'\\u21D0','LeftArrow':'\\u2190','LeftArrowBar':'\\u21E4','LeftArrowRightArrow':'\\u21C6','leftarrowtail':'\\u21A2','LeftCeiling':'\\u2308','LeftDoubleBracket':'\\u27E6','LeftDownTeeVector':'\\u2961','LeftDownVector':'\\u21C3','LeftDownVectorBar':'\\u2959','LeftFloor':'\\u230A','leftharpoondown':'\\u21BD','leftharpoonup':'\\u21BC','leftleftarrows':'\\u21C7','leftrightarrow':'\\u2194','Leftrightarrow':'\\u21D4','LeftRightArrow':'\\u2194','leftrightarrows':'\\u21C6','leftrightharpoons':'\\u21CB','leftrightsquigarrow':'\\u21AD','LeftRightVector':'\\u294E','LeftTee':'\\u22A3','LeftTeeArrow':'\\u21A4','LeftTeeVector':'\\u295A','leftthreetimes':'\\u22CB','LeftTriangle':'\\u22B2','LeftTriangleBar':'\\u29CF','LeftTriangleEqual':'\\u22B4','LeftUpDownVector':'\\u2951','LeftUpTeeVector':'\\u2960','LeftUpVector':'\\u21BF','LeftUpVectorBar':'\\u2958','LeftVector':'\\u21BC','LeftVectorBar':'\\u2952','leg':'\\u22DA','lEg':'\\u2A8B','leq':'\\u2264','leqq':'\\u2266','leqslant':'\\u2A7D','les':'\\u2A7D','lescc':'\\u2AA8','lesdot':'\\u2A7F','lesdoto':'\\u2A81','lesdotor':'\\u2A83','lesg':'\\u22DA\\uFE00','lesges':'\\u2A93','lessapprox':'\\u2A85','lessdot':'\\u22D6','lesseqgtr':'\\u22DA','lesseqqgtr':'\\u2A8B','LessEqualGreater':'\\u22DA','LessFullEqual':'\\u2266','LessGreater':'\\u2276','lessgtr':'\\u2276','LessLess':'\\u2AA1','lesssim':'\\u2272','LessSlantEqual':'\\u2A7D','LessTilde':'\\u2272','lfisht':'\\u297C','lfloor':'\\u230A','lfr':'\\uD835\\uDD29','Lfr':'\\uD835\\uDD0F','lg':'\\u2276','lgE':'\\u2A91','lHar':'\\u2962','lhard':'\\u21BD','lharu':'\\u21BC','lharul':'\\u296A','lhblk':'\\u2584','ljcy':'\\u0459','LJcy':'\\u0409','ll':'\\u226A','Ll':'\\u22D8','llarr':'\\u21C7','llcorner':'\\u231E','Lleftarrow':'\\u21DA','llhard':'\\u296B','lltri':'\\u25FA','lmidot':'\\u0140','Lmidot':'\\u013F','lmoust':'\\u23B0','lmoustache':'\\u23B0','lnap':'\\u2A89','lnapprox':'\\u2A89','lne':'\\u2A87','lnE':'\\u2268','lneq':'\\u2A87','lneqq':'\\u2268','lnsim':'\\u22E6','loang':'\\u27EC','loarr':'\\u21FD','lobrk':'\\u27E6','longleftarrow':'\\u27F5','Longleftarrow':'\\u27F8','LongLeftArrow':'\\u27F5','longleftrightarrow':'\\u27F7','Longleftrightarrow':'\\u27FA','LongLeftRightArrow':'\\u27F7','longmapsto':'\\u27FC','longrightarrow':'\\u27F6','Longrightarrow':'\\u27F9','LongRightArrow':'\\u27F6','looparrowleft':'\\u21AB','looparrowright':'\\u21AC','lopar':'\\u2985','lopf':'\\uD835\\uDD5D','Lopf':'\\uD835\\uDD43','loplus':'\\u2A2D','lotimes':'\\u2A34','lowast':'\\u2217','lowbar':'_','LowerLeftArrow':'\\u2199','LowerRightArrow':'\\u2198','loz':'\\u25CA','lozenge':'\\u25CA','lozf':'\\u29EB','lpar':'(','lparlt':'\\u2993','lrarr':'\\u21C6','lrcorner':'\\u231F','lrhar':'\\u21CB','lrhard':'\\u296D','lrm':'\\u200E','lrtri':'\\u22BF','lsaquo':'\\u2039','lscr':'\\uD835\\uDCC1','Lscr':'\\u2112','lsh':'\\u21B0','Lsh':'\\u21B0','lsim':'\\u2272','lsime':'\\u2A8D','lsimg':'\\u2A8F','lsqb':'[','lsquo':'\\u2018','lsquor':'\\u201A','lstrok':'\\u0142','Lstrok':'\\u0141','lt':'<','Lt':'\\u226A','LT':'<','ltcc':'\\u2AA6','ltcir':'\\u2A79','ltdot':'\\u22D6','lthree':'\\u22CB','ltimes':'\\u22C9','ltlarr':'\\u2976','ltquest':'\\u2A7B','ltri':'\\u25C3','ltrie':'\\u22B4','ltrif':'\\u25C2','ltrPar':'\\u2996','lurdshar':'\\u294A','luruhar':'\\u2966','lvertneqq':'\\u2268\\uFE00','lvnE':'\\u2268\\uFE00','macr':'\\xAF','male':'\\u2642','malt':'\\u2720','maltese':'\\u2720','map':'\\u21A6','Map':'\\u2905','mapsto':'\\u21A6','mapstodown':'\\u21A7','mapstoleft':'\\u21A4','mapstoup':'\\u21A5','marker':'\\u25AE','mcomma':'\\u2A29','mcy':'\\u043C','Mcy':'\\u041C','mdash':'\\u2014','mDDot':'\\u223A','measuredangle':'\\u2221','MediumSpace':'\\u205F','Mellintrf':'\\u2133','mfr':'\\uD835\\uDD2A','Mfr':'\\uD835\\uDD10','mho':'\\u2127','micro':'\\xB5','mid':'\\u2223','midast':'*','midcir':'\\u2AF0','middot':'\\xB7','minus':'\\u2212','minusb':'\\u229F','minusd':'\\u2238','minusdu':'\\u2A2A','MinusPlus':'\\u2213','mlcp':'\\u2ADB','mldr':'\\u2026','mnplus':'\\u2213','models':'\\u22A7','mopf':'\\uD835\\uDD5E','Mopf':'\\uD835\\uDD44','mp':'\\u2213','mscr':'\\uD835\\uDCC2','Mscr':'\\u2133','mstpos':'\\u223E','mu':'\\u03BC','Mu':'\\u039C','multimap':'\\u22B8','mumap':'\\u22B8','nabla':'\\u2207','nacute':'\\u0144','Nacute':'\\u0143','nang':'\\u2220\\u20D2','nap':'\\u2249','napE':'\\u2A70\\u0338','napid':'\\u224B\\u0338','napos':'\\u0149','napprox':'\\u2249','natur':'\\u266E','natural':'\\u266E','naturals':'\\u2115','nbsp':'\\xA0','nbump':'\\u224E\\u0338','nbumpe':'\\u224F\\u0338','ncap':'\\u2A43','ncaron':'\\u0148','Ncaron':'\\u0147','ncedil':'\\u0146','Ncedil':'\\u0145','ncong':'\\u2247','ncongdot':'\\u2A6D\\u0338','ncup':'\\u2A42','ncy':'\\u043D','Ncy':'\\u041D','ndash':'\\u2013','ne':'\\u2260','nearhk':'\\u2924','nearr':'\\u2197','neArr':'\\u21D7','nearrow':'\\u2197','nedot':'\\u2250\\u0338','NegativeMediumSpace':'\\u200B','NegativeThickSpace':'\\u200B','NegativeThinSpace':'\\u200B','NegativeVeryThinSpace':'\\u200B','nequiv':'\\u2262','nesear':'\\u2928','nesim':'\\u2242\\u0338','NestedGreaterGreater':'\\u226B','NestedLessLess':'\\u226A','NewLine':'\\n','nexist':'\\u2204','nexists':'\\u2204','nfr':'\\uD835\\uDD2B','Nfr':'\\uD835\\uDD11','nge':'\\u2271','ngE':'\\u2267\\u0338','ngeq':'\\u2271','ngeqq':'\\u2267\\u0338','ngeqslant':'\\u2A7E\\u0338','nges':'\\u2A7E\\u0338','nGg':'\\u22D9\\u0338','ngsim':'\\u2275','ngt':'\\u226F','nGt':'\\u226B\\u20D2','ngtr':'\\u226F','nGtv':'\\u226B\\u0338','nharr':'\\u21AE','nhArr':'\\u21CE','nhpar':'\\u2AF2','ni':'\\u220B','nis':'\\u22FC','nisd':'\\u22FA','niv':'\\u220B','njcy':'\\u045A','NJcy':'\\u040A','nlarr':'\\u219A','nlArr':'\\u21CD','nldr':'\\u2025','nle':'\\u2270','nlE':'\\u2266\\u0338','nleftarrow':'\\u219A','nLeftarrow':'\\u21CD','nleftrightarrow':'\\u21AE','nLeftrightarrow':'\\u21CE','nleq':'\\u2270','nleqq':'\\u2266\\u0338','nleqslant':'\\u2A7D\\u0338','nles':'\\u2A7D\\u0338','nless':'\\u226E','nLl':'\\u22D8\\u0338','nlsim':'\\u2274','nlt':'\\u226E','nLt':'\\u226A\\u20D2','nltri':'\\u22EA','nltrie':'\\u22EC','nLtv':'\\u226A\\u0338','nmid':'\\u2224','NoBreak':'\\u2060','NonBreakingSpace':'\\xA0','nopf':'\\uD835\\uDD5F','Nopf':'\\u2115','not':'\\xAC','Not':'\\u2AEC','NotCongruent':'\\u2262','NotCupCap':'\\u226D','NotDoubleVerticalBar':'\\u2226','NotElement':'\\u2209','NotEqual':'\\u2260','NotEqualTilde':'\\u2242\\u0338','NotExists':'\\u2204','NotGreater':'\\u226F','NotGreaterEqual':'\\u2271','NotGreaterFullEqual':'\\u2267\\u0338','NotGreaterGreater':'\\u226B\\u0338','NotGreaterLess':'\\u2279','NotGreaterSlantEqual':'\\u2A7E\\u0338','NotGreaterTilde':'\\u2275','NotHumpDownHump':'\\u224E\\u0338','NotHumpEqual':'\\u224F\\u0338','notin':'\\u2209','notindot':'\\u22F5\\u0338','notinE':'\\u22F9\\u0338','notinva':'\\u2209','notinvb':'\\u22F7','notinvc':'\\u22F6','NotLeftTriangle':'\\u22EA','NotLeftTriangleBar':'\\u29CF\\u0338','NotLeftTriangleEqual':'\\u22EC','NotLess':'\\u226E','NotLessEqual':'\\u2270','NotLessGreater':'\\u2278','NotLessLess':'\\u226A\\u0338','NotLessSlantEqual':'\\u2A7D\\u0338','NotLessTilde':'\\u2274','NotNestedGreaterGreater':'\\u2AA2\\u0338','NotNestedLessLess':'\\u2AA1\\u0338','notni':'\\u220C','notniva':'\\u220C','notnivb':'\\u22FE','notnivc':'\\u22FD','NotPrecedes':'\\u2280','NotPrecedesEqual':'\\u2AAF\\u0338','NotPrecedesSlantEqual':'\\u22E0','NotReverseElement':'\\u220C','NotRightTriangle':'\\u22EB','NotRightTriangleBar':'\\u29D0\\u0338','NotRightTriangleEqual':'\\u22ED','NotSquareSubset':'\\u228F\\u0338','NotSquareSubsetEqual':'\\u22E2','NotSquareSuperset':'\\u2290\\u0338','NotSquareSupersetEqual':'\\u22E3','NotSubset':'\\u2282\\u20D2','NotSubsetEqual':'\\u2288','NotSucceeds':'\\u2281','NotSucceedsEqual':'\\u2AB0\\u0338','NotSucceedsSlantEqual':'\\u22E1','NotSucceedsTilde':'\\u227F\\u0338','NotSuperset':'\\u2283\\u20D2','NotSupersetEqual':'\\u2289','NotTilde':'\\u2241','NotTildeEqual':'\\u2244','NotTildeFullEqual':'\\u2247','NotTildeTilde':'\\u2249','NotVerticalBar':'\\u2224','npar':'\\u2226','nparallel':'\\u2226','nparsl':'\\u2AFD\\u20E5','npart':'\\u2202\\u0338','npolint':'\\u2A14','npr':'\\u2280','nprcue':'\\u22E0','npre':'\\u2AAF\\u0338','nprec':'\\u2280','npreceq':'\\u2AAF\\u0338','nrarr':'\\u219B','nrArr':'\\u21CF','nrarrc':'\\u2933\\u0338','nrarrw':'\\u219D\\u0338','nrightarrow':'\\u219B','nRightarrow':'\\u21CF','nrtri':'\\u22EB','nrtrie':'\\u22ED','nsc':'\\u2281','nsccue':'\\u22E1','nsce':'\\u2AB0\\u0338','nscr':'\\uD835\\uDCC3','Nscr':'\\uD835\\uDCA9','nshortmid':'\\u2224','nshortparallel':'\\u2226','nsim':'\\u2241','nsime':'\\u2244','nsimeq':'\\u2244','nsmid':'\\u2224','nspar':'\\u2226','nsqsube':'\\u22E2','nsqsupe':'\\u22E3','nsub':'\\u2284','nsube':'\\u2288','nsubE':'\\u2AC5\\u0338','nsubset':'\\u2282\\u20D2','nsubseteq':'\\u2288','nsubseteqq':'\\u2AC5\\u0338','nsucc':'\\u2281','nsucceq':'\\u2AB0\\u0338','nsup':'\\u2285','nsupe':'\\u2289','nsupE':'\\u2AC6\\u0338','nsupset':'\\u2283\\u20D2','nsupseteq':'\\u2289','nsupseteqq':'\\u2AC6\\u0338','ntgl':'\\u2279','ntilde':'\\xF1','Ntilde':'\\xD1','ntlg':'\\u2278','ntriangleleft':'\\u22EA','ntrianglelefteq':'\\u22EC','ntriangleright':'\\u22EB','ntrianglerighteq':'\\u22ED','nu':'\\u03BD','Nu':'\\u039D','num':'#','numero':'\\u2116','numsp':'\\u2007','nvap':'\\u224D\\u20D2','nvdash':'\\u22AC','nvDash':'\\u22AD','nVdash':'\\u22AE','nVDash':'\\u22AF','nvge':'\\u2265\\u20D2','nvgt':'>\\u20D2','nvHarr':'\\u2904','nvinfin':'\\u29DE','nvlArr':'\\u2902','nvle':'\\u2264\\u20D2','nvlt':'<\\u20D2','nvltrie':'\\u22B4\\u20D2','nvrArr':'\\u2903','nvrtrie':'\\u22B5\\u20D2','nvsim':'\\u223C\\u20D2','nwarhk':'\\u2923','nwarr':'\\u2196','nwArr':'\\u21D6','nwarrow':'\\u2196','nwnear':'\\u2927','oacute':'\\xF3','Oacute':'\\xD3','oast':'\\u229B','ocir':'\\u229A','ocirc':'\\xF4','Ocirc':'\\xD4','ocy':'\\u043E','Ocy':'\\u041E','odash':'\\u229D','odblac':'\\u0151','Odblac':'\\u0150','odiv':'\\u2A38','odot':'\\u2299','odsold':'\\u29BC','oelig':'\\u0153','OElig':'\\u0152','ofcir':'\\u29BF','ofr':'\\uD835\\uDD2C','Ofr':'\\uD835\\uDD12','ogon':'\\u02DB','ograve':'\\xF2','Ograve':'\\xD2','ogt':'\\u29C1','ohbar':'\\u29B5','ohm':'\\u03A9','oint':'\\u222E','olarr':'\\u21BA','olcir':'\\u29BE','olcross':'\\u29BB','oline':'\\u203E','olt':'\\u29C0','omacr':'\\u014D','Omacr':'\\u014C','omega':'\\u03C9','Omega':'\\u03A9','omicron':'\\u03BF','Omicron':'\\u039F','omid':'\\u29B6','ominus':'\\u2296','oopf':'\\uD835\\uDD60','Oopf':'\\uD835\\uDD46','opar':'\\u29B7','OpenCurlyDoubleQuote':'\\u201C','OpenCurlyQuote':'\\u2018','operp':'\\u29B9','oplus':'\\u2295','or':'\\u2228','Or':'\\u2A54','orarr':'\\u21BB','ord':'\\u2A5D','order':'\\u2134','orderof':'\\u2134','ordf':'\\xAA','ordm':'\\xBA','origof':'\\u22B6','oror':'\\u2A56','orslope':'\\u2A57','orv':'\\u2A5B','oS':'\\u24C8','oscr':'\\u2134','Oscr':'\\uD835\\uDCAA','oslash':'\\xF8','Oslash':'\\xD8','osol':'\\u2298','otilde':'\\xF5','Otilde':'\\xD5','otimes':'\\u2297','Otimes':'\\u2A37','otimesas':'\\u2A36','ouml':'\\xF6','Ouml':'\\xD6','ovbar':'\\u233D','OverBar':'\\u203E','OverBrace':'\\u23DE','OverBracket':'\\u23B4','OverParenthesis':'\\u23DC','par':'\\u2225','para':'\\xB6','parallel':'\\u2225','parsim':'\\u2AF3','parsl':'\\u2AFD','part':'\\u2202','PartialD':'\\u2202','pcy':'\\u043F','Pcy':'\\u041F','percnt':'%','period':'.','permil':'\\u2030','perp':'\\u22A5','pertenk':'\\u2031','pfr':'\\uD835\\uDD2D','Pfr':'\\uD835\\uDD13','phi':'\\u03C6','Phi':'\\u03A6','phiv':'\\u03D5','phmmat':'\\u2133','phone':'\\u260E','pi':'\\u03C0','Pi':'\\u03A0','pitchfork':'\\u22D4','piv':'\\u03D6','planck':'\\u210F','planckh':'\\u210E','plankv':'\\u210F','plus':'+','plusacir':'\\u2A23','plusb':'\\u229E','pluscir':'\\u2A22','plusdo':'\\u2214','plusdu':'\\u2A25','pluse':'\\u2A72','PlusMinus':'\\xB1','plusmn':'\\xB1','plussim':'\\u2A26','plustwo':'\\u2A27','pm':'\\xB1','Poincareplane':'\\u210C','pointint':'\\u2A15','popf':'\\uD835\\uDD61','Popf':'\\u2119','pound':'\\xA3','pr':'\\u227A','Pr':'\\u2ABB','prap':'\\u2AB7','prcue':'\\u227C','pre':'\\u2AAF','prE':'\\u2AB3','prec':'\\u227A','precapprox':'\\u2AB7','preccurlyeq':'\\u227C','Precedes':'\\u227A','PrecedesEqual':'\\u2AAF','PrecedesSlantEqual':'\\u227C','PrecedesTilde':'\\u227E','preceq':'\\u2AAF','precnapprox':'\\u2AB9','precneqq':'\\u2AB5','precnsim':'\\u22E8','precsim':'\\u227E','prime':'\\u2032','Prime':'\\u2033','primes':'\\u2119','prnap':'\\u2AB9','prnE':'\\u2AB5','prnsim':'\\u22E8','prod':'\\u220F','Product':'\\u220F','profalar':'\\u232E','profline':'\\u2312','profsurf':'\\u2313','prop':'\\u221D','Proportion':'\\u2237','Proportional':'\\u221D','propto':'\\u221D','prsim':'\\u227E','prurel':'\\u22B0','pscr':'\\uD835\\uDCC5','Pscr':'\\uD835\\uDCAB','psi':'\\u03C8','Psi':'\\u03A8','puncsp':'\\u2008','qfr':'\\uD835\\uDD2E','Qfr':'\\uD835\\uDD14','qint':'\\u2A0C','qopf':'\\uD835\\uDD62','Qopf':'\\u211A','qprime':'\\u2057','qscr':'\\uD835\\uDCC6','Qscr':'\\uD835\\uDCAC','quaternions':'\\u210D','quatint':'\\u2A16','quest':'?','questeq':'\\u225F','quot':'\"','QUOT':'\"','rAarr':'\\u21DB','race':'\\u223D\\u0331','racute':'\\u0155','Racute':'\\u0154','radic':'\\u221A','raemptyv':'\\u29B3','rang':'\\u27E9','Rang':'\\u27EB','rangd':'\\u2992','range':'\\u29A5','rangle':'\\u27E9','raquo':'\\xBB','rarr':'\\u2192','rArr':'\\u21D2','Rarr':'\\u21A0','rarrap':'\\u2975','rarrb':'\\u21E5','rarrbfs':'\\u2920','rarrc':'\\u2933','rarrfs':'\\u291E','rarrhk':'\\u21AA','rarrlp':'\\u21AC','rarrpl':'\\u2945','rarrsim':'\\u2974','rarrtl':'\\u21A3','Rarrtl':'\\u2916','rarrw':'\\u219D','ratail':'\\u291A','rAtail':'\\u291C','ratio':'\\u2236','rationals':'\\u211A','rbarr':'\\u290D','rBarr':'\\u290F','RBarr':'\\u2910','rbbrk':'\\u2773','rbrace':'}','rbrack':']','rbrke':'\\u298C','rbrksld':'\\u298E','rbrkslu':'\\u2990','rcaron':'\\u0159','Rcaron':'\\u0158','rcedil':'\\u0157','Rcedil':'\\u0156','rceil':'\\u2309','rcub':'}','rcy':'\\u0440','Rcy':'\\u0420','rdca':'\\u2937','rdldhar':'\\u2969','rdquo':'\\u201D','rdquor':'\\u201D','rdsh':'\\u21B3','Re':'\\u211C','real':'\\u211C','realine':'\\u211B','realpart':'\\u211C','reals':'\\u211D','rect':'\\u25AD','reg':'\\xAE','REG':'\\xAE','ReverseElement':'\\u220B','ReverseEquilibrium':'\\u21CB','ReverseUpEquilibrium':'\\u296F','rfisht':'\\u297D','rfloor':'\\u230B','rfr':'\\uD835\\uDD2F','Rfr':'\\u211C','rHar':'\\u2964','rhard':'\\u21C1','rharu':'\\u21C0','rharul':'\\u296C','rho':'\\u03C1','Rho':'\\u03A1','rhov':'\\u03F1','RightAngleBracket':'\\u27E9','rightarrow':'\\u2192','Rightarrow':'\\u21D2','RightArrow':'\\u2192','RightArrowBar':'\\u21E5','RightArrowLeftArrow':'\\u21C4','rightarrowtail':'\\u21A3','RightCeiling':'\\u2309','RightDoubleBracket':'\\u27E7','RightDownTeeVector':'\\u295D','RightDownVector':'\\u21C2','RightDownVectorBar':'\\u2955','RightFloor':'\\u230B','rightharpoondown':'\\u21C1','rightharpoonup':'\\u21C0','rightleftarrows':'\\u21C4','rightleftharpoons':'\\u21CC','rightrightarrows':'\\u21C9','rightsquigarrow':'\\u219D','RightTee':'\\u22A2','RightTeeArrow':'\\u21A6','RightTeeVector':'\\u295B','rightthreetimes':'\\u22CC','RightTriangle':'\\u22B3','RightTriangleBar':'\\u29D0','RightTriangleEqual':'\\u22B5','RightUpDownVector':'\\u294F','RightUpTeeVector':'\\u295C','RightUpVector':'\\u21BE','RightUpVectorBar':'\\u2954','RightVector':'\\u21C0','RightVectorBar':'\\u2953','ring':'\\u02DA','risingdotseq':'\\u2253','rlarr':'\\u21C4','rlhar':'\\u21CC','rlm':'\\u200F','rmoust':'\\u23B1','rmoustache':'\\u23B1','rnmid':'\\u2AEE','roang':'\\u27ED','roarr':'\\u21FE','robrk':'\\u27E7','ropar':'\\u2986','ropf':'\\uD835\\uDD63','Ropf':'\\u211D','roplus':'\\u2A2E','rotimes':'\\u2A35','RoundImplies':'\\u2970','rpar':')','rpargt':'\\u2994','rppolint':'\\u2A12','rrarr':'\\u21C9','Rrightarrow':'\\u21DB','rsaquo':'\\u203A','rscr':'\\uD835\\uDCC7','Rscr':'\\u211B','rsh':'\\u21B1','Rsh':'\\u21B1','rsqb':']','rsquo':'\\u2019','rsquor':'\\u2019','rthree':'\\u22CC','rtimes':'\\u22CA','rtri':'\\u25B9','rtrie':'\\u22B5','rtrif':'\\u25B8','rtriltri':'\\u29CE','RuleDelayed':'\\u29F4','ruluhar':'\\u2968','rx':'\\u211E','sacute':'\\u015B','Sacute':'\\u015A','sbquo':'\\u201A','sc':'\\u227B','Sc':'\\u2ABC','scap':'\\u2AB8','scaron':'\\u0161','Scaron':'\\u0160','sccue':'\\u227D','sce':'\\u2AB0','scE':'\\u2AB4','scedil':'\\u015F','Scedil':'\\u015E','scirc':'\\u015D','Scirc':'\\u015C','scnap':'\\u2ABA','scnE':'\\u2AB6','scnsim':'\\u22E9','scpolint':'\\u2A13','scsim':'\\u227F','scy':'\\u0441','Scy':'\\u0421','sdot':'\\u22C5','sdotb':'\\u22A1','sdote':'\\u2A66','searhk':'\\u2925','searr':'\\u2198','seArr':'\\u21D8','searrow':'\\u2198','sect':'\\xA7','semi':';','seswar':'\\u2929','setminus':'\\u2216','setmn':'\\u2216','sext':'\\u2736','sfr':'\\uD835\\uDD30','Sfr':'\\uD835\\uDD16','sfrown':'\\u2322','sharp':'\\u266F','shchcy':'\\u0449','SHCHcy':'\\u0429','shcy':'\\u0448','SHcy':'\\u0428','ShortDownArrow':'\\u2193','ShortLeftArrow':'\\u2190','shortmid':'\\u2223','shortparallel':'\\u2225','ShortRightArrow':'\\u2192','ShortUpArrow':'\\u2191','shy':'\\xAD','sigma':'\\u03C3','Sigma':'\\u03A3','sigmaf':'\\u03C2','sigmav':'\\u03C2','sim':'\\u223C','simdot':'\\u2A6A','sime':'\\u2243','simeq':'\\u2243','simg':'\\u2A9E','simgE':'\\u2AA0','siml':'\\u2A9D','simlE':'\\u2A9F','simne':'\\u2246','simplus':'\\u2A24','simrarr':'\\u2972','slarr':'\\u2190','SmallCircle':'\\u2218','smallsetminus':'\\u2216','smashp':'\\u2A33','smeparsl':'\\u29E4','smid':'\\u2223','smile':'\\u2323','smt':'\\u2AAA','smte':'\\u2AAC','smtes':'\\u2AAC\\uFE00','softcy':'\\u044C','SOFTcy':'\\u042C','sol':'/','solb':'\\u29C4','solbar':'\\u233F','sopf':'\\uD835\\uDD64','Sopf':'\\uD835\\uDD4A','spades':'\\u2660','spadesuit':'\\u2660','spar':'\\u2225','sqcap':'\\u2293','sqcaps':'\\u2293\\uFE00','sqcup':'\\u2294','sqcups':'\\u2294\\uFE00','Sqrt':'\\u221A','sqsub':'\\u228F','sqsube':'\\u2291','sqsubset':'\\u228F','sqsubseteq':'\\u2291','sqsup':'\\u2290','sqsupe':'\\u2292','sqsupset':'\\u2290','sqsupseteq':'\\u2292','squ':'\\u25A1','square':'\\u25A1','Square':'\\u25A1','SquareIntersection':'\\u2293','SquareSubset':'\\u228F','SquareSubsetEqual':'\\u2291','SquareSuperset':'\\u2290','SquareSupersetEqual':'\\u2292','SquareUnion':'\\u2294','squarf':'\\u25AA','squf':'\\u25AA','srarr':'\\u2192','sscr':'\\uD835\\uDCC8','Sscr':'\\uD835\\uDCAE','ssetmn':'\\u2216','ssmile':'\\u2323','sstarf':'\\u22C6','star':'\\u2606','Star':'\\u22C6','starf':'\\u2605','straightepsilon':'\\u03F5','straightphi':'\\u03D5','strns':'\\xAF','sub':'\\u2282','Sub':'\\u22D0','subdot':'\\u2ABD','sube':'\\u2286','subE':'\\u2AC5','subedot':'\\u2AC3','submult':'\\u2AC1','subne':'\\u228A','subnE':'\\u2ACB','subplus':'\\u2ABF','subrarr':'\\u2979','subset':'\\u2282','Subset':'\\u22D0','subseteq':'\\u2286','subseteqq':'\\u2AC5','SubsetEqual':'\\u2286','subsetneq':'\\u228A','subsetneqq':'\\u2ACB','subsim':'\\u2AC7','subsub':'\\u2AD5','subsup':'\\u2AD3','succ':'\\u227B','succapprox':'\\u2AB8','succcurlyeq':'\\u227D','Succeeds':'\\u227B','SucceedsEqual':'\\u2AB0','SucceedsSlantEqual':'\\u227D','SucceedsTilde':'\\u227F','succeq':'\\u2AB0','succnapprox':'\\u2ABA','succneqq':'\\u2AB6','succnsim':'\\u22E9','succsim':'\\u227F','SuchThat':'\\u220B','sum':'\\u2211','Sum':'\\u2211','sung':'\\u266A','sup':'\\u2283','Sup':'\\u22D1','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','supdot':'\\u2ABE','supdsub':'\\u2AD8','supe':'\\u2287','supE':'\\u2AC6','supedot':'\\u2AC4','Superset':'\\u2283','SupersetEqual':'\\u2287','suphsol':'\\u27C9','suphsub':'\\u2AD7','suplarr':'\\u297B','supmult':'\\u2AC2','supne':'\\u228B','supnE':'\\u2ACC','supplus':'\\u2AC0','supset':'\\u2283','Supset':'\\u22D1','supseteq':'\\u2287','supseteqq':'\\u2AC6','supsetneq':'\\u228B','supsetneqq':'\\u2ACC','supsim':'\\u2AC8','supsub':'\\u2AD4','supsup':'\\u2AD6','swarhk':'\\u2926','swarr':'\\u2199','swArr':'\\u21D9','swarrow':'\\u2199','swnwar':'\\u292A','szlig':'\\xDF','Tab':'\\t','target':'\\u2316','tau':'\\u03C4','Tau':'\\u03A4','tbrk':'\\u23B4','tcaron':'\\u0165','Tcaron':'\\u0164','tcedil':'\\u0163','Tcedil':'\\u0162','tcy':'\\u0442','Tcy':'\\u0422','tdot':'\\u20DB','telrec':'\\u2315','tfr':'\\uD835\\uDD31','Tfr':'\\uD835\\uDD17','there4':'\\u2234','therefore':'\\u2234','Therefore':'\\u2234','theta':'\\u03B8','Theta':'\\u0398','thetasym':'\\u03D1','thetav':'\\u03D1','thickapprox':'\\u2248','thicksim':'\\u223C','ThickSpace':'\\u205F\\u200A','thinsp':'\\u2009','ThinSpace':'\\u2009','thkap':'\\u2248','thksim':'\\u223C','thorn':'\\xFE','THORN':'\\xDE','tilde':'\\u02DC','Tilde':'\\u223C','TildeEqual':'\\u2243','TildeFullEqual':'\\u2245','TildeTilde':'\\u2248','times':'\\xD7','timesb':'\\u22A0','timesbar':'\\u2A31','timesd':'\\u2A30','tint':'\\u222D','toea':'\\u2928','top':'\\u22A4','topbot':'\\u2336','topcir':'\\u2AF1','topf':'\\uD835\\uDD65','Topf':'\\uD835\\uDD4B','topfork':'\\u2ADA','tosa':'\\u2929','tprime':'\\u2034','trade':'\\u2122','TRADE':'\\u2122','triangle':'\\u25B5','triangledown':'\\u25BF','triangleleft':'\\u25C3','trianglelefteq':'\\u22B4','triangleq':'\\u225C','triangleright':'\\u25B9','trianglerighteq':'\\u22B5','tridot':'\\u25EC','trie':'\\u225C','triminus':'\\u2A3A','TripleDot':'\\u20DB','triplus':'\\u2A39','trisb':'\\u29CD','tritime':'\\u2A3B','trpezium':'\\u23E2','tscr':'\\uD835\\uDCC9','Tscr':'\\uD835\\uDCAF','tscy':'\\u0446','TScy':'\\u0426','tshcy':'\\u045B','TSHcy':'\\u040B','tstrok':'\\u0167','Tstrok':'\\u0166','twixt':'\\u226C','twoheadleftarrow':'\\u219E','twoheadrightarrow':'\\u21A0','uacute':'\\xFA','Uacute':'\\xDA','uarr':'\\u2191','uArr':'\\u21D1','Uarr':'\\u219F','Uarrocir':'\\u2949','ubrcy':'\\u045E','Ubrcy':'\\u040E','ubreve':'\\u016D','Ubreve':'\\u016C','ucirc':'\\xFB','Ucirc':'\\xDB','ucy':'\\u0443','Ucy':'\\u0423','udarr':'\\u21C5','udblac':'\\u0171','Udblac':'\\u0170','udhar':'\\u296E','ufisht':'\\u297E','ufr':'\\uD835\\uDD32','Ufr':'\\uD835\\uDD18','ugrave':'\\xF9','Ugrave':'\\xD9','uHar':'\\u2963','uharl':'\\u21BF','uharr':'\\u21BE','uhblk':'\\u2580','ulcorn':'\\u231C','ulcorner':'\\u231C','ulcrop':'\\u230F','ultri':'\\u25F8','umacr':'\\u016B','Umacr':'\\u016A','uml':'\\xA8','UnderBar':'_','UnderBrace':'\\u23DF','UnderBracket':'\\u23B5','UnderParenthesis':'\\u23DD','Union':'\\u22C3','UnionPlus':'\\u228E','uogon':'\\u0173','Uogon':'\\u0172','uopf':'\\uD835\\uDD66','Uopf':'\\uD835\\uDD4C','uparrow':'\\u2191','Uparrow':'\\u21D1','UpArrow':'\\u2191','UpArrowBar':'\\u2912','UpArrowDownArrow':'\\u21C5','updownarrow':'\\u2195','Updownarrow':'\\u21D5','UpDownArrow':'\\u2195','UpEquilibrium':'\\u296E','upharpoonleft':'\\u21BF','upharpoonright':'\\u21BE','uplus':'\\u228E','UpperLeftArrow':'\\u2196','UpperRightArrow':'\\u2197','upsi':'\\u03C5','Upsi':'\\u03D2','upsih':'\\u03D2','upsilon':'\\u03C5','Upsilon':'\\u03A5','UpTee':'\\u22A5','UpTeeArrow':'\\u21A5','upuparrows':'\\u21C8','urcorn':'\\u231D','urcorner':'\\u231D','urcrop':'\\u230E','uring':'\\u016F','Uring':'\\u016E','urtri':'\\u25F9','uscr':'\\uD835\\uDCCA','Uscr':'\\uD835\\uDCB0','utdot':'\\u22F0','utilde':'\\u0169','Utilde':'\\u0168','utri':'\\u25B5','utrif':'\\u25B4','uuarr':'\\u21C8','uuml':'\\xFC','Uuml':'\\xDC','uwangle':'\\u29A7','vangrt':'\\u299C','varepsilon':'\\u03F5','varkappa':'\\u03F0','varnothing':'\\u2205','varphi':'\\u03D5','varpi':'\\u03D6','varpropto':'\\u221D','varr':'\\u2195','vArr':'\\u21D5','varrho':'\\u03F1','varsigma':'\\u03C2','varsubsetneq':'\\u228A\\uFE00','varsubsetneqq':'\\u2ACB\\uFE00','varsupsetneq':'\\u228B\\uFE00','varsupsetneqq':'\\u2ACC\\uFE00','vartheta':'\\u03D1','vartriangleleft':'\\u22B2','vartriangleright':'\\u22B3','vBar':'\\u2AE8','Vbar':'\\u2AEB','vBarv':'\\u2AE9','vcy':'\\u0432','Vcy':'\\u0412','vdash':'\\u22A2','vDash':'\\u22A8','Vdash':'\\u22A9','VDash':'\\u22AB','Vdashl':'\\u2AE6','vee':'\\u2228','Vee':'\\u22C1','veebar':'\\u22BB','veeeq':'\\u225A','vellip':'\\u22EE','verbar':'|','Verbar':'\\u2016','vert':'|','Vert':'\\u2016','VerticalBar':'\\u2223','VerticalLine':'|','VerticalSeparator':'\\u2758','VerticalTilde':'\\u2240','VeryThinSpace':'\\u200A','vfr':'\\uD835\\uDD33','Vfr':'\\uD835\\uDD19','vltri':'\\u22B2','vnsub':'\\u2282\\u20D2','vnsup':'\\u2283\\u20D2','vopf':'\\uD835\\uDD67','Vopf':'\\uD835\\uDD4D','vprop':'\\u221D','vrtri':'\\u22B3','vscr':'\\uD835\\uDCCB','Vscr':'\\uD835\\uDCB1','vsubne':'\\u228A\\uFE00','vsubnE':'\\u2ACB\\uFE00','vsupne':'\\u228B\\uFE00','vsupnE':'\\u2ACC\\uFE00','Vvdash':'\\u22AA','vzigzag':'\\u299A','wcirc':'\\u0175','Wcirc':'\\u0174','wedbar':'\\u2A5F','wedge':'\\u2227','Wedge':'\\u22C0','wedgeq':'\\u2259','weierp':'\\u2118','wfr':'\\uD835\\uDD34','Wfr':'\\uD835\\uDD1A','wopf':'\\uD835\\uDD68','Wopf':'\\uD835\\uDD4E','wp':'\\u2118','wr':'\\u2240','wreath':'\\u2240','wscr':'\\uD835\\uDCCC','Wscr':'\\uD835\\uDCB2','xcap':'\\u22C2','xcirc':'\\u25EF','xcup':'\\u22C3','xdtri':'\\u25BD','xfr':'\\uD835\\uDD35','Xfr':'\\uD835\\uDD1B','xharr':'\\u27F7','xhArr':'\\u27FA','xi':'\\u03BE','Xi':'\\u039E','xlarr':'\\u27F5','xlArr':'\\u27F8','xmap':'\\u27FC','xnis':'\\u22FB','xodot':'\\u2A00','xopf':'\\uD835\\uDD69','Xopf':'\\uD835\\uDD4F','xoplus':'\\u2A01','xotime':'\\u2A02','xrarr':'\\u27F6','xrArr':'\\u27F9','xscr':'\\uD835\\uDCCD','Xscr':'\\uD835\\uDCB3','xsqcup':'\\u2A06','xuplus':'\\u2A04','xutri':'\\u25B3','xvee':'\\u22C1','xwedge':'\\u22C0','yacute':'\\xFD','Yacute':'\\xDD','yacy':'\\u044F','YAcy':'\\u042F','ycirc':'\\u0177','Ycirc':'\\u0176','ycy':'\\u044B','Ycy':'\\u042B','yen':'\\xA5','yfr':'\\uD835\\uDD36','Yfr':'\\uD835\\uDD1C','yicy':'\\u0457','YIcy':'\\u0407','yopf':'\\uD835\\uDD6A','Yopf':'\\uD835\\uDD50','yscr':'\\uD835\\uDCCE','Yscr':'\\uD835\\uDCB4','yucy':'\\u044E','YUcy':'\\u042E','yuml':'\\xFF','Yuml':'\\u0178','zacute':'\\u017A','Zacute':'\\u0179','zcaron':'\\u017E','Zcaron':'\\u017D','zcy':'\\u0437','Zcy':'\\u0417','zdot':'\\u017C','Zdot':'\\u017B','zeetrf':'\\u2128','ZeroWidthSpace':'\\u200B','zeta':'\\u03B6','Zeta':'\\u0396','zfr':'\\uD835\\uDD37','Zfr':'\\u2128','zhcy':'\\u0436','ZHcy':'\\u0416','zigrarr':'\\u21DD','zopf':'\\uD835\\uDD6B','Zopf':'\\u2124','zscr':'\\uD835\\uDCCF','Zscr':'\\uD835\\uDCB5','zwj':'\\u200D','zwnj':'\\u200C'};\n\tvar decodeMapLegacy = {'aacute':'\\xE1','Aacute':'\\xC1','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','aelig':'\\xE6','AElig':'\\xC6','agrave':'\\xE0','Agrave':'\\xC0','amp':'&','AMP':'&','aring':'\\xE5','Aring':'\\xC5','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','brvbar':'\\xA6','ccedil':'\\xE7','Ccedil':'\\xC7','cedil':'\\xB8','cent':'\\xA2','copy':'\\xA9','COPY':'\\xA9','curren':'\\xA4','deg':'\\xB0','divide':'\\xF7','eacute':'\\xE9','Eacute':'\\xC9','ecirc':'\\xEA','Ecirc':'\\xCA','egrave':'\\xE8','Egrave':'\\xC8','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','frac12':'\\xBD','frac14':'\\xBC','frac34':'\\xBE','gt':'>','GT':'>','iacute':'\\xED','Iacute':'\\xCD','icirc':'\\xEE','Icirc':'\\xCE','iexcl':'\\xA1','igrave':'\\xEC','Igrave':'\\xCC','iquest':'\\xBF','iuml':'\\xEF','Iuml':'\\xCF','laquo':'\\xAB','lt':'<','LT':'<','macr':'\\xAF','micro':'\\xB5','middot':'\\xB7','nbsp':'\\xA0','not':'\\xAC','ntilde':'\\xF1','Ntilde':'\\xD1','oacute':'\\xF3','Oacute':'\\xD3','ocirc':'\\xF4','Ocirc':'\\xD4','ograve':'\\xF2','Ograve':'\\xD2','ordf':'\\xAA','ordm':'\\xBA','oslash':'\\xF8','Oslash':'\\xD8','otilde':'\\xF5','Otilde':'\\xD5','ouml':'\\xF6','Ouml':'\\xD6','para':'\\xB6','plusmn':'\\xB1','pound':'\\xA3','quot':'\"','QUOT':'\"','raquo':'\\xBB','reg':'\\xAE','REG':'\\xAE','sect':'\\xA7','shy':'\\xAD','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','szlig':'\\xDF','thorn':'\\xFE','THORN':'\\xDE','times':'\\xD7','uacute':'\\xFA','Uacute':'\\xDA','ucirc':'\\xFB','Ucirc':'\\xDB','ugrave':'\\xF9','Ugrave':'\\xD9','uml':'\\xA8','uuml':'\\xFC','Uuml':'\\xDC','yacute':'\\xFD','Yacute':'\\xDD','yen':'\\xA5','yuml':'\\xFF'};\n\tvar decodeMapNumeric = {'0':'\\uFFFD','128':'\\u20AC','130':'\\u201A','131':'\\u0192','132':'\\u201E','133':'\\u2026','134':'\\u2020','135':'\\u2021','136':'\\u02C6','137':'\\u2030','138':'\\u0160','139':'\\u2039','140':'\\u0152','142':'\\u017D','145':'\\u2018','146':'\\u2019','147':'\\u201C','148':'\\u201D','149':'\\u2022','150':'\\u2013','151':'\\u2014','152':'\\u02DC','153':'\\u2122','154':'\\u0161','155':'\\u203A','156':'\\u0153','158':'\\u017E','159':'\\u0178'};\n\tvar invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar has = function(object, propertyName) {\n\t\treturn hasOwnProperty.call(object, propertyName);\n\t};\n\n\tvar contains = function(array, value) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tif (array[index] == value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar merge = function(options, defaults) {\n\t\tif (!options) {\n\t\t\treturn defaults;\n\t\t}\n\t\tvar result = {};\n\t\tvar key;\n\t\tfor (key in defaults) {\n\t\t\t// A `hasOwnProperty` check is not needed here, since only recognized\n\t\t\t// option names are used anyway. Any others are ignored.\n\t\t\tresult[key] = has(options, key) ? options[key] : defaults[key];\n\t\t}\n\t\treturn result;\n\t};\n\n\t// Modified version of `ucs2encode`; see https://mths.be/punycode.\n\tvar codePointToSymbol = function(codePoint, strict) {\n\t\tvar output = '';\n\t\tif ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {\n\t\t\t// See issue #4:\n\t\t\t// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is\n\t\t\t// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD\n\t\t\t// REPLACEMENT CHARACTER.\n\t\t\tif (strict) {\n\t\t\t\tparseError('character reference outside the permissible Unicode range');\n\t\t\t}\n\t\t\treturn '\\uFFFD';\n\t\t}\n\t\tif (has(decodeMapNumeric, codePoint)) {\n\t\t\tif (strict) {\n\t\t\t\tparseError('disallowed character reference');\n\t\t\t}\n\t\t\treturn decodeMapNumeric[codePoint];\n\t\t}\n\t\tif (strict && contains(invalidReferenceCodePoints, codePoint)) {\n\t\t\tparseError('disallowed character reference');\n\t\t}\n\t\tif (codePoint > 0xFFFF) {\n\t\t\tcodePoint -= 0x10000;\n\t\t\toutput += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(codePoint);\n\t\treturn output;\n\t};\n\n\tvar hexEscape = function(codePoint) {\n\t\treturn '&#x' + codePoint.toString(16).toUpperCase() + ';';\n\t};\n\n\tvar decEscape = function(codePoint) {\n\t\treturn '&#' + codePoint + ';';\n\t};\n\n\tvar parseError = function(message) {\n\t\tthrow Error('Parse error: ' + message);\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar encode = function(string, options) {\n\t\toptions = merge(options, encode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidRawCodePoint.test(string)) {\n\t\t\tparseError('forbidden code point');\n\t\t}\n\t\tvar encodeEverything = options.encodeEverything;\n\t\tvar useNamedReferences = options.useNamedReferences;\n\t\tvar allowUnsafeSymbols = options.allowUnsafeSymbols;\n\t\tvar escapeCodePoint = options.decimal ? decEscape : hexEscape;\n\n\t\tvar escapeBmpSymbol = function(symbol) {\n\t\t\treturn escapeCodePoint(symbol.charCodeAt(0));\n\t\t};\n\n\t\tif (encodeEverything) {\n\t\t\t// Encode ASCII symbols.\n\t\t\tstring = string.replace(regexAsciiWhitelist, function(symbol) {\n\t\t\t\t// Use named references if requested & possible.\n\t\t\t\tif (useNamedReferences && has(encodeMap, symbol)) {\n\t\t\t\t\treturn '&' + encodeMap[symbol] + ';';\n\t\t\t\t}\n\t\t\t\treturn escapeBmpSymbol(symbol);\n\t\t\t});\n\t\t\t// Shorten a few escapes that represent two symbols, of which at least one\n\t\t\t// is within the ASCII range.\n\t\t\tif (useNamedReferences) {\n\t\t\t\tstring = string\n\t\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;')\n\t\t\t\t\t.replace(/&#x66;&#x6A;/g, '&fjlig;');\n\t\t\t}\n\t\t\t// Encode non-ASCII symbols.\n\t\t\tif (useNamedReferences) {\n\t\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Note: any remaining non-ASCII symbols are handled outside of the `if`.\n\t\t} else if (useNamedReferences) {\n\t\t\t// Apply named character references.\n\t\t\t// Encode `<>\"'&` using named character references.\n\t\t\tif (!allowUnsafeSymbols) {\n\t\t\t\tstring = string.replace(regexEscape, function(string) {\n\t\t\t\t\treturn '&' + encodeMap[string] + ';'; // no need to check `has()` here\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Shorten escapes that represent two symbols, of which at least one is\n\t\t\t// `<>\"'&`.\n\t\t\tstring = string\n\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;');\n\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t});\n\t\t} else if (!allowUnsafeSymbols) {\n\t\t\t// Encode `<>\"'&` using hexadecimal escapes, now that theyre not handled\n\t\t\t// using named character references.\n\t\t\tstring = string.replace(regexEscape, escapeBmpSymbol);\n\t\t}\n\t\treturn string\n\t\t\t// Encode astral symbols.\n\t\t\t.replace(regexAstralSymbols, function($0) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tvar high = $0.charCodeAt(0);\n\t\t\t\tvar low = $0.charCodeAt(1);\n\t\t\t\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\n\t\t\t\treturn escapeCodePoint(codePoint);\n\t\t\t})\n\t\t\t// Encode any remaining BMP symbols that are not printable ASCII symbols\n\t\t\t// using a hexadecimal escape.\n\t\t\t.replace(regexBmpWhitelist, escapeBmpSymbol);\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tencode.options = {\n\t\t'allowUnsafeSymbols': false,\n\t\t'encodeEverything': false,\n\t\t'strict': false,\n\t\t'useNamedReferences': false,\n\t\t'decimal' : false\n\t};\n\n\tvar decode = function(html, options) {\n\t\toptions = merge(options, decode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidEntity.test(html)) {\n\t\t\tparseError('malformed character reference');\n\t\t}\n\t\treturn html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {\n\t\t\tvar codePoint;\n\t\t\tvar semicolon;\n\t\t\tvar decDigits;\n\t\t\tvar hexDigits;\n\t\t\tvar reference;\n\t\t\tvar next;\n\n\t\t\tif ($1) {\n\t\t\t\treference = $1;\n\t\t\t\t// Note: there is no need to check `has(decodeMap, reference)`.\n\t\t\t\treturn decodeMap[reference];\n\t\t\t}\n\n\t\t\tif ($2) {\n\t\t\t\t// Decode named character references without trailing `;`, e.g. `&amp`.\n\t\t\t\t// This is only a parse error if it gets converted to `&`, or if it is\n\t\t\t\t// followed by `=` in an attribute context.\n\t\t\t\treference = $2;\n\t\t\t\tnext = $3;\n\t\t\t\tif (next && options.isAttributeValue) {\n\t\t\t\t\tif (strict && next == '=') {\n\t\t\t\t\t\tparseError('`&` did not start a character reference');\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t} else {\n\t\t\t\t\tif (strict) {\n\t\t\t\t\t\tparseError(\n\t\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// Note: there is no need to check `has(decodeMapLegacy, reference)`.\n\t\t\t\t\treturn decodeMapLegacy[reference] + (next || '');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($4) {\n\t\t\t\t// Decode decimal escapes, e.g. `&#119558;`.\n\t\t\t\tdecDigits = $4;\n\t\t\t\tsemicolon = $5;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(decDigits, 10);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\n\t\t\tif ($6) {\n\t\t\t\t// Decode hexadecimal escapes, e.g. `&#x1D306;`.\n\t\t\t\thexDigits = $6;\n\t\t\t\tsemicolon = $7;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(hexDigits, 16);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\n\t\t\t// If were still here, `if ($7)` is implied; its an ambiguous\n\t\t\t// ampersand for sure. https://mths.be/notes/ambiguous-ampersands\n\t\t\tif (strict) {\n\t\t\t\tparseError(\n\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn $0;\n\t\t});\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tdecode.options = {\n\t\t'isAttributeValue': false,\n\t\t'strict': false\n\t};\n\n\tvar escape = function(string) {\n\t\treturn string.replace(regexEscape, function($0) {\n\t\t\t// Note: there is no need to check `has(escapeMap, $0)` here.\n\t\t\treturn escapeMap[$0];\n\t\t});\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar he = {\n\t\t'version': '1.2.0',\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'escape': escape,\n\t\t'unescape': decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn he;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = he;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in he) {\n\t\t\t\thas(he, key) && (freeExports[key] = he[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.he = he;\n\t}\n\n}(this));\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar deindent = require('de-indent');\nvar he = require('he');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar deindent__default = /*#__PURE__*/_interopDefaultLegacy(deindent);\nvar he__default = /*#__PURE__*/_interopDefaultLegacy(he);\n\nconst emptyObject = Object.freeze({});\nconst isArray = Array.isArray;\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef(v) {\n    return v === undefined || v === null;\n}\nfunction isDef(v) {\n    return v !== undefined && v !== null;\n}\nfunction isTrue(v) {\n    return v === true;\n}\nfunction isFalse(v) {\n    return v === false;\n}\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive(value) {\n    return (typeof value === 'string' ||\n        typeof value === 'number' ||\n        // $flow-disable-line\n        typeof value === 'symbol' ||\n        typeof value === 'boolean');\n}\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Quick object check - this is primarily used to tell\n * objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nconst _toString = Object.prototype.toString;\nfunction toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n}\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n}\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex(val) {\n    const n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\nfunction isPromise(val) {\n    return (isDef(val) &&\n        typeof val.then === 'function' &&\n        typeof val.catch === 'function');\n}\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString(val) {\n    return val == null\n        ? ''\n        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n            ? JSON.stringify(val, replacer, 2)\n            : String(val);\n}\nfunction replacer(_key, val) {\n    // avoid circular deps from v3\n    if (val && val.__v_isRef) {\n        return val.value;\n    }\n    return val;\n}\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber(val) {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n}\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => map[val.toLowerCase()] : val => map[val];\n}\n/**\n * Check if a tag is a built-in tag.\n */\nconst isBuiltInTag = makeMap('slot,component', true);\n/**\n * Check if an attribute is a reserved attribute.\n */\nconst isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n/**\n * Check whether an object has the property.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n}\n/**\n * Create a cached version of a pure function.\n */\nfunction cached(fn) {\n    const cache = Object.create(null);\n    return function cachedFn(str) {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    };\n}\n/**\n * Camelize a hyphen-delimited string.\n */\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cached((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\n/**\n * Capitalize a string.\n */\nconst capitalize = cached((str) => {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n});\n/**\n * Hyphenate a camelCase string.\n */\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cached((str) => {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n/**\n * Mix properties into target object.\n */\nfunction extend(to, _from) {\n    for (const key in _from) {\n        to[key] = _from[key];\n    }\n    return to;\n}\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject(arr) {\n    const res = {};\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i]) {\n            extend(res, arr[i]);\n        }\n    }\n    return res;\n}\n/* eslint-disable no-unused-vars */\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop(a, b, c) { }\n/**\n * Always return false.\n */\nconst no = (a, b, c) => false;\n/* eslint-enable no-unused-vars */\n/**\n * Return the same value.\n */\nconst identity = (_) => _;\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys$1(modules) {\n    return modules\n        .reduce((keys, m) => keys.concat(m.staticKeys || []), [])\n        .join(',');\n}\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    const isObjectA = isObject(a);\n    const isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n        try {\n            const isArrayA = Array.isArray(a);\n            const isArrayB = Array.isArray(b);\n            if (isArrayA && isArrayB) {\n                return (a.length === b.length &&\n                    a.every((e, i) => {\n                        return looseEqual(e, b[i]);\n                    }));\n            }\n            else if (a instanceof Date && b instanceof Date) {\n                return a.getTime() === b.getTime();\n            }\n            else if (!isArrayA && !isArrayB) {\n                const keysA = Object.keys(a);\n                const keysB = Object.keys(b);\n                return (keysA.length === keysB.length &&\n                    keysA.every(key => {\n                        return looseEqual(a[key], b[key]);\n                    }));\n            }\n            else {\n                /* istanbul ignore next */\n                return false;\n            }\n        }\n        catch (e) {\n            /* istanbul ignore next */\n            return false;\n        }\n    }\n    else if (!isObjectA && !isObjectB) {\n        return String(a) === String(b);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf(arr, val) {\n    for (let i = 0; i < arr.length; i++) {\n        if (looseEqual(arr[i], val))\n            return i;\n    }\n    return -1;\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill\nfunction hasChanged(x, y) {\n    if (x === y) {\n        return x === 0 && 1 / x !== 1 / y;\n    }\n    else {\n        return x === x || y === y;\n    }\n}\n\nconst isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n    'link,meta,param,source,track,wbr');\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nconst canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nconst isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n    'title,tr,track');\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nconst unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n        value: val,\n        enumerable: !!enumerable,\n        writable: true,\n        configurable: true\n    });\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n// Regular Expressions for parsing tags and attributes\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nconst dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+?\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z${unicodeRegExp.source}]*`;\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\nconst startTagOpen = new RegExp(`^<${qnameCapture}`);\nconst startTagClose = /^\\s*(\\/?)>/;\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);\nconst doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being passed as HTML comment when inlined in page\nconst comment = /^<!\\--/;\nconst conditionalComment = /^<!\\[/;\n// Special Elements (can contain anything)\nconst isPlainTextElement = makeMap('script,style,textarea', true);\nconst reCache = {};\nconst decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n};\nconst encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nconst encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n// #5992\nconst isIgnoreNewlineTag = makeMap('pre,textarea', true);\nconst shouldIgnoreFirstNewline = (tag, html) => tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\nfunction decodeAttr(value, shouldDecodeNewlines) {\n    const re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, match => decodingMap[match]);\n}\nfunction parseHTML(html, options) {\n    const stack = [];\n    const expectHTML = options.expectHTML;\n    const isUnaryTag = options.isUnaryTag || no;\n    const canBeLeftOpenTag = options.canBeLeftOpenTag || no;\n    let index = 0;\n    let last, lastTag;\n    while (html) {\n        last = html;\n        // Make sure we're not in a plaintext content element like script/style\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n            let textEnd = html.indexOf('<');\n            if (textEnd === 0) {\n                // Comment:\n                if (comment.test(html)) {\n                    const commentEnd = html.indexOf('-->');\n                    if (commentEnd >= 0) {\n                        if (options.shouldKeepComment && options.comment) {\n                            options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n                        }\n                        advance(commentEnd + 3);\n                        continue;\n                    }\n                }\n                // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n                if (conditionalComment.test(html)) {\n                    const conditionalEnd = html.indexOf(']>');\n                    if (conditionalEnd >= 0) {\n                        advance(conditionalEnd + 2);\n                        continue;\n                    }\n                }\n                // Doctype:\n                const doctypeMatch = html.match(doctype);\n                if (doctypeMatch) {\n                    advance(doctypeMatch[0].length);\n                    continue;\n                }\n                // End tag:\n                const endTagMatch = html.match(endTag);\n                if (endTagMatch) {\n                    const curIndex = index;\n                    advance(endTagMatch[0].length);\n                    parseEndTag(endTagMatch[1], curIndex, index);\n                    continue;\n                }\n                // Start tag:\n                const startTagMatch = parseStartTag();\n                if (startTagMatch) {\n                    handleStartTag(startTagMatch);\n                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n                        advance(1);\n                    }\n                    continue;\n                }\n            }\n            let text, rest, next;\n            if (textEnd >= 0) {\n                rest = html.slice(textEnd);\n                while (!endTag.test(rest) &&\n                    !startTagOpen.test(rest) &&\n                    !comment.test(rest) &&\n                    !conditionalComment.test(rest)) {\n                    // < in plain text, be forgiving and treat it as text\n                    next = rest.indexOf('<', 1);\n                    if (next < 0)\n                        break;\n                    textEnd += next;\n                    rest = html.slice(textEnd);\n                }\n                text = html.substring(0, textEnd);\n            }\n            if (textEnd < 0) {\n                text = html;\n            }\n            if (text) {\n                advance(text.length);\n            }\n            if (options.chars && text) {\n                options.chars(text, index - text.length, index);\n            }\n        }\n        else {\n            let endTagLength = 0;\n            const stackedTag = lastTag.toLowerCase();\n            const reStackedTag = reCache[stackedTag] ||\n                (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n            const rest = html.replace(reStackedTag, function (all, text, endTag) {\n                endTagLength = endTag.length;\n                if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n                    text = text\n                        .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n                        .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n                }\n                if (shouldIgnoreFirstNewline(stackedTag, text)) {\n                    text = text.slice(1);\n                }\n                if (options.chars) {\n                    options.chars(text);\n                }\n                return '';\n            });\n            index += html.length - rest.length;\n            html = rest;\n            parseEndTag(stackedTag, index - endTagLength, index);\n        }\n        if (html === last) {\n            options.chars && options.chars(html);\n            if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n                options.warn(`Mal-formatted tag at end of template: \"${html}\"`, {\n                    start: index + html.length\n                });\n            }\n            break;\n        }\n    }\n    // Clean up any remaining tags\n    parseEndTag();\n    function advance(n) {\n        index += n;\n        html = html.substring(n);\n    }\n    function parseStartTag() {\n        const start = html.match(startTagOpen);\n        if (start) {\n            const match = {\n                tagName: start[1],\n                attrs: [],\n                start: index\n            };\n            advance(start[0].length);\n            let end, attr;\n            while (!(end = html.match(startTagClose)) &&\n                (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n                attr.start = index;\n                advance(attr[0].length);\n                attr.end = index;\n                match.attrs.push(attr);\n            }\n            if (end) {\n                match.unarySlash = end[1];\n                advance(end[0].length);\n                match.end = index;\n                return match;\n            }\n        }\n    }\n    function handleStartTag(match) {\n        const tagName = match.tagName;\n        const unarySlash = match.unarySlash;\n        if (expectHTML) {\n            if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n                parseEndTag(lastTag);\n            }\n            if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n                parseEndTag(tagName);\n            }\n        }\n        const unary = isUnaryTag(tagName) || !!unarySlash;\n        const l = match.attrs.length;\n        const attrs = new Array(l);\n        for (let i = 0; i < l; i++) {\n            const args = match.attrs[i];\n            const value = args[3] || args[4] || args[5] || '';\n            const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n                ? options.shouldDecodeNewlinesForHref\n                : options.shouldDecodeNewlines;\n            attrs[i] = {\n                name: args[1],\n                value: decodeAttr(value, shouldDecodeNewlines)\n            };\n            if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n                attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n                attrs[i].end = args.end;\n            }\n        }\n        if (!unary) {\n            stack.push({\n                tag: tagName,\n                lowerCasedTag: tagName.toLowerCase(),\n                attrs: attrs,\n                start: match.start,\n                end: match.end\n            });\n            lastTag = tagName;\n        }\n        if (options.start) {\n            options.start(tagName, attrs, unary, match.start, match.end);\n        }\n    }\n    function parseEndTag(tagName, start, end) {\n        let pos, lowerCasedTagName;\n        if (start == null)\n            start = index;\n        if (end == null)\n            end = index;\n        // Find the closest opened tag of the same type\n        if (tagName) {\n            lowerCasedTagName = tagName.toLowerCase();\n            for (pos = stack.length - 1; pos >= 0; pos--) {\n                if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n                    break;\n                }\n            }\n        }\n        else {\n            // If no tag name is provided, clean shop\n            pos = 0;\n        }\n        if (pos >= 0) {\n            // Close all the open elements, up the stack\n            for (let i = stack.length - 1; i >= pos; i--) {\n                if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {\n                    options.warn(`tag <${stack[i].tag}> has no matching end tag.`, {\n                        start: stack[i].start,\n                        end: stack[i].end\n                    });\n                }\n                if (options.end) {\n                    options.end(stack[i].tag, start, end);\n                }\n            }\n            // Remove the open elements from the stack\n            stack.length = pos;\n            lastTag = pos && stack[pos - 1].tag;\n        }\n        else if (lowerCasedTagName === 'br') {\n            if (options.start) {\n                options.start(tagName, [], true, start, end);\n            }\n        }\n        else if (lowerCasedTagName === 'p') {\n            if (options.start) {\n                options.start(tagName, [], false, start, end);\n            }\n            if (options.end) {\n                options.end(tagName, start, end);\n            }\n        }\n    }\n}\n\nconst DEFAULT_FILENAME = 'anonymous.vue';\nconst splitRE = /\\r?\\n/g;\nconst replaceRE = /./g;\nconst isSpecialTag = makeMap('script,style,template', true);\n/**\n * Parse a single-file component (*.vue) file into an SFC Descriptor Object.\n */\nfunction parseComponent(source, options = {}) {\n    const sfc = {\n        source,\n        filename: DEFAULT_FILENAME,\n        template: null,\n        script: null,\n        scriptSetup: null,\n        styles: [],\n        customBlocks: [],\n        cssVars: [],\n        errors: [],\n        shouldForceReload: null // attached in parse() by compiler-sfc\n    };\n    let depth = 0;\n    let currentBlock = null;\n    let warn = msg => {\n        sfc.errors.push(msg);\n    };\n    if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n        warn = (msg, range) => {\n            const data = { msg };\n            if (range.start != null) {\n                data.start = range.start;\n            }\n            if (range.end != null) {\n                data.end = range.end;\n            }\n            sfc.errors.push(data);\n        };\n    }\n    function start(tag, attrs, unary, start, end) {\n        if (depth === 0) {\n            currentBlock = {\n                type: tag,\n                content: '',\n                start: end,\n                end: 0,\n                attrs: attrs.reduce((cumulated, { name, value }) => {\n                    cumulated[name] = value || true;\n                    return cumulated;\n                }, {})\n            };\n            if (typeof currentBlock.attrs.src === 'string') {\n                currentBlock.src = currentBlock.attrs.src;\n            }\n            if (isSpecialTag(tag)) {\n                checkAttrs(currentBlock, attrs);\n                if (tag === 'script') {\n                    const block = currentBlock;\n                    if (block.attrs.setup) {\n                        block.setup = currentBlock.attrs.setup;\n                        sfc.scriptSetup = block;\n                    }\n                    else {\n                        sfc.script = block;\n                    }\n                }\n                else if (tag === 'style') {\n                    sfc.styles.push(currentBlock);\n                }\n                else {\n                    sfc[tag] = currentBlock;\n                }\n            }\n            else {\n                // custom blocks\n                sfc.customBlocks.push(currentBlock);\n            }\n        }\n        if (!unary) {\n            depth++;\n        }\n    }\n    function checkAttrs(block, attrs) {\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            if (attr.name === 'lang') {\n                block.lang = attr.value;\n            }\n            if (attr.name === 'scoped') {\n                block.scoped = true;\n            }\n            if (attr.name === 'module') {\n                block.module = attr.value || true;\n            }\n        }\n    }\n    function end(tag, start) {\n        if (depth === 1 && currentBlock) {\n            currentBlock.end = start;\n            let text = source.slice(currentBlock.start, currentBlock.end);\n            if (options.deindent === true ||\n                // by default, deindent unless it's script with default lang or (j/t)sx?\n                (options.deindent !== false &&\n                    !(currentBlock.type === 'script' &&\n                        (!currentBlock.lang || /^(j|t)sx?$/.test(currentBlock.lang))))) {\n                text = deindent__default[\"default\"](text);\n            }\n            // pad content so that linters and pre-processors can output correct\n            // line numbers in errors and warnings\n            if (currentBlock.type !== 'template' && options.pad) {\n                text = padContent(currentBlock, options.pad) + text;\n            }\n            currentBlock.content = text;\n            currentBlock = null;\n        }\n        depth--;\n    }\n    function padContent(block, pad) {\n        if (pad === 'space') {\n            return source.slice(0, block.start).replace(replaceRE, ' ');\n        }\n        else {\n            const offset = source.slice(0, block.start).split(splitRE).length;\n            const padChar = block.type === 'script' && !block.lang ? '//\\n' : '\\n';\n            return Array(offset).join(padChar);\n        }\n    }\n    parseHTML(source, {\n        warn,\n        start,\n        end,\n        outputSourceRange: options.outputSourceRange\n    });\n    return sfc;\n}\n\n// can we use __proto__?\nconst hasProto = '__proto__' in {};\n// Browser environment sniffing\nconst inBrowser = typeof window !== 'undefined';\nconst UA = inBrowser && window.navigator.userAgent.toLowerCase();\nconst isIE = UA && /msie|trident/.test(UA);\nUA && UA.indexOf('msie 9.0') > 0;\nconst isEdge = UA && UA.indexOf('edge/') > 0;\nUA && UA.indexOf('android') > 0;\nUA && /iphone|ipad|ipod|ios/.test(UA);\nUA && /chrome\\/\\d+/.test(UA) && !isEdge;\nUA && /phantomjs/.test(UA);\nUA && UA.match(/firefox\\/(\\d+)/);\n// Firefox has a \"watch\" function on Object.prototype...\n// @ts-expect-error firebox support\nconst nativeWatch = {}.watch;\nlet supportsPassive = false;\nif (inBrowser) {\n    try {\n        const opts = {};\n        Object.defineProperty(opts, 'passive', {\n            get() {\n                /* istanbul ignore next */\n                supportsPassive = true;\n            }\n        }); // https://github.com/facebook/flow/issues/285\n        window.addEventListener('test-passive', null, opts);\n    }\n    catch (e) { }\n}\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nlet _isServer;\nconst isServerRendering = () => {\n    if (_isServer === undefined) {\n        /* istanbul ignore if */\n        if (!inBrowser && typeof global !== 'undefined') {\n            // detect presence of vue-server-renderer and avoid\n            // Webpack shimming the process\n            _isServer =\n                global['process'] && global['process'].env.VUE_ENV === 'server';\n        }\n        else {\n            _isServer = false;\n        }\n    }\n    return _isServer;\n};\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\nconst hasSymbol = typeof Symbol !== 'undefined' &&\n    isNative(Symbol) &&\n    typeof Reflect !== 'undefined' &&\n    isNative(Reflect.ownKeys);\nlet _Set; // $flow-disable-line\n/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n}\nelse {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = class Set {\n        constructor() {\n            this.set = Object.create(null);\n        }\n        has(key) {\n            return this.set[key] === true;\n        }\n        add(key) {\n            this.set[key] = true;\n        }\n        clear() {\n            this.set = Object.create(null);\n        }\n    };\n}\n\nconst ASSET_TYPES = ['component', 'directive', 'filter'];\nconst LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    'serverPrefetch',\n    'renderTracked',\n    'renderTriggered'\n];\n\nvar config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: process.env.NODE_ENV !== 'production',\n    /**\n     * Whether to enable devtools\n     */\n    devtools: process.env.NODE_ENV !== 'production',\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n};\n\nlet currentInstance = null;\n/**\n * @internal\n */\nfunction setCurrentInstance(vm = null) {\n    if (!vm)\n        currentInstance && currentInstance._scope.off();\n    currentInstance = vm;\n    vm && vm._scope.on();\n}\n\n/**\n * @internal\n */\nclass VNode {\n    constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n        this.tag = tag;\n        this.data = data;\n        this.children = children;\n        this.text = text;\n        this.elm = elm;\n        this.ns = undefined;\n        this.context = context;\n        this.fnContext = undefined;\n        this.fnOptions = undefined;\n        this.fnScopeId = undefined;\n        this.key = data && data.key;\n        this.componentOptions = componentOptions;\n        this.componentInstance = undefined;\n        this.parent = undefined;\n        this.raw = false;\n        this.isStatic = false;\n        this.isRootInsert = true;\n        this.isComment = false;\n        this.isCloned = false;\n        this.isOnce = false;\n        this.asyncFactory = asyncFactory;\n        this.asyncMeta = undefined;\n        this.isAsyncPlaceholder = false;\n    }\n    // DEPRECATED: alias for componentInstance for backwards compat.\n    /* istanbul ignore next */\n    get child() {\n        return this.componentInstance;\n    }\n}\nconst createEmptyVNode = (text = '') => {\n    const node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n};\nfunction createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n}\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode(vnode) {\n    const cloned = new VNode(vnode.tag, vnode.data, \n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\nif (process.env.NODE_ENV !== 'production') {\n    makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +\n        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +\n        'require' // for Webpack/Browserify\n    );\n    const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n    if (hasProxy) {\n        const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n        config.keyCodes = new Proxy(config.keyCodes, {\n            set(target, key, value) {\n                if (isBuiltInModifier(key)) {\n                    warn$2(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`);\n                    return false;\n                }\n                else {\n                    target[key] = value;\n                    return true;\n                }\n            }\n        });\n    }\n}\n\nlet uid = 0;\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n * @internal\n */\nclass Dep {\n    constructor() {\n        // pending subs cleanup\n        this._pending = false;\n        this.id = uid++;\n        this.subs = [];\n    }\n    addSub(sub) {\n        this.subs.push(sub);\n    }\n    removeSub(sub) {\n        // #12696 deps with massive amount of subscribers are extremely slow to\n        // clean up in Chromium\n        // to workaround this, we unset the sub for now, and clear them on\n        // next scheduler flush.\n        this.subs[this.subs.indexOf(sub)] = null;\n        if (!this._pending) {\n            this._pending = true;\n        }\n    }\n    depend(info) {\n        if (Dep.target) {\n            Dep.target.addDep(this);\n            if (process.env.NODE_ENV !== 'production' && info && Dep.target.onTrack) {\n                Dep.target.onTrack(Object.assign({ effect: Dep.target }, info));\n            }\n        }\n    }\n    notify(info) {\n        // stabilize the subscriber list first\n        const subs = this.subs.filter(s => s);\n        if (process.env.NODE_ENV !== 'production' && !config.async) {\n            // subs aren't sorted in scheduler if not running async\n            // we need to sort them now to make sure they fire in correct\n            // order\n            subs.sort((a, b) => a.id - b.id);\n        }\n        for (let i = 0, l = subs.length; i < l; i++) {\n            const sub = subs[i];\n            if (process.env.NODE_ENV !== 'production' && info) {\n                sub.onTrigger &&\n                    sub.onTrigger(Object.assign({ effect: subs[i] }, info));\n            }\n            sub.update();\n        }\n    }\n}\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nconst targetStack = [];\nfunction pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n}\nfunction popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\nconst arrayProto = Array.prototype;\nconst arrayMethods = Object.create(arrayProto);\nconst methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n];\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n    // cache original method\n    const original = arrayProto[method];\n    def(arrayMethods, method, function mutator(...args) {\n        const result = original.apply(this, args);\n        const ob = this.__ob__;\n        let inserted;\n        switch (method) {\n            case 'push':\n            case 'unshift':\n                inserted = args;\n                break;\n            case 'splice':\n                inserted = args.slice(2);\n                break;\n        }\n        if (inserted)\n            ob.observeArray(inserted);\n        // notify change\n        if (process.env.NODE_ENV !== 'production') {\n            ob.dep.notify({\n                type: \"array mutation\" /* TriggerOpTypes.ARRAY_MUTATION */,\n                target: this,\n                key: method\n            });\n        }\n        else {\n            ob.dep.notify();\n        }\n        return result;\n    });\n});\n\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods);\nconst NO_INITIAL_VALUE = {};\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nlet shouldObserve = true;\nfunction toggleObserving(value) {\n    shouldObserve = value;\n}\n// ssr mock dep\nconst mockDep = {\n    notify: noop,\n    depend: noop,\n    addSub: noop,\n    removeSub: noop\n};\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nclass Observer {\n    constructor(value, shallow = false, mock = false) {\n        this.value = value;\n        this.shallow = shallow;\n        this.mock = mock;\n        // this.value = value\n        this.dep = mock ? mockDep : new Dep();\n        this.vmCount = 0;\n        def(value, '__ob__', this);\n        if (isArray(value)) {\n            if (!mock) {\n                if (hasProto) {\n                    value.__proto__ = arrayMethods;\n                    /* eslint-enable no-proto */\n                }\n                else {\n                    for (let i = 0, l = arrayKeys.length; i < l; i++) {\n                        const key = arrayKeys[i];\n                        def(value, key, arrayMethods[key]);\n                    }\n                }\n            }\n            if (!shallow) {\n                this.observeArray(value);\n            }\n        }\n        else {\n            /**\n             * Walk through all properties and convert them into\n             * getter/setters. This method should only be called when\n             * value type is Object.\n             */\n            const keys = Object.keys(value);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock);\n            }\n        }\n    }\n    /**\n     * Observe a list of Array items.\n     */\n    observeArray(value) {\n        for (let i = 0, l = value.length; i < l; i++) {\n            observe(value[i], false, this.mock);\n        }\n    }\n}\n// helpers\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(value, shallow, ssrMockReactivity) {\n    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n        return value.__ob__;\n    }\n    if (shouldObserve &&\n        (ssrMockReactivity || !isServerRendering()) &&\n        (isArray(value) || isPlainObject(value)) &&\n        Object.isExtensible(value) &&\n        !value.__v_skip /* ReactiveFlags.SKIP */ &&\n        !isRef(value) &&\n        !(value instanceof VNode)) {\n        return new Observer(value, shallow, ssrMockReactivity);\n    }\n}\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive(obj, key, val, customSetter, shallow, mock, observeEvenIfShallow = false) {\n    const dep = new Dep();\n    const property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n        return;\n    }\n    // cater for pre-defined getter/setters\n    const getter = property && property.get;\n    const setter = property && property.set;\n    if ((!getter || setter) &&\n        (val === NO_INITIAL_VALUE || arguments.length === 2)) {\n        val = obj[key];\n    }\n    let childOb = shallow ? val && val.__ob__ : observe(val, false, mock);\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n            const value = getter ? getter.call(obj) : val;\n            if (Dep.target) {\n                if (process.env.NODE_ENV !== 'production') {\n                    dep.depend({\n                        target: obj,\n                        type: \"get\" /* TrackOpTypes.GET */,\n                        key\n                    });\n                }\n                else {\n                    dep.depend();\n                }\n                if (childOb) {\n                    childOb.dep.depend();\n                    if (isArray(value)) {\n                        dependArray(value);\n                    }\n                }\n            }\n            return isRef(value) && !shallow ? value.value : value;\n        },\n        set: function reactiveSetter(newVal) {\n            const value = getter ? getter.call(obj) : val;\n            if (!hasChanged(value, newVal)) {\n                return;\n            }\n            if (process.env.NODE_ENV !== 'production' && customSetter) {\n                customSetter();\n            }\n            if (setter) {\n                setter.call(obj, newVal);\n            }\n            else if (getter) {\n                // #7981: for accessor properties without setter\n                return;\n            }\n            else if (!shallow && isRef(value) && !isRef(newVal)) {\n                value.value = newVal;\n                return;\n            }\n            else {\n                val = newVal;\n            }\n            childOb = shallow ? newVal && newVal.__ob__ : observe(newVal, false, mock);\n            if (process.env.NODE_ENV !== 'production') {\n                dep.notify({\n                    type: \"set\" /* TriggerOpTypes.SET */,\n                    target: obj,\n                    key,\n                    newValue: newVal,\n                    oldValue: value\n                });\n            }\n            else {\n                dep.notify();\n            }\n        }\n    });\n    return dep;\n}\nfunction set(target, key, val) {\n    if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {\n        warn$2(`Cannot set reactive property on undefined, null, or primitive value: ${target}`);\n    }\n    if (isReadonly(target)) {\n        process.env.NODE_ENV !== 'production' && warn$2(`Set operation on key \"${key}\" failed: target is readonly.`);\n        return;\n    }\n    const ob = target.__ob__;\n    if (isArray(target) && isValidArrayIndex(key)) {\n        target.length = Math.max(target.length, key);\n        target.splice(key, 1, val);\n        // when mocking for SSR, array methods are not hijacked\n        if (ob && !ob.shallow && ob.mock) {\n            observe(val, false, true);\n        }\n        return val;\n    }\n    if (key in target && !(key in Object.prototype)) {\n        target[key] = val;\n        return val;\n    }\n    if (target._isVue || (ob && ob.vmCount)) {\n        process.env.NODE_ENV !== 'production' &&\n            warn$2('Avoid adding reactive properties to a Vue instance or its root $data ' +\n                'at runtime - declare it upfront in the data option.');\n        return val;\n    }\n    if (!ob) {\n        target[key] = val;\n        return val;\n    }\n    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);\n    if (process.env.NODE_ENV !== 'production') {\n        ob.dep.notify({\n            type: \"add\" /* TriggerOpTypes.ADD */,\n            target: target,\n            key,\n            newValue: val,\n            oldValue: undefined\n        });\n    }\n    else {\n        ob.dep.notify();\n    }\n    return val;\n}\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n    for (let e, i = 0, l = value.length; i < l; i++) {\n        e = value[i];\n        if (e && e.__ob__) {\n            e.__ob__.dep.depend();\n        }\n        if (isArray(e)) {\n            dependArray(e);\n        }\n    }\n}\n\nfunction isReadonly(value) {\n    return !!(value && value.__v_isReadonly);\n}\n\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\n\nif (process.env.NODE_ENV !== 'production') ;\n\nconst normalizeEvent = cached((name) => {\n    const passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    const once = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once ? name.slice(1) : name;\n    const capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n        name,\n        once,\n        capture,\n        passive\n    };\n});\nfunction createFnInvoker(fns, vm) {\n    function invoker() {\n        const fns = invoker.fns;\n        if (isArray(fns)) {\n            const cloned = fns.slice();\n            for (let i = 0; i < cloned.length; i++) {\n                invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`);\n            }\n        }\n        else {\n            // return handler return value for single handlers\n            return invokeWithErrorHandling(fns, null, arguments, vm, `v-on handler`);\n        }\n    }\n    invoker.fns = fns;\n    return invoker;\n}\nfunction updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {\n    let name, cur, old, event;\n    for (name in on) {\n        cur = on[name];\n        old = oldOn[name];\n        event = normalizeEvent(name);\n        if (isUndef(cur)) {\n            process.env.NODE_ENV !== 'production' &&\n                warn$2(`Invalid handler for event \"${event.name}\": got ` + String(cur), vm);\n        }\n        else if (isUndef(old)) {\n            if (isUndef(cur.fns)) {\n                cur = on[name] = createFnInvoker(cur, vm);\n            }\n            if (isTrue(event.once)) {\n                cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n            }\n            add(event.name, cur, event.capture, event.passive, event.params);\n        }\n        else if (cur !== old) {\n            old.fns = cur;\n            on[name] = old;\n        }\n    }\n    for (name in oldOn) {\n        if (isUndef(on[name])) {\n            event = normalizeEvent(name);\n            remove(event.name, oldOn[name], event.capture);\n        }\n    }\n}\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    const propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n        return;\n    }\n    const res = {};\n    const { attrs, props } = data;\n    if (isDef(attrs) || isDef(props)) {\n        for (const key in propOptions) {\n            const altKey = hyphenate(key);\n            if (process.env.NODE_ENV !== 'production') {\n                const keyInLowerCase = key.toLowerCase();\n                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n                    tip(`Prop \"${keyInLowerCase}\" is passed to component ` +\n                        `${formatComponentName(\n                        // @ts-expect-error tag is string\n                        tag || Ctor)}, but the declared prop name is` +\n                        ` \"${key}\". ` +\n                        `Note that HTML attributes are case-insensitive and camelCased ` +\n                        `props need to use their kebab-case equivalents when using in-DOM ` +\n                        `templates. You should probably use \"${altKey}\" instead of \"${key}\".`);\n                }\n            }\n            checkProp(res, props, key, altKey, true) ||\n                checkProp(res, attrs, key, altKey, false);\n        }\n    }\n    return res;\n}\nfunction checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n        if (hasOwn(hash, key)) {\n            res[key] = hash[key];\n            if (!preserve) {\n                delete hash[key];\n            }\n            return true;\n        }\n        else if (hasOwn(hash, altKey)) {\n            res[key] = hash[altKey];\n            if (!preserve) {\n                delete hash[altKey];\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n        if (isArray(children[i])) {\n            return Array.prototype.concat.apply([], children);\n        }\n    }\n    return children;\n}\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren(children) {\n    return isPrimitive(children)\n        ? [createTextVNode(children)]\n        : isArray(children)\n            ? normalizeArrayChildren(children)\n            : undefined;\n}\nfunction isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\nfunction normalizeArrayChildren(children, nestedIndex) {\n    const res = [];\n    let i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n        c = children[i];\n        if (isUndef(c) || typeof c === 'boolean')\n            continue;\n        lastIndex = res.length - 1;\n        last = res[lastIndex];\n        //  nested\n        if (isArray(c)) {\n            if (c.length > 0) {\n                c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`);\n                // merge adjacent text nodes\n                if (isTextNode(c[0]) && isTextNode(last)) {\n                    res[lastIndex] = createTextVNode(last.text + c[0].text);\n                    c.shift();\n                }\n                res.push.apply(res, c);\n            }\n        }\n        else if (isPrimitive(c)) {\n            if (isTextNode(last)) {\n                // merge adjacent text nodes\n                // this is necessary for SSR hydration because text nodes are\n                // essentially merged when rendered to HTML strings\n                res[lastIndex] = createTextVNode(last.text + c);\n            }\n            else if (c !== '') {\n                // convert primitive to vnode\n                res.push(createTextVNode(c));\n            }\n        }\n        else {\n            if (isTextNode(c) && isTextNode(last)) {\n                // merge adjacent text nodes\n                res[lastIndex] = createTextVNode(last.text + c.text);\n            }\n            else {\n                // default key for nested array children (likely generated by v-for)\n                if (isTrue(children._isVList) &&\n                    isDef(c.tag) &&\n                    isUndef(c.key) &&\n                    isDef(nestedIndex)) {\n                    c.key = `__vlist${nestedIndex}_${i}__`;\n                }\n                res.push(c);\n            }\n        }\n    }\n    return res;\n}\n\nconst SIMPLE_NORMALIZE = 1;\nconst ALWAYS_NORMALIZE = 2;\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (isArray(data) || isPrimitive(data)) {\n        normalizationType = children;\n        children = data;\n        data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n        normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType);\n}\nfunction _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n        process.env.NODE_ENV !== 'production' &&\n            warn$2(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` + 'Always create fresh vnode data objects in each render!', context);\n        return createEmptyVNode();\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n        tag = data.is;\n    }\n    if (!tag) {\n        // in case of component :is set to falsy value\n        return createEmptyVNode();\n    }\n    // warn against non-primitive key\n    if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n        warn$2('Avoid using non-primitive value as key, ' +\n            'use string/number value instead.', context);\n    }\n    // support single function children as default scoped slot\n    if (isArray(children) && isFunction(children[0])) {\n        data = data || {};\n        data.scopedSlots = { default: children[0] };\n        children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children);\n    }\n    else if (normalizationType === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children);\n    }\n    let vnode, ns;\n    if (typeof tag === 'string') {\n        let Ctor;\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n        if ((!data || !data.pre) &&\n            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {\n            // component\n            vnode = createComponent(Ctor, data, context, children, tag);\n        }\n        else {\n            // unknown or unlisted namespaced elements\n            // check at runtime because it may get assigned a namespace when its\n            // parent normalizes children\n            vnode = new VNode(tag, data, children, undefined, undefined, context);\n        }\n    }\n    else {\n        // direct component options / constructor\n        vnode = createComponent(tag, data, context, children);\n    }\n    if (isArray(vnode)) {\n        return vnode;\n    }\n    else if (isDef(vnode)) {\n        if (isDef(ns))\n            applyNS(vnode, ns);\n        if (isDef(data))\n            registerDeepBindings(data);\n        return vnode;\n    }\n    else {\n        return createEmptyVNode();\n    }\n}\nfunction applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n        // use default namespace inside foreignObject\n        ns = undefined;\n        force = true;\n    }\n    if (isDef(vnode.children)) {\n        for (let i = 0, l = vnode.children.length; i < l; i++) {\n            const child = vnode.children[i];\n            if (isDef(child.tag) &&\n                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n                applyNS(child, ns, force);\n            }\n        }\n    }\n}\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings(data) {\n    if (isObject(data.style)) {\n        traverse(data.style);\n    }\n    if (isObject(data.class)) {\n        traverse(data.class);\n    }\n}\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList(val, render) {\n    let ret = null, i, l, keys, key;\n    if (isArray(val) || typeof val === 'string') {\n        ret = new Array(val.length);\n        for (i = 0, l = val.length; i < l; i++) {\n            ret[i] = render(val[i], i);\n        }\n    }\n    else if (typeof val === 'number') {\n        ret = new Array(val);\n        for (i = 0; i < val; i++) {\n            ret[i] = render(i + 1, i);\n        }\n    }\n    else if (isObject(val)) {\n        if (hasSymbol && val[Symbol.iterator]) {\n            ret = [];\n            const iterator = val[Symbol.iterator]();\n            let result = iterator.next();\n            while (!result.done) {\n                ret.push(render(result.value, ret.length));\n                result = iterator.next();\n            }\n        }\n        else {\n            keys = Object.keys(val);\n            ret = new Array(keys.length);\n            for (i = 0, l = keys.length; i < l; i++) {\n                key = keys[i];\n                ret[i] = render(val[key], key, i);\n            }\n        }\n    }\n    if (!isDef(ret)) {\n        ret = [];\n    }\n    ret._isVList = true;\n    return ret;\n}\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot(name, fallbackRender, props, bindObject) {\n    const scopedSlotFn = this.$scopedSlots[name];\n    let nodes;\n    if (scopedSlotFn) {\n        // scoped slot\n        props = props || {};\n        if (bindObject) {\n            if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n                warn$2('slot v-bind without argument expects an Object', this);\n            }\n            props = extend(extend({}, bindObject), props);\n        }\n        nodes =\n            scopedSlotFn(props) ||\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n    }\n    else {\n        nodes =\n            this.$slots[name] ||\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n    }\n    const target = props && props.slot;\n    if (target) {\n        return this.$createElement('template', { slot: target }, nodes);\n    }\n    else {\n        return nodes;\n    }\n}\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\nfunction isKeyNotMatch(expect, actual) {\n    if (isArray(expect)) {\n        return expect.indexOf(actual) === -1;\n    }\n    else {\n        return expect !== actual;\n    }\n}\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    const mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n        return isKeyNotMatch(builtInKeyName, eventKeyName);\n    }\n    else if (mappedKeyCode) {\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    }\n    else if (eventKeyName) {\n        return hyphenate(eventKeyName) !== key;\n    }\n    return eventKeyCode === undefined;\n}\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n        if (!isObject(value)) {\n            process.env.NODE_ENV !== 'production' &&\n                warn$2('v-bind without argument expects an Object or Array value', this);\n        }\n        else {\n            if (isArray(value)) {\n                value = toObject(value);\n            }\n            let hash;\n            for (const key in value) {\n                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n                    hash = data;\n                }\n                else {\n                    const type = data.attrs && data.attrs.type;\n                    hash =\n                        asProp || config.mustUseProp(tag, type, key)\n                            ? data.domProps || (data.domProps = {})\n                            : data.attrs || (data.attrs = {});\n                }\n                const camelizedKey = camelize(key);\n                const hyphenatedKey = hyphenate(key);\n                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n                    hash[key] = value[key];\n                    if (isSync) {\n                        const on = data.on || (data.on = {});\n                        on[`update:${key}`] = function ($event) {\n                            value[key] = $event;\n                        };\n                    }\n                }\n            }\n        }\n    }\n    return data;\n}\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic(index, isInFor) {\n    const cached = this._staticTrees || (this._staticTrees = []);\n    let tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n        return tree;\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates\n    );\n    markStatic$1(tree, `__static__${index}`, false);\n    return tree;\n}\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce(tree, index, key) {\n    markStatic$1(tree, `__once__${index}${key ? `_${key}` : ``}`, true);\n    return tree;\n}\nfunction markStatic$1(tree, key, isOnce) {\n    if (isArray(tree)) {\n        for (let i = 0; i < tree.length; i++) {\n            if (tree[i] && typeof tree[i] !== 'string') {\n                markStaticNode(tree[i], `${key}_${i}`, isOnce);\n            }\n        }\n    }\n    else {\n        markStaticNode(tree, key, isOnce);\n    }\n}\nfunction markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n}\n\nfunction bindObjectListeners(data, value) {\n    if (value) {\n        if (!isPlainObject(value)) {\n            process.env.NODE_ENV !== 'production' && warn$2('v-on without argument expects an Object value', this);\n        }\n        else {\n            const on = (data.on = data.on ? extend({}, data.on) : {});\n            for (const key in value) {\n                const existing = on[key];\n                const ours = value[key];\n                on[key] = existing ? [].concat(existing, ours) : ours;\n            }\n        }\n    }\n    return data;\n}\n\nfunction resolveScopedSlots(fns, res, \n// the following are added in 2.6\nhasDynamicKeys, contentHashKey) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (let i = 0; i < fns.length; i++) {\n        const slot = fns[i];\n        if (isArray(slot)) {\n            resolveScopedSlots(slot, res, hasDynamicKeys);\n        }\n        else if (slot) {\n            // marker for reverse proxying v-slot without scope on this.$slots\n            // @ts-expect-error\n            if (slot.proxy) {\n                // @ts-expect-error\n                slot.fn.proxy = true;\n            }\n            res[slot.key] = slot.fn;\n        }\n    }\n    if (contentHashKey) {\n        res.$key = contentHashKey;\n    }\n    return res;\n}\n\n// helper to process dynamic keys for dynamic arguments in v-bind and v-on.\nfunction bindDynamicKeys(baseObj, values) {\n    for (let i = 0; i < values.length; i += 2) {\n        const key = values[i];\n        if (typeof key === 'string' && key) {\n            baseObj[values[i]] = values[i + 1];\n        }\n        else if (process.env.NODE_ENV !== 'production' && key !== '' && key !== null) {\n            // null is a special value for explicitly removing a binding\n            warn$2(`Invalid value for dynamic directive argument (expected string or null): ${key}`, this);\n        }\n    }\n    return baseObj;\n}\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n}\n\nfunction installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n}\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots(children, context) {\n    if (!children || !children.length) {\n        return {};\n    }\n    const slots = {};\n    for (let i = 0, l = children.length; i < l; i++) {\n        const child = children[i];\n        const data = child.data;\n        // remove slot attribute if the node is resolved as a Vue slot node\n        if (data && data.attrs && data.attrs.slot) {\n            delete data.attrs.slot;\n        }\n        // named slots should only be respected if the vnode was rendered in the\n        // same context.\n        if ((child.context === context || child.fnContext === context) &&\n            data &&\n            data.slot != null) {\n            const name = data.slot;\n            const slot = slots[name] || (slots[name] = []);\n            if (child.tag === 'template') {\n                slot.push.apply(slot, child.children || []);\n            }\n            else {\n                slot.push(child);\n            }\n        }\n        else {\n            (slots.default || (slots.default = [])).push(child);\n        }\n    }\n    // ignore slots that contains only whitespace\n    for (const name in slots) {\n        if (slots[name].every(isWhitespace)) {\n            delete slots[name];\n        }\n    }\n    return slots;\n}\nfunction isWhitespace(node) {\n    return (node.isComment && !node.asyncFactory) || node.text === ' ';\n}\n\nfunction isAsyncPlaceholder(node) {\n    // @ts-expect-error not really boolean type\n    return node.isComment && node.asyncFactory;\n}\n\nfunction normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {\n    let res;\n    const hasNormalSlots = Object.keys(normalSlots).length > 0;\n    const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;\n    const key = scopedSlots && scopedSlots.$key;\n    if (!scopedSlots) {\n        res = {};\n    }\n    else if (scopedSlots._normalized) {\n        // fast path 1: child component re-render only, parent did not change\n        return scopedSlots._normalized;\n    }\n    else if (isStable &&\n        prevScopedSlots &&\n        prevScopedSlots !== emptyObject &&\n        key === prevScopedSlots.$key &&\n        !hasNormalSlots &&\n        !prevScopedSlots.$hasNormal) {\n        // fast path 2: stable scoped slots w/ no normal slots to proxy,\n        // only need to normalize once\n        return prevScopedSlots;\n    }\n    else {\n        res = {};\n        for (const key in scopedSlots) {\n            if (scopedSlots[key] && key[0] !== '$') {\n                res[key] = normalizeScopedSlot(ownerVm, normalSlots, key, scopedSlots[key]);\n            }\n        }\n    }\n    // expose normal slots on scopedSlots\n    for (const key in normalSlots) {\n        if (!(key in res)) {\n            res[key] = proxyNormalSlot(normalSlots, key);\n        }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (scopedSlots && Object.isExtensible(scopedSlots)) {\n        scopedSlots._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n}\nfunction normalizeScopedSlot(vm, normalSlots, key, fn) {\n    const normalized = function () {\n        const cur = currentInstance;\n        setCurrentInstance(vm);\n        let res = arguments.length ? fn.apply(null, arguments) : fn({});\n        res =\n            res && typeof res === 'object' && !isArray(res)\n                ? [res] // single vnode\n                : normalizeChildren(res);\n        const vnode = res && res[0];\n        setCurrentInstance(cur);\n        return res &&\n            (!vnode ||\n                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391\n            ? undefined\n            : res;\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n        Object.defineProperty(normalSlots, key, {\n            get: normalized,\n            enumerable: true,\n            configurable: true\n        });\n    }\n    return normalized;\n}\nfunction proxyNormalSlot(slots, key) {\n    return () => slots[key];\n}\n\nfunction syncSetupProxy(to, from, prev, instance, type) {\n    let changed = false;\n    for (const key in from) {\n        if (!(key in to)) {\n            changed = true;\n            defineProxyAttr(to, key, instance, type);\n        }\n        else if (from[key] !== prev[key]) {\n            changed = true;\n        }\n    }\n    for (const key in to) {\n        if (!(key in from)) {\n            changed = true;\n            delete to[key];\n        }\n    }\n    return changed;\n}\nfunction defineProxyAttr(proxy, key, instance, type) {\n    Object.defineProperty(proxy, key, {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return instance[type][key];\n        }\n    });\n}\n\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n    const node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data, context, children, tag };\n    return node;\n}\nfunction resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n        return factory.errorComp;\n    }\n    if (isDef(factory.resolved)) {\n        return factory.resolved;\n    }\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n        return factory.loadingComp;\n    }\n}\n\nlet target;\nfunction add(event, fn) {\n    target.$on(event, fn);\n}\nfunction remove(event, fn) {\n    target.$off(event, fn);\n}\nfunction createOnceHandler(event, fn) {\n    const _target = target;\n    return function onceHandler() {\n        const res = fn.apply(null, arguments);\n        if (res !== null) {\n            _target.$off(event, onceHandler);\n        }\n    };\n}\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm);\n    target = undefined;\n}\n\nlet activeInstance = null;\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    if (process.env.NODE_ENV !== 'production') ;\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    const newScopedSlots = parentVnode.data.scopedSlots;\n    const oldScopedSlots = vm.$scopedSlots;\n    const hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||\n        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||\n        (!newScopedSlots && vm.$scopedSlots.$key));\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    let needsForceUpdate = !!(renderChildren || // has new static slots\n        vm.$options._renderChildren || // has old static slots\n        hasDynamicScopedSlot);\n    const prevVNode = vm.$vnode;\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n    if (vm._vnode) {\n        // update child tree's parent\n        vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    const attrs = parentVnode.data.attrs || emptyObject;\n    if (vm._attrsProxy) {\n        // force update if attrs are accessed and has changed since it may be\n        // passed to a child component.\n        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {\n            needsForceUpdate = true;\n        }\n    }\n    vm.$attrs = attrs;\n    // update listeners\n    listeners = listeners || emptyObject;\n    const prevListeners = vm.$options._parentListeners;\n    if (vm._listenersProxy) {\n        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');\n    }\n    vm.$listeners = vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, prevListeners);\n    // update props\n    if (propsData && vm.$options.props) {\n        toggleObserving(false);\n        const props = vm._props;\n        const propKeys = vm.$options._propKeys || [];\n        for (let i = 0; i < propKeys.length; i++) {\n            const key = propKeys[i];\n            const propOptions = vm.$options.props; // wtf flow?\n            props[key] = validateProp(key, propOptions, propsData, vm);\n        }\n        toggleObserving(true);\n        // keep a copy of raw propsData\n        vm.$options.propsData = propsData;\n    }\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n        vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n        vm.$forceUpdate();\n    }\n    if (process.env.NODE_ENV !== 'production') ;\n}\nfunction isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n        if (vm._inactive)\n            return true;\n    }\n    return false;\n}\nfunction activateChildComponent(vm, direct) {\n    if (direct) {\n        vm._directInactive = false;\n        if (isInInactiveTree(vm)) {\n            return;\n        }\n    }\n    else if (vm._directInactive) {\n        return;\n    }\n    if (vm._inactive || vm._inactive === null) {\n        vm._inactive = false;\n        for (let i = 0; i < vm.$children.length; i++) {\n            activateChildComponent(vm.$children[i]);\n        }\n        callHook(vm, 'activated');\n    }\n}\nfunction deactivateChildComponent(vm, direct) {\n    if (direct) {\n        vm._directInactive = true;\n        if (isInInactiveTree(vm)) {\n            return;\n        }\n    }\n    if (!vm._inactive) {\n        vm._inactive = true;\n        for (let i = 0; i < vm.$children.length; i++) {\n            deactivateChildComponent(vm.$children[i]);\n        }\n        callHook(vm, 'deactivated');\n    }\n}\nfunction callHook(vm, hook, args, setContext = true) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    const prevInst = currentInstance;\n    setContext && setCurrentInstance(vm);\n    const handlers = vm.$options[hook];\n    const info = `${hook} hook`;\n    if (handlers) {\n        for (let i = 0, j = handlers.length; i < j; i++) {\n            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);\n        }\n    }\n    if (vm._hasHookEvent) {\n        vm.$emit('hook:' + hook);\n    }\n    if (setContext) {\n        setCurrentInstance(prevInst);\n    }\n    popTarget();\n}\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nlet getNow = Date.now;\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n    const performance = window.performance;\n    if (performance &&\n        typeof performance.now === 'function' &&\n        getNow() > document.createEvent('Event').timeStamp) {\n        // if the event timestamp, although evaluated AFTER the Date.now(), is\n        // smaller than it, it means the event is using a hi-res timestamp,\n        // and we need to use the hi-res version for event listener timestamps as\n        // well.\n        getNow = () => performance.now();\n    }\n}\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n}\n\nfunction handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n        if (vm) {\n            let cur = vm;\n            while ((cur = cur.$parent)) {\n                const hooks = cur.$options.errorCaptured;\n                if (hooks) {\n                    for (let i = 0; i < hooks.length; i++) {\n                        try {\n                            const capture = hooks[i].call(cur, err, vm, info) === false;\n                            if (capture)\n                                return;\n                        }\n                        catch (e) {\n                            globalHandleError(e, cur, 'errorCaptured hook');\n                        }\n                    }\n                }\n            }\n        }\n        globalHandleError(err, vm, info);\n    }\n    finally {\n        popTarget();\n    }\n}\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\n    let res;\n    try {\n        res = args ? handler.apply(context, args) : handler.call(context);\n        if (res && !res._isVue && isPromise(res) && !res._handled) {\n            res.catch(e => handleError(e, vm, info + ` (Promise/async)`));\n            res._handled = true;\n        }\n    }\n    catch (e) {\n        handleError(e, vm, info);\n    }\n    return res;\n}\nfunction globalHandleError(err, vm, info) {\n    logError(err, vm, info);\n}\nfunction logError(err, vm, info) {\n    if (process.env.NODE_ENV !== 'production') {\n        warn$2(`Error in ${info}: \"${err.toString()}\"`, vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n        console.error(err);\n    }\n    else {\n        throw err;\n    }\n}\n\n/* globals MutationObserver */\nconst callbacks = [];\nfunction flushCallbacks() {\n    const copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (let i = 0; i < copies.length; i++) {\n        copies[i]();\n    }\n}\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n    Promise.resolve();\n}\nelse if (!isIE &&\n    typeof MutationObserver !== 'undefined' &&\n    (isNative(MutationObserver) ||\n        // PhantomJS and iOS 7.x\n        MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    let counter = 1;\n    const observer = new MutationObserver(flushCallbacks);\n    const textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n        characterData: true\n    });\n}\nelse if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) ;\nelse ;\n\nconst seenObjects = new _Set();\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse(val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n    return val;\n}\nfunction _traverse(val, seen) {\n    let i, keys;\n    const isA = isArray(val);\n    if ((!isA && !isObject(val)) ||\n        val.__v_skip /* ReactiveFlags.SKIP */ ||\n        Object.isFrozen(val) ||\n        val instanceof VNode) {\n        return;\n    }\n    if (val.__ob__) {\n        const depId = val.__ob__.dep.id;\n        if (seen.has(depId)) {\n            return;\n        }\n        seen.add(depId);\n    }\n    if (isA) {\n        i = val.length;\n        while (i--)\n            _traverse(val[i], seen);\n    }\n    else if (isRef(val)) {\n        _traverse(val.value, seen);\n    }\n    else {\n        keys = Object.keys(val);\n        i = keys.length;\n        while (i--)\n            _traverse(val[keys[i]], seen);\n    }\n}\n\nfunction resolveInject(inject, vm) {\n    if (inject) {\n        // inject is :any because flow is not smart enough to figure out cached\n        const result = Object.create(null);\n        const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            // #6574 in case the inject object is observed...\n            if (key === '__ob__')\n                continue;\n            const provideKey = inject[key].from;\n            if (provideKey in vm._provided) {\n                result[key] = vm._provided[provideKey];\n            }\n            else if ('default' in inject[key]) {\n                const provideDefault = inject[key].default;\n                result[key] = isFunction(provideDefault)\n                    ? provideDefault.call(vm)\n                    : provideDefault;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                warn$2(`Injection \"${key}\" not found`, vm);\n            }\n        }\n        return result;\n    }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n    let options = Ctor.options;\n    if (Ctor.super) {\n        const superOptions = resolveConstructorOptions(Ctor.super);\n        const cachedSuperOptions = Ctor.superOptions;\n        if (superOptions !== cachedSuperOptions) {\n            // super option changed,\n            // need to resolve new options.\n            Ctor.superOptions = superOptions;\n            // check if there are any late-modified/attached options (#4976)\n            const modifiedOptions = resolveModifiedOptions(Ctor);\n            // update base extend options\n            if (modifiedOptions) {\n                extend(Ctor.extendOptions, modifiedOptions);\n            }\n            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n            if (options.name) {\n                options.components[options.name] = Ctor;\n            }\n        }\n    }\n    return options;\n}\nfunction resolveModifiedOptions(Ctor) {\n    let modified;\n    const latest = Ctor.options;\n    const sealed = Ctor.sealedOptions;\n    for (const key in latest) {\n        if (latest[key] !== sealed[key]) {\n            if (!modified)\n                modified = {};\n            modified[key] = latest[key];\n        }\n    }\n    return modified;\n}\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n    const options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    let contextVm;\n    if (hasOwn(parent, '_uid')) {\n        contextVm = Object.create(parent);\n        contextVm._original = parent;\n    }\n    else {\n        // the context vm passed in is a functional context as well.\n        // in this case we want to make sure we are able to get a hold to the\n        // real context instance.\n        contextVm = parent;\n        // @ts-ignore\n        parent = parent._original;\n    }\n    const isCompiled = isTrue(options._compiled);\n    const needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = () => {\n        if (!this.$slots) {\n            normalizeScopedSlots(parent, data.scopedSlots, (this.$slots = resolveSlots(children, parent)));\n        }\n        return this.$slots;\n    };\n    Object.defineProperty(this, 'scopedSlots', {\n        enumerable: true,\n        get() {\n            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());\n        }\n    });\n    // support for compiled functional template\n    if (isCompiled) {\n        // exposing $options for renderStatic()\n        this.$options = options;\n        // pre-resolve slots for renderSlot()\n        this.$slots = this.slots();\n        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);\n    }\n    if (options._scopeId) {\n        this._c = (a, b, c, d) => {\n            const vnode = createElement(contextVm, a, b, c, d, needNormalization);\n            if (vnode && !isArray(vnode)) {\n                vnode.fnScopeId = options._scopeId;\n                vnode.fnContext = parent;\n            }\n            return vnode;\n        };\n    }\n    else {\n        this._c = (a, b, c, d) => createElement(contextVm, a, b, c, d, needNormalization);\n    }\n}\ninstallRenderHelpers(FunctionalRenderContext.prototype);\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    const options = Ctor.options;\n    const props = {};\n    const propOptions = options.props;\n    if (isDef(propOptions)) {\n        for (const key in propOptions) {\n            props[key] = validateProp(key, propOptions, propsData || emptyObject);\n        }\n    }\n    else {\n        if (isDef(data.attrs))\n            mergeProps(props, data.attrs);\n        if (isDef(data.props))\n            mergeProps(props, data.props);\n    }\n    const renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    const vnode = options.render.call(null, renderContext._c, renderContext);\n    if (vnode instanceof VNode) {\n        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    }\n    else if (isArray(vnode)) {\n        const vnodes = normalizeChildren(vnode) || [];\n        const res = new Array(vnodes.length);\n        for (let i = 0; i < vnodes.length; i++) {\n            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n        }\n        return res;\n    }\n}\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    const clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    if (process.env.NODE_ENV !== 'production') {\n        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =\n            renderContext;\n    }\n    if (data.slot) {\n        (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone;\n}\nfunction mergeProps(to, from) {\n    for (const key in from) {\n        to[camelize(key)] = from[key];\n    }\n}\n\nfunction getComponentName(options) {\n    return options.name || options.__name || options._componentTag;\n}\n// inline hooks to be invoked on component VNodes during patch\nconst componentVNodeHooks = {\n    init(vnode, hydrating) {\n        if (vnode.componentInstance &&\n            !vnode.componentInstance._isDestroyed &&\n            vnode.data.keepAlive) {\n            // kept-alive components, treat as a patch\n            const mountedNode = vnode; // work around flow\n            componentVNodeHooks.prepatch(mountedNode, mountedNode);\n        }\n        else {\n            const child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));\n            child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n        }\n    },\n    prepatch(oldVnode, vnode) {\n        const options = vnode.componentOptions;\n        const child = (vnode.componentInstance = oldVnode.componentInstance);\n        updateChildComponent(child, options.propsData, // updated props\n        options.listeners, // updated listeners\n        vnode, // new parent vnode\n        options.children // new children\n        );\n    },\n    insert(vnode) {\n        const { context, componentInstance } = vnode;\n        if (!componentInstance._isMounted) {\n            componentInstance._isMounted = true;\n            callHook(componentInstance, 'mounted');\n        }\n        if (vnode.data.keepAlive) {\n            if (context._isMounted) {\n                // vue-router#1212\n                // During updates, a kept-alive component's child components may\n                // change, so directly walking the tree here may call activated hooks\n                // on incorrect children. Instead we push them into a queue which will\n                // be processed after the whole patch process ended.\n                queueActivatedComponent(componentInstance);\n            }\n            else {\n                activateChildComponent(componentInstance, true /* direct */);\n            }\n        }\n    },\n    destroy(vnode) {\n        const { componentInstance } = vnode;\n        if (!componentInstance._isDestroyed) {\n            if (!vnode.data.keepAlive) {\n                componentInstance.$destroy();\n            }\n            else {\n                deactivateChildComponent(componentInstance, true /* direct */);\n            }\n        }\n    }\n};\nconst hooksToMerge = Object.keys(componentVNodeHooks);\nfunction createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n        return;\n    }\n    const baseCtor = context.$options._base;\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n        Ctor = baseCtor.extend(Ctor);\n    }\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n        if (process.env.NODE_ENV !== 'production') {\n            warn$2(`Invalid Component definition: ${String(Ctor)}`, context);\n        }\n        return;\n    }\n    // async component\n    let asyncFactory;\n    // @ts-expect-error\n    if (isUndef(Ctor.cid)) {\n        asyncFactory = Ctor;\n        Ctor = resolveAsyncComponent(asyncFactory);\n        if (Ctor === undefined) {\n            // return a placeholder node for async component, which is rendered\n            // as a comment node but preserves all the raw information for the node.\n            // the information will be used for async server-rendering and hydration.\n            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n        }\n    }\n    data = data || {};\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n        // @ts-expect-error\n        transformModel(Ctor.options, data);\n    }\n    // extract props\n    // @ts-expect-error\n    const propsData = extractPropsFromVNodeData(data, Ctor, tag);\n    // functional component\n    // @ts-expect-error\n    if (isTrue(Ctor.options.functional)) {\n        return createFunctionalComponent(Ctor, propsData, data, context, children);\n    }\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    const listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n    // @ts-expect-error\n    if (isTrue(Ctor.options.abstract)) {\n        // abstract components do not keep anything\n        // other than props & listeners & slot\n        // work around flow\n        const slot = data.slot;\n        data = {};\n        if (slot) {\n            data.slot = slot;\n        }\n    }\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n    // return a placeholder vnode\n    // @ts-expect-error\n    const name = getComponentName(Ctor.options) || tag;\n    const vnode = new VNode(\n    // @ts-expect-error\n    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, \n    // @ts-expect-error\n    { Ctor, propsData, listeners, tag, children }, asyncFactory);\n    return vnode;\n}\nfunction createComponentInstanceForVnode(\n// we know it's MountedComponentVNode but flow doesn't\nvnode, \n// activeInstance in lifecycle state\nparent) {\n    const options = {\n        _isComponent: true,\n        _parentVnode: vnode,\n        parent\n    };\n    // check inline-template render functions\n    const inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n        options.render = inlineTemplate.render;\n        options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options);\n}\nfunction installComponentHooks(data) {\n    const hooks = data.hook || (data.hook = {});\n    for (let i = 0; i < hooksToMerge.length; i++) {\n        const key = hooksToMerge[i];\n        const existing = hooks[key];\n        const toMerge = componentVNodeHooks[key];\n        // @ts-expect-error\n        if (existing !== toMerge && !(existing && existing._merged)) {\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;\n        }\n    }\n}\nfunction mergeHook(f1, f2) {\n    const merged = (a, b) => {\n        // flow complains about extra args which is why we use any\n        f1(a, b);\n        f2(a, b);\n    };\n    merged._merged = true;\n    return merged;\n}\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel(options, data) {\n    const prop = (options.model && options.model.prop) || 'value';\n    const event = (options.model && options.model.event) || 'input';\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    const on = data.on || (data.on = {});\n    const existing = on[event];\n    const callback = data.model.callback;\n    if (isDef(existing)) {\n        if (isArray(existing)\n            ? existing.indexOf(callback) === -1\n            : existing !== callback) {\n            on[event] = [callback].concat(existing);\n        }\n    }\n    else {\n        on[event] = callback;\n    }\n}\n\nlet warn$2 = noop;\nlet tip = noop;\nlet generateComponentTrace; // work around flow check\nlet formatComponentName;\nif (process.env.NODE_ENV !== 'production') {\n    const hasConsole = typeof console !== 'undefined';\n    const classifyRE = /(?:^|[-_])(\\w)/g;\n    const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\n    warn$2 = (msg, vm = currentInstance) => {\n        const trace = vm ? generateComponentTrace(vm) : '';\n        if (hasConsole && !config.silent) {\n            console.error(`[Vue warn]: ${msg}${trace}`);\n        }\n    };\n    tip = (msg, vm) => {\n        if (hasConsole && !config.silent) {\n            console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ''));\n        }\n    };\n    formatComponentName = (vm, includeFile) => {\n        if (vm.$root === vm) {\n            return '<Root>';\n        }\n        const options = isFunction(vm) && vm.cid != null\n            ? vm.options\n            : vm._isVue\n                ? vm.$options || vm.constructor.options\n                : vm;\n        let name = getComponentName(options);\n        const file = options.__file;\n        if (!name && file) {\n            const match = file.match(/([^/\\\\]+)\\.vue$/);\n            name = match && match[1];\n        }\n        return ((name ? `<${classify(name)}>` : `<Anonymous>`) +\n            (file && includeFile !== false ? ` at ${file}` : ''));\n    };\n    const repeat = (str, n) => {\n        let res = '';\n        while (n) {\n            if (n % 2 === 1)\n                res += str;\n            if (n > 1)\n                str += str;\n            n >>= 1;\n        }\n        return res;\n    };\n    generateComponentTrace = (vm) => {\n        if (vm._isVue && vm.$parent) {\n            const tree = [];\n            let currentRecursiveSequence = 0;\n            while (vm) {\n                if (tree.length > 0) {\n                    const last = tree[tree.length - 1];\n                    if (last.constructor === vm.constructor) {\n                        currentRecursiveSequence++;\n                        vm = vm.$parent;\n                        continue;\n                    }\n                    else if (currentRecursiveSequence > 0) {\n                        tree[tree.length - 1] = [last, currentRecursiveSequence];\n                        currentRecursiveSequence = 0;\n                    }\n                }\n                tree.push(vm);\n                vm = vm.$parent;\n            }\n            return ('\\n\\nfound in\\n\\n' +\n                tree\n                    .map((vm, i) => `${i === 0 ? '---> ' : repeat(' ', 5 + i * 2)}${isArray(vm)\n                    ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`\n                    : formatComponentName(vm)}`)\n                    .join('\\n'));\n        }\n        else {\n            return `\\n\\n(found in ${formatComponentName(vm)})`;\n        }\n    };\n}\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nconst strats = config.optionMergeStrategies;\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n        if (!vm) {\n            warn$2(`option \"${key}\" can only be used during instance ` +\n                'creation with the `new` keyword.');\n        }\n        return defaultStrat(parent, child);\n    };\n}\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData(to, from, recursive = true) {\n    if (!from)\n        return to;\n    let key, toVal, fromVal;\n    const keys = hasSymbol\n        ? Reflect.ownKeys(from)\n        : Object.keys(from);\n    for (let i = 0; i < keys.length; i++) {\n        key = keys[i];\n        // in case the object is already observed...\n        if (key === '__ob__')\n            continue;\n        toVal = to[key];\n        fromVal = from[key];\n        if (!recursive || !hasOwn(to, key)) {\n            set(to, key, fromVal);\n        }\n        else if (toVal !== fromVal &&\n            isPlainObject(toVal) &&\n            isPlainObject(fromVal)) {\n            mergeData(toVal, fromVal);\n        }\n    }\n    return to;\n}\n/**\n * Data\n */\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n        // in a Vue.extend merge, both should be functions\n        if (!childVal) {\n            return parentVal;\n        }\n        if (!parentVal) {\n            return childVal;\n        }\n        // when parentVal & childVal are both present,\n        // we need to return a function that returns the\n        // merged result of both functions... no need to\n        // check if parentVal is a function here because\n        // it has to be a function to pass previous merges.\n        return function mergedDataFn() {\n            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);\n        };\n    }\n    else {\n        return function mergedInstanceDataFn() {\n            // instance merge\n            const instanceData = isFunction(childVal)\n                ? childVal.call(vm, vm)\n                : childVal;\n            const defaultData = isFunction(parentVal)\n                ? parentVal.call(vm, vm)\n                : parentVal;\n            if (instanceData) {\n                return mergeData(instanceData, defaultData);\n            }\n            else {\n                return defaultData;\n            }\n        };\n    }\n}\nstrats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n        if (childVal && typeof childVal !== 'function') {\n            process.env.NODE_ENV !== 'production' &&\n                warn$2('The \"data\" option should be a function ' +\n                    'that returns a per-instance value in component ' +\n                    'definitions.', vm);\n            return parentVal;\n        }\n        return mergeDataOrFn(parentVal, childVal);\n    }\n    return mergeDataOrFn(parentVal, childVal, vm);\n};\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeLifecycleHook(parentVal, childVal) {\n    const res = childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : isArray(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n    return res ? dedupeHooks(res) : res;\n}\nfunction dedupeHooks(hooks) {\n    const res = [];\n    for (let i = 0; i < hooks.length; i++) {\n        if (res.indexOf(hooks[i]) === -1) {\n            res.push(hooks[i]);\n        }\n    }\n    return res;\n}\nLIFECYCLE_HOOKS.forEach(hook => {\n    strats[hook] = mergeLifecycleHook;\n});\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets(parentVal, childVal, vm, key) {\n    const res = Object.create(parentVal || null);\n    if (childVal) {\n        process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n        return extend(res, childVal);\n    }\n    else {\n        return res;\n    }\n}\nASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n});\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    //@ts-expect-error work around\n    if (parentVal === nativeWatch)\n        parentVal = undefined;\n    //@ts-expect-error work around\n    if (childVal === nativeWatch)\n        childVal = undefined;\n    /* istanbul ignore if */\n    if (!childVal)\n        return Object.create(parentVal || null);\n    if (process.env.NODE_ENV !== 'production') {\n        assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal)\n        return childVal;\n    const ret = {};\n    extend(ret, parentVal);\n    for (const key in childVal) {\n        let parent = ret[key];\n        const child = childVal[key];\n        if (parent && !isArray(parent)) {\n            parent = [parent];\n        }\n        ret[key] = parent ? parent.concat(child) : isArray(child) ? child : [child];\n    }\n    return ret;\n};\n/**\n * Other object hashes.\n */\nstrats.props =\n    strats.methods =\n        strats.inject =\n            strats.computed =\n                function (parentVal, childVal, vm, key) {\n                    if (childVal && process.env.NODE_ENV !== 'production') {\n                        assertObjectType(key, childVal, vm);\n                    }\n                    if (!parentVal)\n                        return childVal;\n                    const ret = Object.create(null);\n                    extend(ret, parentVal);\n                    if (childVal)\n                        extend(ret, childVal);\n                    return ret;\n                };\nstrats.provide = function (parentVal, childVal) {\n    if (!parentVal)\n        return childVal;\n    return function () {\n        const ret = Object.create(null);\n        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);\n        if (childVal) {\n            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive\n            );\n        }\n        return ret;\n    };\n};\n/**\n * Default strategy.\n */\nconst defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n};\n/**\n * Validate component names\n */\nfunction checkComponents(options) {\n    for (const key in options.components) {\n        validateComponentName(key);\n    }\n}\nfunction validateComponentName(name) {\n    if (!new RegExp(`^[a-zA-Z][\\\\-\\\\.0-9_${unicodeRegExp.source}]*$`).test(name)) {\n        warn$2('Invalid component name: \"' +\n            name +\n            '\". Component names ' +\n            'should conform to valid custom element name in html5 specification.');\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n        warn$2('Do not use built-in or reserved HTML elements as component ' +\n            'id: ' +\n            name);\n    }\n}\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps(options, vm) {\n    const props = options.props;\n    if (!props)\n        return;\n    const res = {};\n    let i, val, name;\n    if (isArray(props)) {\n        i = props.length;\n        while (i--) {\n            val = props[i];\n            if (typeof val === 'string') {\n                name = camelize(val);\n                res[name] = { type: null };\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                warn$2('props must be strings when using array syntax.');\n            }\n        }\n    }\n    else if (isPlainObject(props)) {\n        for (const key in props) {\n            val = props[key];\n            name = camelize(key);\n            res[name] = isPlainObject(val) ? val : { type: val };\n        }\n    }\n    else if (process.env.NODE_ENV !== 'production') {\n        warn$2(`Invalid value for option \"props\": expected an Array or an Object, ` +\n            `but got ${toRawType(props)}.`, vm);\n    }\n    options.props = res;\n}\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject(options, vm) {\n    const inject = options.inject;\n    if (!inject)\n        return;\n    const normalized = (options.inject = {});\n    if (isArray(inject)) {\n        for (let i = 0; i < inject.length; i++) {\n            normalized[inject[i]] = { from: inject[i] };\n        }\n    }\n    else if (isPlainObject(inject)) {\n        for (const key in inject) {\n            const val = inject[key];\n            normalized[key] = isPlainObject(val)\n                ? extend({ from: key }, val)\n                : { from: val };\n        }\n    }\n    else if (process.env.NODE_ENV !== 'production') {\n        warn$2(`Invalid value for option \"inject\": expected an Array or an Object, ` +\n            `but got ${toRawType(inject)}.`, vm);\n    }\n}\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives(options) {\n    const dirs = options.directives;\n    if (dirs) {\n        for (const key in dirs) {\n            const def = dirs[key];\n            if (isFunction(def)) {\n                dirs[key] = { bind: def, update: def };\n            }\n        }\n    }\n}\nfunction assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n        warn$2(`Invalid value for option \"${name}\": expected an Object, ` +\n            `but got ${toRawType(value)}.`, vm);\n    }\n}\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions(parent, child, vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        checkComponents(child);\n    }\n    if (isFunction(child)) {\n        // @ts-expect-error\n        child = child.options;\n    }\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n        if (child.extends) {\n            parent = mergeOptions(parent, child.extends, vm);\n        }\n        if (child.mixins) {\n            for (let i = 0, l = child.mixins.length; i < l; i++) {\n                parent = mergeOptions(parent, child.mixins[i], vm);\n            }\n        }\n    }\n    const options = {};\n    let key;\n    for (key in parent) {\n        mergeField(key);\n    }\n    for (key in child) {\n        if (!hasOwn(parent, key)) {\n            mergeField(key);\n        }\n    }\n    function mergeField(key) {\n        const strat = strats[key] || defaultStrat;\n        options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n}\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n        return;\n    }\n    const assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id))\n        return assets[id];\n    const camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId))\n        return assets[camelizedId];\n    const PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId))\n        return assets[PascalCaseId];\n    // fallback to prototype chain\n    const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n        warn$2('Failed to resolve ' + type.slice(0, -1) + ': ' + id);\n    }\n    return res;\n}\n\nfunction validateProp(key, propOptions, propsData, vm) {\n    const prop = propOptions[key];\n    const absent = !hasOwn(propsData, key);\n    let value = propsData[key];\n    // boolean casting\n    const booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n        if (absent && !hasOwn(prop, 'default')) {\n            value = false;\n        }\n        else if (value === '' || value === hyphenate(key)) {\n            // only cast empty string / same name to boolean if\n            // boolean has higher priority\n            const stringIndex = getTypeIndex(String, prop.type);\n            if (stringIndex < 0 || booleanIndex < stringIndex) {\n                value = true;\n            }\n        }\n    }\n    // check default value\n    if (value === undefined) {\n        value = getPropDefaultValue(vm, prop, key);\n        // since the default value is a fresh copy,\n        // make sure to observe it.\n        const prevShouldObserve = shouldObserve;\n        toggleObserving(true);\n        observe(value);\n        toggleObserving(prevShouldObserve);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n}\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n        return undefined;\n    }\n    const def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n        warn$2('Invalid default value for prop \"' +\n            key +\n            '\": ' +\n            'Props with type Object/Array must use a factory function ' +\n            'to return the default value.', vm);\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm &&\n        vm.$options.propsData &&\n        vm.$options.propsData[key] === undefined &&\n        vm._props[key] !== undefined) {\n        return vm._props[key];\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return isFunction(def) && getType(prop.type) !== 'Function'\n        ? def.call(vm)\n        : def;\n}\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n        warn$2('Missing required prop: \"' + name + '\"', vm);\n        return;\n    }\n    if (value == null && !prop.required) {\n        return;\n    }\n    let type = prop.type;\n    let valid = !type || type === true;\n    const expectedTypes = [];\n    if (type) {\n        if (!isArray(type)) {\n            type = [type];\n        }\n        for (let i = 0; i < type.length && !valid; i++) {\n            const assertedType = assertType(value, type[i], vm);\n            expectedTypes.push(assertedType.expectedType || '');\n            valid = assertedType.valid;\n        }\n    }\n    const haveExpectedTypes = expectedTypes.some(t => t);\n    if (!valid && haveExpectedTypes) {\n        warn$2(getInvalidTypeMessage(name, value, expectedTypes), vm);\n        return;\n    }\n    const validator = prop.validator;\n    if (validator) {\n        if (!validator(value)) {\n            warn$2('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n        }\n    }\n}\nconst simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\nfunction assertType(value, type, vm) {\n    let valid;\n    const expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n        const t = typeof value;\n        valid = t === expectedType.toLowerCase();\n        // for primitive wrapper objects\n        if (!valid && t === 'object') {\n            valid = value instanceof type;\n        }\n    }\n    else if (expectedType === 'Object') {\n        valid = isPlainObject(value);\n    }\n    else if (expectedType === 'Array') {\n        valid = isArray(value);\n    }\n    else {\n        try {\n            valid = value instanceof type;\n        }\n        catch (e) {\n            warn$2('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\n            valid = false;\n        }\n    }\n    return {\n        valid,\n        expectedType\n    };\n}\nconst functionTypeCheckRE = /^\\s*function (\\w+)/;\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType(fn) {\n    const match = fn && fn.toString().match(functionTypeCheckRE);\n    return match ? match[1] : '';\n}\nfunction isSameType(a, b) {\n    return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n    if (!isArray(expectedTypes)) {\n        return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n    for (let i = 0, len = expectedTypes.length; i < len; i++) {\n        if (isSameType(expectedTypes[i], type)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\n        ` Expected ${expectedTypes.map(capitalize).join(', ')}`;\n    const expectedType = expectedTypes[0];\n    const receivedType = toRawType(value);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        isExplicable(typeof value) &&\n        !isBoolean(expectedType, receivedType)) {\n        message += ` with value ${styleValue(value, expectedType)}`;\n    }\n    message += `, got ${receivedType} `;\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n        message += `with value ${styleValue(value, receivedType)}.`;\n    }\n    return message;\n}\nfunction styleValue(value, type) {\n    if (type === 'String') {\n        return `\"${value}\"`;\n    }\n    else if (type === 'Number') {\n        return `${Number(value)}`;\n    }\n    else {\n        return `${value}`;\n    }\n}\nconst EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\nfunction isExplicable(value) {\n    return EXPLICABLE_TYPES.some(elem => value.toLowerCase() === elem);\n}\nfunction isBoolean(...args) {\n    return args.some(elem => elem.toLowerCase() === 'boolean');\n}\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nmakeMap('style,class');\n// attributes that should be using props for binding\nconst acceptValue = makeMap('input,textarea,option,select,progress');\nconst mustUseProp = (tag, type, attr) => {\n    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||\n        (attr === 'selected' && tag === 'option') ||\n        (attr === 'checked' && tag === 'input') ||\n        (attr === 'muted' && tag === 'video'));\n};\nconst isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\nmakeMap('events,caret,typing,plaintext-only');\nconst isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n    'required,reversed,scoped,seamless,selected,sortable,' +\n    'truespeed,typemustmatch,visible');\n\nconst isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot');\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nconst isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\nconst isPreTag = (tag) => tag === 'pre';\nconst isReservedTag = (tag) => {\n    return isHTMLTag(tag) || isSVG(tag);\n};\nfunction getTagNamespace(tag) {\n    if (isSVG(tag)) {\n        return 'svg';\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n        return 'math';\n    }\n}\nmakeMap('text,number,password,search,email,tel,url');\n\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/;\nfunction parseFilters(exp) {\n    let inSingle = false;\n    let inDouble = false;\n    let inTemplateString = false;\n    let inRegex = false;\n    let curly = 0;\n    let square = 0;\n    let paren = 0;\n    let lastFilterIndex = 0;\n    let c, prev, i, expression, filters;\n    for (i = 0; i < exp.length; i++) {\n        prev = c;\n        c = exp.charCodeAt(i);\n        if (inSingle) {\n            if (c === 0x27 && prev !== 0x5c)\n                inSingle = false;\n        }\n        else if (inDouble) {\n            if (c === 0x22 && prev !== 0x5c)\n                inDouble = false;\n        }\n        else if (inTemplateString) {\n            if (c === 0x60 && prev !== 0x5c)\n                inTemplateString = false;\n        }\n        else if (inRegex) {\n            if (c === 0x2f && prev !== 0x5c)\n                inRegex = false;\n        }\n        else if (c === 0x7c && // pipe\n            exp.charCodeAt(i + 1) !== 0x7c &&\n            exp.charCodeAt(i - 1) !== 0x7c &&\n            !curly &&\n            !square &&\n            !paren) {\n            if (expression === undefined) {\n                // first filter, end of expression\n                lastFilterIndex = i + 1;\n                expression = exp.slice(0, i).trim();\n            }\n            else {\n                pushFilter();\n            }\n        }\n        else {\n            switch (c) {\n                case 0x22:\n                    inDouble = true;\n                    break; // \"\n                case 0x27:\n                    inSingle = true;\n                    break; // '\n                case 0x60:\n                    inTemplateString = true;\n                    break; // `\n                case 0x28:\n                    paren++;\n                    break; // (\n                case 0x29:\n                    paren--;\n                    break; // )\n                case 0x5b:\n                    square++;\n                    break; // [\n                case 0x5d:\n                    square--;\n                    break; // ]\n                case 0x7b:\n                    curly++;\n                    break; // {\n                case 0x7d:\n                    curly--;\n                    break; // }\n            }\n            if (c === 0x2f) {\n                // /\n                let j = i - 1;\n                let p;\n                // find first non-whitespace prev char\n                for (; j >= 0; j--) {\n                    p = exp.charAt(j);\n                    if (p !== ' ')\n                        break;\n                }\n                if (!p || !validDivisionCharRE.test(p)) {\n                    inRegex = true;\n                }\n            }\n        }\n    }\n    if (expression === undefined) {\n        expression = exp.slice(0, i).trim();\n    }\n    else if (lastFilterIndex !== 0) {\n        pushFilter();\n    }\n    function pushFilter() {\n        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n        lastFilterIndex = i + 1;\n    }\n    if (filters) {\n        for (i = 0; i < filters.length; i++) {\n            expression = wrapFilter(expression, filters[i]);\n        }\n    }\n    return expression;\n}\nfunction wrapFilter(exp, filter) {\n    const i = filter.indexOf('(');\n    if (i < 0) {\n        // _f: resolveFilter\n        return `_f(\"${filter}\")(${exp})`;\n    }\n    else {\n        const name = filter.slice(0, i);\n        const args = filter.slice(i + 1);\n        return `_f(\"${name}\")(${exp}${args !== ')' ? ',' + args : args}`;\n    }\n}\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nconst regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nconst buildRegex = cached(delimiters => {\n    const open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    const close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\nfunction parseText(text, delimiters) {\n    //@ts-expect-error\n    const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n        return;\n    }\n    const tokens = [];\n    const rawTokens = [];\n    let lastIndex = (tagRE.lastIndex = 0);\n    let match, index, tokenValue;\n    while ((match = tagRE.exec(text))) {\n        index = match.index;\n        // push text token\n        if (index > lastIndex) {\n            rawTokens.push((tokenValue = text.slice(lastIndex, index)));\n            tokens.push(JSON.stringify(tokenValue));\n        }\n        // tag token\n        const exp = parseFilters(match[1].trim());\n        tokens.push(`_s(${exp})`);\n        rawTokens.push({ '@binding': exp });\n        lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n        rawTokens.push((tokenValue = text.slice(lastIndex)));\n        tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n        expression: tokens.join('+'),\n        tokens: rawTokens\n    };\n}\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn(msg, range) {\n    console.error(`[Vue compiler]: ${msg}`);\n}\n/* eslint-enable no-unused-vars */\nfunction pluckModuleFunction(modules, key) {\n    return modules ? modules.map(m => m[key]).filter(_ => _) : [];\n}\nfunction addProp(el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({ name, value, dynamic }, range));\n    el.plain = false;\n}\nfunction addAttr(el, name, value, range, dynamic) {\n    const attrs = dynamic\n        ? el.dynamicAttrs || (el.dynamicAttrs = [])\n        : el.attrs || (el.attrs = []);\n    attrs.push(rangeSetItem({ name, value, dynamic }, range));\n    el.plain = false;\n}\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr(el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({ name, value }, range));\n}\nfunction addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n        name,\n        rawName,\n        value,\n        arg,\n        isDynamicArg,\n        modifiers\n    }, range));\n    el.plain = false;\n}\nfunction prependModifierMarker(symbol, name, dynamic) {\n    return dynamic ? `_p(${name},\"${symbol}\")` : symbol + name; // mark the event as captured\n}\nfunction addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && warn && modifiers.prevent && modifiers.passive) {\n        warn(\"passive and prevent can't be used together. \" +\n            \"Passive handler can't prevent default event.\", range);\n    }\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (modifiers.right) {\n        if (dynamic) {\n            name = `(${name})==='click'?'contextmenu':(${name})`;\n        }\n        else if (name === 'click') {\n            name = 'contextmenu';\n            delete modifiers.right;\n        }\n    }\n    else if (modifiers.middle) {\n        if (dynamic) {\n            name = `(${name})==='click'?'mouseup':(${name})`;\n        }\n        else if (name === 'click') {\n            name = 'mouseup';\n        }\n    }\n    // check capture modifier\n    if (modifiers.capture) {\n        delete modifiers.capture;\n        name = prependModifierMarker('!', name, dynamic);\n    }\n    if (modifiers.once) {\n        delete modifiers.once;\n        name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n        delete modifiers.passive;\n        name = prependModifierMarker('&', name, dynamic);\n    }\n    let events;\n    if (modifiers.native) {\n        delete modifiers.native;\n        events = el.nativeEvents || (el.nativeEvents = {});\n    }\n    else {\n        events = el.events || (el.events = {});\n    }\n    const newHandler = rangeSetItem({ value: value.trim(), dynamic }, range);\n    if (modifiers !== emptyObject) {\n        newHandler.modifiers = modifiers;\n    }\n    const handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n        important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    }\n    else if (handlers) {\n        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    }\n    else {\n        events[name] = newHandler;\n    }\n    el.plain = false;\n}\nfunction getRawBindingAttr(el, name) {\n    return (el.rawAttrsMap[':' + name] ||\n        el.rawAttrsMap['v-bind:' + name] ||\n        el.rawAttrsMap[name]);\n}\nfunction getBindingAttr(el, name, getStatic) {\n    const dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n        return parseFilters(dynamicValue);\n    }\n    else if (getStatic !== false) {\n        const staticValue = getAndRemoveAttr(el, name);\n        if (staticValue != null) {\n            return JSON.stringify(staticValue);\n        }\n    }\n}\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr(el, name, removeFromMap) {\n    let val;\n    if ((val = el.attrsMap[name]) != null) {\n        const list = el.attrsList;\n        for (let i = 0, l = list.length; i < l; i++) {\n            if (list[i].name === name) {\n                list.splice(i, 1);\n                break;\n            }\n        }\n    }\n    if (removeFromMap) {\n        delete el.attrsMap[name];\n    }\n    return val;\n}\nfunction getAndRemoveAttrByRegex(el, name) {\n    const list = el.attrsList;\n    for (let i = 0, l = list.length; i < l; i++) {\n        const attr = list[i];\n        if (name.test(attr.name)) {\n            list.splice(i, 1);\n            return attr;\n        }\n    }\n}\nfunction rangeSetItem(item, range) {\n    if (range) {\n        if (range.start != null) {\n            item.start = range.start;\n        }\n        if (range.end != null) {\n            item.end = range.end;\n        }\n    }\n    return item;\n}\n\nfunction transformNode$1(el, options) {\n    const warn = options.warn || baseWarn;\n    const staticClass = getAndRemoveAttr(el, 'class');\n    if (process.env.NODE_ENV !== 'production' && staticClass) {\n        const res = parseText(staticClass, options.delimiters);\n        if (res) {\n            warn(`class=\"${staticClass}\": ` +\n                'Interpolation inside attributes has been removed. ' +\n                'Use v-bind or the colon shorthand instead. For example, ' +\n                'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n        }\n    }\n    if (staticClass) {\n        el.staticClass = JSON.stringify(staticClass.replace(/\\s+/g, ' ').trim());\n    }\n    const classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n        el.classBinding = classBinding;\n    }\n}\nfunction genData$2(el) {\n    let data = '';\n    if (el.staticClass) {\n        data += `staticClass:${el.staticClass},`;\n    }\n    if (el.classBinding) {\n        data += `class:${el.classBinding},`;\n    }\n    return data;\n}\nvar klass = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode$1,\n    genData: genData$2\n};\n\nconst parseStyleText = cached(function (cssText) {\n    const res = {};\n    const listDelimiter = /;(?![^(]*\\))/g;\n    const propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n        if (item) {\n            const tmp = item.split(propertyDelimiter);\n            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return res;\n});\n\nfunction transformNode(el, options) {\n    const warn = options.warn || baseWarn;\n    const staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n            const res = parseText(staticStyle, options.delimiters);\n            if (res) {\n                warn(`style=\"${staticStyle}\": ` +\n                    'Interpolation inside attributes has been removed. ' +\n                    'Use v-bind or the colon shorthand instead. For example, ' +\n                    'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n            }\n        }\n        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n    const styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n        el.styleBinding = styleBinding;\n    }\n}\nfunction genData$1(el) {\n    let data = '';\n    if (el.staticStyle) {\n        data += `staticStyle:${el.staticStyle},`;\n    }\n    if (el.styleBinding) {\n        data += `style:(${el.styleBinding}),`;\n    }\n    return data;\n}\nvar style = {\n    staticKeys: ['staticStyle'],\n    transformNode,\n    genData: genData$1\n};\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel(el, value, modifiers) {\n    const { number, trim } = modifiers || {};\n    const baseValueExpression = '$$v';\n    let valueExpression = baseValueExpression;\n    if (trim) {\n        valueExpression =\n            `(typeof ${baseValueExpression} === 'string'` +\n                `? ${baseValueExpression}.trim()` +\n                `: ${baseValueExpression})`;\n    }\n    if (number) {\n        valueExpression = `_n(${valueExpression})`;\n    }\n    const assignment = genAssignmentCode(value, valueExpression);\n    el.model = {\n        value: `(${value})`,\n        expression: JSON.stringify(value),\n        callback: `function (${baseValueExpression}) {${assignment}}`\n    };\n}\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode(value, assignment) {\n    const res = parseModel(value);\n    if (res.key === null) {\n        return `${value}=${assignment}`;\n    }\n    else {\n        return `$set(${res.exp}, ${res.key}, ${assignment})`;\n    }\n}\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\nlet len, str, chr, index, expressionPos, expressionEndPos;\nfunction parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n        index = val.lastIndexOf('.');\n        if (index > -1) {\n            return {\n                exp: val.slice(0, index),\n                key: '\"' + val.slice(index + 1) + '\"'\n            };\n        }\n        else {\n            return {\n                exp: val,\n                key: null\n            };\n        }\n    }\n    str = val;\n    index = expressionPos = expressionEndPos = 0;\n    while (!eof()) {\n        chr = next();\n        /* istanbul ignore if */\n        if (isStringStart(chr)) {\n            parseString(chr);\n        }\n        else if (chr === 0x5b) {\n            parseBracket(chr);\n        }\n    }\n    return {\n        exp: val.slice(0, expressionPos),\n        key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n}\nfunction next() {\n    return str.charCodeAt(++index);\n}\nfunction eof() {\n    return index >= len;\n}\nfunction isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n}\nfunction parseBracket(chr) {\n    let inBracket = 1;\n    expressionPos = index;\n    while (!eof()) {\n        chr = next();\n        if (isStringStart(chr)) {\n            parseString(chr);\n            continue;\n        }\n        if (chr === 0x5b)\n            inBracket++;\n        if (chr === 0x5d)\n            inBracket--;\n        if (inBracket === 0) {\n            expressionEndPos = index;\n            break;\n        }\n    }\n}\nfunction parseString(chr) {\n    const stringQuote = chr;\n    while (!eof()) {\n        chr = next();\n        if (chr === stringQuote) {\n            break;\n        }\n    }\n}\n\nconst onRE = /^@|^v-on:/;\nconst dirRE = /^v-|^@|^:|^#/;\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nconst stripParensRE = /^\\(|\\)$/g;\nconst dynamicArgRE = /^\\[.*\\]$/;\nconst argRE = /:(.*)$/;\nconst bindRE = /^:|^\\.|^v-bind:/;\nconst modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\nconst slotRE = /^v-slot(:|$)|^#/;\nconst lineBreakRE = /[\\r\\n]/;\nconst whitespaceRE = /[ \\f\\t\\r\\n]+/g;\nconst invalidAttributeRE = /[\\s\"'<>\\/=]/;\nconst decodeHTMLCached = cached(he__default[\"default\"].decode);\nconst emptySlotScopeToken = `_empty_`;\n// configurable state\nlet warn$1;\nlet delimiters;\nlet transforms;\nlet preTransforms;\nlet postTransforms;\nlet platformIsPreTag;\nlet platformMustUseProp;\nlet platformGetTagNamespace;\nlet maybeComponent;\nfunction createASTElement(tag, attrs, parent) {\n    return {\n        type: 1,\n        tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        rawAttrsMap: {},\n        parent,\n        children: []\n    };\n}\n/**\n * Convert HTML string to AST.\n */\nfunction parse(template, options) {\n    warn$1 = options.warn || baseWarn;\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    const isReservedTag = options.isReservedTag || no;\n    maybeComponent = (el) => !!(el.component ||\n        el.attrsMap[':is'] ||\n        el.attrsMap['v-bind:is'] ||\n        !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    const stack = [];\n    const preserveWhitespace = options.preserveWhitespace !== false;\n    const whitespaceOption = options.whitespace;\n    let root;\n    let currentParent;\n    let inVPre = false;\n    let inPre = false;\n    let warned = false;\n    function warnOnce(msg, range) {\n        if (!warned) {\n            warned = true;\n            warn$1(msg, range);\n        }\n    }\n    function closeElement(element) {\n        trimEndingWhitespace(element);\n        if (!inVPre && !element.processed) {\n            element = processElement(element, options);\n        }\n        // tree management\n        if (!stack.length && element !== root) {\n            // allow root elements with v-if, v-else-if and v-else\n            if (root.if && (element.elseif || element.else)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    checkRootConstraints(element);\n                }\n                addIfCondition(root, {\n                    exp: element.elseif,\n                    block: element\n                });\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                warnOnce(`Component template should contain exactly one root element. ` +\n                    `If you are using v-if on multiple elements, ` +\n                    `use v-else-if to chain them instead.`, { start: element.start });\n            }\n        }\n        if (currentParent && !element.forbidden) {\n            if (element.elseif || element.else) {\n                processIfConditions(element, currentParent);\n            }\n            else {\n                if (element.slotScope) {\n                    // scoped slot\n                    // keep it in the children list so that v-else(-if) conditions can\n                    // find it as the prev node.\n                    const name = element.slotTarget || '\"default\"';\n                    (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n                }\n                currentParent.children.push(element);\n                element.parent = currentParent;\n            }\n        }\n        // final children cleanup\n        // filter out scoped slots\n        element.children = element.children.filter(c => !c.slotScope);\n        // remove trailing whitespace node again\n        trimEndingWhitespace(element);\n        // check pre state\n        if (element.pre) {\n            inVPre = false;\n        }\n        if (platformIsPreTag(element.tag)) {\n            inPre = false;\n        }\n        // apply post-transforms\n        for (let i = 0; i < postTransforms.length; i++) {\n            postTransforms[i](element, options);\n        }\n    }\n    function trimEndingWhitespace(el) {\n        // remove trailing whitespace node\n        if (!inPre) {\n            let lastNode;\n            while ((lastNode = el.children[el.children.length - 1]) &&\n                lastNode.type === 3 &&\n                lastNode.text === ' ') {\n                el.children.pop();\n            }\n        }\n    }\n    function checkRootConstraints(el) {\n        if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(`Cannot use <${el.tag}> as component root element because it may ` +\n                'contain multiple nodes.', { start: el.start });\n        }\n        if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce('Cannot use v-for on stateful component root element because ' +\n                'it renders multiple elements.', el.rawAttrsMap['v-for']);\n        }\n    }\n    parseHTML(template, {\n        warn: warn$1,\n        expectHTML: options.expectHTML,\n        isUnaryTag: options.isUnaryTag,\n        canBeLeftOpenTag: options.canBeLeftOpenTag,\n        shouldDecodeNewlines: options.shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n        shouldKeepComment: options.comments,\n        outputSourceRange: options.outputSourceRange,\n        start(tag, attrs, unary, start, end) {\n            // check namespace.\n            // inherit parent ns if there is one\n            const ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n            // handle IE svg bug\n            /* istanbul ignore if */\n            if (isIE && ns === 'svg') {\n                attrs = guardIESVGBug(attrs);\n            }\n            let element = createASTElement(tag, attrs, currentParent);\n            if (ns) {\n                element.ns = ns;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (options.outputSourceRange) {\n                    element.start = start;\n                    element.end = end;\n                    element.rawAttrsMap = element.attrsList.reduce((cumulated, attr) => {\n                        cumulated[attr.name] = attr;\n                        return cumulated;\n                    }, {});\n                }\n                attrs.forEach(attr => {\n                    if (invalidAttributeRE.test(attr.name)) {\n                        warn$1(`Invalid dynamic argument expression: attribute names cannot contain ` +\n                            `spaces, quotes, <, >, / or =.`, options.outputSourceRange\n                            ? {\n                                start: attr.start + attr.name.indexOf(`[`),\n                                end: attr.start + attr.name.length\n                            }\n                            : undefined);\n                    }\n                });\n            }\n            if (isForbiddenTag(element) && !isServerRendering()) {\n                element.forbidden = true;\n                process.env.NODE_ENV !== 'production' &&\n                    warn$1('Templates should only be responsible for mapping the state to the ' +\n                        'UI. Avoid placing tags with side-effects in your templates, such as ' +\n                        `<${tag}>` +\n                        ', as they will not be parsed.', { start: element.start });\n            }\n            // apply pre-transforms\n            for (let i = 0; i < preTransforms.length; i++) {\n                element = preTransforms[i](element, options) || element;\n            }\n            if (!inVPre) {\n                processPre(element);\n                if (element.pre) {\n                    inVPre = true;\n                }\n            }\n            if (platformIsPreTag(element.tag)) {\n                inPre = true;\n            }\n            if (inVPre) {\n                processRawAttrs(element);\n            }\n            else if (!element.processed) {\n                // structural directives\n                processFor(element);\n                processIf(element);\n                processOnce(element);\n            }\n            if (!root) {\n                root = element;\n                if (process.env.NODE_ENV !== 'production') {\n                    checkRootConstraints(root);\n                }\n            }\n            if (!unary) {\n                currentParent = element;\n                stack.push(element);\n            }\n            else {\n                closeElement(element);\n            }\n        },\n        end(tag, start, end) {\n            const element = stack[stack.length - 1];\n            // pop stack\n            stack.length -= 1;\n            currentParent = stack[stack.length - 1];\n            if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n                element.end = end;\n            }\n            closeElement(element);\n        },\n        chars(text, start, end) {\n            if (!currentParent) {\n                if (process.env.NODE_ENV !== 'production') {\n                    if (text === template) {\n                        warnOnce('Component template requires a root element, rather than just text.', { start });\n                    }\n                    else if ((text = text.trim())) {\n                        warnOnce(`text \"${text}\" outside root element will be ignored.`, {\n                            start\n                        });\n                    }\n                }\n                return;\n            }\n            // IE textarea placeholder bug\n            /* istanbul ignore if */\n            if (isIE &&\n                currentParent.tag === 'textarea' &&\n                currentParent.attrsMap.placeholder === text) {\n                return;\n            }\n            const children = currentParent.children;\n            if (inPre || text.trim()) {\n                text = isTextTag(currentParent)\n                    ? text\n                    : decodeHTMLCached(text);\n            }\n            else if (!children.length) {\n                // remove the whitespace-only node right after an opening tag\n                text = '';\n            }\n            else if (whitespaceOption) {\n                if (whitespaceOption === 'condense') {\n                    // in condense mode, remove the whitespace node if it contains\n                    // line break, otherwise condense to a single space\n                    text = lineBreakRE.test(text) ? '' : ' ';\n                }\n                else {\n                    text = ' ';\n                }\n            }\n            else {\n                text = preserveWhitespace ? ' ' : '';\n            }\n            if (text) {\n                if (!inPre && whitespaceOption === 'condense') {\n                    // condense consecutive whitespaces into single space\n                    text = text.replace(whitespaceRE, ' ');\n                }\n                let res;\n                let child;\n                if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n                    child = {\n                        type: 2,\n                        expression: res.expression,\n                        tokens: res.tokens,\n                        text\n                    };\n                }\n                else if (text !== ' ' ||\n                    !children.length ||\n                    children[children.length - 1].text !== ' ') {\n                    child = {\n                        type: 3,\n                        text\n                    };\n                }\n                if (child) {\n                    if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n                        child.start = start;\n                        child.end = end;\n                    }\n                    children.push(child);\n                }\n            }\n        },\n        comment(text, start, end) {\n            // adding anything as a sibling to the root node is forbidden\n            // comments should still be allowed, but ignored\n            if (currentParent) {\n                const child = {\n                    type: 3,\n                    text,\n                    isComment: true\n                };\n                if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n                    child.start = start;\n                    child.end = end;\n                }\n                currentParent.children.push(child);\n            }\n        }\n    });\n    return root;\n}\nfunction processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n        el.pre = true;\n    }\n}\nfunction processRawAttrs(el) {\n    const list = el.attrsList;\n    const len = list.length;\n    if (len) {\n        const attrs = (el.attrs = new Array(len));\n        for (let i = 0; i < len; i++) {\n            attrs[i] = {\n                name: list[i].name,\n                value: JSON.stringify(list[i].value)\n            };\n            if (list[i].start != null) {\n                attrs[i].start = list[i].start;\n                attrs[i].end = list[i].end;\n            }\n        }\n    }\n    else if (!el.pre) {\n        // non root node in pre blocks with no attributes\n        el.plain = true;\n    }\n}\nfunction processElement(element, options) {\n    processKey(element);\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain =\n        !element.key && !element.scopedSlots && !element.attrsList.length;\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    for (let i = 0; i < transforms.length; i++) {\n        element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n    return element;\n}\nfunction processKey(el) {\n    const exp = getBindingAttr(el, 'key');\n    if (exp) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (el.tag === 'template') {\n                warn$1(`<template> cannot be keyed. Place the key on real elements instead.`, getRawBindingAttr(el, 'key'));\n            }\n            if (el.for) {\n                const iterator = el.iterator2 || el.iterator1;\n                const parent = el.parent;\n                if (iterator &&\n                    iterator === exp &&\n                    parent &&\n                    parent.tag === 'transition-group') {\n                    warn$1(`Do not use v-for index as key on <transition-group> children, ` +\n                        `this is the same as not using keys.`, getRawBindingAttr(el, 'key'), true /* tip */);\n                }\n            }\n        }\n        el.key = exp;\n    }\n}\nfunction processRef(el) {\n    const ref = getBindingAttr(el, 'ref');\n    if (ref) {\n        el.ref = ref;\n        el.refInFor = checkInFor(el);\n    }\n}\nfunction processFor(el) {\n    let exp;\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n        const res = parseFor(exp);\n        if (res) {\n            extend(el, res);\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            warn$1(`Invalid v-for expression: ${exp}`, el.rawAttrsMap['v-for']);\n        }\n    }\n}\nfunction parseFor(exp) {\n    const inMatch = exp.match(forAliasRE);\n    if (!inMatch)\n        return;\n    const res = {};\n    res.for = inMatch[2].trim();\n    const alias = inMatch[1].trim().replace(stripParensRE, '');\n    const iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n        res.alias = alias.replace(forIteratorRE, '').trim();\n        res.iterator1 = iteratorMatch[1].trim();\n        if (iteratorMatch[2]) {\n            res.iterator2 = iteratorMatch[2].trim();\n        }\n    }\n    else {\n        res.alias = alias;\n    }\n    return res;\n}\nfunction processIf(el) {\n    const exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n        el.if = exp;\n        addIfCondition(el, {\n            exp: exp,\n            block: el\n        });\n    }\n    else {\n        if (getAndRemoveAttr(el, 'v-else') != null) {\n            el.else = true;\n        }\n        const elseif = getAndRemoveAttr(el, 'v-else-if');\n        if (elseif) {\n            el.elseif = elseif;\n        }\n    }\n}\nfunction processIfConditions(el, parent) {\n    const prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n        addIfCondition(prev, {\n            exp: el.elseif,\n            block: el\n        });\n    }\n    else if (process.env.NODE_ENV !== 'production') {\n        warn$1(`v-${el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else'} ` +\n            `used on element <${el.tag}> without corresponding v-if.`, el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n    }\n}\nfunction findPrevElement(children) {\n    let i = children.length;\n    while (i--) {\n        if (children[i].type === 1) {\n            return children[i];\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n                warn$1(`text \"${children[i].text.trim()}\" between v-if and v-else(-if) ` +\n                    `will be ignored.`, children[i]);\n            }\n            children.pop();\n        }\n    }\n}\nfunction addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n        el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n}\nfunction processOnce(el) {\n    const once = getAndRemoveAttr(el, 'v-once');\n    if (once != null) {\n        el.once = true;\n    }\n}\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent(el) {\n    let slotScope;\n    if (el.tag === 'template') {\n        slotScope = getAndRemoveAttr(el, 'scope');\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && slotScope) {\n            warn$1(`the \"scope\" attribute for scoped slots have been deprecated and ` +\n                `replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute ` +\n                `can also be used on plain elements in addition to <template> to ` +\n                `denote scoped slots.`, el.rawAttrsMap['scope'], true);\n        }\n        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    }\n    else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && el.attrsMap['v-for']) {\n            warn$1(`Ambiguous combined usage of slot-scope and v-for on <${el.tag}> ` +\n                `(v-for takes higher priority). Use a wrapper <template> for the ` +\n                `scoped slot to make it clearer.`, el.rawAttrsMap['slot-scope'], true);\n        }\n        el.slotScope = slotScope;\n    }\n    // slot=\"xxx\"\n    const slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n        el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n        // preserve slot as an attribute for native shadow DOM compat\n        // only for non-scoped slots.\n        if (el.tag !== 'template' && !el.slotScope) {\n            addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n        }\n    }\n    // 2.6 v-slot syntax\n    {\n        if (el.tag === 'template') {\n            // v-slot on <template>\n            const slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n            if (slotBinding) {\n                if (process.env.NODE_ENV !== 'production') {\n                    if (el.slotTarget || el.slotScope) {\n                        warn$1(`Unexpected mixed usage of different slot syntaxes.`, el);\n                    }\n                    if (el.parent && !maybeComponent(el.parent)) {\n                        warn$1(`<template v-slot> can only appear at the root level inside ` +\n                            `the receiving component`, el);\n                    }\n                }\n                const { name, dynamic } = getSlotName(slotBinding);\n                el.slotTarget = name;\n                el.slotTargetDynamic = dynamic;\n                el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n            }\n        }\n        else {\n            // v-slot on component, denotes default slot\n            const slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n            if (slotBinding) {\n                if (process.env.NODE_ENV !== 'production') {\n                    if (!maybeComponent(el)) {\n                        warn$1(`v-slot can only be used on components or <template>.`, slotBinding);\n                    }\n                    if (el.slotScope || el.slotTarget) {\n                        warn$1(`Unexpected mixed usage of different slot syntaxes.`, el);\n                    }\n                    if (el.scopedSlots) {\n                        warn$1(`To avoid scope ambiguity, the default slot should also use ` +\n                            `<template> syntax when there are other named slots.`, slotBinding);\n                    }\n                }\n                // add the component's children to its default slot\n                const slots = el.scopedSlots || (el.scopedSlots = {});\n                const { name, dynamic } = getSlotName(slotBinding);\n                const slotContainer = (slots[name] = createASTElement('template', [], el));\n                slotContainer.slotTarget = name;\n                slotContainer.slotTargetDynamic = dynamic;\n                slotContainer.children = el.children.filter((c) => {\n                    if (!c.slotScope) {\n                        c.parent = slotContainer;\n                        return true;\n                    }\n                });\n                slotContainer.slotScope = slotBinding.value || emptySlotScopeToken;\n                // remove children as they are returned from scopedSlots now\n                el.children = [];\n                // mark el non-plain so data gets generated\n                el.plain = false;\n            }\n        }\n    }\n}\nfunction getSlotName(binding) {\n    let name = binding.name.replace(slotRE, '');\n    if (!name) {\n        if (binding.name[0] !== '#') {\n            name = 'default';\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            warn$1(`v-slot shorthand syntax requires a slot name.`, binding);\n        }\n    }\n    return dynamicArgRE.test(name)\n        ? // dynamic [name]\n            { name: name.slice(1, -1), dynamic: true }\n        : // static name\n            { name: `\"${name}\"`, dynamic: false };\n}\n// handle <slot/> outlets\nfunction processSlotOutlet(el) {\n    if (el.tag === 'slot') {\n        el.slotName = getBindingAttr(el, 'name');\n        if (process.env.NODE_ENV !== 'production' && el.key) {\n            warn$1(`\\`key\\` does not work on <slot> because slots are abstract outlets ` +\n                `and can possibly expand into multiple elements. ` +\n                `Use the key on a wrapping element instead.`, getRawBindingAttr(el, 'key'));\n        }\n    }\n}\nfunction processComponent(el) {\n    let binding;\n    if ((binding = getBindingAttr(el, 'is'))) {\n        el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n        el.inlineTemplate = true;\n    }\n}\nfunction processAttrs(el) {\n    const list = el.attrsList;\n    let i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n        name = rawName = list[i].name;\n        value = list[i].value;\n        if (dirRE.test(name)) {\n            // mark element as dynamic\n            el.hasBindings = true;\n            // modifiers\n            modifiers = parseModifiers(name.replace(dirRE, ''));\n            // support .foo shorthand syntax for the .prop modifier\n            if (modifiers) {\n                name = name.replace(modifierRE, '');\n            }\n            if (bindRE.test(name)) {\n                // v-bind\n                name = name.replace(bindRE, '');\n                value = parseFilters(value);\n                isDynamic = dynamicArgRE.test(name);\n                if (isDynamic) {\n                    name = name.slice(1, -1);\n                }\n                if (process.env.NODE_ENV !== 'production' && value.trim().length === 0) {\n                    warn$1(`The value for a v-bind expression cannot be empty. Found in \"v-bind:${name}\"`);\n                }\n                if (modifiers) {\n                    if (modifiers.prop && !isDynamic) {\n                        name = camelize(name);\n                        if (name === 'innerHtml')\n                            name = 'innerHTML';\n                    }\n                    if (modifiers.camel && !isDynamic) {\n                        name = camelize(name);\n                    }\n                    if (modifiers.sync) {\n                        syncGen = genAssignmentCode(value, `$event`);\n                        if (!isDynamic) {\n                            addHandler(el, `update:${camelize(name)}`, syncGen, null, false, warn$1, list[i]);\n                            if (hyphenate(name) !== camelize(name)) {\n                                addHandler(el, `update:${hyphenate(name)}`, syncGen, null, false, warn$1, list[i]);\n                            }\n                        }\n                        else {\n                            // handler w/ dynamic event name\n                            addHandler(el, `\"update:\"+(${name})`, syncGen, null, false, warn$1, list[i], true // dynamic\n                            );\n                        }\n                    }\n                }\n                if ((modifiers && modifiers.prop) ||\n                    (!el.component && platformMustUseProp(el.tag, el.attrsMap.type, name))) {\n                    addProp(el, name, value, list[i], isDynamic);\n                }\n                else {\n                    addAttr(el, name, value, list[i], isDynamic);\n                }\n            }\n            else if (onRE.test(name)) {\n                // v-on\n                name = name.replace(onRE, '');\n                isDynamic = dynamicArgRE.test(name);\n                if (isDynamic) {\n                    name = name.slice(1, -1);\n                }\n                addHandler(el, name, value, modifiers, false, warn$1, list[i], isDynamic);\n            }\n            else {\n                // normal directives\n                name = name.replace(dirRE, '');\n                // parse arg\n                const argMatch = name.match(argRE);\n                let arg = argMatch && argMatch[1];\n                isDynamic = false;\n                if (arg) {\n                    name = name.slice(0, -(arg.length + 1));\n                    if (dynamicArgRE.test(arg)) {\n                        arg = arg.slice(1, -1);\n                        isDynamic = true;\n                    }\n                }\n                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n                if (process.env.NODE_ENV !== 'production' && name === 'model') {\n                    checkForAliasModel(el, value);\n                }\n            }\n        }\n        else {\n            // literal attribute\n            if (process.env.NODE_ENV !== 'production') {\n                const res = parseText(value, delimiters);\n                if (res) {\n                    warn$1(`${name}=\"${value}\": ` +\n                        'Interpolation inside attributes has been removed. ' +\n                        'Use v-bind or the colon shorthand instead. For example, ' +\n                        'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n                }\n            }\n            addAttr(el, name, JSON.stringify(value), list[i]);\n            // #6887 firefox doesn't update muted state if set via attribute\n            // even immediately after element creation\n            if (!el.component &&\n                name === 'muted' &&\n                platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n                addProp(el, name, 'true', list[i]);\n            }\n        }\n    }\n}\nfunction checkInFor(el) {\n    let parent = el;\n    while (parent) {\n        if (parent.for !== undefined) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction parseModifiers(name) {\n    const match = name.match(modifierRE);\n    if (match) {\n        const ret = {};\n        match.forEach(m => {\n            ret[m.slice(1)] = true;\n        });\n        return ret;\n    }\n}\nfunction makeAttrsMap(attrs) {\n    const map = {};\n    for (let i = 0, l = attrs.length; i < l; i++) {\n        if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n            warn$1('duplicate attribute: ' + attrs[i].name, attrs[i]);\n        }\n        map[attrs[i].name] = attrs[i].value;\n    }\n    return map;\n}\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n}\nfunction isForbiddenTag(el) {\n    return (el.tag === 'style' ||\n        (el.tag === 'script' &&\n            (!el.attrsMap.type || el.attrsMap.type === 'text/javascript')));\n}\nconst ieNSBug = /^xmlns:NS\\d+/;\nconst ieNSPrefix = /^NS\\d+:/;\n/* istanbul ignore next */\nfunction guardIESVGBug(attrs) {\n    const res = [];\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (!ieNSBug.test(attr.name)) {\n            attr.name = attr.name.replace(ieNSPrefix, '');\n            res.push(attr);\n        }\n    }\n    return res;\n}\nfunction checkForAliasModel(el, value) {\n    let _el = el;\n    while (_el) {\n        if (_el.for && _el.alias === value) {\n            warn$1(`<${el.tag} v-model=\"${value}\">: ` +\n                `You are binding v-model directly to a v-for iteration alias. ` +\n                `This will not be able to modify the v-for source array because ` +\n                `writing to the alias is like modifying a function local variable. ` +\n                `Consider using an array of objects and use v-model on an object property instead.`, el.rawAttrsMap['v-model']);\n        }\n        _el = _el.parent;\n    }\n}\n\n/**\n * Expand input[v-model] with dynamic type bindings into v-if-else chains\n * Turn this:\n *   <input v-model=\"data[type]\" :type=\"type\">\n * into this:\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\n */\nfunction preTransformNode(el, options) {\n    if (el.tag === 'input') {\n        const map = el.attrsMap;\n        if (!map['v-model']) {\n            return;\n        }\n        let typeBinding;\n        if (map[':type'] || map['v-bind:type']) {\n            typeBinding = getBindingAttr(el, 'type');\n        }\n        if (!map.type && !typeBinding && map['v-bind']) {\n            typeBinding = `(${map['v-bind']}).type`;\n        }\n        if (typeBinding) {\n            const ifCondition = getAndRemoveAttr(el, 'v-if', true);\n            const ifConditionExtra = ifCondition ? `&&(${ifCondition})` : ``;\n            const hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n            const elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n            // 1. checkbox\n            const branch0 = cloneASTElement(el);\n            // process for on the main node\n            processFor(branch0);\n            addRawAttr(branch0, 'type', 'checkbox');\n            processElement(branch0, options);\n            branch0.processed = true; // prevent it from double-processed\n            branch0.if = `(${typeBinding})==='checkbox'` + ifConditionExtra;\n            addIfCondition(branch0, {\n                exp: branch0.if,\n                block: branch0\n            });\n            // 2. add radio else-if condition\n            const branch1 = cloneASTElement(el);\n            getAndRemoveAttr(branch1, 'v-for', true);\n            addRawAttr(branch1, 'type', 'radio');\n            processElement(branch1, options);\n            addIfCondition(branch0, {\n                exp: `(${typeBinding})==='radio'` + ifConditionExtra,\n                block: branch1\n            });\n            // 3. other\n            const branch2 = cloneASTElement(el);\n            getAndRemoveAttr(branch2, 'v-for', true);\n            addRawAttr(branch2, ':type', typeBinding);\n            processElement(branch2, options);\n            addIfCondition(branch0, {\n                exp: ifCondition,\n                block: branch2\n            });\n            if (hasElse) {\n                branch0.else = true;\n            }\n            else if (elseIfCondition) {\n                branch0.elseif = elseIfCondition;\n            }\n            return branch0;\n        }\n    }\n}\nfunction cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n}\nvar model$1 = {\n    preTransformNode\n};\n\nvar modules = [klass, style, model$1];\n\nlet warn;\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nconst RANGE_TOKEN = '__r';\nfunction model(el, dir, _warn) {\n    warn = _warn;\n    const value = dir.value;\n    const modifiers = dir.modifiers;\n    const tag = el.tag;\n    const type = el.attrsMap.type;\n    if (process.env.NODE_ENV !== 'production') {\n        // inputs with type=\"file\" are read only and setting the input's\n        // value will throw an error.\n        if (tag === 'input' && type === 'file') {\n            warn(`<${el.tag} v-model=\"${value}\" type=\"file\">:\\n` +\n                `File inputs are read only. Use a v-on:change listener instead.`, el.rawAttrsMap['v-model']);\n        }\n    }\n    if (el.component) {\n        genComponentModel(el, value, modifiers);\n        // component v-model doesn't need extra runtime\n        return false;\n    }\n    else if (tag === 'select') {\n        genSelect(el, value, modifiers);\n    }\n    else if (tag === 'input' && type === 'checkbox') {\n        genCheckboxModel(el, value, modifiers);\n    }\n    else if (tag === 'input' && type === 'radio') {\n        genRadioModel(el, value, modifiers);\n    }\n    else if (tag === 'input' || tag === 'textarea') {\n        genDefaultModel(el, value, modifiers);\n    }\n    else {\n        genComponentModel(el, value, modifiers);\n        // component v-model doesn't need extra runtime\n        return false;\n    }\n    // ensure runtime directive metadata\n    return true;\n}\nfunction genCheckboxModel(el, value, modifiers) {\n    const number = modifiers && modifiers.number;\n    const valueBinding = getBindingAttr(el, 'value') || 'null';\n    const trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    const falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', `Array.isArray(${value})` +\n        `?_i(${value},${valueBinding})>-1` +\n        (trueValueBinding === 'true'\n            ? `:(${value})`\n            : `:_q(${value},${trueValueBinding})`));\n    addHandler(el, 'change', `var $$a=${value},` +\n        '$$el=$event.target,' +\n        `$$c=$$el.checked?(${trueValueBinding}):(${falseValueBinding});` +\n        'if(Array.isArray($$a)){' +\n        `var $$v=${number ? '_n(' + valueBinding + ')' : valueBinding},` +\n        '$$i=_i($$a,$$v);' +\n        `if($$el.checked){$$i<0&&(${genAssignmentCode(value, '$$a.concat([$$v])')})}` +\n        `else{$$i>-1&&(${genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')})}` +\n        `}else{${genAssignmentCode(value, '$$c')}}`, null, true);\n}\nfunction genRadioModel(el, value, modifiers) {\n    const number = modifiers && modifiers.number;\n    let valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? `_n(${valueBinding})` : valueBinding;\n    addProp(el, 'checked', `_q(${value},${valueBinding})`);\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\nfunction genSelect(el, value, modifiers) {\n    const number = modifiers && modifiers.number;\n    const selectedVal = `Array.prototype.filter` +\n        `.call($event.target.options,function(o){return o.selected})` +\n        `.map(function(o){var val = \"_value\" in o ? o._value : o.value;` +\n        `return ${number ? '_n(val)' : 'val'}})`;\n    const assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    let code = `var $$selectedVal = ${selectedVal};`;\n    code = `${code} ${genAssignmentCode(value, assignment)}`;\n    addHandler(el, 'change', code, null, true);\n}\nfunction genDefaultModel(el, value, modifiers) {\n    const type = el.attrsMap.type;\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    if (process.env.NODE_ENV !== 'production') {\n        const value = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n        const typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n        if (value && !typeBinding) {\n            const binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n            warn(`${binding}=\"${value}\" conflicts with v-model on the same element ` +\n                'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n        }\n    }\n    const { lazy, number, trim } = modifiers || {};\n    const needCompositionGuard = !lazy && type !== 'range';\n    const event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n    let valueExpression = '$event.target.value';\n    if (trim) {\n        valueExpression = `$event.target.value.trim()`;\n    }\n    if (number) {\n        valueExpression = `_n(${valueExpression})`;\n    }\n    let code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n        code = `if($event.target.composing)return;${code}`;\n    }\n    addProp(el, 'value', `(${value})`);\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n        addHandler(el, 'blur', '$forceUpdate()');\n    }\n}\n\nfunction text(el, dir) {\n    if (dir.value) {\n        addProp(el, 'textContent', `_s(${dir.value})`, dir);\n    }\n}\n\nfunction html(el, dir) {\n    if (dir.value) {\n        addProp(el, 'innerHTML', `_s(${dir.value})`, dir);\n    }\n}\n\nvar directives = {\n    model,\n    text,\n    html\n};\n\nconst baseOptions = {\n    expectHTML: true,\n    modules,\n    directives,\n    isPreTag,\n    isUnaryTag,\n    mustUseProp,\n    canBeLeftOpenTag,\n    isReservedTag,\n    getTagNamespace,\n    staticKeys: genStaticKeys$1(modules)\n};\n\nlet isStaticKey;\nlet isPlatformReservedTag$1;\nconst genStaticKeysCached = cached(genStaticKeys);\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize$1(root, options) {\n    if (!root)\n        return;\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag$1 = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n}\nfunction genStaticKeys(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n        (keys ? ',' + keys : ''));\n}\nfunction markStatic(node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n        // do not make component slot content static. this avoids\n        // 1. components not able to mutate slot nodes\n        // 2. static slot content fails for hot-reloading\n        if (!isPlatformReservedTag$1(node.tag) &&\n            node.tag !== 'slot' &&\n            node.attrsMap['inline-template'] == null) {\n            return;\n        }\n        for (let i = 0, l = node.children.length; i < l; i++) {\n            const child = node.children[i];\n            markStatic(child);\n            if (!child.static) {\n                node.static = false;\n            }\n        }\n        if (node.ifConditions) {\n            for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n                const block = node.ifConditions[i].block;\n                markStatic(block);\n                if (!block.static) {\n                    node.static = false;\n                }\n            }\n        }\n    }\n}\nfunction markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n        if (node.static || node.once) {\n            node.staticInFor = isInFor;\n        }\n        // For a node to qualify as a static root, it should have children that\n        // are not just static text. Otherwise the cost of hoisting out will\n        // outweigh the benefits and it's better off to just always render it fresh.\n        if (node.static &&\n            node.children.length &&\n            !(node.children.length === 1 && node.children[0].type === 3)) {\n            node.staticRoot = true;\n            return;\n        }\n        else {\n            node.staticRoot = false;\n        }\n        if (node.children) {\n            for (let i = 0, l = node.children.length; i < l; i++) {\n                markStaticRoots(node.children[i], isInFor || !!node.for);\n            }\n        }\n        if (node.ifConditions) {\n            for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n                markStaticRoots(node.ifConditions[i].block, isInFor);\n            }\n        }\n    }\n}\nfunction isStatic(node) {\n    if (node.type === 2) {\n        // expression\n        return false;\n    }\n    if (node.type === 3) {\n        // text\n        return true;\n    }\n    return !!(node.pre ||\n        (!node.hasBindings && // no dynamic bindings\n            !node.if &&\n            !node.for && // not v-if or v-for or v-else\n            !isBuiltInTag(node.tag) && // not a built-in\n            isPlatformReservedTag$1(node.tag) && // not a component\n            !isDirectChildOfTemplateFor(node) &&\n            Object.keys(node).every(isStaticKey)));\n}\nfunction isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n        node = node.parent;\n        if (node.tag !== 'template') {\n            return false;\n        }\n        if (node.for) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\nconst fnInvokeRE = /\\([^)]*?\\);*$/;\nconst simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n// KeyboardEvent.keyCode aliases\nconst keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    delete: [8, 46]\n};\n// KeyboardEvent.key aliases\nconst keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    delete: ['Backspace', 'Delete', 'Del']\n};\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nconst genGuard = condition => `if(${condition})return null;`;\nconst modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(`$event.target !== $event.currentTarget`),\n    ctrl: genGuard(`!$event.ctrlKey`),\n    shift: genGuard(`!$event.shiftKey`),\n    alt: genGuard(`!$event.altKey`),\n    meta: genGuard(`!$event.metaKey`),\n    left: genGuard(`'button' in $event && $event.button !== 0`),\n    middle: genGuard(`'button' in $event && $event.button !== 1`),\n    right: genGuard(`'button' in $event && $event.button !== 2`)\n};\nfunction genHandlers(events, isNative) {\n    const prefix = isNative ? 'nativeOn:' : 'on:';\n    let staticHandlers = ``;\n    let dynamicHandlers = ``;\n    for (const name in events) {\n        const handlerCode = genHandler(events[name]);\n        //@ts-expect-error\n        if (events[name] && events[name].dynamic) {\n            dynamicHandlers += `${name},${handlerCode},`;\n        }\n        else {\n            staticHandlers += `\"${name}\":${handlerCode},`;\n        }\n    }\n    staticHandlers = `{${staticHandlers.slice(0, -1)}}`;\n    if (dynamicHandlers) {\n        return prefix + `_d(${staticHandlers},[${dynamicHandlers.slice(0, -1)}])`;\n    }\n    else {\n        return prefix + staticHandlers;\n    }\n}\nfunction genHandler(handler) {\n    if (!handler) {\n        return 'function(){}';\n    }\n    if (Array.isArray(handler)) {\n        return `[${handler.map(handler => genHandler(handler)).join(',')}]`;\n    }\n    const isMethodPath = simplePathRE.test(handler.value);\n    const isFunctionExpression = fnExpRE.test(handler.value);\n    const isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n    if (!handler.modifiers) {\n        if (isMethodPath || isFunctionExpression) {\n            return handler.value;\n        }\n        return `function($event){${isFunctionInvocation ? `return ${handler.value}` : handler.value}}`; // inline statement\n    }\n    else {\n        let code = '';\n        let genModifierCode = '';\n        const keys = [];\n        for (const key in handler.modifiers) {\n            if (modifierCode[key]) {\n                genModifierCode += modifierCode[key];\n                // left/right\n                if (keyCodes[key]) {\n                    keys.push(key);\n                }\n            }\n            else if (key === 'exact') {\n                const modifiers = handler.modifiers;\n                genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta']\n                    .filter(keyModifier => !modifiers[keyModifier])\n                    .map(keyModifier => `$event.${keyModifier}Key`)\n                    .join('||'));\n            }\n            else {\n                keys.push(key);\n            }\n        }\n        if (keys.length) {\n            code += genKeyFilter(keys);\n        }\n        // Make sure modifiers like prevent and stop get executed after key filtering\n        if (genModifierCode) {\n            code += genModifierCode;\n        }\n        const handlerCode = isMethodPath\n            ? `return ${handler.value}.apply(null, arguments)`\n            : isFunctionExpression\n                ? `return (${handler.value}).apply(null, arguments)`\n                : isFunctionInvocation\n                    ? `return ${handler.value}`\n                    : handler.value;\n        return `function($event){${code}${handlerCode}}`;\n    }\n}\nfunction genKeyFilter(keys) {\n    return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    `if(!$event.type.indexOf('key')&&` +\n        `${keys.map(genFilterCode).join('&&')})return null;`);\n}\nfunction genFilterCode(key) {\n    const keyVal = parseInt(key, 10);\n    if (keyVal) {\n        return `$event.keyCode!==${keyVal}`;\n    }\n    const keyCode = keyCodes[key];\n    const keyName = keyNames[key];\n    return (`_k($event.keyCode,` +\n        `${JSON.stringify(key)},` +\n        `${JSON.stringify(keyCode)},` +\n        `$event.key,` +\n        `${JSON.stringify(keyName)}` +\n        `)`);\n}\n\nfunction on(el, dir) {\n    if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n        warn$2(`v-on without argument does not support modifiers.`);\n    }\n    el.wrapListeners = (code) => `_g(${code},${dir.value})`;\n}\n\nfunction bind(el, dir) {\n    el.wrapData = (code) => {\n        return `_b(${code},'${el.tag}',${dir.value},${dir.modifiers && dir.modifiers.prop ? 'true' : 'false'}${dir.modifiers && dir.modifiers.sync ? ',true' : ''})`;\n    };\n}\n\nvar baseDirectives = {\n    on,\n    bind,\n    cloak: noop\n};\n\nclass CodegenState {\n    constructor(options) {\n        this.options = options;\n        this.warn = options.warn || baseWarn;\n        this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n        this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n        this.directives = extend(extend({}, baseDirectives), options.directives);\n        const isReservedTag = options.isReservedTag || no;\n        this.maybeComponent = (el) => !!el.component || !isReservedTag(el.tag);\n        this.onceId = 0;\n        this.staticRenderFns = [];\n        this.pre = false;\n    }\n}\nfunction generate$1(ast, options) {\n    const state = new CodegenState(options);\n    // fix #11483, Root level <script> tags should not be rendered.\n    const code = ast\n        ? ast.tag === 'script'\n            ? 'null'\n            : genElement(ast, state)\n        : '_c(\"div\")';\n    return {\n        render: `with(this){return ${code}}`,\n        staticRenderFns: state.staticRenderFns\n    };\n}\nfunction genElement(el, state) {\n    if (el.parent) {\n        el.pre = el.pre || el.parent.pre;\n    }\n    if (el.staticRoot && !el.staticProcessed) {\n        return genStatic(el, state);\n    }\n    else if (el.once && !el.onceProcessed) {\n        return genOnce(el, state);\n    }\n    else if (el.for && !el.forProcessed) {\n        return genFor(el, state);\n    }\n    else if (el.if && !el.ifProcessed) {\n        return genIf(el, state);\n    }\n    else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n        return genChildren(el, state) || 'void 0';\n    }\n    else if (el.tag === 'slot') {\n        return genSlot(el, state);\n    }\n    else {\n        // component or element\n        let code;\n        if (el.component) {\n            code = genComponent(el.component, el, state);\n        }\n        else {\n            let data;\n            const maybeComponent = state.maybeComponent(el);\n            if (!el.plain || (el.pre && maybeComponent)) {\n                data = genData(el, state);\n            }\n            let tag;\n            // check if this is a component in <script setup>\n            const bindings = state.options.bindings;\n            if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {\n                tag = checkBindingType(bindings, el.tag);\n            }\n            if (!tag)\n                tag = `'${el.tag}'`;\n            const children = el.inlineTemplate ? null : genChildren(el, state, true);\n            code = `_c(${tag}${data ? `,${data}` : '' // data\n            }${children ? `,${children}` : '' // children\n            })`;\n        }\n        // module transforms\n        for (let i = 0; i < state.transforms.length; i++) {\n            code = state.transforms[i](el, code);\n        }\n        return code;\n    }\n}\nfunction checkBindingType(bindings, key) {\n    const camelName = camelize(key);\n    const PascalName = capitalize(camelName);\n    const checkType = (type) => {\n        if (bindings[key] === type) {\n            return key;\n        }\n        if (bindings[camelName] === type) {\n            return camelName;\n        }\n        if (bindings[PascalName] === type) {\n            return PascalName;\n        }\n    };\n    const fromConst = checkType(\"setup-const\" /* BindingTypes.SETUP_CONST */) ||\n        checkType(\"setup-reactive-const\" /* BindingTypes.SETUP_REACTIVE_CONST */);\n    if (fromConst) {\n        return fromConst;\n    }\n    const fromMaybeRef = checkType(\"setup-let\" /* BindingTypes.SETUP_LET */) ||\n        checkType(\"setup-ref\" /* BindingTypes.SETUP_REF */) ||\n        checkType(\"setup-maybe-ref\" /* BindingTypes.SETUP_MAYBE_REF */);\n    if (fromMaybeRef) {\n        return fromMaybeRef;\n    }\n}\n// hoist static sub-trees out\nfunction genStatic(el, state) {\n    el.staticProcessed = true;\n    // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n    const originalPreState = state.pre;\n    if (el.pre) {\n        state.pre = el.pre;\n    }\n    state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`);\n    state.pre = originalPreState;\n    return `_m(${state.staticRenderFns.length - 1}${el.staticInFor ? ',true' : ''})`;\n}\n// v-once\nfunction genOnce(el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n        return genIf(el, state);\n    }\n    else if (el.staticInFor) {\n        let key = '';\n        let parent = el.parent;\n        while (parent) {\n            if (parent.for) {\n                key = parent.key;\n                break;\n            }\n            parent = parent.parent;\n        }\n        if (!key) {\n            process.env.NODE_ENV !== 'production' &&\n                state.warn(`v-once can only be used inside v-for that is keyed. `, el.rawAttrsMap['v-once']);\n            return genElement(el, state);\n        }\n        return `_o(${genElement(el, state)},${state.onceId++},${key})`;\n    }\n    else {\n        return genStatic(el, state);\n    }\n}\nfunction genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n}\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n        return altEmpty || '_e()';\n    }\n    const condition = conditions.shift();\n    if (condition.exp) {\n        return `(${condition.exp})?${genTernaryExp(condition.block)}:${genIfConditions(conditions, state, altGen, altEmpty)}`;\n    }\n    else {\n        return `${genTernaryExp(condition.block)}`;\n    }\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp(el) {\n        return altGen\n            ? altGen(el, state)\n            : el.once\n                ? genOnce(el, state)\n                : genElement(el, state);\n    }\n}\nfunction genFor(el, state, altGen, altHelper) {\n    const exp = el.for;\n    const alias = el.alias;\n    const iterator1 = el.iterator1 ? `,${el.iterator1}` : '';\n    const iterator2 = el.iterator2 ? `,${el.iterator2}` : '';\n    if (process.env.NODE_ENV !== 'production' &&\n        state.maybeComponent(el) &&\n        el.tag !== 'slot' &&\n        el.tag !== 'template' &&\n        !el.key) {\n        state.warn(`<${el.tag} v-for=\"${alias} in ${exp}\">: component lists rendered with ` +\n            `v-for should have explicit keys. ` +\n            `See https://v2.vuejs.org/v2/guide/list.html#key for more info.`, el.rawAttrsMap['v-for'], true /* tip */);\n    }\n    el.forProcessed = true; // avoid recursion\n    return (`${altHelper || '_l'}((${exp}),` +\n        `function(${alias}${iterator1}${iterator2}){` +\n        `return ${(altGen || genElement)(el, state)}` +\n        '})');\n}\nfunction genData(el, state) {\n    let data = '{';\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    const dirs = genDirectives(el, state);\n    if (dirs)\n        data += dirs + ',';\n    // key\n    if (el.key) {\n        data += `key:${el.key},`;\n    }\n    // ref\n    if (el.ref) {\n        data += `ref:${el.ref},`;\n    }\n    if (el.refInFor) {\n        data += `refInFor:true,`;\n    }\n    // pre\n    if (el.pre) {\n        data += `pre:true,`;\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n        data += `tag:\"${el.tag}\",`;\n    }\n    // module data generation functions\n    for (let i = 0; i < state.dataGenFns.length; i++) {\n        data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n        data += `attrs:${genProps(el.attrs)},`;\n    }\n    // DOM props\n    if (el.props) {\n        data += `domProps:${genProps(el.props)},`;\n    }\n    // event handlers\n    if (el.events) {\n        data += `${genHandlers(el.events, false)},`;\n    }\n    if (el.nativeEvents) {\n        data += `${genHandlers(el.nativeEvents, true)},`;\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n        data += `slot:${el.slotTarget},`;\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n        data += `${genScopedSlots(el, el.scopedSlots, state)},`;\n    }\n    // component v-model\n    if (el.model) {\n        data += `model:{value:${el.model.value},callback:${el.model.callback},expression:${el.model.expression}},`;\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n        const inlineTemplate = genInlineTemplate(el, state);\n        if (inlineTemplate) {\n            data += `${inlineTemplate},`;\n        }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n    if (el.dynamicAttrs) {\n        data = `_b(${data},\"${el.tag}\",${genProps(el.dynamicAttrs)})`;\n    }\n    // v-bind data wrap\n    if (el.wrapData) {\n        data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n        data = el.wrapListeners(data);\n    }\n    return data;\n}\nfunction genDirectives(el, state) {\n    const dirs = el.directives;\n    if (!dirs)\n        return;\n    let res = 'directives:[';\n    let hasRuntime = false;\n    let i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n        dir = dirs[i];\n        needRuntime = true;\n        const gen = state.directives[dir.name];\n        if (gen) {\n            // compile-time directive that manipulates AST.\n            // returns true if it also needs a runtime counterpart.\n            needRuntime = !!gen(el, dir, state.warn);\n        }\n        if (needRuntime) {\n            hasRuntime = true;\n            res += `{name:\"${dir.name}\",rawName:\"${dir.rawName}\"${dir.value\n                ? `,value:(${dir.value}),expression:${JSON.stringify(dir.value)}`\n                : ''}${dir.arg ? `,arg:${dir.isDynamicArg ? dir.arg : `\"${dir.arg}\"`}` : ''}${dir.modifiers ? `,modifiers:${JSON.stringify(dir.modifiers)}` : ''}},`;\n        }\n    }\n    if (hasRuntime) {\n        return res.slice(0, -1) + ']';\n    }\n}\nfunction genInlineTemplate(el, state) {\n    const ast = el.children[0];\n    if (process.env.NODE_ENV !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {\n        state.warn('Inline-template components must have exactly one child element.', { start: el.start });\n    }\n    if (ast && ast.type === 1) {\n        const inlineRenderFns = generate$1(ast, state.options);\n        return `inlineTemplate:{render:function(){${inlineRenderFns.render}},staticRenderFns:[${inlineRenderFns.staticRenderFns\n            .map(code => `function(){${code}}`)\n            .join(',')}]}`;\n    }\n}\nfunction genScopedSlots(el, slots, state) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    let needsForceUpdate = el.for ||\n        Object.keys(slots).some(key => {\n            const slot = slots[key];\n            return (slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n            );\n        });\n    // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n    let needsKey = !!el.if;\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n    if (!needsForceUpdate) {\n        let parent = el.parent;\n        while (parent) {\n            if ((parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n                parent.for) {\n                needsForceUpdate = true;\n                break;\n            }\n            if (parent.if) {\n                needsKey = true;\n            }\n            parent = parent.parent;\n        }\n    }\n    const generatedSlots = Object.keys(slots)\n        .map(key => genScopedSlot(slots[key], state))\n        .join(',');\n    return `scopedSlots:_u([${generatedSlots}]${needsForceUpdate ? `,null,true` : ``}${!needsForceUpdate && needsKey ? `,null,false,${hash(generatedSlots)}` : ``})`;\n}\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i) {\n        hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    return hash >>> 0;\n}\nfunction containsSlotChild(el) {\n    if (el.type === 1) {\n        if (el.tag === 'slot') {\n            return true;\n        }\n        return el.children.some(containsSlotChild);\n    }\n    return false;\n}\nfunction genScopedSlot(el, state) {\n    const isLegacySyntax = el.attrsMap['slot-scope'];\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n        return genIf(el, state, genScopedSlot, `null`);\n    }\n    if (el.for && !el.forProcessed) {\n        return genFor(el, state, genScopedSlot);\n    }\n    const slotScope = el.slotScope === emptySlotScopeToken ? `` : String(el.slotScope);\n    const fn = `function(${slotScope}){` +\n        `return ${el.tag === 'template'\n            ? el.if && isLegacySyntax\n                ? `(${el.if})?${genChildren(el, state) || 'undefined'}:undefined`\n                : genChildren(el, state) || 'undefined'\n            : genElement(el, state)}}`;\n    // reverse proxy v-slot without scope on this.$slots\n    const reverseProxy = slotScope ? `` : `,proxy:true`;\n    return `{key:${el.slotTarget || `\"default\"`},fn:${fn}${reverseProxy}}`;\n}\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    const children = el.children;\n    if (children.length) {\n        const el = children[0];\n        // optimize single v-for\n        if (children.length === 1 &&\n            el.for &&\n            el.tag !== 'template' &&\n            el.tag !== 'slot') {\n            const normalizationType = checkSkip\n                ? state.maybeComponent(el)\n                    ? `,1`\n                    : `,0`\n                : ``;\n            return `${(altGenElement || genElement)(el, state)}${normalizationType}`;\n        }\n        const normalizationType = checkSkip\n            ? getNormalizationType(children, state.maybeComponent)\n            : 0;\n        const gen = altGenNode || genNode;\n        return `[${children.map(c => gen(c, state)).join(',')}]${normalizationType ? `,${normalizationType}` : ''}`;\n    }\n}\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType(children, maybeComponent) {\n    let res = 0;\n    for (let i = 0; i < children.length; i++) {\n        const el = children[i];\n        if (el.type !== 1) {\n            continue;\n        }\n        if (needsNormalization(el) ||\n            (el.ifConditions &&\n                el.ifConditions.some(c => needsNormalization(c.block)))) {\n            res = 2;\n            break;\n        }\n        if (maybeComponent(el) ||\n            (el.ifConditions && el.ifConditions.some(c => maybeComponent(c.block)))) {\n            res = 1;\n        }\n    }\n    return res;\n}\nfunction needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\nfunction genNode(node, state) {\n    if (node.type === 1) {\n        return genElement(node, state);\n    }\n    else if (node.type === 3 && node.isComment) {\n        return genComment(node);\n    }\n    else {\n        return genText(node);\n    }\n}\nfunction genText(text) {\n    return `_v(${text.type === 2\n        ? text.expression // no need for () because already wrapped in _s()\n        : transformSpecialNewlines(JSON.stringify(text.text))})`;\n}\nfunction genComment(comment) {\n    return `_e(${JSON.stringify(comment.text)})`;\n}\nfunction genSlot(el, state) {\n    const slotName = el.slotName || '\"default\"';\n    const children = genChildren(el, state);\n    let res = `_t(${slotName}${children ? `,function(){return ${children}}` : ''}`;\n    const attrs = el.attrs || el.dynamicAttrs\n        ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(attr => ({\n            // slot props are camelized\n            name: camelize(attr.name),\n            value: attr.value,\n            dynamic: attr.dynamic\n        })))\n        : null;\n    const bind = el.attrsMap['v-bind'];\n    if ((attrs || bind) && !children) {\n        res += `,null`;\n    }\n    if (attrs) {\n        res += `,${attrs}`;\n    }\n    if (bind) {\n        res += `${attrs ? '' : ',null'},${bind}`;\n    }\n    return res + ')';\n}\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent(componentName, el, state) {\n    const children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return `_c(${componentName},${genData(el, state)}${children ? `,${children}` : ''})`;\n}\nfunction genProps(props) {\n    let staticProps = ``;\n    let dynamicProps = ``;\n    for (let i = 0; i < props.length; i++) {\n        const prop = props[i];\n        const value = transformSpecialNewlines(prop.value);\n        if (prop.dynamic) {\n            dynamicProps += `${prop.name},${value},`;\n        }\n        else {\n            staticProps += `\"${prop.name}\":${value},`;\n        }\n    }\n    staticProps = `{${staticProps.slice(0, -1)}}`;\n    if (dynamicProps) {\n        return `_d(${staticProps},[${dynamicProps.slice(0, -1)}])`;\n    }\n    else {\n        return staticProps;\n    }\n}\n// #3895, #4268\nfunction transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nconst prohibitedKeywordRE = new RegExp('\\\\b' +\n    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n        'super,throw,while,yield,delete,export,import,return,switch,default,' +\n        'extends,finally,continue,debugger,function,arguments')\n        .split(',')\n        .join('\\\\b|\\\\b') +\n    '\\\\b');\n// these unary operators should not be used as property/method names\nconst unaryOperatorsRE = new RegExp('\\\\b' +\n    'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') +\n    '\\\\s*\\\\([^\\\\)]*\\\\)');\n// strip strings in expressions\nconst stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n// detect problematic expressions in a template\nfunction detectErrors(ast, warn) {\n    if (ast) {\n        checkNode(ast, warn);\n    }\n}\nfunction checkNode(node, warn) {\n    if (node.type === 1) {\n        for (const name in node.attrsMap) {\n            if (dirRE.test(name)) {\n                const value = node.attrsMap[name];\n                if (value) {\n                    const range = node.rawAttrsMap[name];\n                    if (name === 'v-for') {\n                        checkFor(node, `v-for=\"${value}\"`, warn, range);\n                    }\n                    else if (name === 'v-slot' || name[0] === '#') {\n                        checkFunctionParameterExpression(value, `${name}=\"${value}\"`, warn, range);\n                    }\n                    else if (onRE.test(name)) {\n                        checkEvent(value, `${name}=\"${value}\"`, warn, range);\n                    }\n                    else {\n                        checkExpression(value, `${name}=\"${value}\"`, warn, range);\n                    }\n                }\n            }\n        }\n        if (node.children) {\n            for (let i = 0; i < node.children.length; i++) {\n                checkNode(node.children[i], warn);\n            }\n        }\n    }\n    else if (node.type === 2) {\n        checkExpression(node.expression, node.text, warn, node);\n    }\n}\nfunction checkEvent(exp, text, warn, range) {\n    const stripped = exp.replace(stripStringRE, '');\n    const keywordMatch = stripped.match(unaryOperatorsRE);\n    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n        warn(`avoid using JavaScript unary operator as property name: ` +\n            `\"${keywordMatch[0]}\" in expression ${text.trim()}`, range);\n    }\n    checkExpression(exp, text, warn, range);\n}\nfunction checkFor(node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\nfunction checkIdentifier(ident, type, text, warn, range) {\n    if (typeof ident === 'string') {\n        try {\n            new Function(`var ${ident}=_`);\n        }\n        catch (e) {\n            warn(`invalid ${type} \"${ident}\" in expression: ${text.trim()}`, range);\n        }\n    }\n}\nfunction checkExpression(exp, text, warn, range) {\n    try {\n        new Function(`return ${exp}`);\n    }\n    catch (e) {\n        const keywordMatch = exp\n            .replace(stripStringRE, '')\n            .match(prohibitedKeywordRE);\n        if (keywordMatch) {\n            warn(`avoid using JavaScript keyword as property name: ` +\n                `\"${keywordMatch[0]}\"\\n  Raw expression: ${text.trim()}`, range);\n        }\n        else {\n            warn(`invalid expression: ${e.message} in\\n\\n` +\n                `    ${exp}\\n\\n` +\n                `  Raw expression: ${text.trim()}\\n`, range);\n        }\n    }\n}\nfunction checkFunctionParameterExpression(exp, text, warn, range) {\n    try {\n        new Function(exp, '');\n    }\n    catch (e) {\n        warn(`invalid function parameter expression: ${e.message} in\\n\\n` +\n            `    ${exp}\\n\\n` +\n            `  Raw expression: ${text.trim()}\\n`, range);\n    }\n}\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    const lines = source.split(/\\r?\\n/);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count += lines[i].length + 1;\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                res.push(`${j + 1}${repeat(` `, 3 - String(j + 1).length)}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - lineLength) + 1;\n                    const length = end > count ? lineLength - pad : end - start;\n                    res.push(`   |  ` + repeat(` `, pad) + repeat(`^`, length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.min(end - count, lineLength);\n                        res.push(`   |  ` + repeat(`^`, length));\n                    }\n                    count += lineLength + 1;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\nfunction repeat(str, n) {\n    let result = '';\n    if (n > 0) {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // eslint-disable-line\n            if (n & 1)\n                result += str;\n            n >>>= 1;\n            if (n <= 0)\n                break;\n            str += str;\n        }\n    }\n    return result;\n}\n\nfunction createFunction(code, errors) {\n    try {\n        return new Function(code);\n    }\n    catch (err) {\n        errors.push({ err, code });\n        return noop;\n    }\n}\nfunction createCompileToFunctionFn(compile) {\n    const cache = Object.create(null);\n    return function compileToFunctions(template, options, vm) {\n        options = extend({}, options);\n        const warn = options.warn || warn$2;\n        delete options.warn;\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n            // detect possible CSP restriction\n            try {\n                new Function('return 1');\n            }\n            catch (e) {\n                if (e.toString().match(/unsafe-eval|CSP/)) {\n                    warn('It seems you are using the standalone build of Vue.js in an ' +\n                        'environment with Content Security Policy that prohibits unsafe-eval. ' +\n                        'The template compiler cannot work in this environment. Consider ' +\n                        'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n                        'templates into render functions.');\n                }\n            }\n        }\n        // check cache\n        const key = options.delimiters\n            ? String(options.delimiters) + template\n            : template;\n        if (cache[key]) {\n            return cache[key];\n        }\n        // compile\n        const compiled = compile(template, options);\n        // check compilation errors/tips\n        if (process.env.NODE_ENV !== 'production') {\n            if (compiled.errors && compiled.errors.length) {\n                if (options.outputSourceRange) {\n                    compiled.errors.forEach(e => {\n                        warn(`Error compiling template:\\n\\n${e.msg}\\n\\n` +\n                            generateCodeFrame(template, e.start, e.end), vm);\n                    });\n                }\n                else {\n                    warn(`Error compiling template:\\n\\n${template}\\n\\n` +\n                        compiled.errors.map(e => `- ${e}`).join('\\n') +\n                        '\\n', vm);\n                }\n            }\n            if (compiled.tips && compiled.tips.length) {\n                if (options.outputSourceRange) {\n                    compiled.tips.forEach(e => tip(e.msg, vm));\n                }\n                else {\n                    compiled.tips.forEach(msg => tip(msg, vm));\n                }\n            }\n        }\n        // turn code into functions\n        const res = {};\n        const fnGenErrors = [];\n        res.render = createFunction(compiled.render, fnGenErrors);\n        res.staticRenderFns = compiled.staticRenderFns.map(code => {\n            return createFunction(code, fnGenErrors);\n        });\n        // check function generation errors.\n        // this should only happen if there is a bug in the compiler itself.\n        // mostly for codegen development use\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n            if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n                warn(`Failed to generate render function:\\n\\n` +\n                    fnGenErrors\n                        .map(({ err, code }) => `${err.toString()} in\\n\\n${code}\\n`)\n                        .join('\\n'), vm);\n            }\n        }\n        return (cache[key] = res);\n    };\n}\n\nfunction createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n        function compile(template, options) {\n            const finalOptions = Object.create(baseOptions);\n            const errors = [];\n            const tips = [];\n            let warn = (msg, range, tip) => {\n                (tip ? tips : errors).push(msg);\n            };\n            if (options) {\n                if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {\n                    // $flow-disable-line\n                    const leadingSpaceLength = template.match(/^\\s*/)[0].length;\n                    warn = (msg, range, tip) => {\n                        const data = typeof msg === 'string' ? { msg } : msg;\n                        if (range) {\n                            if (range.start != null) {\n                                data.start = range.start + leadingSpaceLength;\n                            }\n                            if (range.end != null) {\n                                data.end = range.end + leadingSpaceLength;\n                            }\n                        }\n                        (tip ? tips : errors).push(data);\n                    };\n                }\n                // merge custom modules\n                if (options.modules) {\n                    finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n                }\n                // merge custom directives\n                if (options.directives) {\n                    finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n                }\n                // copy other options\n                for (const key in options) {\n                    if (key !== 'modules' && key !== 'directives') {\n                        finalOptions[key] = options[key];\n                    }\n                }\n            }\n            finalOptions.warn = warn;\n            const compiled = baseCompile(template.trim(), finalOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                detectErrors(compiled.ast, warn);\n            }\n            compiled.errors = errors;\n            compiled.tips = tips;\n            return compiled;\n        }\n        return {\n            compile,\n            compileToFunctions: createCompileToFunctionFn(compile)\n        };\n    };\n}\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nconst createCompiler$1 = createCompilerCreator(function baseCompile(template, options) {\n    const ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n        optimize$1(ast, options);\n    }\n    const code = generate$1(ast, options);\n    return {\n        ast,\n        render: code.render,\n        staticRenderFns: code.staticRenderFns\n    };\n});\n\nconst { compile: compile$1, compileToFunctions: compileToFunctions$1 } = createCompiler$1(baseOptions);\n\nconst isAttr = makeMap('accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +\n    'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +\n    'checked,cite,class,code,codebase,color,cols,colspan,content,' +\n    'contenteditable,contextmenu,controls,coords,data,datetime,default,' +\n    'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,for,' +\n    'form,formaction,headers,height,hidden,high,href,hreflang,http-equiv,' +\n    'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +\n    'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +\n    'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +\n    'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +\n    'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +\n    'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +\n    'target,title,usemap,value,width,wrap');\n/* istanbul ignore next */\nconst isRenderableAttr = (name) => {\n    return (isAttr(name) || name.indexOf('data-') === 0 || name.indexOf('aria-') === 0);\n};\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\nconst ESC = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '&': '&amp;'\n};\nfunction escape(s) {\n    return s.replace(/[<>\"&]/g, escapeChar);\n}\nfunction escapeChar(a) {\n    return ESC[a] || a;\n}\n\nconst plainStringRE = /^\"(?:[^\"\\\\]|\\\\.)*\"$|^'(?:[^'\\\\]|\\\\.)*'$/;\n// let the model AST transform translate v-model into appropriate\n// props bindings\nfunction applyModelTransform(el, state) {\n    if (el.directives) {\n        for (let i = 0; i < el.directives.length; i++) {\n            const dir = el.directives[i];\n            if (dir.name === 'model') {\n                state.directives.model(el, dir, state.warn);\n                // remove value for textarea as its converted to text\n                if (el.tag === 'textarea' && el.props) {\n                    el.props = el.props.filter(p => p.name !== 'value');\n                }\n                break;\n            }\n        }\n    }\n}\nfunction genAttrSegments(attrs) {\n    return attrs.map(({ name, value }) => genAttrSegment(name, value));\n}\nfunction genDOMPropSegments(props, attrs) {\n    const segments = [];\n    props.forEach(({ name, value }) => {\n        name = propsToAttrMap[name] || name.toLowerCase();\n        if (isRenderableAttr(name) &&\n            !(attrs && attrs.some(a => a.name === name))) {\n            segments.push(genAttrSegment(name, value));\n        }\n    });\n    return segments;\n}\nfunction genAttrSegment(name, value) {\n    if (plainStringRE.test(value)) {\n        // force double quote\n        value = value.replace(/^'|'$/g, '\"');\n        // force enumerated attr to \"true\"\n        if (isEnumeratedAttr(name) && value !== `\"false\"`) {\n            value = `\"true\"`;\n        }\n        return {\n            type: RAW,\n            value: isBooleanAttr(name)\n                ? ` ${name}=\"${name}\"`\n                : value === '\"\"'\n                    ? ` ${name}`\n                    : ` ${name}=\"${JSON.parse(value)}\"`\n        };\n    }\n    else {\n        return {\n            type: EXPRESSION,\n            value: `_ssrAttr(${JSON.stringify(name)},${value})`\n        };\n    }\n}\nfunction genClassSegments(staticClass, classBinding) {\n    if (staticClass && !classBinding) {\n        return [{ type: RAW, value: ` class=\"${JSON.parse(staticClass)}\"` }];\n    }\n    else {\n        return [\n            {\n                type: EXPRESSION,\n                value: `_ssrClass(${staticClass || 'null'},${classBinding || 'null'})`\n            }\n        ];\n    }\n}\nfunction genStyleSegments(staticStyle, parsedStaticStyle, styleBinding, vShowExpression) {\n    if (staticStyle && !styleBinding && !vShowExpression) {\n        return [{ type: RAW, value: ` style=${JSON.stringify(staticStyle)}` }];\n    }\n    else {\n        return [\n            {\n                type: EXPRESSION,\n                value: `_ssrStyle(${parsedStaticStyle || 'null'},${styleBinding || 'null'}, ${vShowExpression\n                    ? `{ display: (${vShowExpression}) ? '' : 'none' }`\n                    : 'null'})`\n            }\n        ];\n    }\n}\n\n/**\n * In SSR, the vdom tree is generated only once and never patched, so\n * we can optimize most element / trees into plain string render functions.\n * The SSR optimizer walks the AST tree to detect optimizable elements and trees.\n *\n * The criteria for SSR optimizability is quite a bit looser than static tree\n * detection (which is designed for client re-render). In SSR we bail only for\n * components/slots/custom directives.\n */\n// optimizability constants\nconst optimizability = {\n    FALSE: 0,\n    FULL: 1,\n    SELF: 2,\n    CHILDREN: 3,\n    PARTIAL: 4 // self un-optimizable with some un-optimizable children\n};\nlet isPlatformReservedTag;\nfunction optimize(root, options) {\n    if (!root)\n        return;\n    isPlatformReservedTag = options.isReservedTag || no;\n    walk(root, true);\n}\nfunction walk(node, isRoot) {\n    if (isUnOptimizableTree(node)) {\n        node.ssrOptimizability = optimizability.FALSE;\n        return;\n    }\n    // root node or nodes with custom directives should always be a VNode\n    const selfUnoptimizable = isRoot || hasCustomDirective(node);\n    const check = child => {\n        if (child.ssrOptimizability !== optimizability.FULL) {\n            node.ssrOptimizability = selfUnoptimizable\n                ? optimizability.PARTIAL\n                : optimizability.SELF;\n        }\n    };\n    if (selfUnoptimizable) {\n        node.ssrOptimizability = optimizability.CHILDREN;\n    }\n    if (node.type === 1) {\n        for (let i = 0, l = node.children.length; i < l; i++) {\n            const child = node.children[i];\n            walk(child);\n            check(child);\n        }\n        if (node.ifConditions) {\n            for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n                const block = node.ifConditions[i].block;\n                walk(block, isRoot);\n                check(block);\n            }\n        }\n        if (node.ssrOptimizability == null ||\n            (!isRoot && (node.attrsMap['v-html'] || node.attrsMap['v-text']))) {\n            node.ssrOptimizability = optimizability.FULL;\n        }\n        else {\n            node.children = optimizeSiblings(node);\n        }\n    }\n    else {\n        node.ssrOptimizability = optimizability.FULL;\n    }\n}\nfunction optimizeSiblings(el) {\n    const children = el.children;\n    const optimizedChildren = [];\n    let currentOptimizableGroup = [];\n    const pushGroup = () => {\n        if (currentOptimizableGroup.length) {\n            optimizedChildren.push({\n                type: 1,\n                parent: el,\n                tag: 'template',\n                attrsList: [],\n                attrsMap: {},\n                rawAttrsMap: {},\n                children: currentOptimizableGroup,\n                ssrOptimizability: optimizability.FULL\n            });\n        }\n        currentOptimizableGroup = [];\n    };\n    for (let i = 0; i < children.length; i++) {\n        const c = children[i];\n        if (c.ssrOptimizability === optimizability.FULL) {\n            currentOptimizableGroup.push(c);\n        }\n        else {\n            // wrap fully-optimizable adjacent siblings inside a template tag\n            // so that they can be optimized into a single ssrNode by codegen\n            pushGroup();\n            optimizedChildren.push(c);\n        }\n    }\n    pushGroup();\n    return optimizedChildren;\n}\nfunction isUnOptimizableTree(node) {\n    if (node.type === 2 || node.type === 3) {\n        // text or expression\n        return false;\n    }\n    return (isBuiltInTag(node.tag) || // built-in (slot, component)\n        !isPlatformReservedTag(node.tag) || // custom component\n        !!node.component || // \"is\" component\n        isSelectWithModel(node) // <select v-model> requires runtime inspection\n    );\n}\nconst isBuiltInDir = makeMap('text,html,show,on,bind,model,pre,cloak,once');\nfunction hasCustomDirective(node) {\n    return (node.type === 1 &&\n        node.directives &&\n        node.directives.some(d => !isBuiltInDir(d.name)));\n}\n// <select v-model> cannot be optimized because it requires a runtime check\n// to determine proper selected option\nfunction isSelectWithModel(node) {\n    return (node.type === 1 &&\n        node.tag === 'select' &&\n        node.directives != null &&\n        node.directives.some(d => d.name === 'model'));\n}\n\n// The SSR codegen is essentially extending the default codegen to handle\n// segment types\nconst RAW = 0;\nconst INTERPOLATION = 1;\nconst EXPRESSION = 2;\nfunction generate(ast, options) {\n    const state = new CodegenState(options);\n    const code = ast ? genSSRElement(ast, state) : '_c(\"div\")';\n    return {\n        render: `with(this){return ${code}}`,\n        staticRenderFns: state.staticRenderFns\n    };\n}\nfunction genSSRElement(el, state) {\n    if (el.for && !el.forProcessed) {\n        return genFor(el, state, genSSRElement);\n    }\n    else if (el.if && !el.ifProcessed) {\n        return genIf(el, state, genSSRElement);\n    }\n    else if (el.tag === 'template' && !el.slotTarget) {\n        return el.ssrOptimizability === optimizability.FULL\n            ? genChildrenAsStringNode(el, state)\n            : genSSRChildren(el, state) || 'void 0';\n    }\n    switch (el.ssrOptimizability) {\n        case optimizability.FULL:\n            // stringify whole tree\n            return genStringElement(el, state);\n        case optimizability.SELF:\n            // stringify self and check children\n            return genStringElementWithChildren(el, state);\n        case optimizability.CHILDREN:\n            // generate self as VNode and stringify children\n            return genNormalElement(el, state, true);\n        case optimizability.PARTIAL:\n            // generate self as VNode and check children\n            return genNormalElement(el, state, false);\n        default:\n            // bail whole tree\n            return genElement(el, state);\n    }\n}\nfunction genNormalElement(el, state, stringifyChildren) {\n    const data = el.plain ? undefined : genData(el, state);\n    const children = stringifyChildren\n        ? `[${genChildrenAsStringNode(el, state)}]`\n        : genSSRChildren(el, state, true);\n    return `_c('${el.tag}'${data ? `,${data}` : ''}${children ? `,${children}` : ''})`;\n}\nfunction genSSRChildren(el, state, checkSkip) {\n    return genChildren(el, state, checkSkip, genSSRElement, genSSRNode);\n}\nfunction genSSRNode(el, state) {\n    return el.type === 1 ? genSSRElement(el, state) : genText(el);\n}\nfunction genChildrenAsStringNode(el, state) {\n    return el.children.length\n        ? `_ssrNode(${flattenSegments(childrenToSegments(el, state))})`\n        : '';\n}\nfunction genStringElement(el, state) {\n    return `_ssrNode(${elementToString(el, state)})`;\n}\nfunction genStringElementWithChildren(el, state) {\n    const children = genSSRChildren(el, state, true);\n    return `_ssrNode(${flattenSegments(elementToOpenTagSegments(el, state))},\"</${el.tag}>\"${children ? `,${children}` : ''})`;\n}\nfunction elementToString(el, state) {\n    return `(${flattenSegments(elementToSegments(el, state))})`;\n}\nfunction elementToSegments(el, state) {\n    // v-for / v-if\n    if (el.for && !el.forProcessed) {\n        el.forProcessed = true;\n        return [\n            {\n                type: EXPRESSION,\n                value: genFor(el, state, elementToString, '_ssrList')\n            }\n        ];\n    }\n    else if (el.if && !el.ifProcessed) {\n        el.ifProcessed = true;\n        return [\n            {\n                type: EXPRESSION,\n                value: genIf(el, state, elementToString, '\"<!---->\"')\n            }\n        ];\n    }\n    else if (el.tag === 'template') {\n        return childrenToSegments(el, state);\n    }\n    const openSegments = elementToOpenTagSegments(el, state);\n    const childrenSegments = childrenToSegments(el, state);\n    const { isUnaryTag } = state.options;\n    const close = isUnaryTag && isUnaryTag(el.tag)\n        ? []\n        : [{ type: RAW, value: `</${el.tag}>` }];\n    return openSegments.concat(childrenSegments, close);\n}\nfunction elementToOpenTagSegments(el, state) {\n    applyModelTransform(el, state);\n    let binding;\n    const segments = [{ type: RAW, value: `<${el.tag}` }];\n    // attrs\n    if (el.attrs) {\n        segments.push.apply(segments, genAttrSegments(el.attrs));\n    }\n    // domProps\n    if (el.props) {\n        segments.push.apply(segments, genDOMPropSegments(el.props, el.attrs));\n    }\n    // v-bind=\"object\"\n    if ((binding = el.attrsMap['v-bind'])) {\n        segments.push({ type: EXPRESSION, value: `_ssrAttrs(${binding})` });\n    }\n    // v-bind.prop=\"object\"\n    if ((binding = el.attrsMap['v-bind.prop'])) {\n        segments.push({ type: EXPRESSION, value: `_ssrDOMProps(${binding})` });\n    }\n    // class\n    if (el.staticClass || el.classBinding) {\n        segments.push.apply(segments, genClassSegments(el.staticClass, el.classBinding));\n    }\n    // style & v-show\n    if (el.staticStyle || el.styleBinding || el.attrsMap['v-show']) {\n        segments.push.apply(segments, genStyleSegments(el.attrsMap.style, el.staticStyle, el.styleBinding, el.attrsMap['v-show']));\n    }\n    // _scopedId\n    if (state.options.scopeId) {\n        segments.push({ type: RAW, value: ` ${state.options.scopeId}` });\n    }\n    segments.push({ type: RAW, value: `>` });\n    return segments;\n}\nfunction childrenToSegments(el, state) {\n    let binding;\n    if ((binding = el.attrsMap['v-html'])) {\n        return [{ type: EXPRESSION, value: `_s(${binding})` }];\n    }\n    if ((binding = el.attrsMap['v-text'])) {\n        return [{ type: INTERPOLATION, value: `_s(${binding})` }];\n    }\n    if (el.tag === 'textarea' && (binding = el.attrsMap['v-model'])) {\n        return [{ type: INTERPOLATION, value: `_s(${binding})` }];\n    }\n    return el.children ? nodesToSegments(el.children, state) : [];\n}\nfunction nodesToSegments(children, state) {\n    const segments = [];\n    for (let i = 0; i < children.length; i++) {\n        const c = children[i];\n        if (c.type === 1) {\n            segments.push.apply(segments, elementToSegments(c, state));\n        }\n        else if (c.type === 2) {\n            segments.push({ type: INTERPOLATION, value: c.expression });\n        }\n        else if (c.type === 3) {\n            let text = escape(c.text);\n            if (c.isComment) {\n                text = '<!--' + text + '-->';\n            }\n            segments.push({ type: RAW, value: text });\n        }\n    }\n    return segments;\n}\nfunction flattenSegments(segments) {\n    const mergedSegments = [];\n    let textBuffer = '';\n    const pushBuffer = () => {\n        if (textBuffer) {\n            mergedSegments.push(JSON.stringify(textBuffer));\n            textBuffer = '';\n        }\n    };\n    for (let i = 0; i < segments.length; i++) {\n        const s = segments[i];\n        if (s.type === RAW) {\n            textBuffer += s.value;\n        }\n        else if (s.type === INTERPOLATION) {\n            pushBuffer();\n            mergedSegments.push(`_ssrEscape(${s.value})`);\n        }\n        else if (s.type === EXPRESSION) {\n            pushBuffer();\n            mergedSegments.push(`(${s.value})`);\n        }\n    }\n    pushBuffer();\n    return mergedSegments.join('+');\n}\n\nconst createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    const ast = parse(template.trim(), options);\n    optimize(ast, options);\n    const code = generate(ast, options);\n    return {\n        ast,\n        render: code.render,\n        staticRenderFns: code.staticRenderFns\n    };\n});\n\nconst { compile, compileToFunctions } = createCompiler(baseOptions);\n\nexports.compile = compile$1;\nexports.compileToFunctions = compileToFunctions$1;\nexports.generateCodeFrame = generateCodeFrame;\nexports.parseComponent = parseComponent;\nexports.ssrCompile = compile;\nexports.ssrCompileToFunctions = compileToFunctions;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compile = void 0;\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst Vue2TemplateCompiler = require('@vue/compiler-vue2/build');\nconst compile = (template, options = {}) => {\n    if (typeof template !== 'string') {\n        throw new Error(`[@vue/language-core] compile() first argument must be string.`);\n    }\n    const onError = options.onError;\n    const onWarn = options.onWarn;\n    options.onError = error => {\n        if (error.code === 33 // :key binding allowed in v-for template child in vue 2\n            || error.code === 29 // fix https://github.com/vuejs/language-tools/issues/1638\n        ) {\n            return;\n        }\n        if (onError) {\n            onError(error);\n        }\n        else {\n            throw error;\n        }\n    };\n    const vue2Result = Vue2TemplateCompiler.compile(template, { outputSourceRange: true });\n    for (const error of vue2Result.errors) {\n        onError?.({\n            code: 'vue-template-compiler',\n            name: '',\n            message: error.msg,\n            loc: {\n                source: '',\n                start: { column: -1, line: -1, offset: error.start },\n                end: { column: -1, line: -1, offset: error.end ?? error.start },\n            },\n        });\n    }\n    for (const error of vue2Result.tips) {\n        onWarn?.({\n            code: 'vue-template-compiler',\n            name: '',\n            message: error.msg,\n            loc: {\n                source: '',\n                start: { column: -1, line: -1, offset: error.start },\n                end: { column: -1, line: -1, offset: error.end ?? error.start },\n            },\n        });\n    }\n    return baseCompile(template, Object.assign({}, CompilerDOM.parserOptions, options, {\n        nodeTransforms: [\n            ...CompilerDOM.DOMNodeTransforms,\n            ...(options.nodeTransforms || [])\n        ],\n        directiveTransforms: Object.assign({}, CompilerDOM.DOMDirectiveTransforms, options.directiveTransforms || {}),\n    }));\n};\nexports.compile = compile;\nfunction baseCompile(template, options = {}) {\n    const onError = options.onError || (error => { throw error; });\n    const isModuleMode = options.mode === 'module';\n    const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;\n    if (!prefixIdentifiers && options.cacheHandlers) {\n        onError(CompilerDOM.createCompilerError(49));\n    }\n    if (options.scopeId && !isModuleMode) {\n        onError(CompilerDOM.createCompilerError(50));\n    }\n    const ast = CompilerDOM.baseParse(template, options);\n    const [nodeTransforms, directiveTransforms] = CompilerDOM.getBaseTransformPreset(prefixIdentifiers);\n    // v-for > v-if in vue 2\n    const transformIf = nodeTransforms[1];\n    const transformFor = nodeTransforms[3];\n    nodeTransforms[1] = transformFor;\n    nodeTransforms[3] = transformIf;\n    CompilerDOM.transform(ast, Object.assign({}, options, {\n        prefixIdentifiers,\n        nodeTransforms: [\n            ...nodeTransforms,\n            ...(options.nodeTransforms || []) // user transforms\n        ],\n        directiveTransforms: Object.assign({}, directiveTransforms, options.directiveTransforms || {} // user transforms\n        )\n    }));\n    return CompilerDOM.generate(ast, Object.assign({}, options, {\n        prefixIdentifiers\n    }));\n}\n//# sourceMappingURL=vue2TemplateCompiler.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VueEmbeddedCode = void 0;\nclass VueEmbeddedCode {\n    constructor(id, lang, content) {\n        this.id = id;\n        this.lang = lang;\n        this.content = content;\n        this.linkedCodeMappings = [];\n        this.embeddedCodes = [];\n    }\n}\nexports.VueEmbeddedCode = VueEmbeddedCode;\n//# sourceMappingURL=embeddedFile.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computedEmbeddedCodes = computedEmbeddedCodes;\nexports.resolveCommonLanguageId = resolveCommonLanguageId;\nconst alien_signals_1 = require(\"alien-signals\");\nconst muggle_string_1 = require(\"muggle-string\");\nconst buildMappings_1 = require(\"../utils/buildMappings\");\nconst embeddedFile_1 = require(\"./embeddedFile\");\nfunction computedEmbeddedCodes(plugins, fileName, sfc) {\n    const nameToBlock = (0, alien_signals_1.computed)(() => {\n        const blocks = {};\n        if (sfc.template) {\n            blocks[sfc.template.name] = sfc.template;\n        }\n        if (sfc.script) {\n            blocks[sfc.script.name] = sfc.script;\n        }\n        if (sfc.scriptSetup) {\n            blocks[sfc.scriptSetup.name] = sfc.scriptSetup;\n        }\n        for (const block of sfc.styles) {\n            blocks[block.name] = block;\n        }\n        for (const block of sfc.customBlocks) {\n            blocks[block.name] = block;\n        }\n        return blocks;\n    });\n    const pluginsResult = plugins.map(plugin => computedPluginEmbeddedCodes(plugins, plugin, fileName, sfc, nameToBlock));\n    const flatResult = (0, alien_signals_1.computed)(() => pluginsResult.map(r => r.get()).flat());\n    const structuredResult = (0, alien_signals_1.computed)(() => {\n        const embeddedCodes = [];\n        let remain = [...flatResult.get()];\n        while (remain.length) {\n            const beforeLength = remain.length;\n            consumeRemain();\n            if (beforeLength === remain.length) {\n                break;\n            }\n        }\n        for (const { code } of remain) {\n            console.error('Unable to resolve embedded: ' + code.parentCodeId + ' -> ' + code.id);\n        }\n        return embeddedCodes;\n        function consumeRemain() {\n            for (let i = remain.length - 1; i >= 0; i--) {\n                const { code, snapshot, mappings } = remain[i];\n                if (!code.parentCodeId) {\n                    embeddedCodes.push({\n                        id: code.id,\n                        languageId: resolveCommonLanguageId(code.lang),\n                        linkedCodeMappings: code.linkedCodeMappings,\n                        snapshot,\n                        mappings,\n                        embeddedCodes: [],\n                    });\n                    remain.splice(i, 1);\n                }\n                else {\n                    const parent = findParentStructure(code.parentCodeId, embeddedCodes);\n                    if (parent) {\n                        parent.embeddedCodes ??= [];\n                        parent.embeddedCodes.push({\n                            id: code.id,\n                            languageId: resolveCommonLanguageId(code.lang),\n                            linkedCodeMappings: code.linkedCodeMappings,\n                            snapshot,\n                            mappings,\n                            embeddedCodes: [],\n                        });\n                        remain.splice(i, 1);\n                    }\n                }\n            }\n        }\n        function findParentStructure(id, current) {\n            for (const child of current) {\n                if (child.id === id) {\n                    return child;\n                }\n                let parent = findParentStructure(id, child.embeddedCodes ?? []);\n                if (parent) {\n                    return parent;\n                }\n            }\n        }\n    });\n    return structuredResult;\n}\nfunction computedPluginEmbeddedCodes(plugins, plugin, fileName, sfc, nameToBlock) {\n    const computeds = new Map();\n    const getComputedKey = (code) => code.id + '__' + code.lang;\n    const codes = (0, alien_signals_1.computed)(() => {\n        try {\n            if (!plugin.getEmbeddedCodes) {\n                return [...computeds.values()];\n            }\n            const embeddedCodeInfos = plugin.getEmbeddedCodes(fileName, sfc);\n            for (const oldId of computeds.keys()) {\n                if (!embeddedCodeInfos.some(code => getComputedKey(code) === oldId)) {\n                    computeds.delete(oldId);\n                }\n            }\n            for (const codeInfo of embeddedCodeInfos) {\n                if (!computeds.has(getComputedKey(codeInfo))) {\n                    computeds.set(getComputedKey(codeInfo), (0, alien_signals_1.computed)(() => {\n                        const content = [];\n                        const code = new embeddedFile_1.VueEmbeddedCode(codeInfo.id, codeInfo.lang, content);\n                        for (const plugin of plugins) {\n                            if (!plugin.resolveEmbeddedCode) {\n                                continue;\n                            }\n                            try {\n                                plugin.resolveEmbeddedCode(fileName, sfc, code);\n                            }\n                            catch (e) {\n                                console.error(e);\n                            }\n                        }\n                        const newText = (0, muggle_string_1.toString)(code.content);\n                        const changeRanges = new Map();\n                        const snapshot = {\n                            getText: (start, end) => newText.slice(start, end),\n                            getLength: () => newText.length,\n                            getChangeRange(oldSnapshot) {\n                                if (!changeRanges.has(oldSnapshot)) {\n                                    changeRanges.set(oldSnapshot, undefined);\n                                    const oldText = oldSnapshot.getText(0, oldSnapshot.getLength());\n                                    const changeRange = fullDiffTextChangeRange(oldText, newText);\n                                    if (changeRange) {\n                                        changeRanges.set(oldSnapshot, changeRange);\n                                    }\n                                }\n                                return changeRanges.get(oldSnapshot);\n                            },\n                        };\n                        return {\n                            code,\n                            snapshot,\n                        };\n                    }));\n                }\n            }\n        }\n        catch (e) {\n            console.error(e);\n        }\n        return [...computeds.values()];\n    });\n    return (0, alien_signals_1.computed)(() => {\n        return codes.get().map(_file => {\n            const { code, snapshot } = _file.get();\n            const mappings = (0, buildMappings_1.buildMappings)(code.content.map(segment => {\n                if (typeof segment === 'string') {\n                    return segment;\n                }\n                const source = segment[1];\n                if (source === undefined) {\n                    return segment;\n                }\n                const block = nameToBlock.get()[source];\n                if (!block) {\n                    // console.warn('Unable to find block: ' + source);\n                    return segment;\n                }\n                return [\n                    segment[0],\n                    undefined,\n                    segment[2] + block.startTagEnd,\n                    segment[3],\n                ];\n            }));\n            const newMappings = [];\n            let lastValidMapping;\n            for (let i = 0; i < mappings.length; i++) {\n                const mapping = mappings[i];\n                if (mapping.data.__combineOffsetMapping !== undefined) {\n                    const offsetMapping = mappings[i - mapping.data.__combineOffsetMapping];\n                    if (typeof offsetMapping === 'string' || !offsetMapping) {\n                        throw new Error('Invalid offset mapping, mappings: ' + mappings.length + ', i: ' + i + ', offset: ' + mapping.data.__combineOffsetMapping);\n                    }\n                    offsetMapping.sourceOffsets.push(...mapping.sourceOffsets);\n                    offsetMapping.generatedOffsets.push(...mapping.generatedOffsets);\n                    offsetMapping.lengths.push(...mapping.lengths);\n                    continue;\n                }\n                else if (mapping.data.__combineLastMapping) {\n                    lastValidMapping.sourceOffsets.push(...mapping.sourceOffsets);\n                    lastValidMapping.generatedOffsets.push(...mapping.generatedOffsets);\n                    lastValidMapping.lengths.push(...mapping.lengths);\n                    continue;\n                }\n                else {\n                    lastValidMapping = mapping;\n                }\n                newMappings.push(mapping);\n            }\n            return {\n                code,\n                snapshot,\n                mappings: newMappings,\n            };\n        });\n    });\n}\nfunction fullDiffTextChangeRange(oldText, newText) {\n    for (let start = 0; start < oldText.length && start < newText.length; start++) {\n        if (oldText[start] !== newText[start]) {\n            let end = oldText.length;\n            for (let i = 0; i < oldText.length - start && i < newText.length - start; i++) {\n                if (oldText[oldText.length - i - 1] !== newText[newText.length - i - 1]) {\n                    break;\n                }\n                end--;\n            }\n            let length = end - start;\n            let newLength = length + (newText.length - oldText.length);\n            if (newLength < 0) {\n                length -= newLength;\n                newLength = 0;\n            }\n            return {\n                span: { start, length },\n                newLength,\n            };\n        }\n    }\n}\nfunction resolveCommonLanguageId(lang) {\n    switch (lang) {\n        case 'js': return 'javascript';\n        case 'cjs': return 'javascript';\n        case 'mjs': return 'javascript';\n        case 'ts': return 'typescript';\n        case 'cts': return 'typescript';\n        case 'mts': return 'typescript';\n        case 'jsx': return 'javascriptreact';\n        case 'tsx': return 'typescriptreact';\n        case 'pug': return 'jade';\n        case 'md': return 'markdown';\n    }\n    return lang;\n}\n//# sourceMappingURL=computedEmbeddedCodes.js.map", "\"use strict\";\n// https://github.com/vuejs/core/blob/main/packages/compiler-sfc/src/cssVars.ts#L47-L61\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.commentReg = void 0;\nexports.parseCssVars = parseCssVars;\nexports.fillBlank = fillBlank;\nconst vBindCssVarReg = /\\bv-bind\\(\\s*(?:'([^']+)'|\"([^\"]+)\"|([a-z_]\\w*))\\s*\\)/gi;\nexports.commentReg = /(?<=\\/\\*)[\\s\\S]*?(?=\\*\\/)|(?<=\\/\\/)[\\s\\S]*?(?=\\n)/g;\nfunction* parseCssVars(css) {\n    css = fillBlank(css, exports.commentReg);\n    const matchs = css.matchAll(vBindCssVarReg);\n    for (const match of matchs) {\n        const matchText = match.slice(1).find(t => t);\n        if (matchText) {\n            const offset = match.index + css.slice(match.index).indexOf(matchText);\n            yield { offset, text: matchText };\n        }\n    }\n}\nfunction fillBlank(css, ...regs) {\n    for (const reg of regs) {\n        css = css.replace(reg, match => ' '.repeat(match.length));\n    }\n    return css;\n}\n//# sourceMappingURL=parseCssVars.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseCssClassNames = parseCssClassNames;\nconst parseCssVars_1 = require(\"./parseCssVars\");\nconst cssClassNameReg = /(?=(\\.[a-z_][-\\w]*)[\\s.,+~>:#)[{])/gi;\nconst fragmentReg = /(?<={)[^{]*(?=(?<!\\\\);)/g;\nfunction* parseCssClassNames(css) {\n    css = (0, parseCssVars_1.fillBlank)(css, parseCssVars_1.commentReg, fragmentReg);\n    const matches = css.matchAll(cssClassNameReg);\n    for (const match of matches) {\n        const matchText = match[1];\n        if (matchText) {\n            yield { offset: match.index, text: matchText };\n        }\n    }\n}\n//# sourceMappingURL=parseCssClassNames.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computedSfc = computedSfc;\nconst alien_signals_1 = require(\"alien-signals\");\nconst parseCssClassNames_1 = require(\"../utils/parseCssClassNames\");\nconst parseCssVars_1 = require(\"../utils/parseCssVars\");\nfunction computedSfc(ts, plugins, fileName, snapshot, parsed) {\n    const untrackedSnapshot = () => {\n        const prevTrackId = alien_signals_1.System.activeTrackId;\n        alien_signals_1.System.activeTrackId = 0;\n        const res = snapshot.get();\n        alien_signals_1.System.activeTrackId = prevTrackId;\n        return res;\n    };\n    const content = (0, alien_signals_1.computed)(() => {\n        return snapshot.get().getText(0, snapshot.get().getLength());\n    });\n    const template = computedNullableSfcBlock('template', 'html', (0, alien_signals_1.computed)(() => parsed.get()?.descriptor.template ?? undefined), (_block, base) => {\n        const compiledAst = computedTemplateAst(base);\n        return mergeObject(base, {\n            get ast() { return compiledAst.get()?.ast; },\n            get errors() { return compiledAst.get()?.errors; },\n            get warnings() { return compiledAst.get()?.warnings; },\n        });\n    });\n    const script = computedNullableSfcBlock('script', 'js', (0, alien_signals_1.computed)(() => parsed.get()?.descriptor.script ?? undefined), (block, base) => {\n        const src = (0, alien_signals_1.computed)(() => block.get().src);\n        const srcOffset = (0, alien_signals_1.computed)(() => {\n            const _src = src.get();\n            return _src ? untrackedSnapshot().getText(0, base.startTagEnd).lastIndexOf(_src) - base.startTagEnd : -1;\n        });\n        const ast = (0, alien_signals_1.computed)(() => {\n            for (const plugin of plugins) {\n                const ast = plugin.compileSFCScript?.(base.lang, base.content);\n                if (ast) {\n                    return ast;\n                }\n            }\n            return ts.createSourceFile(fileName + '.' + base.lang, '', 99);\n        });\n        return mergeObject(base, {\n            get src() { return src.get(); },\n            get srcOffset() { return srcOffset.get(); },\n            get ast() { return ast.get(); },\n        });\n    });\n    const scriptSetupOriginal = computedNullableSfcBlock('scriptSetup', 'js', (0, alien_signals_1.computed)(() => parsed.get()?.descriptor.scriptSetup ?? undefined), (block, base) => {\n        const generic = (0, alien_signals_1.computed)(() => {\n            const _block = block.get();\n            return typeof _block.attrs.generic === 'string' ? _block.attrs.generic : undefined;\n        });\n        const genericOffset = (0, alien_signals_1.computed)(() => {\n            const _generic = generic.get();\n            return _generic !== undefined ? untrackedSnapshot().getText(0, base.startTagEnd).lastIndexOf(_generic) - base.startTagEnd : -1;\n        });\n        const ast = (0, alien_signals_1.computed)(() => {\n            for (const plugin of plugins) {\n                const ast = plugin.compileSFCScript?.(base.lang, base.content);\n                if (ast) {\n                    return ast;\n                }\n            }\n            return ts.createSourceFile(fileName + '.' + base.lang, '', 99);\n        });\n        return mergeObject(base, {\n            get generic() { return generic.get(); },\n            get genericOffset() { return genericOffset.get(); },\n            get ast() { return ast.get(); },\n        });\n    });\n    const hasScript = (0, alien_signals_1.computed)(() => !!parsed.get()?.descriptor.script);\n    const hasScriptSetup = (0, alien_signals_1.computed)(() => !!parsed.get()?.descriptor.scriptSetup);\n    const scriptSetup = (0, alien_signals_1.computed)(() => {\n        if (!hasScript.get() && !hasScriptSetup.get()) {\n            //#region monkey fix: https://github.com/vuejs/language-tools/pull/2113\n            return {\n                content: '',\n                lang: 'ts',\n                name: '',\n                start: 0,\n                end: 0,\n                startTagEnd: 0,\n                endTagStart: 0,\n                generic: undefined,\n                genericOffset: 0,\n                attrs: {},\n                ast: ts.createSourceFile('', '', 99, false, ts.ScriptKind.TS),\n            };\n        }\n        return scriptSetupOriginal.get();\n    });\n    const styles = alien_signals_1.Unstable.computedArray((0, alien_signals_1.computed)(() => parsed.get()?.descriptor.styles ?? []), (block, i) => {\n        const base = computedSfcBlock('style_' + i, 'css', block);\n        const module = (0, alien_signals_1.computed)(() => {\n            const _module = block.get().module;\n            return _module ? {\n                name: _module.name,\n                offset: _module.offset ? base.start + _module.offset : undefined\n            } : undefined;\n        });\n        const scoped = (0, alien_signals_1.computed)(() => !!block.get().scoped);\n        const cssVars = (0, alien_signals_1.computed)(() => [...(0, parseCssVars_1.parseCssVars)(base.content)]);\n        const classNames = (0, alien_signals_1.computed)(() => [...(0, parseCssClassNames_1.parseCssClassNames)(base.content)]);\n        return () => mergeObject(base, {\n            get module() { return module.get(); },\n            get scoped() { return scoped.get(); },\n            get cssVars() { return cssVars.get(); },\n            get classNames() { return classNames.get(); },\n        });\n    });\n    const customBlocks = alien_signals_1.Unstable.computedArray((0, alien_signals_1.computed)(() => parsed.get()?.descriptor.customBlocks ?? []), (block, i) => {\n        const base = computedSfcBlock('custom_block_' + i, 'txt', block);\n        const type = (0, alien_signals_1.computed)(() => block.get().type);\n        return () => mergeObject(base, {\n            get type() { return type.get(); },\n        });\n    });\n    return {\n        get content() { return content.get(); },\n        get template() { return template.get(); },\n        get script() { return script.get(); },\n        get scriptSetup() { return scriptSetup.get(); },\n        get styles() { return styles; },\n        get customBlocks() { return customBlocks; },\n    };\n    function computedTemplateAst(base) {\n        let cache;\n        return (0, alien_signals_1.computed)(() => {\n            if (cache?.template === base.content) {\n                return {\n                    errors: [],\n                    warnings: [],\n                    ast: cache?.result.ast,\n                };\n            }\n            // incremental update\n            if (cache?.plugin.updateSFCTemplate) {\n                const change = untrackedSnapshot().getChangeRange(cache.snapshot);\n                if (change) {\n                    const prevTrackId = alien_signals_1.System.activeTrackId;\n                    alien_signals_1.System.activeTrackId = 0;\n                    const templateOffset = base.startTagEnd;\n                    alien_signals_1.System.activeTrackId = prevTrackId;\n                    const newText = untrackedSnapshot().getText(change.span.start, change.span.start + change.newLength);\n                    const newResult = cache.plugin.updateSFCTemplate(cache.result, {\n                        start: change.span.start - templateOffset,\n                        end: change.span.start + change.span.length - templateOffset,\n                        newText,\n                    });\n                    if (newResult) {\n                        cache.template = base.content;\n                        cache.snapshot = untrackedSnapshot();\n                        cache.result = newResult;\n                        return {\n                            errors: [],\n                            warnings: [],\n                            ast: newResult.ast,\n                        };\n                    }\n                }\n            }\n            const errors = [];\n            const warnings = [];\n            let options = {\n                onError: (err) => errors.push(err),\n                onWarn: (err) => warnings.push(err),\n                expressionPlugins: ['typescript'],\n            };\n            for (const plugin of plugins) {\n                if (plugin.resolveTemplateCompilerOptions) {\n                    options = plugin.resolveTemplateCompilerOptions(options);\n                }\n            }\n            for (const plugin of plugins) {\n                let result;\n                try {\n                    result = plugin.compileSFCTemplate?.(base.lang, base.content, options);\n                }\n                catch (e) {\n                    const err = e;\n                    errors.push(err);\n                }\n                if (result || errors.length) {\n                    if (result && !errors.length && !warnings.length) {\n                        cache = {\n                            template: base.content,\n                            snapshot: untrackedSnapshot(),\n                            result: result,\n                            plugin,\n                        };\n                    }\n                    else {\n                        cache = undefined;\n                    }\n                    return {\n                        errors,\n                        warnings,\n                        ast: result?.ast,\n                    };\n                }\n            }\n            return {\n                errors,\n                warnings,\n                ast: undefined,\n            };\n        });\n    }\n    function computedNullableSfcBlock(name, defaultLang, block, resolve) {\n        const hasBlock = (0, alien_signals_1.computed)(() => !!block.get());\n        return (0, alien_signals_1.computed)(() => {\n            if (!hasBlock.get()) {\n                return;\n            }\n            const _block = (0, alien_signals_1.computed)(() => block.get());\n            return resolve(_block, computedSfcBlock(name, defaultLang, _block));\n        });\n    }\n    function computedSfcBlock(name, defaultLang, block) {\n        const lang = (0, alien_signals_1.computed)(() => block.get().lang ?? defaultLang);\n        const attrs = (0, alien_signals_1.computed)(() => block.get().attrs); // TODO: computed it\n        const content = (0, alien_signals_1.computed)(() => block.get().content);\n        const startTagEnd = (0, alien_signals_1.computed)(() => block.get().loc.start.offset);\n        const endTagStart = (0, alien_signals_1.computed)(() => block.get().loc.end.offset);\n        const start = (0, alien_signals_1.computed)(() => untrackedSnapshot().getText(0, startTagEnd.get()).lastIndexOf('<' + block.get().type));\n        const end = (0, alien_signals_1.computed)(() => endTagStart.get() + untrackedSnapshot().getText(endTagStart.get(), untrackedSnapshot().getLength()).indexOf('>') + 1);\n        return {\n            name,\n            get lang() { return lang.get(); },\n            get attrs() { return attrs.get(); },\n            get content() { return content.get(); },\n            get startTagEnd() { return startTagEnd.get(); },\n            get endTagStart() { return endTagStart.get(); },\n            get start() { return start.get(); },\n            get end() { return end.get(); },\n        };\n    }\n}\nfunction mergeObject(a, b) {\n    return Object.defineProperties(a, Object.getOwnPropertyDescriptors(b));\n}\n//# sourceMappingURL=computedSfc.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computedVueSfc = computedVueSfc;\nconst alien_signals_1 = require(\"alien-signals\");\nfunction computedVueSfc(plugins, fileName, languageId, snapshot) {\n    let cache;\n    return (0, alien_signals_1.computed)(() => {\n        // incremental update\n        if (cache?.plugin.updateSFC) {\n            const change = snapshot.get().getChangeRange(cache.snapshot);\n            if (change) {\n                const newSfc = cache.plugin.updateSFC(cache.sfc, {\n                    start: change.span.start,\n                    end: change.span.start + change.span.length,\n                    newText: snapshot.get().getText(change.span.start, change.span.start + change.newLength),\n                });\n                if (newSfc) {\n                    cache.snapshot = snapshot.get();\n                    // force dirty\n                    cache.sfc = JSON.parse(JSON.stringify(newSfc));\n                    return cache.sfc;\n                }\n            }\n        }\n        for (const plugin of plugins) {\n            const sfc = plugin.parseSFC?.(fileName, snapshot.get().getText(0, snapshot.get().getLength()))\n                ?? plugin.parseSFC2?.(fileName, languageId, snapshot.get().getText(0, snapshot.get().getLength()));\n            if (sfc) {\n                if (!sfc.errors.length) {\n                    cache = {\n                        snapshot: snapshot.get(),\n                        sfc,\n                        plugin,\n                    };\n                }\n                return sfc;\n            }\n        }\n    });\n}\n//# sourceMappingURL=computedVueSfc.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VueVirtualCode = void 0;\nconst alien_signals_1 = require(\"alien-signals\");\nconst plugins_1 = require(\"../plugins\");\nconst computedEmbeddedCodes_1 = require(\"./computedEmbeddedCodes\");\nconst computedSfc_1 = require(\"./computedSfc\");\nconst computedVueSfc_1 = require(\"./computedVueSfc\");\nclass VueVirtualCode {\n    // others\n    get embeddedCodes() {\n        return this._embeddedCodes.get();\n    }\n    get snapshot() {\n        return this._snapshot.get();\n    }\n    get mappings() {\n        return this._mappings.get();\n    }\n    constructor(fileName, languageId, initSnapshot, vueCompilerOptions, plugins, ts) {\n        this.fileName = fileName;\n        this.languageId = languageId;\n        this.initSnapshot = initSnapshot;\n        this.vueCompilerOptions = vueCompilerOptions;\n        this.plugins = plugins;\n        this.ts = ts;\n        // sources\n        this.id = 'main';\n        this._snapshot = (0, alien_signals_1.signal)(undefined);\n        // computeds\n        this._vueSfc = (0, computedVueSfc_1.computedVueSfc)(this.plugins, this.fileName, this.languageId, this._snapshot);\n        this._sfc = (0, computedSfc_1.computedSfc)(this.ts, this.plugins, this.fileName, this._snapshot, this._vueSfc);\n        this._mappings = (0, alien_signals_1.computed)(() => {\n            const snapshot = this._snapshot.get();\n            return [{\n                    sourceOffsets: [0],\n                    generatedOffsets: [0],\n                    lengths: [snapshot.getLength()],\n                    data: plugins_1.allCodeFeatures,\n                }];\n        });\n        this._embeddedCodes = (0, computedEmbeddedCodes_1.computedEmbeddedCodes)(this.plugins, this.fileName, this._sfc);\n        this._snapshot.set(initSnapshot);\n    }\n    update(newSnapshot) {\n        this._snapshot.set(newSnapshot);\n    }\n}\nexports.VueVirtualCode = VueVirtualCode;\n//# sourceMappingURL=vueFile.js.map", "\"use strict\";\n/// <reference types=\"@volar/typescript\" />\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createVueLanguagePlugin = createVueLanguagePlugin;\nexports.getAllExtensions = getAllExtensions;\nconst language_core_1 = require(\"@volar/language-core\");\nconst CompilerDOM = require(\"@vue/compiler-dom\");\nconst plugins_1 = require(\"./plugins\");\nconst CompilerVue2 = require(\"./utils/vue2TemplateCompiler\");\nconst vueFile_1 = require(\"./virtualFile/vueFile\");\nconst fileRegistries = [];\nfunction getVueFileRegistry(key, plugins) {\n    let fileRegistry = fileRegistries.find(r => r.key === key\n        && r.plugins.length === plugins.length\n        && r.plugins.every(plugin => plugins.includes(plugin)))?.files;\n    if (!fileRegistry) {\n        fileRegistry = new Map();\n        fileRegistries.push({\n            key: key,\n            plugins: plugins,\n            files: fileRegistry,\n        });\n    }\n    return fileRegistry;\n}\nfunction getFileRegistryKey(compilerOptions, vueCompilerOptions, plugins) {\n    const values = [\n        ...Object.keys(vueCompilerOptions)\n            .sort()\n            .filter(key => key !== 'plugins')\n            .map(key => [key, vueCompilerOptions[key]]),\n        [...new Set(plugins.map(plugin => plugin.requiredCompilerOptions ?? []).flat())]\n            .sort()\n            .map(key => [key, compilerOptions[key]]),\n    ];\n    return JSON.stringify(values);\n}\nfunction createVueLanguagePlugin(ts, compilerOptions, vueCompilerOptions, asFileName) {\n    const pluginContext = {\n        modules: {\n            '@vue/compiler-dom': vueCompilerOptions.target < 3\n                ? {\n                    ...CompilerDOM,\n                    compile: CompilerVue2.compile,\n                }\n                : CompilerDOM,\n            typescript: ts,\n        },\n        compilerOptions,\n        vueCompilerOptions,\n    };\n    const plugins = (0, plugins_1.createPlugins)(pluginContext);\n    const fileRegistry = getVueFileRegistry(getFileRegistryKey(compilerOptions, vueCompilerOptions, plugins), vueCompilerOptions.plugins);\n    return {\n        getLanguageId(scriptId) {\n            const fileName = asFileName(scriptId);\n            for (const plugin of plugins) {\n                const languageId = plugin.getLanguageId?.(fileName);\n                if (languageId) {\n                    return languageId;\n                }\n            }\n        },\n        createVirtualCode(scriptId, languageId, snapshot) {\n            const fileName = asFileName(scriptId);\n            if (plugins.some(plugin => plugin.isValidFile?.(fileName, languageId))) {\n                const code = fileRegistry.get(fileName);\n                if (code) {\n                    code.update(snapshot);\n                    return code;\n                }\n                else {\n                    const code = new vueFile_1.VueVirtualCode(fileName, languageId, snapshot, vueCompilerOptions, plugins, ts);\n                    fileRegistry.set(fileName, code);\n                    return code;\n                }\n            }\n        },\n        updateVirtualCode(_fileId, code, snapshot) {\n            code.update(snapshot);\n            return code;\n        },\n        typescript: {\n            extraFileExtensions: getAllExtensions(vueCompilerOptions)\n                .map(ext => ({\n                extension: ext.slice(1),\n                isMixedContent: true,\n                scriptKind: 7,\n            })),\n            getServiceScript(root) {\n                for (const code of (0, language_core_1.forEachEmbeddedCode)(root)) {\n                    if (/script_(js|jsx|ts|tsx)/.test(code.id)) {\n                        const lang = code.id.substring('script_'.length);\n                        return {\n                            code,\n                            extension: '.' + lang,\n                            scriptKind: lang === 'js' ? ts.ScriptKind.JS\n                                : lang === 'jsx' ? ts.ScriptKind.JSX\n                                    : lang === 'tsx' ? ts.ScriptKind.TSX\n                                        : ts.ScriptKind.TS,\n                        };\n                    }\n                }\n            },\n        },\n    };\n}\nfunction getAllExtensions(options) {\n    const result = new Set();\n    for (const key in options) {\n        if (key === 'extensions' || key.endsWith('Extensions')) {\n            const value = options[key];\n            if (Array.isArray(value) && value.every(v => typeof v === 'string')) {\n                for (const ext of value) {\n                    result.add(ext);\n                }\n            }\n        }\n    }\n    return [...result];\n}\n//# sourceMappingURL=languagePlugin.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createParsedCommandLineByJson = createParsedCommandLineByJson;\nexports.createParsedCommandLine = createParsedCommandLine;\nexports.resolveVueCompilerOptions = resolveVueCompilerOptions;\nexports.setupGlobalTypes = setupGlobalTypes;\nconst shared_1 = require(\"@vue/shared\");\nconst path_browserify_1 = require(\"path-browserify\");\nconst languagePlugin_1 = require(\"../languagePlugin\");\nconst globalTypes_1 = require(\"../codegen/globalTypes\");\nfunction createParsedCommandLineByJson(ts, parseConfigHost, rootDir, json, configFileName = rootDir + '/jsconfig.json', skipGlobalTypesSetup = false) {\n    const proxyHost = proxyParseConfigHostForExtendConfigPaths(parseConfigHost);\n    ts.parseJsonConfigFileContent(json, proxyHost.host, rootDir, {}, configFileName);\n    let vueOptions = {};\n    for (const extendPath of proxyHost.extendConfigPaths.reverse()) {\n        try {\n            vueOptions = {\n                ...vueOptions,\n                ...getPartialVueCompilerOptions(ts, ts.readJsonConfigFile(extendPath, proxyHost.host.readFile)),\n            };\n        }\n        catch (err) { }\n    }\n    const resolvedVueOptions = resolveVueCompilerOptions(vueOptions);\n    if (skipGlobalTypesSetup) {\n        resolvedVueOptions.__setupedGlobalTypes = true;\n    }\n    else {\n        resolvedVueOptions.__setupedGlobalTypes = setupGlobalTypes(rootDir, resolvedVueOptions, parseConfigHost);\n    }\n    const parsed = ts.parseJsonConfigFileContent(json, proxyHost.host, rootDir, {}, configFileName, undefined, (0, languagePlugin_1.getAllExtensions)(resolvedVueOptions)\n        .map(extension => ({\n        extension: extension.slice(1),\n        isMixedContent: true,\n        scriptKind: ts.ScriptKind.Deferred,\n    })));\n    // fix https://github.com/vuejs/language-tools/issues/1786\n    // https://github.com/microsoft/TypeScript/issues/30457\n    // patching ts server broke with outDir + rootDir + composite/incremental\n    parsed.options.outDir = undefined;\n    return {\n        ...parsed,\n        vueOptions: resolvedVueOptions,\n    };\n}\nfunction createParsedCommandLine(ts, parseConfigHost, tsConfigPath, skipGlobalTypesSetup = false) {\n    try {\n        const proxyHost = proxyParseConfigHostForExtendConfigPaths(parseConfigHost);\n        const config = ts.readJsonConfigFile(tsConfigPath, proxyHost.host.readFile);\n        ts.parseJsonSourceFileConfigFileContent(config, proxyHost.host, path_browserify_1.posix.dirname(tsConfigPath), {}, tsConfigPath);\n        let vueOptions = {};\n        for (const extendPath of proxyHost.extendConfigPaths.reverse()) {\n            try {\n                vueOptions = {\n                    ...vueOptions,\n                    ...getPartialVueCompilerOptions(ts, ts.readJsonConfigFile(extendPath, proxyHost.host.readFile)),\n                };\n            }\n            catch (err) { }\n        }\n        const resolvedVueOptions = resolveVueCompilerOptions(vueOptions);\n        if (skipGlobalTypesSetup) {\n            resolvedVueOptions.__setupedGlobalTypes = true;\n        }\n        else {\n            resolvedVueOptions.__setupedGlobalTypes = setupGlobalTypes(path_browserify_1.posix.dirname(tsConfigPath), resolvedVueOptions, parseConfigHost);\n        }\n        const parsed = ts.parseJsonSourceFileConfigFileContent(config, proxyHost.host, path_browserify_1.posix.dirname(tsConfigPath), {}, tsConfigPath, undefined, (0, languagePlugin_1.getAllExtensions)(resolvedVueOptions)\n            .map(extension => ({\n            extension: extension.slice(1),\n            isMixedContent: true,\n            scriptKind: ts.ScriptKind.Deferred,\n        })));\n        // fix https://github.com/vuejs/language-tools/issues/1786\n        // https://github.com/microsoft/TypeScript/issues/30457\n        // patching ts server broke with outDir + rootDir + composite/incremental\n        parsed.options.outDir = undefined;\n        return {\n            ...parsed,\n            vueOptions: resolvedVueOptions,\n        };\n    }\n    catch (err) {\n        // console.warn('Failed to resolve tsconfig path:', tsConfigPath, err);\n        return {\n            fileNames: [],\n            options: {},\n            vueOptions: resolveVueCompilerOptions({}),\n            errors: [],\n        };\n    }\n}\nfunction proxyParseConfigHostForExtendConfigPaths(parseConfigHost) {\n    const extendConfigPaths = [];\n    const host = new Proxy(parseConfigHost, {\n        get(target, key) {\n            if (key === 'readFile') {\n                return (fileName) => {\n                    if (!fileName.endsWith('/package.json') && !extendConfigPaths.includes(fileName)) {\n                        extendConfigPaths.push(fileName);\n                    }\n                    return target.readFile(fileName);\n                };\n            }\n            return target[key];\n        }\n    });\n    return {\n        host,\n        extendConfigPaths,\n    };\n}\nfunction getPartialVueCompilerOptions(ts, tsConfigSourceFile) {\n    const folder = path_browserify_1.posix.dirname(tsConfigSourceFile.fileName);\n    const obj = ts.convertToObject(tsConfigSourceFile, []);\n    const rawOptions = obj?.vueCompilerOptions ?? {};\n    const result = {\n        ...rawOptions,\n    };\n    const target = rawOptions.target ?? 'auto';\n    if (target === 'auto') {\n        const resolvedPath = resolvePath('vue/package.json');\n        if (resolvedPath) {\n            const vuePackageJson = require(resolvedPath);\n            const versionNumbers = vuePackageJson.version.split('.');\n            result.target = Number(versionNumbers[0] + '.' + versionNumbers[1]);\n        }\n        else {\n            // console.warn('Load vue/package.json failed from', folder);\n        }\n    }\n    else {\n        result.target = target;\n    }\n    if (rawOptions.plugins) {\n        const plugins = rawOptions.plugins\n            .map((pluginPath) => {\n            try {\n                const resolvedPath = resolvePath(pluginPath);\n                if (resolvedPath) {\n                    const plugin = require(resolvedPath);\n                    plugin.__moduleName = pluginPath;\n                    return plugin;\n                }\n                else {\n                    console.warn('[Vue] Load plugin failed:', pluginPath);\n                }\n            }\n            catch (error) {\n                console.warn('[Vue] Resolve plugin path failed:', pluginPath, error);\n            }\n            return [];\n        });\n        result.plugins = plugins;\n    }\n    return result;\n    function resolvePath(scriptPath) {\n        try {\n            if (require?.resolve) {\n                return require.resolve(scriptPath, { paths: [folder] });\n            }\n            else {\n                // console.warn('failed to resolve path:', scriptPath, 'require.resolve is not supported in web');\n            }\n        }\n        catch (error) {\n            // console.warn(error);\n        }\n    }\n}\nfunction resolveVueCompilerOptions(vueOptions) {\n    const target = vueOptions.target ?? 3.3;\n    const lib = vueOptions.lib ?? 'vue';\n    return {\n        ...vueOptions,\n        target,\n        extensions: vueOptions.extensions ?? ['.vue'],\n        vitePressExtensions: vueOptions.vitePressExtensions ?? [],\n        petiteVueExtensions: vueOptions.petiteVueExtensions ?? [],\n        lib,\n        jsxSlots: vueOptions.jsxSlots ?? false,\n        strictTemplates: vueOptions.strictTemplates ?? false,\n        skipTemplateCodegen: vueOptions.skipTemplateCodegen ?? false,\n        fallthroughAttributes: vueOptions.fallthroughAttributes ?? false,\n        dataAttributes: vueOptions.dataAttributes ?? [],\n        htmlAttributes: vueOptions.htmlAttributes ?? ['aria-*'],\n        optionsWrapper: vueOptions.optionsWrapper ?? (target >= 2.7\n            ? [`(await import('${lib}')).defineComponent(`, `)`]\n            : [`(await import('${lib}')).default.extend(`, `)`]),\n        macros: {\n            defineProps: ['defineProps'],\n            defineSlots: ['defineSlots'],\n            defineEmits: ['defineEmits'],\n            defineExpose: ['defineExpose'],\n            defineModel: ['defineModel'],\n            defineOptions: ['defineOptions'],\n            withDefaults: ['withDefaults'],\n            ...vueOptions.macros,\n        },\n        composibles: {\n            useCssModule: ['useCssModule'],\n            useTemplateRef: ['useTemplateRef', 'templateRef'],\n            ...vueOptions.composibles,\n        },\n        plugins: vueOptions.plugins ?? [],\n        // experimental\n        experimentalDefinePropProposal: vueOptions.experimentalDefinePropProposal ?? false,\n        experimentalResolveStyleCssClasses: vueOptions.experimentalResolveStyleCssClasses ?? 'scoped',\n        // https://github.com/vuejs/vue-next/blob/master/packages/compiler-dom/src/transforms/vModel.ts#L49-L51\n        // https://vuejs.org/guide/essentials/forms.html#form-input-bindings\n        experimentalModelPropName: Object.fromEntries(Object.entries(vueOptions.experimentalModelPropName ?? {\n            '': {\n                input: true\n            },\n            value: {\n                input: { type: 'text' },\n                textarea: true,\n                select: true\n            }\n        }).map(([k, v]) => [(0, shared_1.camelize)(k), v])),\n    };\n}\nfunction setupGlobalTypes(rootDir, vueOptions, host) {\n    if (!host.writeFile) {\n        return;\n    }\n    try {\n        let dir = rootDir;\n        while (!host.fileExists(path_browserify_1.posix.join(dir, 'node_modules', vueOptions.lib, 'package.json'))) {\n            const parentDir = path_browserify_1.posix.dirname(dir);\n            if (dir === parentDir) {\n                throw 0;\n            }\n            dir = parentDir;\n        }\n        const globalTypesPath = path_browserify_1.posix.join(dir, 'node_modules', '.vue-global-types', `${vueOptions.lib}_${vueOptions.target}_${vueOptions.strictTemplates}.d.ts`);\n        const globalTypesContents = `// @ts-nocheck\\nexport {};\\n` + (0, globalTypes_1.generateGlobalTypes)(vueOptions.lib, vueOptions.target, vueOptions.strictTemplates);\n        host.writeFile(globalTypesPath, globalTypesContents);\n        return { absolutePath: globalTypesPath };\n    }\n    catch { }\n}\n//# sourceMappingURL=ts.js.map", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tsCodegen = exports.scriptRanges = void 0;\n__exportStar(require(\"./lib/codegen/globalTypes\"), exports);\n__exportStar(require(\"./lib/codegen/template\"), exports);\n__exportStar(require(\"./lib/languagePlugin\"), exports);\n__exportStar(require(\"./lib/parsers/scriptSetupRanges\"), exports);\n__exportStar(require(\"./lib/plugins\"), exports);\n__exportStar(require(\"./lib/types\"), exports);\n__exportStar(require(\"./lib/utils/parseSfc\"), exports);\n__exportStar(require(\"./lib/utils/ts\"), exports);\n__exportStar(require(\"./lib/virtualFile/vueFile\"), exports);\nexports.scriptRanges = require(\"./lib/parsers/scriptRanges\");\nvar vue_tsx_1 = require(\"./lib/plugins/vue-tsx\");\nObject.defineProperty(exports, \"tsCodegen\", { enumerable: true, get: function () { return vue_tsx_1.tsCodegen; } });\n__exportStar(require(\"./lib/utils/shared\"), exports);\n__exportStar(require(\"@volar/language-core\"), exports);\n//# sourceMappingURL=index.js.map", "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n", "/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n", "class ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nexport { ShikiError };\n", "class ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nfunction getHeapMax() {\n  return 2147483648;\n}\nfunction _emscripten_get_now() {\n  return typeof performance !== \"undefined\" ? performance.now() : Date.now();\n}\nconst alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\nasync function main(init) {\n  let wasmMemory;\n  let buffer;\n  const binding = {};\n  function updateGlobalBufferAndViews(buf) {\n    buffer = buf;\n    binding.HEAPU8 = new Uint8Array(buf);\n    binding.HEAPU32 = new Uint32Array(buf);\n  }\n  function _emscripten_memcpy_big(dest, src, num) {\n    binding.HEAPU8.copyWithin(dest, src, src + num);\n  }\n  function emscripten_realloc_buffer(size) {\n    try {\n      wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      return 1;\n    } catch {\n    }\n  }\n  function _emscripten_resize_heap(requestedSize) {\n    const oldSize = binding.HEAPU8.length;\n    requestedSize = requestedSize >>> 0;\n    const maxHeapSize = getHeapMax();\n    if (requestedSize > maxHeapSize)\n      return false;\n    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n      const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n      const replacement = emscripten_realloc_buffer(newSize);\n      if (replacement)\n        return true;\n    }\n    return false;\n  }\n  const UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead = 1024) {\n    const endIdx = idx + maxBytesToRead;\n    let endPtr = idx;\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx))\n      ++endPtr;\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n    }\n    let str = \"\";\n    while (idx < endPtr) {\n      let u0 = heapOrArray[idx++];\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n      const u1 = heapOrArray[idx++] & 63;\n      if ((u0 & 224) === 192) {\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\n        continue;\n      }\n      const u2 = heapOrArray[idx++] & 63;\n      if ((u0 & 240) === 224) {\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n      } else {\n        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0);\n      } else {\n        const ch = u0 - 65536;\n        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n      }\n    }\n    return str;\n  }\n  function UTF8ToString(ptr, maxBytesToRead) {\n    return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : \"\";\n  }\n  const asmLibraryArg = {\n    emscripten_get_now: _emscripten_get_now,\n    emscripten_memcpy_big: _emscripten_memcpy_big,\n    emscripten_resize_heap: _emscripten_resize_heap,\n    fd_write: () => 0\n  };\n  async function createWasm() {\n    const info = {\n      env: asmLibraryArg,\n      wasi_snapshot_preview1: asmLibraryArg\n    };\n    const exports = await init(info);\n    wasmMemory = exports.memory;\n    updateGlobalBufferAndViews(wasmMemory.buffer);\n    Object.assign(binding, exports);\n    binding.UTF8ToString = UTF8ToString;\n  }\n  await createWasm();\n  return binding;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nlet onigBinding = null;\nfunction throwLastOnigError(onigBinding2) {\n  throw new ShikiError(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));\n}\nclass UtfString {\n  constructor(str) {\n    __publicField(this, \"utf16Length\");\n    __publicField(this, \"utf8Length\");\n    __publicField(this, \"utf16Value\");\n    __publicField(this, \"utf8Value\");\n    __publicField(this, \"utf16OffsetToUtf8\");\n    __publicField(this, \"utf8OffsetToUtf16\");\n    const utf16Length = str.length;\n    const utf8Length = UtfString._utf8ByteLength(str);\n    const computeIndicesMapping = utf8Length !== utf16Length;\n    const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;\n    if (computeIndicesMapping)\n      utf16OffsetToUtf8[utf16Length] = utf8Length;\n    const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;\n    if (computeIndicesMapping)\n      utf8OffsetToUtf16[utf8Length] = utf16Length;\n    const utf8Value = new Uint8Array(utf8Length);\n    let i8 = 0;\n    for (let i16 = 0; i16 < utf16Length; i16++) {\n      const charCode = str.charCodeAt(i16);\n      let codePoint = charCode;\n      let wasSurrogatePair = false;\n      if (charCode >= 55296 && charCode <= 56319) {\n        if (i16 + 1 < utf16Length) {\n          const nextCharCode = str.charCodeAt(i16 + 1);\n          if (nextCharCode >= 56320 && nextCharCode <= 57343) {\n            codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;\n            wasSurrogatePair = true;\n          }\n        }\n      }\n      if (computeIndicesMapping) {\n        utf16OffsetToUtf8[i16] = i8;\n        if (wasSurrogatePair)\n          utf16OffsetToUtf8[i16 + 1] = i8;\n        if (codePoint <= 127) {\n          utf8OffsetToUtf16[i8 + 0] = i16;\n        } else if (codePoint <= 2047) {\n          utf8OffsetToUtf16[i8 + 0] = i16;\n          utf8OffsetToUtf16[i8 + 1] = i16;\n        } else if (codePoint <= 65535) {\n          utf8OffsetToUtf16[i8 + 0] = i16;\n          utf8OffsetToUtf16[i8 + 1] = i16;\n          utf8OffsetToUtf16[i8 + 2] = i16;\n        } else {\n          utf8OffsetToUtf16[i8 + 0] = i16;\n          utf8OffsetToUtf16[i8 + 1] = i16;\n          utf8OffsetToUtf16[i8 + 2] = i16;\n          utf8OffsetToUtf16[i8 + 3] = i16;\n        }\n      }\n      if (codePoint <= 127) {\n        utf8Value[i8++] = codePoint;\n      } else if (codePoint <= 2047) {\n        utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;\n        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;\n      } else if (codePoint <= 65535) {\n        utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;\n        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;\n        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;\n      } else {\n        utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;\n        utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;\n        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;\n        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;\n      }\n      if (wasSurrogatePair)\n        i16++;\n    }\n    this.utf16Length = utf16Length;\n    this.utf8Length = utf8Length;\n    this.utf16Value = str;\n    this.utf8Value = utf8Value;\n    this.utf16OffsetToUtf8 = utf16OffsetToUtf8;\n    this.utf8OffsetToUtf16 = utf8OffsetToUtf16;\n  }\n  static _utf8ByteLength(str) {\n    let result = 0;\n    for (let i = 0, len = str.length; i < len; i++) {\n      const charCode = str.charCodeAt(i);\n      let codepoint = charCode;\n      let wasSurrogatePair = false;\n      if (charCode >= 55296 && charCode <= 56319) {\n        if (i + 1 < len) {\n          const nextCharCode = str.charCodeAt(i + 1);\n          if (nextCharCode >= 56320 && nextCharCode <= 57343) {\n            codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;\n            wasSurrogatePair = true;\n          }\n        }\n      }\n      if (codepoint <= 127)\n        result += 1;\n      else if (codepoint <= 2047)\n        result += 2;\n      else if (codepoint <= 65535)\n        result += 3;\n      else\n        result += 4;\n      if (wasSurrogatePair)\n        i++;\n    }\n    return result;\n  }\n  createString(onigBinding2) {\n    const result = onigBinding2.omalloc(this.utf8Length);\n    onigBinding2.HEAPU8.set(this.utf8Value, result);\n    return result;\n  }\n}\nconst _OnigString = class {\n  constructor(str) {\n    __publicField(this, \"id\", ++_OnigString.LAST_ID);\n    __publicField(this, \"_onigBinding\");\n    __publicField(this, \"content\");\n    __publicField(this, \"utf16Length\");\n    __publicField(this, \"utf8Length\");\n    __publicField(this, \"utf16OffsetToUtf8\");\n    __publicField(this, \"utf8OffsetToUtf16\");\n    __publicField(this, \"ptr\");\n    if (!onigBinding)\n      throw new ShikiError(\"Must invoke loadWasm first.\");\n    this._onigBinding = onigBinding;\n    this.content = str;\n    const utfString = new UtfString(str);\n    this.utf16Length = utfString.utf16Length;\n    this.utf8Length = utfString.utf8Length;\n    this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;\n    this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;\n    if (this.utf8Length < 1e4 && !_OnigString._sharedPtrInUse) {\n      if (!_OnigString._sharedPtr)\n        _OnigString._sharedPtr = onigBinding.omalloc(1e4);\n      _OnigString._sharedPtrInUse = true;\n      onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString._sharedPtr);\n      this.ptr = _OnigString._sharedPtr;\n    } else {\n      this.ptr = utfString.createString(onigBinding);\n    }\n  }\n  convertUtf8OffsetToUtf16(utf8Offset) {\n    if (this.utf8OffsetToUtf16) {\n      if (utf8Offset < 0)\n        return 0;\n      if (utf8Offset > this.utf8Length)\n        return this.utf16Length;\n      return this.utf8OffsetToUtf16[utf8Offset];\n    }\n    return utf8Offset;\n  }\n  convertUtf16OffsetToUtf8(utf16Offset) {\n    if (this.utf16OffsetToUtf8) {\n      if (utf16Offset < 0)\n        return 0;\n      if (utf16Offset > this.utf16Length)\n        return this.utf8Length;\n      return this.utf16OffsetToUtf8[utf16Offset];\n    }\n    return utf16Offset;\n  }\n  dispose() {\n    if (this.ptr === _OnigString._sharedPtr)\n      _OnigString._sharedPtrInUse = false;\n    else\n      this._onigBinding.ofree(this.ptr);\n  }\n};\nlet OnigString = _OnigString;\n__publicField(OnigString, \"LAST_ID\", 0);\n__publicField(OnigString, \"_sharedPtr\", 0);\n// a pointer to a string of 10000 bytes\n__publicField(OnigString, \"_sharedPtrInUse\", false);\nclass OnigScanner {\n  constructor(patterns) {\n    __publicField(this, \"_onigBinding\");\n    __publicField(this, \"_ptr\");\n    if (!onigBinding)\n      throw new ShikiError(\"Must invoke loadWasm first.\");\n    const strPtrsArr = [];\n    const strLenArr = [];\n    for (let i = 0, len = patterns.length; i < len; i++) {\n      const utfString = new UtfString(patterns[i]);\n      strPtrsArr[i] = utfString.createString(onigBinding);\n      strLenArr[i] = utfString.utf8Length;\n    }\n    const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);\n    onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);\n    const strLenPtr = onigBinding.omalloc(4 * patterns.length);\n    onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);\n    const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);\n    for (let i = 0, len = patterns.length; i < len; i++)\n      onigBinding.ofree(strPtrsArr[i]);\n    onigBinding.ofree(strLenPtr);\n    onigBinding.ofree(strPtrsPtr);\n    if (scannerPtr === 0)\n      throwLastOnigError(onigBinding);\n    this._onigBinding = onigBinding;\n    this._ptr = scannerPtr;\n  }\n  dispose() {\n    this._onigBinding.freeOnigScanner(this._ptr);\n  }\n  findNextMatchSync(string, startPosition, arg) {\n    let options = 0 /* None */;\n    if (typeof arg === \"number\") {\n      options = arg;\n    }\n    if (typeof string === \"string\") {\n      string = new OnigString(string);\n      const result = this._findNextMatchSync(string, startPosition, false, options);\n      string.dispose();\n      return result;\n    }\n    return this._findNextMatchSync(string, startPosition, false, options);\n  }\n  _findNextMatchSync(string, startPosition, debugCall, options) {\n    const onigBinding2 = this._onigBinding;\n    const resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);\n    if (resultPtr === 0) {\n      return null;\n    }\n    const HEAPU32 = onigBinding2.HEAPU32;\n    let offset = resultPtr / 4;\n    const index = HEAPU32[offset++];\n    const count = HEAPU32[offset++];\n    const captureIndices = [];\n    for (let i = 0; i < count; i++) {\n      const beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);\n      const end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);\n      captureIndices[i] = {\n        start: beg,\n        end,\n        length: end - beg\n      };\n    }\n    return {\n      index,\n      captureIndices\n    };\n  }\n}\nfunction isInstantiatorOptionsObject(dataOrOptions) {\n  return typeof dataOrOptions.instantiator === \"function\";\n}\nfunction isInstantiatorModule(dataOrOptions) {\n  return typeof dataOrOptions.default === \"function\";\n}\nfunction isDataOptionsObject(dataOrOptions) {\n  return typeof dataOrOptions.data !== \"undefined\";\n}\nfunction isResponse(dataOrOptions) {\n  return typeof Response !== \"undefined\" && dataOrOptions instanceof Response;\n}\nfunction isArrayBuffer(data) {\n  return typeof ArrayBuffer !== \"undefined\" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer !== \"undefined\" && Buffer.isBuffer?.(data) || typeof SharedArrayBuffer !== \"undefined\" && data instanceof SharedArrayBuffer || typeof Uint32Array !== \"undefined\" && data instanceof Uint32Array;\n}\nlet initPromise;\nfunction loadWasm(options) {\n  if (initPromise)\n    return initPromise;\n  async function _load() {\n    onigBinding = await main(async (info) => {\n      let instance = options;\n      instance = await instance;\n      if (typeof instance === \"function\")\n        instance = await instance(info);\n      if (typeof instance === \"function\")\n        instance = await instance(info);\n      if (isInstantiatorOptionsObject(instance)) {\n        instance = await instance.instantiator(info);\n      } else if (isInstantiatorModule(instance)) {\n        instance = await instance.default(info);\n      } else {\n        if (isDataOptionsObject(instance))\n          instance = instance.data;\n        if (isResponse(instance)) {\n          if (typeof WebAssembly.instantiateStreaming === \"function\")\n            instance = await _makeResponseStreamingLoader(instance)(info);\n          else\n            instance = await _makeResponseNonStreamingLoader(instance)(info);\n        } else if (isArrayBuffer(instance)) {\n          instance = await _makeArrayBufferLoader(instance)(info);\n        } else if (instance instanceof WebAssembly.Module) {\n          instance = await _makeArrayBufferLoader(instance)(info);\n        } else if (\"default\" in instance && instance.default instanceof WebAssembly.Module) {\n          instance = await _makeArrayBufferLoader(instance.default)(info);\n        }\n      }\n      if (\"instance\" in instance)\n        instance = instance.instance;\n      if (\"exports\" in instance)\n        instance = instance.exports;\n      return instance;\n    });\n  }\n  initPromise = _load();\n  return initPromise;\n}\nfunction _makeArrayBufferLoader(data) {\n  return (importObject) => WebAssembly.instantiate(data, importObject);\n}\nfunction _makeResponseStreamingLoader(data) {\n  return (importObject) => WebAssembly.instantiateStreaming(data, importObject);\n}\nfunction _makeResponseNonStreamingLoader(data) {\n  return async (importObject) => {\n    const arrayBuffer = await data.arrayBuffer();\n    return WebAssembly.instantiate(arrayBuffer, importObject);\n  };\n}\n\nlet _defaultWasmLoader;\nfunction setDefaultWasmLoader(_loader) {\n  _defaultWasmLoader = _loader;\n}\nfunction getDefaultWasmLoader() {\n  return _defaultWasmLoader;\n}\nasync function createOnigurumaEngine(options) {\n  if (options)\n    await loadWasm(options);\n  return {\n    createScanner(patterns) {\n      return new OnigScanner(patterns.map((p) => typeof p === \"string\" ? p : p.source));\n    },\n    createString(s) {\n      return new OnigString(s);\n    }\n  };\n}\nasync function createWasmOnigEngine(options) {\n  return createOnigurumaEngine(options);\n}\n\nexport { createOnigurumaEngine, createWasmOnigEngine, getDefaultWasmLoader, loadWasm, setDefaultWasmLoader };\n", "let _emitDeprecation = false;\nlet _emitError = false;\nfunction enableDeprecationWarnings(emitDeprecation = true, emitError = false) {\n  _emitDeprecation = emitDeprecation;\n  _emitError = emitError;\n}\nfunction warnDeprecated(message, version = 3) {\n  if (!_emitDeprecation)\n    return;\n  if (typeof _emitDeprecation === \"number\" && version > _emitDeprecation)\n    return;\n  if (_emitError) {\n    throw new Error(`[SHIKI DEPRECATE]: ${message}`);\n  } else {\n    console.trace(`[SHIKI DEPRECATE]: ${message}`);\n  }\n}\n\nexport { enableDeprecationWarnings as e, warnDeprecated as w };\n", "/**\n * List of HTML void tag names.\n *\n * @type {Array<string>}\n */\nexport const htmlVoidElements = [\n  'area',\n  'base',\n  'basefont',\n  'bgsound',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'frame',\n  'hr',\n  'image',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr'\n]\n", "/**\n * @import {Schema as SchemaType, Space} from 'property-information'\n */\n\n/** @type {SchemaType} */\nexport class Schema {\n  /**\n   * @param {SchemaType['property']} property\n   *   Property.\n   * @param {SchemaType['normal']} normal\n   *   Normal.\n   * @param {Space | undefined} [space]\n   *   Space.\n   * @returns\n   *   Schema.\n   */\n  constructor(property, normal, space) {\n    this.normal = normal\n    this.property = property\n\n    if (space) {\n      this.space = space\n    }\n  }\n}\n\nSchema.prototype.normal = {}\nSchema.prototype.property = {}\nSchema.prototype.space = undefined\n", "/**\n * @import {Info, Space} from 'property-information'\n */\n\nimport {Schema} from './schema.js'\n\n/**\n * @param {ReadonlyArray<Schema>} definitions\n *   Definitions.\n * @param {Space | undefined} [space]\n *   Space.\n * @returns {Schema}\n *   Schema.\n */\nexport function merge(definitions, space) {\n  /** @type {Record<string, Info>} */\n  const property = {}\n  /** @type {Record<string, string>} */\n  const normal = {}\n\n  for (const definition of definitions) {\n    Object.assign(property, definition.property)\n    Object.assign(normal, definition.normal)\n  }\n\n  return new Schema(property, normal, space)\n}\n", "/**\n * Get the cleaned case insensitive form of an attribute or property.\n *\n * @param {string} value\n *   An attribute-like or property-like name.\n * @returns {string}\n *   Value that can be used to look up the properly cased property on a\n *   `Schema`.\n */\nexport function normalize(value) {\n  return value.toLowerCase()\n}\n", "/**\n * @import {Info as InfoType} from 'property-information'\n */\n\n/** @type {InfoType} */\nexport class Info {\n  /**\n   * @param {string} property\n   *   Property.\n   * @param {string} attribute\n   *   Attribute.\n   * @returns\n   *   Info.\n   */\n  constructor(property, attribute) {\n    this.attribute = attribute\n    this.property = property\n  }\n}\n\nInfo.prototype.attribute = ''\nInfo.prototype.booleanish = false\nInfo.prototype.boolean = false\nInfo.prototype.commaOrSpaceSeparated = false\nInfo.prototype.commaSeparated = false\nInfo.prototype.defined = false\nInfo.prototype.mustUseProperty = false\nInfo.prototype.number = false\nInfo.prototype.overloadedBoolean = false\nInfo.prototype.property = ''\nInfo.prototype.spaceSeparated = false\nInfo.prototype.space = undefined\n", "let powers = 0\n\nexport const boolean = increment()\nexport const booleanish = increment()\nexport const overloadedBoolean = increment()\nexport const number = increment()\nexport const spaceSeparated = increment()\nexport const commaSeparated = increment()\nexport const commaOrSpaceSeparated = increment()\n\nfunction increment() {\n  return 2 ** ++powers\n}\n", "/**\n * @import {Space} from 'property-information'\n */\n\nimport {Info} from './info.js'\nimport * as types from './types.js'\n\nconst checks = /** @type {ReadonlyArray<keyof typeof types>} */ (\n  Object.keys(types)\n)\n\nexport class DefinedInfo extends Info {\n  /**\n   * @constructor\n   * @param {string} property\n   *   Property.\n   * @param {string} attribute\n   *   Attribute.\n   * @param {number | null | undefined} [mask]\n   *   Mask.\n   * @param {Space | undefined} [space]\n   *   Space.\n   * @returns\n   *   Info.\n   */\n  constructor(property, attribute, mask, space) {\n    let index = -1\n\n    super(property, attribute)\n\n    mark(this, 'space', space)\n\n    if (typeof mask === 'number') {\n      while (++index < checks.length) {\n        const check = checks[index]\n        mark(this, checks[index], (mask & types[check]) === types[check])\n      }\n    }\n  }\n}\n\nDefinedInfo.prototype.defined = true\n\n/**\n * @template {keyof DefinedInfo} Key\n *   Key type.\n * @param {DefinedInfo} values\n *   Info.\n * @param {Key} key\n *   Key.\n * @param {DefinedInfo[Key]} value\n *   Value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction mark(values, key, value) {\n  if (value) {\n    values[key] = value\n  }\n}\n", "/**\n * @import {Info, Space} from 'property-information'\n */\n\n/**\n * @typedef Definition\n *   Definition of a schema.\n * @property {Record<string, string> | undefined} [attributes]\n *   Normalzed names to special attribute case.\n * @property {ReadonlyArray<string> | undefined} [mustUseProperty]\n *   Normalized names that must be set as properties.\n * @property {Record<string, number | null>} properties\n *   Property names to their types.\n * @property {Space | undefined} [space]\n *   Space.\n * @property {Transform} transform\n *   Transform a property name.\n */\n\n/**\n * @callback Transform\n *   Transform.\n * @param {Record<string, string>} attributes\n *   Attributes.\n * @param {string} property\n *   Property.\n * @returns {string}\n *   Attribute.\n */\n\nimport {normalize} from '../normalize.js'\nimport {DefinedInfo} from './defined-info.js'\nimport {Schema} from './schema.js'\n\n/**\n * @param {Definition} definition\n *   Definition.\n * @returns {Schema}\n *   Schema.\n */\nexport function create(definition) {\n  /** @type {Record<string, Info>} */\n  const properties = {}\n  /** @type {Record<string, string>} */\n  const normals = {}\n\n  for (const [property, value] of Object.entries(definition.properties)) {\n    const info = new DefinedInfo(\n      property,\n      definition.transform(definition.attributes || {}, property),\n      value,\n      definition.space\n    )\n\n    if (\n      definition.mustUseProperty &&\n      definition.mustUseProperty.includes(property)\n    ) {\n      info.mustUseProperty = true\n    }\n\n    properties[property] = info\n\n    normals[normalize(property)] = property\n    normals[normalize(info.attribute)] = property\n  }\n\n  return new Schema(properties, normals, definition.space)\n}\n", "import {create} from './util/create.js'\nimport {booleanish, number, spaceSeparated} from './util/types.js'\n\nexport const aria = create({\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: booleanish,\n    ariaAutoComplete: null,\n    ariaBusy: booleanish,\n    ariaChecked: booleanish,\n    ariaColCount: number,\n    ariaColIndex: number,\n    ariaColSpan: number,\n    ariaControls: spaceSeparated,\n    ariaCurrent: null,\n    ariaDescribedBy: spaceSeparated,\n    ariaDetails: null,\n    ariaDisabled: booleanish,\n    ariaDropEffect: spaceSeparated,\n    ariaErrorMessage: null,\n    ariaExpanded: booleanish,\n    ariaFlowTo: spaceSeparated,\n    ariaGrabbed: booleanish,\n    ariaHasPopup: null,\n    ariaHidden: booleanish,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: spaceSeparated,\n    ariaLevel: number,\n    ariaLive: null,\n    ariaModal: booleanish,\n    ariaMultiLine: booleanish,\n    ariaMultiSelectable: booleanish,\n    ariaOrientation: null,\n    ariaOwns: spaceSeparated,\n    ariaPlaceholder: null,\n    ariaPosInSet: number,\n    ariaPressed: booleanish,\n    ariaReadOnly: booleanish,\n    ariaRelevant: null,\n    ariaRequired: booleanish,\n    ariaRoleDescription: spaceSeparated,\n    ariaRowCount: number,\n    ariaRowIndex: number,\n    ariaRowSpan: number,\n    ariaSelected: booleanish,\n    ariaSetSize: number,\n    ariaSort: null,\n    ariaValueMax: number,\n    ariaValueMin: number,\n    ariaValueNow: number,\n    ariaValueText: null,\n    role: null\n  },\n  transform(_, property) {\n    return property === 'role'\n      ? property\n      : 'aria-' + property.slice(4).toLowerCase()\n  }\n})\n", "/**\n * @param {Record<string, string>} attributes\n *   Attributes.\n * @param {string} attribute\n *   Attribute.\n * @returns {string}\n *   Transformed attribute.\n */\nexport function caseSensitiveTransform(attributes, attribute) {\n  return attribute in attributes ? attributes[attribute] : attribute\n}\n", "import {caseSensitiveTransform} from './case-sensitive-transform.js'\n\n/**\n * @param {Record<string, string>} attributes\n *   Attributes.\n * @param {string} property\n *   Property.\n * @returns {string}\n *   Transformed property.\n */\nexport function caseInsensitiveTransform(attributes, property) {\n  return caseSensitiveTransform(attributes, property.toLowerCase())\n}\n", "import {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\nimport {create} from './util/create.js'\nimport {\n  booleanish,\n  boolean,\n  commaSeparated,\n  number,\n  overloadedBoolean,\n  spaceSeparated\n} from './util/types.js'\n\nexport const html = create({\n  attributes: {\n    acceptcharset: 'accept-charset',\n    classname: 'class',\n    htmlfor: 'for',\n    httpequiv: 'http-equiv'\n  },\n  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: commaSeparated,\n    acceptCharset: spaceSeparated,\n    accessKey: spaceSeparated,\n    action: null,\n    allow: null,\n    allowFullScreen: boolean,\n    allowPaymentRequest: boolean,\n    allowUserMedia: boolean,\n    alt: null,\n    as: null,\n    async: boolean,\n    autoCapitalize: null,\n    autoComplete: spaceSeparated,\n    autoFocus: boolean,\n    autoPlay: boolean,\n    blocking: spaceSeparated,\n    capture: null,\n    charSet: null,\n    checked: boolean,\n    cite: null,\n    className: spaceSeparated,\n    cols: number,\n    colSpan: null,\n    content: null,\n    contentEditable: booleanish,\n    controls: boolean,\n    controlsList: spaceSeparated,\n    coords: number | commaSeparated,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: boolean,\n    defer: boolean,\n    dir: null,\n    dirName: null,\n    disabled: boolean,\n    download: overloadedBoolean,\n    draggable: booleanish,\n    encType: null,\n    enterKeyHint: null,\n    fetchPriority: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: boolean,\n    formTarget: null,\n    headers: spaceSeparated,\n    height: number,\n    hidden: overloadedBoolean,\n    high: number,\n    href: null,\n    hrefLang: null,\n    htmlFor: spaceSeparated,\n    httpEquiv: spaceSeparated,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inert: boolean,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: boolean,\n    itemId: null,\n    itemProp: spaceSeparated,\n    itemRef: spaceSeparated,\n    itemScope: boolean,\n    itemType: spaceSeparated,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: boolean,\n    low: number,\n    manifest: null,\n    max: null,\n    maxLength: number,\n    media: null,\n    method: null,\n    min: null,\n    minLength: number,\n    multiple: boolean,\n    muted: boolean,\n    name: null,\n    nonce: null,\n    noModule: boolean,\n    noValidate: boolean,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeToggle: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: boolean,\n    optimum: number,\n    pattern: null,\n    ping: spaceSeparated,\n    placeholder: null,\n    playsInline: boolean,\n    popover: null,\n    popoverTarget: null,\n    popoverTargetAction: null,\n    poster: null,\n    preload: null,\n    readOnly: boolean,\n    referrerPolicy: null,\n    rel: spaceSeparated,\n    required: boolean,\n    reversed: boolean,\n    rows: number,\n    rowSpan: number,\n    sandbox: spaceSeparated,\n    scope: null,\n    scoped: boolean,\n    seamless: boolean,\n    selected: boolean,\n    shadowRootClonable: boolean,\n    shadowRootDelegatesFocus: boolean,\n    shadowRootMode: null,\n    shape: null,\n    size: number,\n    sizes: null,\n    slot: null,\n    span: number,\n    spellCheck: booleanish,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: number,\n    step: null,\n    style: null,\n    tabIndex: number,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: boolean,\n    useMap: null,\n    value: booleanish,\n    width: number,\n    wrap: null,\n    writingSuggestions: null,\n\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null, // Several. Use CSS `text-align` instead,\n    aLink: null, // `<body>`. Use CSS `a:active {color}` instead\n    archive: spaceSeparated, // `<object>`. List of URIs to archives\n    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null, // `<body>`. Use CSS `background-image` instead\n    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead\n    border: number, // `<table>`. Use CSS `border-width` instead,\n    borderColor: null, // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: number, // `<body>`\n    cellPadding: null, // `<table>`\n    cellSpacing: null, // `<table>`\n    char: null, // Several table elements. When `align=char`, sets the character to align on\n    charOff: null, // Several table elements. When `char`, offsets the alignment\n    classId: null, // `<object>`\n    clear: null, // `<br>`. Use CSS `clear` instead\n    code: null, // `<object>`\n    codeBase: null, // `<object>`\n    codeType: null, // `<object>`\n    color: null, // `<font>` and `<hr>`. Use CSS instead\n    compact: boolean, // Lists. Use CSS to reduce space between items instead\n    declare: boolean, // `<object>`\n    event: null, // `<script>`\n    face: null, // `<font>`. Use CSS instead\n    frame: null, // `<table>`\n    frameBorder: null, // `<iframe>`. Use CSS `border` instead\n    hSpace: number, // `<img>` and `<object>`\n    leftMargin: number, // `<body>`\n    link: null, // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null, // `<img>`. Use a `<picture>`\n    marginHeight: number, // `<body>`\n    marginWidth: number, // `<body>`\n    noResize: boolean, // `<frame>`\n    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: boolean, // `<hr>`. Use background-color and height instead of borders\n    noWrap: boolean, // `<td>` and `<th>`\n    object: null, // `<applet>`\n    profile: null, // `<head>`\n    prompt: null, // `<isindex>`\n    rev: null, // `<link>`\n    rightMargin: number, // `<body>`\n    rules: null, // `<table>`\n    scheme: null, // `<meta>`\n    scrolling: booleanish, // `<frame>`. Use overflow in the child context\n    standby: null, // `<object>`\n    summary: null, // `<table>`\n    text: null, // `<body>`. Use CSS `color` instead\n    topMargin: number, // `<body>`\n    valueType: null, // `<param>`\n    version: null, // `<html>`. Use a doctype.\n    vAlign: null, // Several. Use CSS `vertical-align` instead\n    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: number, // `<img>` and `<object>`\n\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: boolean,\n    disableRemotePlayback: boolean,\n    prefix: null,\n    property: null,\n    results: number,\n    security: null,\n    unselectable: null\n  },\n  space: 'html',\n  transform: caseInsensitiveTransform\n})\n", "import {caseSensitiveTransform} from './util/case-sensitive-transform.js'\nimport {create} from './util/create.js'\nimport {\n  boolean,\n  commaOrSpaceSeparated,\n  commaSeparated,\n  number,\n  spaceSeparated\n} from './util/types.js'\n\nexport const svg = create({\n  attributes: {\n    accentHeight: 'accent-height',\n    alignmentBaseline: 'alignment-baseline',\n    arabicForm: 'arabic-form',\n    baselineShift: 'baseline-shift',\n    capHeight: 'cap-height',\n    className: 'class',\n    clipPath: 'clip-path',\n    clipRule: 'clip-rule',\n    colorInterpolation: 'color-interpolation',\n    colorInterpolationFilters: 'color-interpolation-filters',\n    colorProfile: 'color-profile',\n    colorRendering: 'color-rendering',\n    crossOrigin: 'crossorigin',\n    dataType: 'datatype',\n    dominantBaseline: 'dominant-baseline',\n    enableBackground: 'enable-background',\n    fillOpacity: 'fill-opacity',\n    fillRule: 'fill-rule',\n    floodColor: 'flood-color',\n    floodOpacity: 'flood-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    fontSizeAdjust: 'font-size-adjust',\n    fontStretch: 'font-stretch',\n    fontStyle: 'font-style',\n    fontVariant: 'font-variant',\n    fontWeight: 'font-weight',\n    glyphName: 'glyph-name',\n    glyphOrientationHorizontal: 'glyph-orientation-horizontal',\n    glyphOrientationVertical: 'glyph-orientation-vertical',\n    hrefLang: 'hreflang',\n    horizAdvX: 'horiz-adv-x',\n    horizOriginX: 'horiz-origin-x',\n    horizOriginY: 'horiz-origin-y',\n    imageRendering: 'image-rendering',\n    letterSpacing: 'letter-spacing',\n    lightingColor: 'lighting-color',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    navDown: 'nav-down',\n    navDownLeft: 'nav-down-left',\n    navDownRight: 'nav-down-right',\n    navLeft: 'nav-left',\n    navNext: 'nav-next',\n    navPrev: 'nav-prev',\n    navRight: 'nav-right',\n    navUp: 'nav-up',\n    navUpLeft: 'nav-up-left',\n    navUpRight: 'nav-up-right',\n    onAbort: 'onabort',\n    onActivate: 'onactivate',\n    onAfterPrint: 'onafterprint',\n    onBeforePrint: 'onbeforeprint',\n    onBegin: 'onbegin',\n    onCancel: 'oncancel',\n    onCanPlay: 'oncanplay',\n    onCanPlayThrough: 'oncanplaythrough',\n    onChange: 'onchange',\n    onClick: 'onclick',\n    onClose: 'onclose',\n    onCopy: 'oncopy',\n    onCueChange: 'oncuechange',\n    onCut: 'oncut',\n    onDblClick: 'ondblclick',\n    onDrag: 'ondrag',\n    onDragEnd: 'ondragend',\n    onDragEnter: 'ondragenter',\n    onDragExit: 'ondragexit',\n    onDragLeave: 'ondragleave',\n    onDragOver: 'ondragover',\n    onDragStart: 'ondragstart',\n    onDrop: 'ondrop',\n    onDurationChange: 'ondurationchange',\n    onEmptied: 'onemptied',\n    onEnd: 'onend',\n    onEnded: 'onended',\n    onError: 'onerror',\n    onFocus: 'onfocus',\n    onFocusIn: 'onfocusin',\n    onFocusOut: 'onfocusout',\n    onHashChange: 'onhashchange',\n    onInput: 'oninput',\n    onInvalid: 'oninvalid',\n    onKeyDown: 'onkeydown',\n    onKeyPress: 'onkeypress',\n    onKeyUp: 'onkeyup',\n    onLoad: 'onload',\n    onLoadedData: 'onloadeddata',\n    onLoadedMetadata: 'onloadedmetadata',\n    onLoadStart: 'onloadstart',\n    onMessage: 'onmessage',\n    onMouseDown: 'onmousedown',\n    onMouseEnter: 'onmouseenter',\n    onMouseLeave: 'onmouseleave',\n    onMouseMove: 'onmousemove',\n    onMouseOut: 'onmouseout',\n    onMouseOver: 'onmouseover',\n    onMouseUp: 'onmouseup',\n    onMouseWheel: 'onmousewheel',\n    onOffline: 'onoffline',\n    onOnline: 'ononline',\n    onPageHide: 'onpagehide',\n    onPageShow: 'onpageshow',\n    onPaste: 'onpaste',\n    onPause: 'onpause',\n    onPlay: 'onplay',\n    onPlaying: 'onplaying',\n    onPopState: 'onpopstate',\n    onProgress: 'onprogress',\n    onRateChange: 'onratechange',\n    onRepeat: 'onrepeat',\n    onReset: 'onreset',\n    onResize: 'onresize',\n    onScroll: 'onscroll',\n    onSeeked: 'onseeked',\n    onSeeking: 'onseeking',\n    onSelect: 'onselect',\n    onShow: 'onshow',\n    onStalled: 'onstalled',\n    onStorage: 'onstorage',\n    onSubmit: 'onsubmit',\n    onSuspend: 'onsuspend',\n    onTimeUpdate: 'ontimeupdate',\n    onToggle: 'ontoggle',\n    onUnload: 'onunload',\n    onVolumeChange: 'onvolumechange',\n    onWaiting: 'onwaiting',\n    onZoom: 'onzoom',\n    overlinePosition: 'overline-position',\n    overlineThickness: 'overline-thickness',\n    paintOrder: 'paint-order',\n    panose1: 'panose-1',\n    pointerEvents: 'pointer-events',\n    referrerPolicy: 'referrerpolicy',\n    renderingIntent: 'rendering-intent',\n    shapeRendering: 'shape-rendering',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strikethroughPosition: 'strikethrough-position',\n    strikethroughThickness: 'strikethrough-thickness',\n    strokeDashArray: 'stroke-dasharray',\n    strokeDashOffset: 'stroke-dashoffset',\n    strokeLineCap: 'stroke-linecap',\n    strokeLineJoin: 'stroke-linejoin',\n    strokeMiterLimit: 'stroke-miterlimit',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    tabIndex: 'tabindex',\n    textAnchor: 'text-anchor',\n    textDecoration: 'text-decoration',\n    textRendering: 'text-rendering',\n    transformOrigin: 'transform-origin',\n    typeOf: 'typeof',\n    underlinePosition: 'underline-position',\n    underlineThickness: 'underline-thickness',\n    unicodeBidi: 'unicode-bidi',\n    unicodeRange: 'unicode-range',\n    unitsPerEm: 'units-per-em',\n    vAlphabetic: 'v-alphabetic',\n    vHanging: 'v-hanging',\n    vIdeographic: 'v-ideographic',\n    vMathematical: 'v-mathematical',\n    vectorEffect: 'vector-effect',\n    vertAdvY: 'vert-adv-y',\n    vertOriginX: 'vert-origin-x',\n    vertOriginY: 'vert-origin-y',\n    wordSpacing: 'word-spacing',\n    writingMode: 'writing-mode',\n    xHeight: 'x-height',\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: 'playbackorder',\n    timelineBegin: 'timelinebegin'\n  },\n  properties: {\n    about: commaOrSpaceSeparated,\n    accentHeight: number,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: number,\n    amplitude: number,\n    arabicForm: null,\n    ascent: number,\n    attributeName: null,\n    attributeType: null,\n    azimuth: number,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: number,\n    by: null,\n    calcMode: null,\n    capHeight: number,\n    className: spaceSeparated,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: number,\n    diffuseConstant: number,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: number,\n    dominantBaseline: null,\n    download: boolean,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: number,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: number,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: number,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: commaSeparated,\n    g2: commaSeparated,\n    glyphName: commaSeparated,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: number,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: number,\n    horizOriginX: number,\n    horizOriginY: number,\n    id: null,\n    ideographic: number,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: number,\n    k: number,\n    k1: number,\n    k2: number,\n    k3: number,\n    k4: number,\n    kernelMatrix: commaOrSpaceSeparated,\n    kernelUnitLength: null,\n    keyPoints: null, // SEMI_COLON_SEPARATED\n    keySplines: null, // SEMI_COLON_SEPARATED\n    keyTimes: null, // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: number,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: number,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: number,\n    overlineThickness: number,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: number,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: spaceSeparated,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: number,\n    pointsAtY: number,\n    pointsAtZ: number,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: commaOrSpaceSeparated,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: commaOrSpaceSeparated,\n    rev: commaOrSpaceSeparated,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: commaOrSpaceSeparated,\n    requiredFeatures: commaOrSpaceSeparated,\n    requiredFonts: commaOrSpaceSeparated,\n    requiredFormats: commaOrSpaceSeparated,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: number,\n    specularExponent: number,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: number,\n    strikethroughThickness: number,\n    string: null,\n    stroke: null,\n    strokeDashArray: commaOrSpaceSeparated,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: number,\n    strokeOpacity: number,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: number,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: commaOrSpaceSeparated,\n    tabIndex: number,\n    tableValues: null,\n    target: null,\n    targetX: number,\n    targetY: number,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: commaOrSpaceSeparated,\n    to: null,\n    transform: null,\n    transformOrigin: null,\n    u1: null,\n    u2: null,\n    underlinePosition: number,\n    underlineThickness: number,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: number,\n    values: null,\n    vAlphabetic: number,\n    vMathematical: number,\n    vectorEffect: null,\n    vHanging: number,\n    vIdeographic: number,\n    version: null,\n    vertAdvY: number,\n    vertOriginX: number,\n    vertOriginY: number,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: number,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  },\n  space: 'svg',\n  transform: caseSensitiveTransform\n})\n", "import {create} from './util/create.js'\n\nexport const xlink = create({\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  },\n  space: 'xlink',\n  transform(_, property) {\n    return 'xlink:' + property.slice(5).toLowerCase()\n  }\n})\n", "import {create} from './util/create.js'\nimport {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\n\nexport const xmlns = create({\n  attributes: {xmlnsxlink: 'xmlns:xlink'},\n  properties: {xmlnsXLink: null, xmlns: null},\n  space: 'xmlns',\n  transform: caseInsensitiveTransform\n})\n", "import {create} from './util/create.js'\n\nexport const xml = create({\n  properties: {xmlBase: null, xmlLang: null, xmlSpace: null},\n  space: 'xml',\n  transform(_, property) {\n    return 'xml:' + property.slice(3).toLowerCase()\n  }\n})\n", "/**\n * @import {Schema} from 'property-information'\n */\n\nimport {DefinedInfo} from './util/defined-info.js'\nimport {Info} from './util/info.js'\nimport {normalize} from './normalize.js'\n\nconst cap = /[A-Z]/g\nconst dash = /-[a-z]/g\nconst valid = /^data[-\\w.:]+$/i\n\n/**\n * Look up info on a property.\n *\n * In most cases the given `schema` contains info on the property.\n * All standard,\n * most legacy,\n * and some non-standard properties are supported.\n * For these cases,\n * the returned `Info` has hints about the value of the property.\n *\n * `name` can also be a valid data attribute or property,\n * in which case an `Info` object with the correctly cased `attribute` and\n * `property` is returned.\n *\n * `name` can be an unknown attribute,\n * in which case an `Info` object with `attribute` and `property` set to the\n * given name is returned.\n * It is not recommended to provide unsupported legacy or recently specced\n * properties.\n *\n *\n * @param {Schema} schema\n *   Schema;\n *   either the `html` or `svg` export.\n * @param {string} value\n *   An attribute-like or property-like name;\n *   it will be passed through `normalize` to hopefully find the correct info.\n * @returns {Info}\n *   Info.\n */\nexport function find(schema, value) {\n  const normal = normalize(value)\n  let property = value\n  let Type = Info\n\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]]\n  }\n\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase)\n      property = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4)\n\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab)\n\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes\n        }\n\n        value = 'data' + dashes\n      }\n    }\n\n    Type = DefinedInfo\n  }\n\n  return new Type(property, value)\n}\n\n/**\n * @param {string} $0\n *   Value.\n * @returns {string}\n *   Kebab.\n */\nfunction kebab($0) {\n  return '-' + $0.toLowerCase()\n}\n\n/**\n * @param {string} $0\n *   Value.\n * @returns {string}\n *   Camel.\n */\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase()\n}\n", "// Note: types exposed from `index.d.ts`.\nimport {merge} from './lib/util/merge.js'\nimport {aria} from './lib/aria.js'\nimport {html as htmlBase} from './lib/html.js'\nimport {svg as svgBase} from './lib/svg.js'\nimport {xlink} from './lib/xlink.js'\nimport {xmlns} from './lib/xmlns.js'\nimport {xml} from './lib/xml.js'\n\nexport {hastToReact} from './lib/hast-to-react.js'\n\nexport const html = merge([aria, htmlBase, xlink, xmlns, xml], 'html')\n\nexport {find} from './lib/find.js'\nexport {normalize} from './lib/normalize.js'\n\nexport const svg = merge([aria, svgBase, xlink, xmlns, xml], 'svg')\n", "/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and its value is this functions\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but its set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesnt have a `key` property, the special\n   * invalid handler will be called.\n   * If `value` has an unknown `key`, the special unknown handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and its result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but its set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n", "/**\n * @typedef CoreOptions\n * @property {ReadonlyArray<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\nconst defaultSubsetRegex = /[\"&'<>`]/g\nconst surrogatePairsRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\nconst controlCharactersRegex =\n  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\nconst regexEscapeRegex = /[|\\\\{}()[\\]^$+*?.]/g\n\n/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */\nconst subsetToRegexCache = new WeakMap()\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset\n      ? charactersToExpressionCached(options.subset)\n      : defaultSubsetRegex,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(surrogatePairsRegex, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(controlCharactersRegex, basic)\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.\n * This can improve performance when tooling calls `charactersToExpression` repeatedly\n * with the same subset.\n *\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpressionCached(subset) {\n  let cached = subsetToRegexCache.get(subset)\n\n  if (!cached) {\n    cached = charactersToExpression(subset)\n    subsetToRegexCache.set(subset, cached)\n  }\n\n  return cached\n}\n\n/**\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(regexEscapeRegex, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n", "const hexadecimalRegex = /[\\dA-Fa-f]/\n\n/**\n * Configurable ways to encode characters as hexadecimal references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @returns {string}\n */\nexport function toHexadecimal(code, next, omit) {\n  const value = '&#x' + code.toString(16).toUpperCase()\n  return omit && next && !hexadecimalRegex.test(String.fromCharCode(next))\n    ? value\n    : value + ';'\n}\n", "const decimalRegex = /\\d/\n\n/**\n * Configurable ways to encode characters as decimal references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @returns {string}\n */\nexport function toDecimal(code, next, omit) {\n  const value = '&#' + String(code)\n  return omit && next && !decimalRegex.test(String.fromCharCode(next))\n    ? value\n    : value + ';'\n}\n", "/**\n * List of legacy HTML named character references that dont need a trailing semicolon.\n *\n * @type {Array<string>}\n */\nexport const characterEntitiesLegacy = [\n  'AElig',\n  'AMP',\n  'Aacute',\n  'Acirc',\n  'Agrave',\n  'Aring',\n  'Atilde',\n  'Auml',\n  'COPY',\n  'Ccedil',\n  'ETH',\n  'Eacute',\n  'Ecirc',\n  'Egrave',\n  'Euml',\n  'GT',\n  'Iacute',\n  'Icirc',\n  'Igrave',\n  'Iuml',\n  'LT',\n  'Ntilde',\n  'Oacute',\n  'Ocirc',\n  'Ograve',\n  'Oslash',\n  'Otilde',\n  'Ouml',\n  'QUOT',\n  'REG',\n  'THORN',\n  'Uacute',\n  'Ucirc',\n  'Ugrave',\n  'Uuml',\n  'Yacute',\n  'aacute',\n  'acirc',\n  'acute',\n  'aelig',\n  'agrave',\n  'amp',\n  'aring',\n  'atilde',\n  'auml',\n  'brvbar',\n  'ccedil',\n  'cedil',\n  'cent',\n  'copy',\n  'curren',\n  'deg',\n  'divide',\n  'eacute',\n  'ecirc',\n  'egrave',\n  'eth',\n  'euml',\n  'frac12',\n  'frac14',\n  'frac34',\n  'gt',\n  'iacute',\n  'icirc',\n  'iexcl',\n  'igrave',\n  'iquest',\n  'iuml',\n  'laquo',\n  'lt',\n  'macr',\n  'micro',\n  'middot',\n  'nbsp',\n  'not',\n  'ntilde',\n  'oacute',\n  'ocirc',\n  'ograve',\n  'ordf',\n  'ordm',\n  'oslash',\n  'otilde',\n  'ouml',\n  'para',\n  'plusmn',\n  'pound',\n  'quot',\n  'raquo',\n  'reg',\n  'sect',\n  'shy',\n  'sup1',\n  'sup2',\n  'sup3',\n  'szlig',\n  'thorn',\n  'times',\n  'uacute',\n  'ucirc',\n  'ugrave',\n  'uml',\n  'uuml',\n  'yacute',\n  'yen',\n  'yuml'\n]\n", "/**\n * Map of named character references from HTML 4.\n *\n * @type {Record<string, string>}\n */\nexport const characterEntitiesHtml4 = {\n  nbsp: '',\n  iexcl: '',\n  cent: '',\n  pound: '',\n  curren: '',\n  yen: '',\n  brvbar: '',\n  sect: '',\n  uml: '',\n  copy: '',\n  ordf: '',\n  laquo: '',\n  not: '',\n  shy: '',\n  reg: '',\n  macr: '',\n  deg: '',\n  plusmn: '',\n  sup2: '',\n  sup3: '',\n  acute: '',\n  micro: '',\n  para: '',\n  middot: '',\n  cedil: '',\n  sup1: '',\n  ordm: '',\n  raquo: '',\n  frac14: '',\n  frac12: '',\n  frac34: '',\n  iquest: '',\n  Agrave: '',\n  Aacute: '',\n  Acirc: '',\n  Atilde: '',\n  Auml: '',\n  Aring: '',\n  AElig: '',\n  Ccedil: '',\n  Egrave: '',\n  Eacute: '',\n  Ecirc: '',\n  Euml: '',\n  Igrave: '',\n  Iacute: '',\n  Icirc: '',\n  Iuml: '',\n  ETH: '',\n  Ntilde: '',\n  Ograve: '',\n  Oacute: '',\n  Ocirc: '',\n  Otilde: '',\n  Ouml: '',\n  times: '',\n  Oslash: '',\n  Ugrave: '',\n  Uacute: '',\n  Ucirc: '',\n  Uuml: '',\n  Yacute: '',\n  THORN: '',\n  szlig: '',\n  agrave: '',\n  aacute: '',\n  acirc: '',\n  atilde: '',\n  auml: '',\n  aring: '',\n  aelig: '',\n  ccedil: '',\n  egrave: '',\n  eacute: '',\n  ecirc: '',\n  euml: '',\n  igrave: '',\n  iacute: '',\n  icirc: '',\n  iuml: '',\n  eth: '',\n  ntilde: '',\n  ograve: '',\n  oacute: '',\n  ocirc: '',\n  otilde: '',\n  ouml: '',\n  divide: '',\n  oslash: '',\n  ugrave: '',\n  uacute: '',\n  ucirc: '',\n  uuml: '',\n  yacute: '',\n  thorn: '',\n  yuml: '',\n  fnof: '',\n  Alpha: '',\n  Beta: '',\n  Gamma: '',\n  Delta: '',\n  Epsilon: '',\n  Zeta: '',\n  Eta: '',\n  Theta: '',\n  Iota: '',\n  Kappa: '',\n  Lambda: '',\n  Mu: '',\n  Nu: '',\n  Xi: '',\n  Omicron: '',\n  Pi: '',\n  Rho: '',\n  Sigma: '',\n  Tau: '',\n  Upsilon: '',\n  Phi: '',\n  Chi: '',\n  Psi: '',\n  Omega: '',\n  alpha: '',\n  beta: '',\n  gamma: '',\n  delta: '',\n  epsilon: '',\n  zeta: '',\n  eta: '',\n  theta: '',\n  iota: '',\n  kappa: '',\n  lambda: '',\n  mu: '',\n  nu: '',\n  xi: '',\n  omicron: '',\n  pi: '',\n  rho: '',\n  sigmaf: '',\n  sigma: '',\n  tau: '',\n  upsilon: '',\n  phi: '',\n  chi: '',\n  psi: '',\n  omega: '',\n  thetasym: '',\n  upsih: '',\n  piv: '',\n  bull: '',\n  hellip: '',\n  prime: '',\n  Prime: '',\n  oline: '',\n  frasl: '',\n  weierp: '',\n  image: '',\n  real: '',\n  trade: '',\n  alefsym: '',\n  larr: '',\n  uarr: '',\n  rarr: '',\n  darr: '',\n  harr: '',\n  crarr: '',\n  lArr: '',\n  uArr: '',\n  rArr: '',\n  dArr: '',\n  hArr: '',\n  forall: '',\n  part: '',\n  exist: '',\n  empty: '',\n  nabla: '',\n  isin: '',\n  notin: '',\n  ni: '',\n  prod: '',\n  sum: '',\n  minus: '',\n  lowast: '',\n  radic: '',\n  prop: '',\n  infin: '',\n  ang: '',\n  and: '',\n  or: '',\n  cap: '',\n  cup: '',\n  int: '',\n  there4: '',\n  sim: '',\n  cong: '',\n  asymp: '',\n  ne: '',\n  equiv: '',\n  le: '',\n  ge: '',\n  sub: '',\n  sup: '',\n  nsub: '',\n  sube: '',\n  supe: '',\n  oplus: '',\n  otimes: '',\n  perp: '',\n  sdot: '',\n  lceil: '',\n  rceil: '',\n  lfloor: '',\n  rfloor: '',\n  lang: '',\n  rang: '',\n  loz: '',\n  spades: '',\n  clubs: '',\n  hearts: '',\n  diams: '',\n  quot: '\"',\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  OElig: '',\n  oelig: '',\n  Scaron: '',\n  scaron: '',\n  Yuml: '',\n  circ: '',\n  tilde: '',\n  ensp: '',\n  emsp: '',\n  thinsp: '',\n  zwnj: '',\n  zwj: '',\n  lrm: '',\n  rlm: '',\n  ndash: '',\n  mdash: '',\n  lsquo: '',\n  rsquo: '',\n  sbquo: '',\n  ldquo: '',\n  rdquo: '',\n  bdquo: '',\n  dagger: '',\n  Dagger: '',\n  permil: '',\n  lsaquo: '',\n  rsaquo: '',\n  euro: ''\n}\n", "/**\n * List of legacy (that dont need a trailing `;`) named references which could,\n * depending on what follows them, turn into a different meaning\n *\n * @type {Array<string>}\n */\nexport const dangerous = [\n  'cent',\n  'copy',\n  'divide',\n  'gt',\n  'lt',\n  'not',\n  'para',\n  'times'\n]\n", "import {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterEntitiesHtml4} from 'character-entities-html4'\nimport {dangerous} from '../constant/dangerous.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * `characterEntitiesHtml4` but inverted.\n *\n * @type {Record<string, string>}\n */\nconst characters = {}\n\n/** @type {string} */\nlet key\n\nfor (key in characterEntitiesHtml4) {\n  if (own.call(characterEntitiesHtml4, key)) {\n    characters[characterEntitiesHtml4[key]] = key\n  }\n}\n\nconst notAlphanumericRegex = /[^\\dA-Za-z]/\n\n/**\n * Configurable ways to encode characters as named references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @param {boolean|undefined} attribute\n * @returns {string}\n */\nexport function toNamed(code, next, omit, attribute) {\n  const character = String.fromCharCode(code)\n\n  if (own.call(characters, character)) {\n    const name = characters[character]\n    const value = '&' + name\n\n    if (\n      omit &&\n      characterEntitiesLegacy.includes(name) &&\n      !dangerous.includes(name) &&\n      (!attribute ||\n        (next &&\n          next !== 61 /* `=` */ &&\n          notAlphanumericRegex.test(String.fromCharCode(next))))\n    ) {\n      return value\n    }\n\n    return value + ';'\n  }\n\n  return ''\n}\n", "/**\n * @typedef FormatSmartOptions\n * @property {boolean} [useNamedReferences=false]\n *   Prefer named character references (`&amp;`) where possible.\n * @property {boolean} [useShortestReferences=false]\n *   Prefer the shortest possible reference, if that results in less bytes.\n *   **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.\n * @property {boolean} [omitOptionalSemicolons=false]\n *   Whether to omit semicolons when possible.\n *   **Note**: This creates what HTML calls parse errors but is otherwise still valid HTML  dont use this except when building a minifier.\n *   Omitting semicolons is possible for certain named and numeric references in some cases.\n * @property {boolean} [attribute=false]\n *   Create character references which dont fail in attributes.\n *   **Note**: `attribute` only applies when operating dangerously with\n *   `omitOptionalSemicolons: true`.\n */\n\nimport {toHexadecimal} from './to-hexadecimal.js'\nimport {toDecimal} from './to-decimal.js'\nimport {toNamed} from './to-named.js'\n\n/**\n * Configurable ways to encode a character yielding pretty or small results.\n *\n * @param {number} code\n * @param {number} next\n * @param {FormatSmartOptions} options\n * @returns {string}\n */\nexport function formatSmart(code, next, options) {\n  let numeric = toHexadecimal(code, next, options.omitOptionalSemicolons)\n  /** @type {string|undefined} */\n  let named\n\n  if (options.useNamedReferences || options.useShortestReferences) {\n    named = toNamed(\n      code,\n      next,\n      options.omitOptionalSemicolons,\n      options.attribute\n    )\n  }\n\n  // Use the shortest numeric reference when requested.\n  // A simple algorithm would use decimal for all code points under 100, as\n  // those are shorter than hexadecimal:\n  //\n  // * `&#99;` vs `&#x63;` (decimal shorter)\n  // * `&#100;` vs `&#x64;` (equal)\n  //\n  // However, because we take `next` into consideration when `omit` is used,\n  // And it would be possible that decimals are shorter on bigger values as\n  // well if `next` is hexadecimal but not decimal, we instead compare both.\n  if (\n    (options.useShortestReferences || !named) &&\n    options.useShortestReferences\n  ) {\n    const decimal = toDecimal(code, next, options.omitOptionalSemicolons)\n\n    if (decimal.length < numeric.length) {\n      numeric = decimal\n    }\n  }\n\n  return named &&\n    (!options.useShortestReferences || named.length < numeric.length)\n    ? named\n    : numeric\n}\n", "/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n", "/**\n * @import {Comment, Parents} from 'hast'\n * @import {State} from '../index.js'\n */\n\nimport {stringifyEntities} from 'stringify-entities'\n\nconst htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g\n\n// Declare arrays as variables so it can be cached by `stringifyEntities`\nconst bogusCommentEntitySubset = ['>']\nconst commentEntitySubset = ['<', '>']\n\n/**\n * Serialize a comment.\n *\n * @param {Comment} node\n *   Node to handle.\n * @param {number | undefined} _1\n *   Index of `node` in `parent.\n * @param {Parents | undefined} _2\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function comment(node, _1, _2, state) {\n  // See: <https://html.spec.whatwg.org/multipage/syntax.html#comments>\n  return state.settings.bogusComments\n    ? '<?' +\n        stringifyEntities(\n          node.value,\n          Object.assign({}, state.settings.characterReferences, {\n            subset: bogusCommentEntitySubset\n          })\n        ) +\n        '>'\n    : '<!--' + node.value.replace(htmlCommentRegex, encode) + '-->'\n\n  /**\n   * @param {string} $0\n   */\n  function encode($0) {\n    return stringifyEntities(\n      $0,\n      Object.assign({}, state.settings.characterReferences, {\n        subset: commentEntitySubset\n      })\n    )\n  }\n}\n", "/**\n * @import {Doctype, Parents} from 'hast'\n * @import {State} from '../index.js'\n */\n\n/**\n * Serialize a doctype.\n *\n * @param {Doctype} _1\n *   Node to handle.\n * @param {number | undefined} _2\n *   Index of `node` in `parent.\n * @param {Parents | undefined} _3\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function doctype(_1, _2, _3, state) {\n  return (\n    '<!' +\n    (state.settings.upperDoctype ? 'DOCTYPE' : 'doctype') +\n    (state.settings.tightDoctype ? '' : ' ') +\n    'html>'\n  )\n}\n", "/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n", "/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */\n\n/**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */\n\n/**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  /** @type {Array<string>} */\n  const tokens = []\n  const input = String(value || '')\n  let index = input.indexOf(',')\n  let start = 0\n  /** @type {boolean} */\n  let end = false\n\n  while (!end) {\n    if (index === -1) {\n      index = input.length\n      end = true\n    }\n\n    const token = input.slice(start, index).trim()\n\n    if (token || !end) {\n      tokens.push(token)\n    }\n\n    start = index + 1\n    index = input.indexOf(',', start)\n  }\n\n  return tokens\n}\n\n/**\n * Serialize an array of strings or numbers to comma-separated tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @param {Options} [options]\n *   Configuration for `stringify` (optional).\n * @returns {string}\n *   Comma-separated tokens.\n */\nexport function stringify(values, options) {\n  const settings = options || {}\n\n  // Ensure the last empty entry is seen.\n  const input = values[values.length - 1] === '' ? [...values, ''] : values\n\n  return input\n    .join(\n      (settings.padRight ? ' ' : '') +\n        ',' +\n        (settings.padLeft === false ? '' : ' ')\n    )\n    .trim()\n}\n", "/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nexport function stringify(values) {\n  return values.join(' ').trim()\n}\n", "/**\n * @typedef {import('hast').Nodes} Nodes\n */\n\n// HTML whitespace expression.\n// See <https://infra.spec.whatwg.org/#ascii-whitespace>.\nconst re = /[ \\t\\n\\f\\r]/g\n\n/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {Nodes | string} thing\n *   Thing to check (`Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`); if a node is passed it must be a `Text` node,\n *   whose `value` field is checked.\n */\nexport function whitespace(thing) {\n  return typeof thing === 'object'\n    ? thing.type === 'text'\n      ? empty(thing.value)\n      : false\n    : empty(thing)\n}\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction empty(value) {\n  return value.replace(re, '') === ''\n}\n", "/**\n * @import {Parents, RootContent} from 'hast'\n */\n\nimport {whitespace} from 'hast-util-whitespace'\n\nexport const siblingAfter = siblings(1)\nexport const siblingBefore = siblings(-1)\n\n/** @type {Array<RootContent>} */\nconst emptyChildren = []\n\n/**\n * Factory to check siblings in a direction.\n *\n * @param {number} increment\n */\nfunction siblings(increment) {\n  return sibling\n\n  /**\n   * Find applicable siblings in a direction.\n   *\n   * @template {Parents} Parent\n   *   Parent type.\n   * @param {Parent | undefined} parent\n   *   Parent.\n   * @param {number | undefined} index\n   *   Index of child in `parent`.\n   * @param {boolean | undefined} [includeWhitespace=false]\n   *   Whether to include whitespace (default: `false`).\n   * @returns {Parent extends {children: Array<infer Child>} ? Child | undefined : never}\n   *   Child of parent.\n   */\n  function sibling(parent, index, includeWhitespace) {\n    const siblings = parent ? parent.children : emptyChildren\n    let offset = (index || 0) + increment\n    let next = siblings[offset]\n\n    if (!includeWhitespace) {\n      while (next && whitespace(next)) {\n        offset += increment\n        next = siblings[offset]\n      }\n    }\n\n    // @ts-expect-error: its a correct child.\n    return next\n  }\n}\n", "/**\n * @import {Element, Parents} from 'hast'\n */\n\n/**\n * @callback OmitHandle\n *   Check if a tag can be omitted.\n * @param {Element} element\n *   Element to check.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether to omit a tag.\n *\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Factory to check if a given node can have a tag omitted.\n *\n * @param {Record<string, OmitHandle>} handlers\n *   Omission handlers, where each key is a tag name, and each value is the\n *   corresponding handler.\n * @returns {OmitHandle}\n *   Whether to omit a tag of an element.\n */\nexport function omission(handlers) {\n  return omit\n\n  /**\n   * Check if a given node can have a tag omitted.\n   *\n   * @type {OmitHandle}\n   */\n  function omit(node, index, parent) {\n    return (\n      own.call(handlers, node.tagName) &&\n      handlers[node.tagName](node, index, parent)\n    )\n  }\n}\n", "/**\n * @import {Element, Parents} from 'hast'\n */\n\nimport {whitespace} from 'hast-util-whitespace'\nimport {siblingAfter} from './util/siblings.js'\nimport {omission} from './omission.js'\n\nexport const closing = omission({\n  body,\n  caption: headOrColgroupOrCaption,\n  colgroup: headOrColgroupOrCaption,\n  dd,\n  dt,\n  head: headOrColgroupOrCaption,\n  html,\n  li,\n  optgroup,\n  option,\n  p,\n  rp: rubyElement,\n  rt: rubyElement,\n  tbody,\n  td: cells,\n  tfoot,\n  th: cells,\n  thead,\n  tr\n})\n\n/**\n * Macro for `</head>`, `</colgroup>`, and `</caption>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction headOrColgroupOrCaption(_, index, parent) {\n  const next = siblingAfter(parent, index, true)\n  return (\n    !next ||\n    (next.type !== 'comment' &&\n      !(next.type === 'text' && whitespace(next.value.charAt(0))))\n  )\n}\n\n/**\n * Whether to omit `</html>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction html(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || next.type !== 'comment'\n}\n\n/**\n * Whether to omit `</body>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction body(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || next.type !== 'comment'\n}\n\n/**\n * Whether to omit `</p>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction p(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return next\n    ? next.type === 'element' &&\n        (next.tagName === 'address' ||\n          next.tagName === 'article' ||\n          next.tagName === 'aside' ||\n          next.tagName === 'blockquote' ||\n          next.tagName === 'details' ||\n          next.tagName === 'div' ||\n          next.tagName === 'dl' ||\n          next.tagName === 'fieldset' ||\n          next.tagName === 'figcaption' ||\n          next.tagName === 'figure' ||\n          next.tagName === 'footer' ||\n          next.tagName === 'form' ||\n          next.tagName === 'h1' ||\n          next.tagName === 'h2' ||\n          next.tagName === 'h3' ||\n          next.tagName === 'h4' ||\n          next.tagName === 'h5' ||\n          next.tagName === 'h6' ||\n          next.tagName === 'header' ||\n          next.tagName === 'hgroup' ||\n          next.tagName === 'hr' ||\n          next.tagName === 'main' ||\n          next.tagName === 'menu' ||\n          next.tagName === 'nav' ||\n          next.tagName === 'ol' ||\n          next.tagName === 'p' ||\n          next.tagName === 'pre' ||\n          next.tagName === 'section' ||\n          next.tagName === 'table' ||\n          next.tagName === 'ul')\n    : !parent ||\n        // Confusing parent.\n        !(\n          parent.type === 'element' &&\n          (parent.tagName === 'a' ||\n            parent.tagName === 'audio' ||\n            parent.tagName === 'del' ||\n            parent.tagName === 'ins' ||\n            parent.tagName === 'map' ||\n            parent.tagName === 'noscript' ||\n            parent.tagName === 'video')\n        )\n}\n\n/**\n * Whether to omit `</li>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction li(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'li')\n}\n\n/**\n * Whether to omit `</dt>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction dt(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return Boolean(\n    next &&\n      next.type === 'element' &&\n      (next.tagName === 'dt' || next.tagName === 'dd')\n  )\n}\n\n/**\n * Whether to omit `</dd>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction dd(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'dt' || next.tagName === 'dd'))\n  )\n}\n\n/**\n * Whether to omit `</rt>` or `</rp>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction rubyElement(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'rp' || next.tagName === 'rt'))\n  )\n}\n\n/**\n * Whether to omit `</optgroup>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction optgroup(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'optgroup')\n}\n\n/**\n * Whether to omit `</option>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction option(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'option' || next.tagName === 'optgroup'))\n  )\n}\n\n/**\n * Whether to omit `</thead>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction thead(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return Boolean(\n    next &&\n      next.type === 'element' &&\n      (next.tagName === 'tbody' || next.tagName === 'tfoot')\n  )\n}\n\n/**\n * Whether to omit `</tbody>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tbody(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'tbody' || next.tagName === 'tfoot'))\n  )\n}\n\n/**\n * Whether to omit `</tfoot>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tfoot(_, index, parent) {\n  return !siblingAfter(parent, index)\n}\n\n/**\n * Whether to omit `</tr>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tr(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'tr')\n}\n\n/**\n * Whether to omit `</td>` or `</th>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction cells(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'td' || next.tagName === 'th'))\n  )\n}\n", "/**\n * @import {Element, Parents} from 'hast'\n */\n\nimport {whitespace} from 'hast-util-whitespace'\nimport {siblingAfter, siblingBefore} from './util/siblings.js'\nimport {closing} from './closing.js'\nimport {omission} from './omission.js'\n\nexport const opening = omission({\n  body,\n  colgroup,\n  head,\n  html,\n  tbody\n})\n\n/**\n * Whether to omit `<html>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction html(node) {\n  const head = siblingAfter(node, -1)\n  return !head || head.type !== 'comment'\n}\n\n/**\n * Whether to omit `<head>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction head(node) {\n  /** @type {Set<string>} */\n  const seen = new Set()\n\n  // Whether `srcdoc` or not,\n  // make sure the content model at least doesnt have too many `base`s/`title`s.\n  for (const child of node.children) {\n    if (\n      child.type === 'element' &&\n      (child.tagName === 'base' || child.tagName === 'title')\n    ) {\n      if (seen.has(child.tagName)) return false\n      seen.add(child.tagName)\n    }\n  }\n\n  // May be omitted if the element is empty,\n  // or if the first thing inside the head element is an element.\n  const child = node.children[0]\n  return !child || child.type === 'element'\n}\n\n/**\n * Whether to omit `<body>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction body(node) {\n  const head = siblingAfter(node, -1, true)\n\n  return (\n    !head ||\n    (head.type !== 'comment' &&\n      !(head.type === 'text' && whitespace(head.value.charAt(0))) &&\n      !(\n        head.type === 'element' &&\n        (head.tagName === 'meta' ||\n          head.tagName === 'link' ||\n          head.tagName === 'script' ||\n          head.tagName === 'style' ||\n          head.tagName === 'template')\n      ))\n  )\n}\n\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but its easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction colgroup(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1, true)\n\n  // Previous colgroup was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    previous.tagName === 'colgroup' &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return Boolean(head && head.type === 'element' && head.tagName === 'col')\n}\n\n/**\n * Whether to omit `<tbody>`.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction tbody(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1)\n\n  // Previous table section was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    (previous.tagName === 'thead' || previous.tagName === 'tbody') &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return Boolean(head && head.type === 'element' && head.tagName === 'tr')\n}\n", "/**\n * @import {Element, Parents, Properties} from 'hast'\n * @import {State} from '../index.js'\n */\n\nimport {ccount} from 'ccount'\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {find, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {stringifyEntities} from 'stringify-entities'\nimport {closing} from '../omission/closing.js'\nimport {opening} from '../omission/opening.js'\n\n/**\n * Maps of subsets.\n *\n * Each value is a matrix of tuples.\n * The value at `0` causes parse errors, the value at `1` is valid.\n * Of both, the value at `0` is unsafe, and the value at `1` is safe.\n *\n * @type {Record<'double' | 'name' | 'single' | 'unquoted', Array<[Array<string>, Array<string>]>>}\n */\nconst constants = {\n  // See: <https://html.spec.whatwg.org/#attribute-name-state>.\n  name: [\n    ['\\t\\n\\f\\r &/=>'.split(''), '\\t\\n\\f\\r \"&\\'/=>`'.split('')],\n    ['\\0\\t\\n\\f\\r \"&\\'/<=>'.split(''), '\\0\\t\\n\\f\\r \"&\\'/<=>`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.\n  unquoted: [\n    ['\\t\\n\\f\\r &>'.split(''), '\\0\\t\\n\\f\\r \"&\\'<=>`'.split('')],\n    ['\\0\\t\\n\\f\\r \"&\\'<=>`'.split(''), '\\0\\t\\n\\f\\r \"&\\'<=>`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.\n  single: [\n    [\"&'\".split(''), '\"&\\'`'.split('')],\n    [\"\\0&'\".split(''), '\\0\"&\\'`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.\n  double: [\n    ['\"&'.split(''), '\"&\\'`'.split('')],\n    ['\\0\"&'.split(''), '\\0\"&\\'`'.split('')]\n  ]\n}\n\n/**\n * Serialize an element node.\n *\n * @param {Element} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function element(node, index, parent, state) {\n  const schema = state.schema\n  const omit = schema.space === 'svg' ? false : state.settings.omitOptionalTags\n  let selfClosing =\n    schema.space === 'svg'\n      ? state.settings.closeEmptyElements\n      : state.settings.voids.includes(node.tagName.toLowerCase())\n  /** @type {Array<string>} */\n  const parts = []\n  /** @type {string} */\n  let last\n\n  if (schema.space === 'html' && node.tagName === 'svg') {\n    state.schema = svg\n  }\n\n  const attributes = serializeAttributes(state, node.properties)\n\n  const content = state.all(\n    schema.space === 'html' && node.tagName === 'template' ? node.content : node\n  )\n\n  state.schema = schema\n\n  // If the node is categorised as void, but it has children, remove the\n  // categorisation.\n  // This enables for example `menuitem`s, which are void in W3C HTML but not\n  // void in WHATWG HTML, to be stringified properly.\n  // Note: `menuitem` has since been removed from the HTML spec, and so is no\n  // longer void.\n  if (content) selfClosing = false\n\n  if (attributes || !omit || !opening(node, index, parent)) {\n    parts.push('<', node.tagName, attributes ? ' ' + attributes : '')\n\n    if (\n      selfClosing &&\n      (schema.space === 'svg' || state.settings.closeSelfClosing)\n    ) {\n      last = attributes.charAt(attributes.length - 1)\n      if (\n        !state.settings.tightSelfClosing ||\n        last === '/' ||\n        (last && last !== '\"' && last !== \"'\")\n      ) {\n        parts.push(' ')\n      }\n\n      parts.push('/')\n    }\n\n    parts.push('>')\n  }\n\n  parts.push(content)\n\n  if (!selfClosing && (!omit || !closing(node, index, parent))) {\n    parts.push('</' + node.tagName + '>')\n  }\n\n  return parts.join('')\n}\n\n/**\n * @param {State} state\n * @param {Properties | null | undefined} properties\n * @returns {string}\n */\nfunction serializeAttributes(state, properties) {\n  /** @type {Array<string>} */\n  const values = []\n  let index = -1\n  /** @type {string} */\n  let key\n\n  if (properties) {\n    for (key in properties) {\n      if (properties[key] !== null && properties[key] !== undefined) {\n        const value = serializeAttribute(state, key, properties[key])\n        if (value) values.push(value)\n      }\n    }\n  }\n\n  while (++index < values.length) {\n    const last = state.settings.tightAttributes\n      ? values[index].charAt(values[index].length - 1)\n      : undefined\n\n    // In tight mode, dont add a space after quoted attributes.\n    if (index !== values.length - 1 && last !== '\"' && last !== \"'\") {\n      values[index] += ' '\n    }\n  }\n\n  return values.join('')\n}\n\n/**\n * @param {State} state\n * @param {string} key\n * @param {Properties[keyof Properties]} value\n * @returns {string}\n */\nfunction serializeAttribute(state, key, value) {\n  const info = find(state.schema, key)\n  const x =\n    state.settings.allowParseErrors && state.schema.space === 'html' ? 0 : 1\n  const y = state.settings.allowDangerousCharacters ? 0 : 1\n  let quote = state.quote\n  /** @type {string | undefined} */\n  let result\n\n  if (info.overloadedBoolean && (value === info.attribute || value === '')) {\n    value = true\n  } else if (\n    (info.boolean || info.overloadedBoolean) &&\n    (typeof value !== 'string' || value === info.attribute || value === '')\n  ) {\n    value = Boolean(value)\n  }\n\n  if (\n    value === null ||\n    value === undefined ||\n    value === false ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return ''\n  }\n\n  const name = stringifyEntities(\n    info.attribute,\n    Object.assign({}, state.settings.characterReferences, {\n      // Always encode without parse errors in non-HTML.\n      subset: constants.name[x][y]\n    })\n  )\n\n  // No value.\n  // There is currently only one boolean property in SVG: `[download]` on\n  // `<a>`.\n  // This property does not seem to work in browsers (Firefox, Safari, Chrome),\n  // so I cant test if dropping the value works.\n  // But I assume that it should:\n  //\n  // ```html\n  // <!doctype html>\n  // <svg viewBox=\"0 0 100 100\">\n  //   <a href=https://example.com download>\n  //     <circle cx=50 cy=40 r=35 />\n  //   </a>\n  // </svg>\n  // ```\n  //\n  // See: <https://github.com/wooorm/property-information/blob/main/lib/svg.js>\n  if (value === true) return name\n\n  // `spaces` doesnt accept a second argument, but its given here just to\n  // keep the code cleaner.\n  value = Array.isArray(value)\n    ? (info.commaSeparated ? commas : spaces)(value, {\n        padLeft: !state.settings.tightCommaSeparatedLists\n      })\n    : String(value)\n\n  if (state.settings.collapseEmptyAttributes && !value) return name\n\n  // Check unquoted value.\n  if (state.settings.preferUnquoted) {\n    result = stringifyEntities(\n      value,\n      Object.assign({}, state.settings.characterReferences, {\n        attribute: true,\n        subset: constants.unquoted[x][y]\n      })\n    )\n  }\n\n  // If we dont want unquoted, or if `value` contains character references when\n  // unquoted\n  if (result !== value) {\n    // If the alternative is less common than `quote`, switch.\n    if (\n      state.settings.quoteSmart &&\n      ccount(value, quote) > ccount(value, state.alternative)\n    ) {\n      quote = state.alternative\n    }\n\n    result =\n      quote +\n      stringifyEntities(\n        value,\n        Object.assign({}, state.settings.characterReferences, {\n          // Always encode without parse errors in non-HTML.\n          subset: (quote === \"'\" ? constants.single : constants.double)[x][y],\n          attribute: true\n        })\n      ) +\n      quote\n  }\n\n  // Dont add a `=` for unquoted empties.\n  return name + (result ? '=' + result : result)\n}\n", "/**\n * @import {Parents, Text} from 'hast'\n * @import {Raw} from 'mdast-util-to-hast'\n * @import {State} from '../index.js'\n */\n\nimport {stringifyEntities} from 'stringify-entities'\n\n// Declare array as variable so it can be cached by `stringifyEntities`\nconst textEntitySubset = ['<', '&']\n\n/**\n * Serialize a text node.\n *\n * @param {Raw | Text} node\n *   Node to handle.\n * @param {number | undefined} _\n *   Index of `node` in `parent.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function text(node, _, parent, state) {\n  // Check if content of `node` should be escaped.\n  return parent &&\n    parent.type === 'element' &&\n    (parent.tagName === 'script' || parent.tagName === 'style')\n    ? node.value\n    : stringifyEntities(\n        node.value,\n        Object.assign({}, state.settings.characterReferences, {\n          subset: textEntitySubset\n        })\n      )\n}\n", "/**\n * @import {Parents} from 'hast'\n * @import {Raw} from 'mdast-util-to-hast'\n * @import {State} from '../index.js'\n */\n\nimport {text} from './text.js'\n\n/**\n * Serialize a raw node.\n *\n * @param {Raw} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function raw(node, index, parent, state) {\n  return state.settings.allowDangerousHtml\n    ? node.value\n    : text(node, index, parent, state)\n}\n", "/**\n * @import {Parents, Root} from 'hast'\n * @import {State} from '../index.js'\n */\n\n/**\n * Serialize a root.\n *\n * @param {Root} node\n *   Node to handle.\n * @param {number | undefined} _1\n *   Index of `node` in `parent.\n * @param {Parents | undefined} _2\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function root(node, _1, _2, state) {\n  return state.all(node)\n}\n", "/**\n * @import {Nodes, Parents} from 'hast'\n * @import {State} from '../index.js'\n */\n\nimport {zwitch} from 'zwitch'\nimport {comment} from './comment.js'\nimport {doctype} from './doctype.js'\nimport {element} from './element.js'\nimport {raw} from './raw.js'\nimport {root} from './root.js'\nimport {text} from './text.js'\n\n/**\n * @type {(node: Nodes, index: number | undefined, parent: Parents | undefined, state: State) => string}\n */\nexport const handle = zwitch('type', {\n  invalid,\n  unknown,\n  handlers: {comment, doctype, element, raw, root, text}\n})\n\n/**\n * Fail when a non-node is found in the tree.\n *\n * @param {unknown} node\n *   Unknown value.\n * @returns {never}\n *   Never.\n */\nfunction invalid(node) {\n  throw new Error('Expected node, not `' + node + '`')\n}\n\n/**\n * Fail when a node with an unknown type is found in the tree.\n *\n * @param {unknown} node_\n *  Unknown node.\n * @returns {never}\n *   Never.\n */\nfunction unknown(node_) {\n  // `type` is guaranteed by runtime JS.\n  const node = /** @type {Nodes} */ (node_)\n  throw new Error('Cannot compile unknown node `' + node.type + '`')\n}\n", "/**\n * @import {Nodes, Parents, RootContent} from 'hast'\n * @import {Schema} from 'property-information'\n * @import {Options as StringifyEntitiesOptions} from 'stringify-entities'\n */\n\n/**\n * @typedef {Omit<StringifyEntitiesOptions, 'attribute' | 'escapeOnly' | 'subset'>} CharacterReferences\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [allowDangerousCharacters=false]\n *   Do not encode some characters which cause XSS vulnerabilities in older\n *   browsers (default: `false`).\n *\n *   >  **Danger**: only set this if you completely trust the content.\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Allow `raw` nodes and insert them as raw HTML (default: `false`).\n *\n *   When `false`, `Raw` nodes are encoded.\n *\n *   >  **Danger**: only set this if you completely trust the content.\n * @property {boolean | null | undefined} [allowParseErrors=false]\n *   Do not encode characters which cause parse errors (even though they work),\n *   to save bytes (default: `false`).\n *\n *   Not used in the SVG space.\n *\n *   >  **Note**: intentionally creates parse errors in markup (how parse\n *   > errors are handled is well defined, so this works but isnt pretty).\n * @property {boolean | null | undefined} [bogusComments=false]\n *   Use bogus comments instead of comments to save byes: `<?charlie>`\n *   instead of `<!--charlie-->` (default: `false`).\n *\n *   >  **Note**: intentionally creates parse errors in markup (how parse\n *   > errors are handled is well defined, so this works but isnt pretty).\n * @property {CharacterReferences | null | undefined} [characterReferences]\n *   Configure how to serialize character references (optional).\n * @property {boolean | null | undefined} [closeEmptyElements=false]\n *   Close SVG elements without any content with slash (`/`) on the opening tag\n *   instead of an end tag: `<circle />` instead of `<circle></circle>`\n *   (default: `false`).\n *\n *   See `tightSelfClosing` to control whether a space is used before the\n *   slash.\n *\n *   Not used in the HTML space.\n * @property {boolean | null | undefined} [closeSelfClosing=false]\n *   Close self-closing nodes with an extra slash (`/`): `<img />` instead of\n *   `<img>` (default: `false`).\n *\n *   See `tightSelfClosing` to control whether a space is used before the\n *   slash.\n *\n *   Not used in the SVG space.\n * @property {boolean | null | undefined} [collapseEmptyAttributes=false]\n *   Collapse empty attributes: get `class` instead of `class=\"\"` (default:\n *   `false`).\n *\n *   Not used in the SVG space.\n *\n *   >  **Note**: boolean attributes (such as `hidden`) are always collapsed.\n * @property {boolean | null | undefined} [omitOptionalTags=false]\n *   Omit optional opening and closing tags (default: `false`).\n *\n *   For example, in `<ol><li>one</li><li>two</li></ol>`, both `</li>` closing\n *   tags can be omitted.\n *   The first because its followed by another `li`, the last because its\n *   followed by nothing.\n *\n *   Not used in the SVG space.\n * @property {boolean | null | undefined} [preferUnquoted=false]\n *   Leave attributes unquoted if that results in less bytes (default: `false`).\n *\n *   Not used in the SVG space.\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes (default: `false`).\n * @property {Quote | null | undefined} [quote='\"']\n *   Preferred quote to use (default: `'\"'`).\n * @property {Space | null | undefined} [space='html']\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it (default: `'html'`).\n *\n *   >  **Note**: hast is not XML.\n *   > It supports SVG as embedded in HTML.\n *   > It does not support the features available in XML.\n *   > Passing SVG might break but fragments of modern SVG should be fine.\n *   > Use [`xast`][xast] if you need to support SVG as XML.\n * @property {boolean | null | undefined} [tightAttributes=false]\n *   Join attributes together, without whitespace, if possible: get\n *   `class=\"a b\"title=\"c d\"` instead of `class=\"a b\" title=\"c d\"` to save\n *   bytes (default: `false`).\n *\n *   Not used in the SVG space.\n *\n *   >  **Note**: intentionally creates parse errors in markup (how parse\n *   > errors are handled is well defined, so this works but isnt pretty).\n * @property {boolean | null | undefined} [tightCommaSeparatedLists=false]\n *   Join known comma-separated attribute values with just a comma (`,`),\n *   instead of padding them on the right as well (`,`, where `` represents a\n *   space) (default: `false`).\n * @property {boolean | null | undefined} [tightDoctype=false]\n *   Drop unneeded spaces in doctypes: `<!doctypehtml>` instead of\n *   `<!doctype html>` to save bytes (default: `false`).\n *\n *   >  **Note**: intentionally creates parse errors in markup (how parse\n *   > errors are handled is well defined, so this works but isnt pretty).\n * @property {boolean | null | undefined} [tightSelfClosing=false]\n *   Do not use an extra space when closing self-closing elements: `<img/>`\n *   instead of `<img />` (default: `false`).\n *\n *   >  **Note**: only used if `closeSelfClosing: true` or\n *   > `closeEmptyElements: true`.\n * @property {boolean | null | undefined} [upperDoctype=false]\n *   Use a `<!DOCTYPE` instead of `<!doctype` (default: `false`).\n *\n *   Useless except for XHTML.\n * @property {ReadonlyArray<string> | null | undefined} [voids]\n *   Tag names of elements to serialize without closing tag (default: `html-void-elements`).\n *\n *   Not used in the SVG space.\n *\n *   >  **Note**: Its highly unlikely that you want to pass this, because\n *   > hast is not for XML, and HTML will not add more void elements.\n *\n * @typedef {'\"' | \"'\"} Quote\n *   HTML quotes for attribute values.\n *\n * @typedef {Omit<Required<{[key in keyof Options]: Exclude<Options[key], null | undefined>}>, 'space' | 'quote'>} Settings\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {(node: Parents | undefined) => string} all\n *   Serialize the children of a parent node.\n * @property {Quote} alternative\n *   Alternative quote.\n * @property {(node: Nodes, index: number | undefined, parent: Parents | undefined) => string} one\n *   Serialize one node.\n * @property {Quote} quote\n *   Preferred quote.\n * @property {Schema} schema\n *   Current schema.\n * @property {Settings} settings\n *   User configuration.\n */\n\nimport {htmlVoidElements} from 'html-void-elements'\nimport {html, svg} from 'property-information'\nimport {handle} from './handle/index.js'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/** @type {CharacterReferences} */\nconst emptyCharacterReferences = {}\n\n/** @type {Array<never>} */\nconst emptyChildren = []\n\n/**\n * Serialize hast as HTML.\n *\n * @param {Array<RootContent> | Nodes} tree\n *   Tree to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized HTML.\n */\nexport function toHtml(tree, options) {\n  const options_ = options || emptyOptions\n  const quote = options_.quote || '\"'\n  const alternative = quote === '\"' ? \"'\" : '\"'\n\n  if (quote !== '\"' && quote !== \"'\") {\n    throw new Error('Invalid quote `' + quote + '`, expected `\\'` or `\"`')\n  }\n\n  /** @type {State} */\n  const state = {\n    one,\n    all,\n    settings: {\n      omitOptionalTags: options_.omitOptionalTags || false,\n      allowParseErrors: options_.allowParseErrors || false,\n      allowDangerousCharacters: options_.allowDangerousCharacters || false,\n      quoteSmart: options_.quoteSmart || false,\n      preferUnquoted: options_.preferUnquoted || false,\n      tightAttributes: options_.tightAttributes || false,\n      upperDoctype: options_.upperDoctype || false,\n      tightDoctype: options_.tightDoctype || false,\n      bogusComments: options_.bogusComments || false,\n      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,\n      tightSelfClosing: options_.tightSelfClosing || false,\n      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,\n      allowDangerousHtml: options_.allowDangerousHtml || false,\n      voids: options_.voids || htmlVoidElements,\n      characterReferences:\n        options_.characterReferences || emptyCharacterReferences,\n      closeSelfClosing: options_.closeSelfClosing || false,\n      closeEmptyElements: options_.closeEmptyElements || false\n    },\n    schema: options_.space === 'svg' ? svg : html,\n    quote,\n    alternative\n  }\n\n  return state.one(\n    Array.isArray(tree) ? {type: 'root', children: tree} : tree,\n    undefined,\n    undefined\n  )\n}\n\n/**\n * Serialize a node.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(node, index, parent) {\n  return handle(node, index, parent, this)\n}\n\n/**\n * Serialize all children of `parent`.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parents | undefined} parent\n *   Parent whose children to serialize.\n * @returns {string}\n */\nexport function all(parent) {\n  /** @type {Array<string>} */\n  const results = []\n  const children = (parent && parent.children) || emptyChildren\n  let index = -1\n\n  while (++index < children.length) {\n    results[index] = this.one(children[index], index, parent)\n  }\n\n  return results.join('')\n}\n", "const r = String.raw;\nconst seq = r`(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})`;\nconst sTags = r`\\u{E0061}-\\u{E007A}`;\nexport default () => new RegExp(r`[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[${sTags}]{2}[\\u{E0030}-\\u{E0039}${sTags}]{1,3}\\u{E007F}|${seq}(?:\\u200D${seq})*`, 'gu');\n", "// Constant properties for tracking regex syntax context\nexport const Context = Object.freeze({\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n});\n\n/**\nReplaces all unescaped instances of a regex pattern in the given context, using a replacement\nstring or callback.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {string | (match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {string} Updated expression\n@example\nconst str = '.\\\\.\\\\\\\\.[[\\\\.].].';\nreplaceUnescaped(str, '\\\\.', '@');\n//  '@\\\\.\\\\\\\\@[[\\\\.]@]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.DEFAULT);\n//  '@\\\\.\\\\\\\\@[[\\\\.].]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.CHAR_CLASS);\n//  '.\\\\.\\\\\\\\.[[\\\\.]@].'\n*/\nexport function replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, 'gsu');\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of expression.matchAll(re)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1],\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === '[') {\n      numCharClassesOpen++;\n      negated.push(m[1] === '^');\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRuns a callback for each unescaped instance of a regex pattern in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {(match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => void} callback\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n*/\nexport function forEachUnescaped(expression, needle, callback, context) {\n  // Do this the easy way\n  replaceUnescaped(expression, needle, callback, context);\n}\n\n/**\nReturns a match object for the first unescaped instance of a regex pattern in the given context, or\n`null`.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {number} [pos] Offset to start the search\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {RegExpExecArray | null}\n*/\nexport function execUnescaped(expression, needle, pos = 0, context) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su').test(expression))) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, 'gsu');\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    // Avoid an infinite loop on zero-length matches\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\n\n/**\nChecks whether an unescaped instance of a regex pattern appears in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {boolean} Whether the pattern was found\n*/\nexport function hasUnescaped(expression, needle, context) {\n  // Do this the easy way\n  return !!execUnescaped(expression, needle, 0, context);\n}\n\n/**\nExtracts the full contents of a group (subpattern) from the given expression, accounting for\nescaped characters, nested groups, and character classes. The group is identified by the position\nwhere its contents start (the string index just after the group's opening delimiter). Returns the\nrest of the string if the group is unclosed.\n\nAssumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {number} contentsStartPos\n@returns {string}\n*/\nexport function getGroupContents(expression, contentsStartPos) {\n  const token = /\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(expression)) {\n    const [m] = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === '(') {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n", "import {Context, replaceUnescaped} from 'regex-utilities';\n\n// This marker was chosen because it's impossible to match (so its extemely unlikely to be used in\n// a user-provided regex); it's not at risk of being optimized away, transformed, or flagged as an\n// error by a plugin; and it ends with an unquantifiable token\nconst emulationGroupMarker = '$E$';\n// Note: Emulation groups with transfer are also supported. They look like `($N$E$)` where `N` is\n// an integer 1 or greater. They're not used directly by Regex+ but can be used by plugins and\n// libraries that use Regex+ internals. Emulation groups with transfer are not only excluded from\n// match results, but additionally transfer their match to the group specified by `N`\n\n/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but automatically\nadjusts matches and subpattern indices (with flag `d`) to account for injected emulation groups.\n*/\nclass RegExpSubclass extends RegExp {\n  // Avoid `#private` to allow for subclassing\n  /**\n  @private\n  @type {Array<{\n    exclude: boolean;\n    transfer?: number;\n  }> | undefined}\n  */\n  _captureMap;\n  /**\n  @private\n  @type {Record<number, string> | undefined}\n  */\n  _namesByIndex;\n  /**\n  @param {string | RegExpSubclass} expression\n  @param {string} [flags]\n  @param {{useEmulationGroups: boolean;}} [options]\n  */\n  constructor(expression, flags, options) {\n    if (expression instanceof RegExp && options) {\n      throw new Error('Cannot provide options when copying a regexp');\n    }\n    const useEmulationGroups = !!options?.useEmulationGroups;\n    const unmarked = useEmulationGroups ? unmarkEmulationGroups(expression) : null;\n    super(unmarked?.expression || expression, flags);\n    // The third argument `options` isn't provided when regexes are copied as part of the internal\n    // handling of string methods `matchAll` and `split`\n    const src = useEmulationGroups ? unmarked : (expression instanceof RegExpSubclass ? expression : null);\n    if (src) {\n      this._captureMap = src._captureMap;\n      this._namesByIndex = src._namesByIndex;\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const match = RegExp.prototype.exec.call(this, str);\n    if (!match || !this._captureMap) {\n      return match;\n    }\n    const matchCopy = [...match];\n    // Empty all but the first value of the array while preserving its other properties\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    for (let i = 1; i < matchCopy.length; i++) {\n      if (this._captureMap[i].exclude) {\n        const transfer = this._captureMap[i].transfer;\n        if (transfer && match.length > transfer) {\n          match[transfer] = matchCopy[i];\n          const transferName = this._namesByIndex[transfer];\n          if (transferName) {\n            match.groups[transferName] = matchCopy[i];\n            if (this.hasIndices) {\n              match.indices.groups[transferName] = indicesCopy[i];\n            }\n          }\n          if (this.hasIndices) {\n            match.indices[transfer] = indicesCopy[i];\n          }\n        }\n      } else {\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n    }\n    return match;\n  }\n}\n\n/**\nBuild the capturing group map (with emulation groups marked to indicate their submatches shouldn't\nappear in results), and remove the markers for captures that were added to emulate extended syntax.\n@param {string} expression\n@returns {{\n  _captureMap: Array<{\n    exclude: boolean;\n    transfer?: number;\n  }>;\n  _namesByIndex: Record<number, string>;\n  expression: string;\n}}\n*/\nfunction unmarkEmulationGroups(expression) {\n  const marker = emulationGroupMarker.replace(/\\$/g, '\\\\$');\n  const _captureMap = [{exclude: false}];\n  const _namesByIndex = {0: ''};\n  let realCaptureNum = 0;\n  expression = replaceUnescaped(\n    expression,\n    String.raw`\\((?:(?!\\?)|\\?<(?![=!])(?<name>[^>]+)>)(?<mark>(?:\\$(?<transfer>[1-9]\\d*))?${marker})?`,\n    ({0: m, groups: {name, mark, transfer}}) => {\n      if (mark) {\n        _captureMap.push({\n          exclude: true,\n          transfer: transfer && +transfer,\n        });\n        return m.slice(0, -mark.length);\n      }\n      realCaptureNum++;\n      if (name) {\n        _namesByIndex[realCaptureNum] = name;\n      }\n      _captureMap.push({\n        exclude: false,\n      });\n      return m;\n    },\n    Context.DEFAULT\n  );\n  return {\n    _captureMap,\n    _namesByIndex,\n    expression,\n  };\n}\n\nexport {\n  emulationGroupMarker,\n  RegExpSubclass,\n};\n", "// Separating some utils for improved tree shaking of the `./internals` export\n\nconst noncapturingDelim = String.raw`\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]|\\(DEFINE\\))`;\n\n/**\n@param {string} str\n@param {number} pos\n@param {string} oldValue\n@param {string} newValue\n@returns {string}\n*/\nfunction spliceStr(str, pos, oldValue, newValue) {\n  return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);\n}\n\nexport {\n  noncapturingDelim,\n  spliceStr,\n};\n", "import {emulationGroupMarker} from './subclass.js';\nimport {noncapturingDelim, spliceStr} from './utils-internals.js';\nimport {Context, replaceUnescaped} from 'regex-utilities';\n\nconst atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${noncapturingDelim})|(?<capturingStart>\\((?:\\?<[^>]+>)?)|\\\\?.`, 'gsu');\n\n/**\nApply transformations for atomic groups: `(?>)`.\n@param {string} expression\n@param {import('./regex.js').PluginData} [data]\n@returns {string}\n*/\nfunction atomic(expression, data) {\n  if (!/\\(\\?>/.test(expression)) {\n    return expression;\n  }\n  const aGDelim = '(?>';\n  const emulatedAGDelim = `(?:(?=(${data?.useEmulationGroups ? emulationGroupMarker : ''}`;\n  const captureNumMap = [0];\n  let numCapturesBeforeAG = 0;\n  let numAGs = 0;\n  let aGPos = NaN;\n  let hasProcessedAG;\n  do {\n    hasProcessedAG = false;\n    let numCharClassesOpen = 0;\n    let numGroupsOpenInAG = 0;\n    let inAG = false;\n    let match;\n    atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;\n    while (match = atomicPluginToken.exec(expression)) {\n      const {0: m, index, groups: {capturingStart, noncapturingStart}} = match;\n      if (m === '[') {\n        numCharClassesOpen++;\n      } else if (!numCharClassesOpen) {\n\n        if (m === aGDelim && !inAG) {\n          aGPos = index;\n          inAG = true;\n        } else if (inAG && noncapturingStart) {\n          numGroupsOpenInAG++;\n        } else if (capturingStart) {\n          if (inAG) {\n            numGroupsOpenInAG++;\n          } else {\n            numCapturesBeforeAG++;\n            captureNumMap.push(numCapturesBeforeAG + numAGs);\n          }\n        } else if (m === ')' && inAG) {\n          if (!numGroupsOpenInAG) {\n            numAGs++;\n            // Replace `expression` and use `<$$N>` as a temporary wrapper for the backref so it\n            // can avoid backref renumbering afterward. Need to wrap the whole substitution\n            // (including the lookahead and following backref) in a noncapturing group to handle\n            // following quantifiers and literal digits\n            expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${\n                expression.slice(aGPos + aGDelim.length, index)\n              }))<$$${numAGs + numCapturesBeforeAG}>)${expression.slice(index + 1)}`;\n            hasProcessedAG = true;\n            break;\n          }\n          numGroupsOpenInAG--;\n        }\n\n      } else if (m === ']') {\n        numCharClassesOpen--;\n      }\n    }\n  // Start over from the beginning of the last atomic group's contents, in case the processed group\n  // contains additional atomic groups\n  } while (hasProcessedAG);\n\n  // Second pass to adjust numbered backrefs\n  expression = replaceUnescaped(\n    expression,\n    String.raw`\\\\(?<backrefNum>[1-9]\\d*)|<\\$\\$(?<wrappedBackrefNum>\\d+)>`,\n    ({0: m, groups: {backrefNum, wrappedBackrefNum}}) => {\n      if (backrefNum) {\n        const bNum = +backrefNum;\n        if (bNum > captureNumMap.length - 1) {\n          throw new Error(`Backref \"${m}\" greater than number of captures`);\n        }\n        return `\\\\${captureNumMap[bNum]}`;\n      }\n      return `\\\\${wrappedBackrefNum}`;\n    },\n    Context.DEFAULT\n  );\n  return expression;\n}\n\nconst baseQuantifier = String.raw`(?:[?*+]|\\{\\d+(?:,\\d*)?\\})`;\n// Complete tokenizer for base syntax; doesn't (need to) know about character-class-only syntax\nconst possessivePluginToken = new RegExp(String.raw`\n\\\\(?: \\d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]\\{[^\\}]+\\}\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  )\n| \\((?: \\? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z\\-]+:\n  | \\(DEFINE\\)\n  ))?\n| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\\{]?)\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nTransform posessive quantifiers into atomic groups. The posessessive quantifiers are:\n`?+`, `*+`, `++`, `{N}+`, `{N,}+`, `{N,N}+`.\nThis follows Java, PCRE, Perl, and Python.\nPossessive quantifiers in Oniguruma and Onigmo are only: `?+`, `*+`, `++`.\n@param {string} expression\n@returns {string}\n*/\nfunction possessive(expression) {\n  if (!(new RegExp(`${baseQuantifier}\\\\+`).test(expression))) {\n    return expression;\n  }\n  const openGroupIndices = [];\n  let lastGroupIndex = null;\n  let lastCharClassIndex = null;\n  let lastToken = '';\n  let numCharClassesOpen = 0;\n  let match;\n  possessivePluginToken.lastIndex = 0;\n  while (match = possessivePluginToken.exec(expression)) {\n    const {0: m, index, groups: {qBase, qMod, invalidQ}} = match;\n    if (m === '[') {\n      if (!numCharClassesOpen) {\n        lastCharClassIndex = index;\n      }\n      numCharClassesOpen++;\n    } else if (m === ']') {\n      if (numCharClassesOpen) {\n        numCharClassesOpen--;\n      // Unmatched `]`\n      } else {\n        lastCharClassIndex = null;\n      }\n    } else if (!numCharClassesOpen) {\n\n      if (qMod === '+' && lastToken && !lastToken.startsWith('(')) {\n        // Invalid following quantifier would become valid via the wrapping group\n        if (invalidQ) {\n          throw new Error(`Invalid quantifier \"${m}\"`);\n        }\n        let charsAdded = -1; // -1 for removed trailing `+`\n        // Possessivizing fixed repetition quantifiers like `{2}` does't change their behavior, so\n        // avoid doing so (convert them to greedy)\n        if (/^\\{\\d+\\}$/.test(qBase)) {\n          expression = spliceStr(expression, index + qBase.length, qMod, '');\n        } else {\n          if (lastToken === ')' || lastToken === ']') {\n            const nodeIndex = lastToken === ')' ? lastGroupIndex : lastCharClassIndex;\n            // Unmatched `)` would break out of the wrapping group and mess with handling.\n            // Unmatched `]` wouldn't be a problem, but it's unnecessary to have dedicated support\n            // for unescaped `]++` since this won't work with flag u or v anyway\n            if (nodeIndex === null) {\n              throw new Error(`Invalid unmatched \"${lastToken}\"`);\n            }\n            expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m.length)}`;\n          } else {\n            expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m.length)}`;\n          }\n          charsAdded += 4; // `(?>)`\n        }\n        possessivePluginToken.lastIndex += charsAdded;\n      } else if (m[0] === '(') {\n        openGroupIndices.push(index);\n      } else if (m === ')') {\n        lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;\n      }\n\n    }\n    lastToken = m;\n  }\n  return expression;\n}\n\nexport {\n  atomic,\n  possessive,\n};\n", "import {Context, forEachUnescaped, getGroupContents, hasUnescaped, replaceUnescaped} from 'regex-utilities';\nimport {emulationGroupMarker} from 'regex/internals';\n\nconst r = String.raw;\nconst gRToken = r`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nconst recursiveToken = r`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nconst namedCapturingDelim = r`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst token = new RegExp(r`${namedCapturingDelim}|${recursiveToken}|\\(\\?|\\\\?.`, 'gsu');\nconst overlappingRecursionMsg = 'Cannot use multiple overlapping recursions';\n// Support emulation groups with transfer marker prefix\nconst emulationGroupMarkerRe = new RegExp(r`(?:\\$[1-9]\\d*)?${emulationGroupMarker.replace(/\\$/g, r`\\$`)}`, 'y');\n\n/**\n@param {string} expression\n@param {{\n  flags?: string;\n  useEmulationGroups?: boolean;\n}} [data]\n@returns {string}\n*/\nexport function recursion(expression, data) {\n  // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing\n  // without the accuracy improvement of using `hasUnescaped` with default `Context`\n  if (!(new RegExp(recursiveToken, 'su').test(expression))) {\n    return expression;\n  }\n  if (hasUnescaped(expression, r`\\(\\?\\(DEFINE\\)`, Context.DEFAULT)) {\n    throw new Error('DEFINE groups cannot be used with recursion');\n  }\n  const useEmulationGroups = !!data?.useEmulationGroups;\n  const hasNumberedBackref = hasUnescaped(expression, r`\\\\[1-9]`, Context.DEFAULT);\n  const groupContentsStartPos = new Map();\n  const openGroups = [];\n  let hasRecursed = false;\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  token.lastIndex = 0;\n  while ((match = token.exec(expression))) {\n    const {0: m, groups: {captureName, rDepth, gRNameOrNum, gRDepth}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n\n      // `(?R=N)`\n      if (rDepth) {\n        assertMaxInBounds(rDepth);\n        if (hasRecursed) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        if (hasNumberedBackref) {\n          // Could add support for numbered backrefs with extra effort, but it's probably not worth\n          // it. To trigger this error, the regex must include recursion and one of the following:\n          // - An interpolated regex that contains a numbered backref (since other numbered\n          //   backrefs are prevented by implicit flag n).\n          // - A numbered backref, when flag n is explicitly disabled.\n          // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also\n          // add numbered backrefs, but those work fine because external plugins like this one run\n          // *before* the transformation of built-in syntax extensions\n          throw new Error('Numbered backrefs cannot be used with global recursion');\n        }\n        const pre = expression.slice(0, match.index);\n        const post = expression.slice(token.lastIndex);\n        if (hasUnescaped(post, recursiveToken, Context.DEFAULT)) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        // No need to parse further\n        return makeRecursive(pre, post, +rDepth, false, useEmulationGroups);\n      // `\\g<name&R=N>`, `\\g<number&R=N>`\n      } else if (gRNameOrNum) {\n        assertMaxInBounds(gRDepth);\n        let isWithinReffedGroup = false;\n        for (const g of openGroups) {\n          if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n            isWithinReffedGroup = true;\n            if (g.hasRecursedWithin) {\n              throw new Error(overlappingRecursionMsg);\n            }\n            break;\n          }\n        }\n        if (!isWithinReffedGroup) {\n          throw new Error(r`Recursive \\g cannot be used outside the referenced group \"\\g<${gRNameOrNum}&R=${gRDepth}>\"`);\n        }\n        const startPos = groupContentsStartPos.get(gRNameOrNum);\n        const groupContents = getGroupContents(expression, startPos);\n        if (\n          hasNumberedBackref &&\n          hasUnescaped(groupContents, r`${namedCapturingDelim}|\\((?!\\?)`, Context.DEFAULT)\n        ) {\n          throw new Error('Numbered backrefs cannot be used with recursion of capturing groups');\n        }\n        const groupContentsPre = expression.slice(startPos, match.index);\n        const groupContentsPost = groupContents.slice(groupContentsPre.length + m.length);\n        const expansion = makeRecursive(groupContentsPre, groupContentsPost, +gRDepth, true, useEmulationGroups);\n        const pre = expression.slice(0, startPos);\n        const post = expression.slice(startPos + groupContents.length);\n        // Modify the string we're looping over\n        expression = `${pre}${expansion}${post}`;\n        // Step forward for the next loop iteration\n        token.lastIndex += expansion.length - m.length - groupContentsPre.length - groupContentsPost.length;\n        openGroups.forEach(g => g.hasRecursedWithin = true);\n        hasRecursed = true;\n      } else if (captureName) {\n        numCaptures++;\n        // NOTE: Not currently handling *named* emulation groups that already exist in the pattern\n        groupContentsStartPos.set(String(numCaptures), token.lastIndex);\n        groupContentsStartPos.set(captureName, token.lastIndex);\n        openGroups.push({\n          num: numCaptures,\n          name: captureName,\n        });\n      } else if (m.startsWith('(')) {\n        const isUnnamedCapture = m === '(';\n        if (isUnnamedCapture) {\n          numCaptures++;\n          groupContentsStartPos.set(\n            String(numCaptures),\n            token.lastIndex + (useEmulationGroups ? emulationGroupMarkerLength(expression, token.lastIndex) : 0)\n          );\n        }\n        openGroups.push(isUnnamedCapture ? {num: numCaptures} : {});\n      } else if (m === ')') {\n        openGroups.pop();\n      }\n\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n\n  return expression;\n}\n\n/**\n@param {string} max\n*/\nfunction assertMaxInBounds(max) {\n  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n  if (!/^[1-9]\\d*$/.test(max)) {\n    throw new Error(errMsg);\n  }\n  max = +max;\n  if (max < 2 || max > 100) {\n    throw new Error(errMsg);\n  }\n}\n\n/**\n@param {string} pre\n@param {string} post\n@param {number} maxDepth\n@param {boolean} isSubpattern\n@param {boolean} useEmulationGroups\n@returns {string}\n*/\nfunction makeRecursive(pre, post, maxDepth, isSubpattern, useEmulationGroups) {\n  const namesInRecursed = new Set();\n  // Avoid this work if not needed\n  if (isSubpattern) {\n    forEachUnescaped(pre + post, namedCapturingDelim, ({groups: {captureName}}) => {\n      namesInRecursed.add(captureName);\n    }, Context.DEFAULT);\n  }\n  const reps = maxDepth - 1;\n  // Depth 2: 'pre(?:pre(?:)post)post'\n  // Depth 3: 'pre(?:pre(?:pre(?:)post)post)post'\n  return `${pre}${\n    repeatWithDepth(`(?:${pre}`, reps, (isSubpattern ? namesInRecursed : null), 'forward', useEmulationGroups)\n  }(?:)${\n    repeatWithDepth(`${post})`, reps, (isSubpattern ? namesInRecursed : null), 'backward', useEmulationGroups)\n  }${post}`;\n}\n\n/**\n@param {string} expression\n@param {number} reps\n@param {Set<string> | null} namesInRecursed\n@param {'forward' | 'backward'} direction\n@param {boolean} useEmulationGroups\n@returns {string}\n*/\nfunction repeatWithDepth(expression, reps, namesInRecursed, direction, useEmulationGroups) {\n  const startNum = 2;\n  const depthNum = i => direction === 'backward' ? reps - i + startNum - 1 : i + startNum;\n  let result = '';\n  for (let i = 0; i < reps; i++) {\n    const captureNum = depthNum(i);\n    result += replaceUnescaped(\n      expression,\n      // NOTE: Not currently handling *named* emulation groups that already exist in the pattern\n      r`${namedCapturingDelim}|\\\\k<(?<backref>[^>]+)>${\n        useEmulationGroups ? r`|(?<unnamed>\\()(?!\\?)(?:${emulationGroupMarkerRe.source})?` : ''\n      }`,\n      ({0: m, index, groups: {captureName, backref, unnamed}}) => {\n        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n          // Don't alter backrefs to groups outside the recursed subpattern\n          return m;\n        }\n        // Only matches unnamed capture delim if `useEmulationGroups`\n        if (unnamed) {\n          // Add an emulation group marker, possibly replacing an existing marker (removes any\n          // transfer prefix)\n          return `(${emulationGroupMarker}`;\n        }\n        const suffix = `_$${captureNum}`;\n        return captureName ?\n          `(?<${captureName}${suffix}>${useEmulationGroups ? emulationGroupMarker : ''}` :\n          r`\\k<${backref}${suffix}>`;\n      },\n      Context.DEFAULT\n    );\n  }\n  return result;\n}\n\nfunction emulationGroupMarkerLength(expression, index) {\n  emulationGroupMarkerRe.lastIndex = index;\n  const match = emulationGroupMarkerRe.exec(expression);\n  return match ? match[0].length : 0;\n}\n", "import {EsVersion, Target} from './options.js';\n\nconst cp = String.fromCodePoint;\nconst r = String.raw;\n\nconst envSupportsFlagGroups = (() => {\n  try {\n    new RegExp('(?i:)');\n  } catch {\n    return false;\n  }\n  return true;\n})();\n\nconst envSupportsFlagV = (() => {\n  try {\n    new RegExp('', 'v');\n  } catch {\n    return false;\n  }\n  return true;\n})();\n\nfunction getNewCurrentFlags(current, {enable, disable}) {\n  return {\n    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase),\n  };\n}\n\nfunction getOrCreate(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\n\n/**\n@param {keyof Target} target\n@param {keyof Target} min\n@returns {boolean}\n*/\nfunction isMinTarget(target, min) {\n  return EsVersion[target] >= EsVersion[min];\n}\n\nfunction throwIfNot(value, msg) {\n  if (!value) {\n    throw new Error(msg ?? 'Value expected');\n  }\n  return value;\n}\n\nexport {\n  cp,\n  envSupportsFlagGroups,\n  envSupportsFlagV,\n  getNewCurrentFlags,\n  getOrCreate,\n  isMinTarget,\n  r,\n  throwIfNot,\n};\n", "import {envSupportsFlagGroups, envSupportsFlagV} from './utils.js';\n\nconst Accuracy = /** @type {const} */ ({\n  default: 'default',\n  strict: 'strict',\n});\n\nconst EsVersion = {\n  ES2025: 2025,\n  ES2024: 2024,\n  ES2018: 2018,\n};\n\nconst Target = /** @type {const} */ ({\n  auto: 'auto',\n  ES2025: 'ES2025',\n  ES2024: 'ES2024',\n  ES2018: 'ES2018',\n});\n\n/**\nReturns a complete set of options, with default values set for options that weren't provided.\n@param {import('.').OnigurumaToEsOptions} [options]\n@returns {Required<import('.').OnigurumaToEsOptions>}\n*/\nfunction getOptions(options) {\n  if (options?.target !== undefined && !Target[options.target]) {\n    throw new Error(`Unexpected target \"${options.target}\"`)\n  }\n  // Set default values\n  const opts = {\n    // Sets the level of emulation rigor/strictness.\n    accuracy: 'default',\n    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n    // certain patterns not being emulatable.\n    avoidSubclass: false,\n    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W` in any order (all optional).\n    // Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n    flags: '',\n    // Include JavaScript flag `g` (`global`) in the result.\n    global: false,\n    // Include JavaScript flag `d` (`hasIndices`) in the result.\n    hasIndices: false,\n    // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n    // your environment. Later targets allow faster processing, simpler generated source, and\n    // support for additional features.\n    target: 'auto',\n    // Disables optimizations that simplify the pattern when it doesn't change the meaning.\n    verbose: false,\n    ...options,\n    // Advanced options that override standard behavior, error checking, and flags when enabled.\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns.\n      allowOrphanBackrefs: false,\n      // Use ASCII-based `\\b` and `\\B`, which increases search performance of generated regexes.\n      asciiWordBoundaries: false,\n      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in\n      // `vscode-oniguruma`.\n      captureGroup: false,\n      // Change the recursion depth limit from Oniguruma's `20` to an integer `2`\u2013`20`.\n      recursionLimit: 20,\n      // `^` as `\\A`; `$` as`\\Z`. Improves search performance of generated regexes without changing\n      // meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.\n      singleline: false,\n      ...(options?.rules),\n    },\n  };\n  if (opts.target === 'auto') {\n    opts.target = envSupportsFlagGroups ? 'ES2025' : (envSupportsFlagV ? 'ES2024' : 'ES2018');\n  }\n  return opts;\n}\n\nexport {\n  Accuracy,\n  EsVersion,\n  getOptions,\n  Target,\n};\n", "import {cp, r} from './utils.js';\n\nconst CharsWithoutIgnoreCaseExpansion = new Set([\n  cp(0x130), // \u0130\n  cp(0x131), // \u0131\n]);\n\nfunction getIgnoreCaseMatchChars(char) {\n  // Some chars should not match the chars they case swap to\n  if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n    return [char];\n  }\n  const set = new Set();\n  const lower = char.toLowerCase();\n  // Everything else is based on `lower`\n  const upper = lower.toUpperCase();\n  const title = LowerToTitleCaseMap.get(lower);\n  const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n  // Exclude ucase if multiple chars; count code point length. Excludes ucase versions of German\n  // es-zed '\u00DF', ligatures like '\uFB00', and chars with no precomposed ucase like '\u0149'. See\n  // <unicode.org/Public/UNIDATA/SpecialCasing.txt>\n  if ([...upper].length === 1) {\n    set.add(upper);\n  }\n  altUpper && set.add(altUpper);\n  title && set.add(title);\n  // Lcase of '\u0130' is multiple chars, but it's excluded by `CharsWithoutIgnoreCaseExpansion`\n  set.add(lower);\n  altLower && set.add(altLower);\n  return [...set];\n}\n\n// The following set includes:\n// - All ES2024 general categories and their aliases (all are supported by Oniguruma). See\n//   <github.com/mathiasbynens/unicode-match-property-value-ecmascript/blob/main/data/mappings.js>\n// - All ES2024 binary properties and their aliases (all are supported by Oniguruma). See\n//   <tc39.es/ecma262/multipage/text-processing.html#table-binary-unicode-properties>\n// Unicode properties must be mapped to property names supported by JS, and must also apply JS's\n// stricter rules for casing, whitespace, and underscores in Unicode property names. In order to\n// remain lightweight, this library assumes properties not in this list are Unicode script names\n// (which require a `Script=` or `sc=` prefix in JS). Unlike JS, Oniguruma doesn't support script\n// extensions, and it supports some properties that aren't supported in JS (including blocks with\n// an `In_` prefix). See also:\n// - Properties supported in Oniguruma: <github.com/kkos/oniguruma/blob/master/doc/UNICODE_PROPERTIES>\n// - Properties supported in JS by spec version: <github.com/eslint-community/regexpp/blob/main/src/unicode/properties.ts>\nconst JsUnicodeProperties = new Set(\n`C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS`.split(/\\s/)\n);\n\nconst JsUnicodePropertiesMap = new Map();\nfor (const p of JsUnicodeProperties) {\n  JsUnicodePropertiesMap.set(slug(p), p);\n}\n\nconst JsUnicodePropertiesOfStrings = new Set([\n  // ES2024 properties of strings; none are supported by Oniguruma\n  'Basic_Emoji',\n  'Emoji_Keycap_Sequence',\n  'RGI_Emoji',\n  'RGI_Emoji_Flag_Sequence',\n  'RGI_Emoji_Modifier_Sequence',\n  'RGI_Emoji_Tag_Sequence',\n  'RGI_Emoji_ZWJ_Sequence',\n]);\n\nconst JsUnicodePropertiesOfStringsMap = new Map();\nfor (const p of JsUnicodePropertiesOfStrings) {\n  JsUnicodePropertiesOfStringsMap.set(slug(p), p);\n}\n\nconst LowerToAlternativeLowerCaseMap = new Map([\n  ['s', cp(0x17F)], // s, \u017F\n  [cp(0x17F), 's'], // \u017F, s\n]);\n\nconst LowerToAlternativeUpperCaseMap = new Map([\n  [cp(0xDF), cp(0x1E9E)], // \u00DF, \u1E9E\n  [cp(0x6B), cp(0x212A)], // k, \u212A (Kelvin)\n  [cp(0xE5), cp(0x212B)], // \u00E5, \u212B (Angstrom)\n  [cp(0x3C9), cp(0x2126)], // \u03C9, \u2126 (Ohm)\n]);\n\n// See <github.com/node-unicode/unicode-16.0.0/tree/main/General_Category/Titlecase_Letter>\nconst LowerToTitleCaseMap = new Map([\n  titleEntry(0x1C5),\n  titleEntry(0x1C8),\n  titleEntry(0x1CB),\n  titleEntry(0x1F2),\n  ...titleRange(0x1F88, 0x1F8F),\n  ...titleRange(0x1F98, 0x1F9F),\n  ...titleRange(0x1FA8, 0x1FAF),\n  titleEntry(0x1FBC),\n  titleEntry(0x1FCC),\n  titleEntry(0x1FFC),\n]);\n\n// Unlike Oniguruma's Unicode properties via `\\p` and `\\P`, these names are case sensitive and\n// don't allow inserting whitespace and underscores. Definitions at\n// <github.com/kkos/oniguruma/blob/master/doc/RE> (see: POSIX bracket: Unicode Case)\n// Note: Handling in the transformer assumes all values here are a single, negateable node that's\n// not pre-negated at the top level. It also uses ASCII versions of `graph` and `print` for target\n// `ES2018` (which doesn't allow intersection) if `accuracy` isn't `strict`\nconst PosixClassesMap = new Map([\n  ['alnum', r`[\\p{Alpha}\\p{Nd}]`],\n  ['alpha', r`\\p{Alpha}`],\n  ['ascii', r`\\p{ASCII}`],\n  ['blank', r`[\\p{Zs}\\t]`],\n  ['cntrl', r`\\p{cntrl}`],\n  ['digit', r`\\p{Nd}`],\n  ['graph', r`[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]`],\n  ['lower', r`\\p{Lower}`],\n  ['print', r`[[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`],\n  ['punct', r`[\\p{P}\\p{S}]`], // New value from Oniguruma 6.9.9\n  ['space', r`\\p{space}`],\n  ['upper', r`\\p{Upper}`],\n  ['word', r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`],\n  ['xdigit', r`\\p{AHex}`],\n]);\n\n// Apart from the property names provided by Unicode, Oniguruma explicitly adds several names (see\n// <github.com/kkos/oniguruma/blob/master/doc/RE>) that can be used within `\\p{}` and `\\P{}` (those\n// below). These should be listed here in lowercase, though they aren't case sensitive when used\nconst PosixProperties = new Set([\n  'alnum',\n  'blank',\n  'graph',\n  'print',\n  'word',\n  'xdigit',\n  // The following are available with the same name in JS (see `JsUnicodeProperties`), so can be\n  // handled as standard Unicode properties\n  // 'alpha', // (JS: Alpha)\n  // 'ascii', // (JS: ASCII)\n  // 'cntrl', // (JS: cntrl)\n  // 'digit', // (JS: digit)\n  // 'lower', // (JS: Lower)\n  // 'punct', // (JS: punct)\n  // 'space', // (JS: space)\n  // 'upper', // (JS: Upper)\n]);\n\nfunction range(start, end) {\n  // const range = Array.from(Array(end + 1 - start), (_, i) => i + start);\n  // const range = Array(end + 1 - start).fill(start).map((x, i) => x + i);\n  const range = [];\n  for (let i = start; i <= end; i++) {\n    range.push(i);\n  }\n  return range;\n}\n\n// Generates a Unicode property lookup name: lowercase, without spaces, hyphens, underscores\nfunction slug(name) {\n  return name.replace(/[- _]+/g, '').toLowerCase();\n}\n\nfunction titleEntry(codePoint) {\n  const char = cp(codePoint);\n  return [char.toLowerCase(), char];\n}\n\nfunction titleRange(start, end) {\n  return range(start, end).map(codePoint => titleEntry(codePoint));\n}\n\nconst UnicodePropertiesWithSpecificCase = new Set([\n  'Lower', 'Lowercase',\n  'Upper', 'Uppercase',\n  'Ll', 'Lowercase_Letter',\n  'Lt', 'Titlecase_Letter',\n  'Lu', 'Uppercase_Letter',\n  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.\n  // Some other properties include a handful of chars with specific cases only, but these chars are\n  // generally extreme edge cases and using such properties case insensitively generally produces\n  // undesired behavior anyway\n]);\n\nexport {\n  getIgnoreCaseMatchChars,\n  JsUnicodeProperties,\n  JsUnicodePropertiesMap,\n  JsUnicodePropertiesOfStringsMap,\n  PosixClassesMap,\n  PosixProperties,\n  slug,\n  UnicodePropertiesWithSpecificCase,\n};\n", "import {PosixClassesMap} from './unicode.js';\nimport {r} from './utils.js';\n\nconst TokenTypes = /** @type {const} */ ({\n  Alternator: 'Alternator',\n  Assertion: 'Assertion',\n  Backreference: 'Backreference',\n  Character: 'Character',\n  CharacterClassClose: 'CharacterClassClose',\n  CharacterClassHyphen: 'CharacterClassHyphen',\n  CharacterClassIntersector: 'CharacterClassIntersector',\n  CharacterClassOpen: 'CharacterClassOpen',\n  CharacterSet: 'CharacterSet',\n  Directive: 'Directive',\n  GroupClose: 'GroupClose',\n  GroupOpen: 'GroupOpen',\n  Subroutine: 'Subroutine',\n  Quantifier: 'Quantifier',\n  // These aren't allowed in char classes, so they aren't equivalent to JS `[\\q{}]`\n  VariableLengthCharacterSet: 'VariableLengthCharacterSet',\n  // Intermediate representation not included in results\n  EscapedNumber: 'EscapedNumber',\n});\n\nconst TokenCharacterSetKinds = {\n  any: 'any',\n  digit: 'digit',\n  dot: 'dot',\n  hex: 'hex',\n  non_newline: 'non_newline',\n  posix: 'posix',\n  property: 'property',\n  space: 'space',\n  word: 'word',\n};\n\nconst TokenDirectiveKinds = {\n  flags: 'flags',\n  keep: 'keep',\n};\n\nconst TokenGroupKinds = {\n  absent_repeater: 'absent_repeater',\n  atomic: 'atomic',\n  capturing: 'capturing',\n  group: 'group',\n  lookahead: 'lookahead',\n  lookbehind: 'lookbehind',\n};\n\nconst EscapeCharCodes = new Map([\n  ['a',  7], // alert/bell (Not available in JS)\n  ['b',  8], // backspace (only in char classes)\n  ['e', 27], // escape (Not available in JS)\n  ['f', 12], // form feed\n  ['n', 10], // line feed\n  ['r', 13], // carriage return\n  ['t',  9], // horizontal tab\n  ['v', 11], // vertical tab\n]);\n\nconst charClassOpenPattern = r`\\[\\^?`;\nconst sharedEscapesPattern = `${\n  // Control char\n  'c.? | C(?:-.?)?'\n}|${\n  // Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n  // `\\p{gc=L}` are invalid\n  r`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`\n}|${\n  // Hex encoded byte sequence; attempt match before other `\\xNN` hex char\n  r`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`\n}|${\n  // Hex char\n  r`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`\n}|${\n  // Enclosed octal code point\n  r`o\\{[^\\}]*\\}?`\n}|${\n  // Escaped number\n  r`\\d{1,3}`\n}`;\n// Even with flag x, Onig doesn't allow whitespace to separate a quantifier from the `?` or `+`\n// that makes it lazy or possessive. Possessive suffixes don't apply to interval quantifiers\nconst quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nconst tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?: \\? (?:\n    [:=!>(]\n    | <[=!]\n    | <[^>]*>\n    | '[^']*'\n    | ~\\|?\n    | # (?:[^)\\\\] | \\\\.?)*\n    | [imx\\-]+[:)]\n  )?)?\n  | ${quantifierRe.source}\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\nconst charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:[^:]*:\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\n@typedef {{\n  type: keyof TokenTypes;\n  raw: string;\n  [key: string]: string | number | boolean;\n}} Token\n@typedef {{\n  tokens: Array<Token>;\n  flags: {\n    dotAll: boolean;\n    extended: boolean;\n    ignoreCase: boolean;\n  };\n  rules: {\n    captureGroup: boolean;\n    singleline: boolean;\n  };\n}} TokenizerResult\n*/\n/**\n@param {string} pattern Oniguruma pattern.\n@param {string} [flags] Oniguruma flags.\n@param {{\n  captureGroup?: boolean;\n  singleline?: boolean;\n}} [rules] Oniguruma compile-time options.\n@returns {TokenizerResult}\n*/\nfunction tokenize(pattern, flags = '', rules) {\n  rules = {\n    // `ONIG_OPTION_CAPTURE_GROUP`\n    captureGroup: false,\n    // `ONIG_OPTION_SINGLELINE`\n    singleline: false,\n    ...rules,\n  };\n  if (typeof pattern !== 'string') {\n    throw new Error('String expected as pattern');\n  }\n  if (!/^[imxDSW]*$/.test(flags)) {\n    throw new Error(`Flags \"${flags}\" includes unsupported value`);\n  }\n  const extended = flags.includes('x');\n  const xStack = [extended];\n  const context = {\n    captureGroup: rules.captureGroup,\n    getCurrentModX: () => xStack.at(-1),\n    numOpenGroups: 0,\n    popModX() {xStack.pop()},\n    pushModX(isXOn) {xStack.push(isXOn)},\n    replaceCurrentModX(isXOn) {xStack[xStack.length - 1] = isXOn},\n    singleline: rules.singleline,\n  };\n  let tokens = [];\n  let match;\n  tokenRe.lastIndex = 0;\n  while ((match = tokenRe.exec(pattern))) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== undefined) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n\n  const potentialUnnamedCaptureTokens = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.forEach(t => {\n    if (t.type === TokenTypes.GroupOpen) {\n      if (t.kind === TokenGroupKinds.capturing) {\n        t.number = ++numNamedAndOptInUnnamedCaptures;\n      } else if (t.raw === '(') {\n        potentialUnnamedCaptureTokens.push(t);\n      }\n    }\n  });\n  // Enable unnamed capturing groups if no named captures (when `captureGroup` not enabled)\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = TokenGroupKinds.capturing;\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  // Can now split escaped nums accurately, accounting for number of captures\n  tokens = tokens.map(\n    t => t.type === TokenTypes.EscapedNumber ? splitEscapedNumToken(t, numCaptures) : t\n  ).flat();\n\n  return {\n    tokens,\n    flags: {\n      ignoreCase: flags.includes('i'),\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      dotAll: flags.includes('m'),\n      // Flag x is fully handled during tokenization\n      extended,\n      // Flags D, S, W are currently only supported as top-level flags\n      digitIsAscii: flags.includes('D'),\n      spaceIsAscii: flags.includes('S'),\n      wordIsAscii: flags.includes('W'),\n    },\n    rules,\n  };\n}\n\nfunction getTokenWithDetails(context, pattern, m, lastIndex) {\n  const [m0, m1, m2] = m;\n  if (m0 === '[') {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex,\n    };\n  }\n  if (m0 === '\\\\') {\n    if ('AbBGzZ'.includes(m1)) {\n      return {\n        token: createToken(TokenTypes.Assertion, m, {\n          kind: m,\n        }),\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Subroutine, m),\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Backreference, m),\n      };\n    }\n    if (m1 === 'K') {\n      return {\n        token: createToken(TokenTypes.Directive, m, {\n          kind: TokenDirectiveKinds.keep,\n        }),\n      };\n    }\n    if (m1 === 'N') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.non_newline,\n        }),\n      };\n    }\n    if (m1 === 'O') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.any,\n        }),\n      };\n    }\n    if ('RX'.includes(m1)) {\n      return {\n        token: createToken(TokenTypes.VariableLengthCharacterSet, m, {\n          kind: m,\n        }),\n      };\n    }\n    // Grapheme boundaries not yet unsupported; avoid treating as an identity escape\n    if ('yY'.includes(m1)) {\n      throw new Error(`Unsupported grapheme boundary \"${m}\"`);\n    }\n    // Run last since it assumes an identity escape as final condition\n    const result = createTokenForSharedEscape(m, {inCharClass: false});\n    return Array.isArray(result) ? {tokens: result} : {token: result};\n  }\n  if (m0 === '(') {\n    // Comment group\n    if (m2 === '#') {\n      // The closing unescaped `)` isn't included in the match\n      if (pattern[lastIndex] !== ')') {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        lastIndex: lastIndex + 1,\n      };\n    }\n    // Flag modifier (directive or group opener); allows solo `-`\n    if ('-imx'.includes(m2)) {\n      return {\n        token: createTokenForFlagMod(m, context),\n      };\n    }\n    // Remaining group types all reuse current flag x status\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      (m === '(' && !context.captureGroup) ||\n      // Noncapturing group\n      m === '(?:'\n    ) {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          // For `(`, will later change to `capturing` and add `number` prop if no named captures\n          kind: TokenGroupKinds.group,\n        }),\n      };\n    }\n    // Atomic group\n    if (m === '(?>') {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.atomic,\n        }),\n      };\n    }\n    // Lookaround\n    if (m === '(?=' || m === '(?!' || m === '(?<=' || m === '(?<!') {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: m2 === '<' ? TokenGroupKinds.lookbehind : TokenGroupKinds.lookahead,\n          negate: m.endsWith('!'),\n        }),\n      };\n    }\n    // Named capture (checked after lookbehind due to similar syntax), or unnamed capture when\n    // `captureGroup` enabled\n    if (m2 === '<' || m2 === \"'\" || (m === '(' && context.captureGroup)) {\n      const token = createToken(TokenTypes.GroupOpen, m, {\n        kind: TokenGroupKinds.capturing,\n        // Will add `number` in a second pass\n      });\n      if (m !== '(') {\n        token.name = m.slice(3, -1);\n      }\n      return {\n        token,\n      };\n    }\n    if (m2 === '~') {\n      if (m === '(?~|') {\n        throw new Error(`Unsupported absent function kind \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.absent_repeater,\n        }),\n      };\n    }\n    if (m2 === '(') {\n      // [TODO] Some forms are supportable\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    if (m === '(?') {\n      throw new Error('Invalid group');\n    }\n    throw new Error(`Unexpected group \"${m}\"`);\n  }\n  if (m === ')') {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createToken(TokenTypes.GroupClose, m),\n    };\n  }\n  if (m === '#' && context.getCurrentModX()) {\n    // Onig's only line break char is line feed\n    const end = pattern.indexOf('\\n', lastIndex);\n    return {\n      // Jump forward to the end of the comment\n      lastIndex: end === -1 ? pattern.length : end,\n    };\n  }\n  if (/^\\s$/.test(m) && context.getCurrentModX()) {\n    const re = /\\s+/y;\n    re.lastIndex = lastIndex;\n    const rest = re.exec(pattern);\n    return {\n      // Jump forward to the end of the whitespace\n      lastIndex: rest ? re.lastIndex : lastIndex,\n    };\n  }\n  if (m === '.') {\n    return {\n      token: createToken(TokenTypes.CharacterSet, m, {\n        kind: TokenCharacterSetKinds.dot,\n      }),\n    };\n  }\n  if (m === '^' || m === '$') {\n    const kind = context.singleline ? {\n      '^': r`\\A`,\n      '$': r`\\Z`,\n    }[m] : m;\n    return {\n      token: createToken(TokenTypes.Assertion, m, {\n        kind,\n      }),\n    };\n  }\n  if (m === '|') {\n    return {\n      token: createToken(TokenTypes.Alternator, m),\n    };\n  }\n  if (quantifierRe.test(m)) {\n    return {\n      token: createTokenForQuantifier(m),\n    };\n  }\n  assertSingleCodePoint(m);\n  return {\n    token: createToken(TokenTypes.Character, m, {\n      value: m.codePointAt(0),\n    }),\n  };\n}\n\nfunction getAllTokensForCharClass(pattern, opener, lastIndex) {\n  const tokens = [createToken(TokenTypes.CharacterClassOpen, opener, {\n    negate: opener[1] === '^',\n  })];\n  let numCharClassesOpen = 1;\n  let match;\n  charClassTokenRe.lastIndex = lastIndex;\n  while ((match = charClassTokenRe.exec(pattern))) {\n    const m = match[0];\n    // Start of nested char class\n    // POSIX classes are handled as a single token; not as a nested char class\n    if (m[0] === '[' && m[1] !== ':') {\n      numCharClassesOpen++;\n      tokens.push(createToken(TokenTypes.CharacterClassOpen, m, {\n        negate: m[1] === '^',\n      }));\n    } else if (m === ']') {\n      if (tokens.at(-1).type === TokenTypes.CharacterClassOpen) {\n        // Allow unescaped `]` as leading char\n        tokens.push(createToken(TokenTypes.Character, m, {\n          value: 93,\n        }));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createToken(TokenTypes.CharacterClassClose, m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = createTokenForAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length,\n  }\n}\n\nfunction createTokenForAnyTokenWithinCharClass(raw) {\n  if (raw[0] === '\\\\') {\n    // Assumes an identity escape as final condition\n    return createTokenForSharedEscape(raw, {inCharClass: true});\n  }\n  // POSIX class: `[:name:]` or `[:^name:]`\n  if (raw[0] === '[') {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassesMap.get(posix.groups.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createToken(TokenTypes.CharacterSet, raw, {\n      kind: TokenCharacterSetKinds.posix,\n      negate: !!posix.groups.negate,\n      value: posix.groups.name,\n    });\n  }\n  // Range (possibly invalid) or literal hyphen\n  if (raw === '-') {\n    return createToken(TokenTypes.CharacterClassHyphen, raw);\n  }\n  if (raw === '&&') {\n    return createToken(TokenTypes.CharacterClassIntersector, raw);\n  }\n  assertSingleCodePoint(raw);\n  return createToken(TokenTypes.Character, raw, {\n    value: raw.codePointAt(0),\n  });\n}\n\n// Tokens shared by base syntax and char class syntax that start with `\\`\nfunction createTokenForSharedEscape(raw, {inCharClass}) {\n  const char1 = raw[1];\n  if (char1 === 'c' || char1 === 'C') {\n    return createTokenForControlChar(raw);\n  }\n  if ('dDhHsSwW'.includes(char1)) {\n    return createTokenForShorthandCharClass(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return createTokenForUnicodeProperty(raw);\n  }\n  // Hex UTF-8 encoded byte sequence\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map(hex => parseInt(hex, 16));\n      const decoded = new TextDecoder('utf-8', {\n        ignoreBOM: true,\n        fatal: true,\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map(char => {\n        // Since this regenerates `raw`, it might have different casing for hex A-F than the input\n        const raw = [...encoder.encode(char)].map(byte => `\\\\x${byte.toString(16)}`).join('');\n        return createToken(TokenTypes.Character, raw, {\n          value: char.codePointAt(0),\n        });\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === 'u' || char1 === 'x') {\n    return createToken(TokenTypes.Character, raw, {\n      value: getValidatedHexCharCode(raw),\n    });\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createToken(TokenTypes.Character, raw, {\n      value: EscapeCharCodes.get(char1),\n    });\n  }\n  // Escaped number: backref (possibly invalid), null, octal, or identity escape, possibly followed\n  // by 1-2 literal digits\n  if (/\\d/.test(char1)) {\n    return createToken(TokenTypes.EscapedNumber, raw, {\n      inCharClass,\n    });\n  }\n  if (raw === '\\\\') {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  // Meta `\\M-x` and `\\M-\\C-x` are unsupported; avoid treating as an identity escape\n  if (char1 === 'M') {\n    // [TODO] Supportable; see <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#12-onig_syn_op2_esc_capital_m_bar_meta-enable-m-x>, <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>, <https://github.com/ammar/regexp_parser/blob/8851030feda68223d74f502335fb254a20d77016/lib/regexp_parser/expression/classes/escape_sequence.rb#L75>\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  // Identity escape; count code point length\n  if ([...raw].length === 2) {\n    return createToken(TokenTypes.Character, raw, {\n      value: raw.codePointAt(1),\n    });\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\n\n/**\n@param {keyof TokenTypes} type\n@param {string} raw\n@param {{[key: string]: string | number | boolean;}} [data]\n@returns {Token}\n*/\nfunction createToken(type, raw, data) {\n  return {\n    type,\n    raw,\n    ...data,\n  };\n}\n\n// Expects `\\cx` or `\\C-x`\nfunction createTokenForControlChar(raw) {\n  const char = raw[1] === 'c' ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    // Unlike JS, Onig allows any char to follow `\\c` or `\\C-`, but this is an extreme edge case\n    // [TODO] Supportable; see <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#11-onig_syn_op2_esc_capital_c_bar_control-enable-c-x>, <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createToken(TokenTypes.Character, raw, {\n    value: char.toUpperCase().codePointAt(0) - 64,\n  });\n}\n\nfunction createTokenForFlagMod(raw, context) {\n  // Allows multiple `-` and solo `-` without `on` or `off` flags\n  let {on, off} = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[imx\\-]*))?/.exec(raw).groups;\n  // If the capturing group didn't participate\n  off ??= '';\n  // Flag x is used directly by the tokenizer since it changes how to interpret the pattern\n  const isXOn = (context.getCurrentModX() || on.includes('x')) && !off.includes('x');\n  const enabledFlags = getFlagPropsForToken(on);\n  const disabledFlags = getFlagPropsForToken(off);\n  const flagChanges = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  // Flag directive; ex: `(?im-x)`\n  if (raw.endsWith(')')) {\n    // Replace flag x value until the end of the current group\n    context.replaceCurrentModX(isXOn);\n    // Can't remove flag directives without flags like `(?-)`; they affect following quantifiers\n    return createToken(TokenTypes.Directive, raw, {\n      kind: TokenDirectiveKinds.flags,\n      flags: flagChanges,\n    });\n  }\n  // Flag group opener; ex: `(?im-x:`\n  if (raw.endsWith(':')) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    const token = createToken(TokenTypes.GroupOpen, raw, {\n      kind: TokenGroupKinds.group,\n    });\n    if (enabledFlags || disabledFlags) {\n      token.flags = flagChanges;\n    }\n    return token;\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\n\nfunction createTokenForQuantifier(raw) {\n  const data = {};\n  if (raw[0] === '{') {\n    const {min, max} = /^\\{(?<min>\\d*)(?:,(?<max>\\d*))?/.exec(raw).groups;\n    const limit = 100_000;\n    if (+min > limit || +max > limit) {\n      throw new Error('Quantifier value unsupported in Oniguruma');\n    }\n    data.min = +min;\n    data.max = max === undefined ? +min : (max === '' ? Infinity : +max);\n    data.greedy = !raw.endsWith('?');\n    // By default, Onig doesn't support making interval quantifiers possessive\n    data.possessive = false;\n  } else {\n    data.min = raw[0] === '+' ? 1 : 0;\n    data.max = raw[0] === '?' ? 1 : Infinity;\n    data.greedy = raw[1] !== '?';\n    data.possessive = raw[1] === '+';\n  }\n  return createToken(TokenTypes.Quantifier, raw, data);\n}\n\nfunction createTokenForShorthandCharClass(raw) {\n  const lower = raw[1].toLowerCase();\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: {\n      'd': TokenCharacterSetKinds.digit,\n      'h': TokenCharacterSetKinds.hex, // Not available in JS\n      's': TokenCharacterSetKinds.space, // Different than JS\n      'w': TokenCharacterSetKinds.word,\n    }[lower],\n    negate: raw[1] !== lower,\n  });\n}\n\nfunction createTokenForUnicodeProperty(raw) {\n  const {p, neg, value} = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw).groups;\n  const negate = (p === 'P' && !neg) || (p === 'p' && !!neg);\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: TokenCharacterSetKinds.property,\n    negate,\n    value,\n  });\n}\n\nfunction getFlagPropsForToken(flags) {\n  // Don't include `false` for flags that aren't included\n  const obj = {};\n  if (flags.includes('i')) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes('m')) {\n    // Onig flag m is equivalent to JS flag s\n    obj.dotAll = true;\n  }\n  if (flags.includes('x')) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\n\n// - Unenclosed `\\xNN` above 0x7F is handled elsewhere as a UTF-8 encoded byte sequence\n// - Enclosed `\\x{}` with value above 0x10FFFF is allowed here; handled in the parser\nfunction getValidatedHexCharCode(raw) {\n  // Note: Onig (tested 6.9.8) has a bug where bare `\\u` and `\\x` are identity escapes if they\n  // appear at the very end of the pattern, so e.g. `\\u` matches `u`, but `\\u0`, `\\u.`, and `[\\u]`\n  // are all errors, and `\\x.` and `[\\x]` aren't errors but instead the `\\x` is equivalent to `\\0`.\n  // Don't emulate these bugs (see #21), and just treat these cases as errors. Also, Onig treats\n  // incomplete `\\x{` (with the brace and not immediately followed by a hex digit) as an identity\n  // escape, so e.g. `\\x{` matches `x{` and `^\\x{,2}$` matches `xx`, but `\\x{2,}` and `\\x{0,2}` are\n  // errors. Don't emulate this pointless ambiguity; just treat incomplete `\\x{` as an error\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  // Might include leading 0s\n  const hex = raw[2] === '{' ?\n    /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw).groups.hex :\n    raw.slice(2);\n  const dec = parseInt(hex, 16);\n  return dec;\n}\n\n// Value is 1-3 digits, which can be a backref (possibly invalid), null, octal, or identity escape,\n// possibly followed by 1-2 literal digits\nfunction splitEscapedNumToken(token, numCaptures) {\n  const {raw, inCharClass} = token;\n  // Keep any leading 0s since they indicate octal\n  const value = raw.slice(1);\n  // Backref (possibly invalid)\n  if (\n    !inCharClass &&\n    ( // Single digit 1-9 outside a char class is always treated as a backref\n      (value !== '0' && value.length === 1) ||\n      // Leading 0 makes it octal; backrefs can't include following literal digits\n      (value[0] !== '0' && +value <= numCaptures)\n    )\n  ) {\n    return [createToken(TokenTypes.Backreference, raw)];\n  }\n  const tokens = [];\n  // Returns 1-3 matches; the first (only) might be octal\n  const matches = value.match(/^[0-7]+|\\d/g);\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value;\n    // Octal digits are 0-7\n    if (i === 0 && m !== '8' && m !== '9') {\n      value = parseInt(m, 8);\n      if (value > 0o177) {\n        // Octal UTF-8 encoded byte sequence; not yet supported\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value = m.codePointAt(0);\n    }\n    tokens.push(createToken(TokenTypes.Character, (i === 0 ? '\\\\' : '') + m, {\n      value,\n    }));\n  }\n  return tokens;\n}\n\nfunction assertSingleCodePoint(raw) {\n  if ([...raw].length !== 1) {\n    throw new Error(`Expected \"${raw}\" to be a single code point`);\n  }\n}\n\nexport {\n  tokenize,\n  TokenCharacterSetKinds,\n  TokenDirectiveKinds,\n  TokenGroupKinds,\n  TokenTypes,\n};\n", "import {AstAssertionKinds, AstTypes} from './parse.js';\n\nfunction hasOnlyChild({alternatives}, kidFn) {\n  return (\n    alternatives.length === 1 &&\n    alternatives[0].elements.length === 1 &&\n    (!kidFn || kidFn(alternatives[0].elements[0]))\n  );\n}\n\nfunction isAlwaysZeroLength({type}) {\n  return type === AstTypes.Assertion || type === AstTypes.Directive;\n}\n\nfunction isAlwaysNonZeroLength(node) {\n  const types = [\n    AstTypes.Character,\n    AstTypes.CharacterClass,\n    AstTypes.CharacterSet,\n  ];\n  return types.includes(node.type) || (\n    node.type === AstTypes.Quantifier &&\n    node.min &&\n    types.includes(node.element.type)\n  );\n}\n\n// Consumptive groups add to the match.\n// - Includes: Capturing, named capturing, noncapturing, atomic, and flag groups.\n// - Excludes: Lookarounds.\n//   - Special case: Absent functions are consumptive (and negated, quantified) but are different\n//     in other ways so are excluded here.\n// See also `AstTypeAliases.AnyGroup`.\nfunction isConsumptiveGroup({type}) {\n  return type === AstTypes.CapturingGroup || type === AstTypes.Group;\n}\n\nfunction isLookaround({type, kind}) {\n  return (\n    type === AstTypes.Assertion &&\n    (kind === AstAssertionKinds.lookahead || kind === AstAssertionKinds.lookbehind)\n  );\n}\n\nexport {\n  hasOnlyChild,\n  isAlwaysNonZeroLength,\n  isAlwaysZeroLength,\n  isConsumptiveGroup,\n  isLookaround,\n};\n", "import {AstTypes} from './parse.js';\nimport {throwIfNot} from './utils.js';\nimport {isConsumptiveGroup, isLookaround} from './utils-ast.js';\n\nfunction traverse(path, state, visitor) {\n  let ast = path.node;\n  while (ast.parent) {\n    ast = ast.parent;\n  }\n  function traverseArray(array, parent) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(node, parent = null, key = null, container = null) {\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path = {\n      node,\n      parent,\n      key,\n      container,\n      ast,\n      remove() {\n        throwIfNot(container, 'Container expected').splice(Math.max(0, key + keyShift), 1);\n        keyShift -= 1;\n      },\n      removeAllNextSiblings() {\n        return throwIfNot(container, 'Container expected').splice(key + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = key + keyShift;\n        keyShift -= shifted;\n        return throwIfNot(container, 'Container expected').splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode) {\n        setParent(newNode, parent);\n        if (container) {\n          container[Math.max(0, key + keyShift)] = newNode;\n        } else {\n          parent[key] = newNode;\n        }\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      },\n    };\n    const visitorKey = getAstTypeAliases(node).find(key => !!visitor[key]);\n    const methods = visitorKey && visitor[visitorKey];\n    const enterFn = typeof methods === 'function' ? methods : methods?.enter;\n    const exitFn = methods?.exit;\n    enterFn?.(path, state);\n    if (!skipTraversingKidsOfPath) {\n      switch (node.type) {\n        case AstTypes.Regex:\n          traverseNode(node.pattern, node, 'pattern');\n          traverseNode(node.flags, node, 'flags');\n          break;\n        case AstTypes.Alternative:\n        case AstTypes.CharacterClass:\n          traverseArray(node.elements, node);\n          break;\n        case AstTypes.Assertion:\n          if (isLookaround(node)) {\n            traverseArray(node.alternatives, node);\n          }\n          break;\n        case AstTypes.Backreference:\n        case AstTypes.Character:\n        case AstTypes.CharacterSet:\n        case AstTypes.Directive:\n        case AstTypes.Flags:\n        case AstTypes.Recursion:\n        case AstTypes.Subroutine:\n        case AstTypes.VariableLengthCharacterSet:\n          break;\n        case AstTypes.AbsentFunction:\n        case AstTypes.CapturingGroup:\n        case AstTypes.Group:\n        case AstTypes.Pattern:\n          traverseArray(node.alternatives, node);\n          break;\n        case AstTypes.CharacterClassIntersection:\n          traverseArray(node.classes, node);\n          break;\n        case AstTypes.CharacterClassRange:\n          traverseNode(node.min, node, 'min');\n          traverseNode(node.max, node, 'max');\n          break;\n        case AstTypes.Quantifier:\n          traverseNode(node.element, node, 'element');\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${node.type}\"`);\n      }\n    }\n    exitFn?.(path, state);\n    return keyShift;\n  }\n  traverseNode(path.node, path.parent, path.key, path.container);\n}\n\nconst AstTypeAliases = {\n  AnyGroup: 'AnyGroup',\n  AnyNode: 'AnyNode',\n};\n\nfunction getAstTypeAliases(node) {\n  const types = [AstTypeAliases.AnyNode];\n  if (isConsumptiveGroup(node) || isLookaround(node)) {\n    types.push(AstTypeAliases.AnyGroup);\n  }\n  types.push(node.type);\n  return types;\n}\n\nfunction setParent(node, parent) {\n  // The traverser can work with ASTs whose nodes include or don't include `parent` props, so only\n  // update the parent if a prop for it exists\n  if ('parent' in parent) {\n    node.parent = parent;\n  }\n}\n\nexport {\n  traverse,\n};\n", "import {TokenCharacterSetKinds, TokenDirectiveKinds, TokenGroupKinds, TokenTypes} from './tokenize.js';\nimport {traverse} from './traverse.js';\nimport {JsUnicodePropertiesMap, JsUnicodePropertiesOfStringsMap, PosixProperties, slug} from './unicode.js';\nimport {getOrCreate, r, throwIfNot} from './utils.js';\nimport {hasOnlyChild} from './utils-ast.js';\n\nconst AstTypes = {\n  AbsentFunction: 'AbsentFunction',\n  Alternative: 'Alternative',\n  Assertion: 'Assertion',\n  Backreference: 'Backreference',\n  CapturingGroup: 'CapturingGroup',\n  Character: 'Character',\n  CharacterClass: 'CharacterClass',\n  CharacterClassIntersection: 'CharacterClassIntersection',\n  CharacterClassRange: 'CharacterClassRange',\n  CharacterSet: 'CharacterSet',\n  Directive: 'Directive',\n  Flags: 'Flags',\n  Group: 'Group',\n  Pattern: 'Pattern',\n  Quantifier: 'Quantifier',\n  Regex: 'Regex',\n  Subroutine: 'Subroutine',\n  VariableLengthCharacterSet: 'VariableLengthCharacterSet',\n  // Used only by the transformer for Regex+ ASTs\n  Recursion: 'Recursion',\n};\n\nconst AstAbsentFunctionKinds = {\n  // See <github.com/slevithan/oniguruma-to-es/issues/13>\n  repeater: 'repeater',\n};\n\nconst AstAssertionKinds = {\n  line_end: 'line_end',\n  line_start: 'line_start',\n  lookahead: 'lookahead',\n  lookbehind: 'lookbehind',\n  search_start: 'search_start',\n  string_end: 'string_end',\n  string_end_newline: 'string_end_newline',\n  string_start: 'string_start',\n  word_boundary: 'word_boundary',\n};\n\n// Identical values\nconst AstCharacterSetKinds = TokenCharacterSetKinds;\nconst AstDirectiveKinds = TokenDirectiveKinds;\n\nconst AstVariableLengthCharacterSetKinds = {\n  grapheme: 'grapheme',\n  newline: 'newline',\n};\n\n/**\n@typedef {{\n  type: 'Regex';\n  parent: null;\n  pattern: Object;\n  flags: Object;\n}} OnigurumaAst\n*/\n/**\n@param {import('./tokenize.js').TokenizerResult} tokenizerResult\n@param {{\n  skipBackrefValidation?: boolean;\n  skipPropertyNameValidation?: boolean;\n  verbose?: boolean;\n}} [options]\n@returns {OnigurumaAst}\n*/\nfunction parse({tokens, flags, rules}, options) {\n  const opts = {\n    skipBackrefValidation: false,\n    skipLookbehindValidation: false,\n    skipPropertyNameValidation: false,\n    verbose: false,\n    ...options,\n  };\n  const context = {\n    capturingGroups: [],\n    current: 0,\n    hasNumberedRef: false,\n    namedGroupsByName: new Map(),\n    parent: null,\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipLookbehindValidation: opts.skipLookbehindValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    token: null,\n    tokens,\n    verbose: opts.verbose,\n    walk,\n  };\n  function walk(parent, state) {\n    const token = tokens[context.current];\n    context.parent = parent;\n    context.token = token;\n    // Advance for the next iteration\n    context.current++;\n    switch (token.type) {\n      case TokenTypes.Alternator:\n        // Top-level only; groups handle their own alternators\n        return createAlternative();\n      case TokenTypes.Assertion:\n        return createAssertionFromToken(token);\n      case TokenTypes.Backreference:\n        return parseBackreference(context);\n      case TokenTypes.Character:\n        return createCharacter(token.value, {useLastValid: !!state.isCheckingRangeEnd});\n      case TokenTypes.CharacterClassHyphen:\n        return parseCharacterClassHyphen(context, state);\n      case TokenTypes.CharacterClassOpen:\n        return parseCharacterClassOpen(context, state);\n      case TokenTypes.CharacterSet:\n        return parseCharacterSet(context);\n      case TokenTypes.Directive:\n        return createDirectiveFromToken(token);\n      case TokenTypes.GroupOpen:\n        return parseGroupOpen(context, state);\n      case TokenTypes.Quantifier:\n        return parseQuantifier(context);\n      case TokenTypes.Subroutine:\n        return parseSubroutine(context);\n      case TokenTypes.VariableLengthCharacterSet:\n        return createVariableLengthCharacterSet(token.kind);\n      default:\n        throw new Error(`Unexpected token type \"${token.type}\"`);\n    }\n  }\n  const ast = createRegex(createPattern(), createFlags(flags));\n  let top = ast.pattern.alternatives[0];\n  while (context.current < tokens.length) {\n    const node = walk(top, {});\n    if (node.type === AstTypes.Alternative) {\n      ast.pattern.alternatives.push(node);\n      top = node;\n    } else {\n      top.elements.push(node);\n    }\n  }\n  // `context` updated by preceding `walk` loop\n  const {capturingGroups, hasNumberedRef, namedGroupsByName, subroutines} = context;\n  // Validation that requires knowledge about the complete pattern\n  if (hasNumberedRef && namedGroupsByName.size && !rules.captureGroup) {\n    throw new Error('Numbered backref/subroutine not allowed when using named capture');\n  }\n  for (const {ref} of subroutines) {\n    if (typeof ref === 'number') {\n      // Relative nums are already resolved\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref).length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    }\n  }\n  // Add `parent` properties now that we have a final AST\n  traverse({node: ast}, null, {\n    AnyNode({node, parent}) {\n      node.parent = parent;\n    },\n  });\n  return ast;\n}\n\n// Supported (if the backref appears to the right of the reffed capture's opening paren):\n// - `\\k<name>`, `\\k'name'`\n// - When named capture not used:\n//   - `\\n`, `\\nn`, `\\nnn`\n//   - `\\k<n>`, `\\k'n'\n//   - `\\k<-n>`, `\\k'-n'`\n// Unsupported:\n// - `\\k<+n>`, `\\k'+n'` - Note that, Unlike Oniguruma, Onigmo doesn't support this as special\n//   syntax and therefore considers it a valid group name.\n// - Backref with recursion level (with num or name): `\\k<n+level>`, `\\k<n-level>`, etc.\n//   (Onigmo also supports `\\k<-n+level>`, `\\k<-n-level>`, etc.)\n// Backrefs in Onig use multiplexing for duplicate group names (the rules can be complicated when\n// overlapping with subroutines), but a `Backreference`'s simple `ref` prop doesn't capture these\n// details so multiplexed ref pointers need to be derived when working with the AST\nfunction parseBackreference(context) {\n  const {raw} = context.token;\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    // Note: It's not an error for numbered backrefs to come before their referenced group in Onig,\n    // but an error is the best path for this library because:\n    // 1. Most placements are mistakes and can never match (based on the Onig behavior for backrefs\n    //    to nonparticipating groups).\n    // 2. Erroring matches the behavior of named backrefs.\n    // 3. The edge cases where they're matchable rely on rules for backref resetting within\n    //    quantified groups that are different in JS and aren't emulatable. Note that it's not a\n    //    backref in the first place if using `\\10` or higher and not as many capturing groups are\n    //    defined to the left (it's an octal or identity escape).\n    // [TODO] Ideally this would be refactored to include the backref in the AST when it's not an\n    // error in Onig (due to the reffed group being defined to the right), and the error handling\n    // would move to the transformer\n    if (num > numCapturesToLeft) {\n      // [WARNING] Skipping the error breaks assumptions and might create edge case issues, since\n      // backrefs are required to come after their captures; unfortunately this option is needed\n      // for TextMate grammars\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, {orphan});\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups.num, !!numberedRef.groups.sign);\n    }\n    // Invalid in a backref name even when valid in a group name\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\n\nfunction parseCharacterClassHyphen(context, state) {\n  const {parent, tokens, walk} = context;\n  const prevSiblingNode = parent.elements.at(-1);\n  const nextToken = tokens[context.current];\n  if (\n    !state.isCheckingRangeEnd &&\n    prevSiblingNode &&\n    prevSiblingNode.type !== AstTypes.CharacterClass &&\n    prevSiblingNode.type !== AstTypes.CharacterClassRange &&\n    nextToken &&\n    nextToken.type !== TokenTypes.CharacterClassOpen &&\n    nextToken.type !== TokenTypes.CharacterClassClose &&\n    nextToken.type !== TokenTypes.CharacterClassIntersector\n  ) {\n    const nextNode = walk(parent, {\n      ...state,\n      isCheckingRangeEnd: true,\n    });\n    if (prevSiblingNode.type === AstTypes.Character && nextNode.type === AstTypes.Character) {\n      parent.elements.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error('Invalid character class range');\n  }\n  // Literal hyphen\n  return createCharacter(45);\n}\n\nfunction parseCharacterClassOpen(context, state) {\n  const {token, tokens, verbose, walk} = context;\n  const firstClassToken = tokens[context.current];\n  let node = createCharacterClass({negate: token.negate});\n  const intersection = node.elements[0];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== TokenTypes.CharacterClassClose) {\n    if (nextToken.type === TokenTypes.CharacterClassIntersector) {\n      intersection.classes.push(createCharacterClass({negate: false, baseOnly: true}));\n      // Skip the intersector\n      context.current++;\n    } else {\n      const cc = intersection.classes.at(-1);\n      cc.elements.push(walk(cc, state));\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.current], firstClassToken);\n  }\n  if (!verbose) {\n    optimizeCharacterClassIntersection(intersection);\n  }\n  // Simplify tree if we don't need the intersection wrapper\n  if (intersection.classes.length === 1) {\n    const cc = intersection.classes[0];\n    // Only needed if `!verbose`; otherwise an intersection's direct kids are never negated\n    cc.negate = node.negate !== cc.negate;\n    node = cc;\n  }\n  // Skip the closing square bracket\n  context.current++;\n  return node;\n}\n\nfunction parseCharacterSet({token, skipPropertyNameValidation}) {\n  let {kind, negate, value} = token;\n  if (kind === TokenCharacterSetKinds.property) {\n    const normalized = slug(value);\n    if (PosixProperties.has(normalized)) {\n      kind = TokenCharacterSetKinds.posix;\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value, {\n        negate,\n        skipPropertyNameValidation,\n      });\n    }\n  }\n  if (kind === TokenCharacterSetKinds.posix) {\n    return {\n      type: AstTypes.CharacterSet,\n      kind: AstCharacterSetKinds.posix,\n      negate,\n      value,\n    };\n  }\n  return createCharacterSet(kind, {negate});\n}\n\nfunction parseGroupOpen(context, state) {\n  const {token, tokens, capturingGroups, namedGroupsByName, skipLookbehindValidation, verbose, walk} = context;\n  let node = createByGroupKind(token);\n  const isAbsentFunction = node.type === AstTypes.AbsentFunction;\n  const isLookbehind = node.kind === AstAssertionKinds.lookbehind;\n  const isNegLookbehind = isLookbehind && node.negate;\n  // Track capturing group details for backrefs and subroutines (before parsing the group's\n  // contents so nested groups with the same name are tracked in order)\n  if (node.type === AstTypes.CapturingGroup) {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrCreate(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  // Don't allow nested absent functions\n  if (isAbsentFunction && state.isInAbsentFunction) {\n    // Is officially unsupported in Onig but doesn't throw, gives strange results\n    throw new Error('Nested absent function not supported by Oniguruma');\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  while (nextToken.type !== TokenTypes.GroupClose) {\n    if (nextToken.type === TokenTypes.Alternator) {\n      node.alternatives.push(createAlternative());\n      // Skip the alternator\n      context.current++;\n    } else {\n      const alt = node.alternatives.at(-1);\n      const child = walk(alt, {\n        ...state,\n        isInAbsentFunction: state.isInAbsentFunction || isAbsentFunction,\n        isInLookbehind: state.isInLookbehind || isLookbehind,\n        isInNegLookbehind: state.isInNegLookbehind || isNegLookbehind,\n      });\n      alt.elements.push(child);\n      // Centralized validation of lookbehind contents\n      if ((isLookbehind || state.isInLookbehind) && !skipLookbehindValidation) {\n        // JS supports all features within lookbehind, but Onig doesn't. Absent functions of form\n        // `(?~|)` and `(?~|\u2026)` are also invalid in lookbehind (the `(?~\u2026)` and `(?~|\u2026|\u2026)` forms\n        // are allowed), but all forms with `(?~|` throw since they aren't yet supported\n        const msg = 'Lookbehind includes a pattern not allowed by Oniguruma';\n        if (isNegLookbehind || state.isInNegLookbehind) {\n          // - Invalid: `(?=\u2026)`, `(?!\u2026)`, capturing groups\n          // - Valid: `(?<=\u2026)`, `(?<!\u2026)`\n          if (child.kind === AstAssertionKinds.lookahead || child.type === AstTypes.CapturingGroup) {\n            throw new Error(msg);\n          }\n        } else {\n          // - Invalid: `(?=\u2026)`, `(?!\u2026)`, `(?<!\u2026)`\n          // - Valid: `(?<=\u2026)`, capturing groups\n          if (child.kind === AstAssertionKinds.lookahead || (child.kind === AstAssertionKinds.lookbehind && child.negate)) {\n            throw new Error(msg);\n          }\n        }\n      }\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  }\n  if (!verbose) {\n    node = getOptimizedGroup(node);\n  }\n  // Skip the closing parenthesis\n  context.current++;\n  return node;\n}\n\nfunction parseQuantifier({token, parent}) {\n  const {min, max, greedy, possessive} = token;\n  const quantifiedNode = parent.elements.at(-1);\n  if (\n    !quantifiedNode ||\n    quantifiedNode.type === AstTypes.Assertion ||\n    quantifiedNode.type === AstTypes.Directive\n  ) {\n    throw new Error(`Quantifier requires a repeatable token`);\n  }\n  const node = createQuantifier(quantifiedNode, min, max, greedy, possessive);\n  parent.elements.pop();\n  return node;\n}\n\n// Onig subroutine behavior:\n// - Subroutines can appear before the groups they reference; ex: `\\g<1>(a)` is valid.\n// - Multiple subroutines can reference the same group.\n// - Subroutines can reference groups that themselves contain subroutines, followed to any depth.\n// - Subroutines can be used recursively, and `\\g<0>` recursively references the whole pattern.\n// - Subroutines can use relative references (backward or forward); ex: `\\g<+1>(.)\\g<-1>`.\n// - Subroutines don't get their own capturing group numbers; ex: `(.)\\g<1>\\2` is invalid.\n// - Subroutines use the flags that apply to their referenced group, so e.g.\n//   `(?-i)(?<a>a)(?i)\\g<a>` is fully case sensitive.\n// - Differences from PCRE/Perl/Regex+ subroutines:\n//   - Subroutines can't reference duplicate group names (though duplicate names are valid if no\n//     subroutines reference them).\n//   - Subroutines can't use absolute or relative numbers if named capture is used anywhere.\n//   - Named backrefs must be to the right of their group definition, so the backref in\n//     `\\g<a>\\k<a>(?<a>)` is invalid (not directly related to subroutines).\n//   - Subroutines don't restore capturing group match values (for backrefs) upon exit, so e.g.\n//     `(?<a>(?<b>[ab]))\\g<a>\\k<b>` matches `abb` but not `aba`; same for numbered.\n// The interaction of backref multiplexing (an Onig-specific feature) and subroutines is complex:\n// - Only the most recent value matched by a capturing group and its subroutines is considered for\n//   backref multiplexing, and this also applies to capturing groups nested within a group that's\n//   referenced by a subroutine.\n// - Although a subroutine can't reference a group with a duplicate name, it can reference a group\n//   with a nested capture whose name is duplicated (e.g. outside of the referenced group).\n//   - These duplicate names can then multiplex; but only the most recent value matched from within\n//     the outer group (or the subroutines that reference it) is available for multiplexing.\n//   - Ex: With `(?<a>(?<b>[123]))\\g<a>\\g<a>(?<b>0)\\k<b>`, the backref `\\k<b>` can only match `0`\n//     or whatever was matched by the most recently matched subroutine. If you took out `(?<b>0)`,\n//     no multiplexing would occur.\nfunction parseSubroutine(context) {\n  const {token, capturingGroups, subroutines} = context;\n  let ref = token.raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      '': num,\n      '+': numCapturesToLeft + num,\n      '-': numCapturesToLeft + 1 - num,\n    }[numberedRef.groups.sign];\n    if (ref < 1) {\n      throw new Error('Invalid subroutine number');\n    }\n  // Special case for full-pattern recursion; can't be `+0`, `-0`, `00`, etc.\n  } else if (ref === '0') {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\n\nfunction createAbsentFunction(kind) {\n  if (kind !== AstAbsentFunctionKinds.repeater) {\n    throw new Error(`Unexpected absent function kind \"${kind}\"`);\n  }\n  return {\n    type: AstTypes.AbsentFunction,\n    kind,\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createAlternative() {\n  return {\n    type: AstTypes.Alternative,\n    elements: [],\n  };\n}\n\nfunction createAssertion(kind, options) {\n  // Use `createLookaround` for lookahead and lookbehind assertions\n  const negate = !!options?.negate;\n  return {\n    type: AstTypes.Assertion,\n    kind,\n    ...(kind === AstAssertionKinds.word_boundary && {negate}),\n  };\n}\n\nfunction createAssertionFromToken({kind}) {\n  return createAssertion(\n    throwIfNot({\n      '^': AstAssertionKinds.line_start,\n      '$': AstAssertionKinds.line_end,\n      '\\\\A': AstAssertionKinds.string_start,\n      '\\\\b': AstAssertionKinds.word_boundary,\n      '\\\\B': AstAssertionKinds.word_boundary,\n      '\\\\G': AstAssertionKinds.search_start,\n      '\\\\z': AstAssertionKinds.string_end,\n      '\\\\Z': AstAssertionKinds.string_end_newline,\n    }[kind], `Unexpected assertion kind \"${kind}\"`),\n    {negate: kind === r`\\B`}\n  );\n}\n\nfunction createBackreference(ref, options) {\n  const orphan = !!options?.orphan;\n  return {\n    type: AstTypes.Backreference,\n    ...(orphan && {orphan}),\n    ref,\n  };\n}\n\nfunction createByGroupKind({flags, kind, name, negate, number}) {\n  switch (kind) {\n    case TokenGroupKinds.absent_repeater:\n      return createAbsentFunction(AstAbsentFunctionKinds.repeater);\n    case TokenGroupKinds.atomic:\n      return createGroup({atomic: true});\n    case TokenGroupKinds.capturing:\n      return createCapturingGroup(number, name);\n    case TokenGroupKinds.group:\n      return createGroup({flags});\n    case TokenGroupKinds.lookahead:\n    case TokenGroupKinds.lookbehind:\n      return createLookaround({\n        behind: kind === TokenGroupKinds.lookbehind,\n        negate,\n      });\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\n\nfunction createCapturingGroup(number, name) {\n  const hasName = name !== undefined;\n  if (hasName && !isValidGroupNameOniguruma(name)) {\n    throw new Error(`Group name \"${name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: AstTypes.CapturingGroup,\n    number,\n    ...(hasName && {name}),\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createCharacter(charCode, options) {\n  const opts = {\n    useLastValid: false,\n    ...options,\n  };\n  if (charCode > 0x10FFFF) {\n    const hex = charCode.toString(16);\n    if (opts.useLastValid) {\n      charCode = 0x10FFFF;\n    } else if (charCode > 0x13FFFF) {\n      throw new Error(`Invalid code point out of range \"\\\\x{${hex}}\"`);\n    } else {\n      throw new Error(`Invalid code point out of range in JS \"\\\\x{${hex}}\"`);\n    }\n  }\n  return {\n    type: AstTypes.Character,\n    value: charCode,\n  };\n}\n\nfunction createCharacterClass(options) {\n  const opts = {\n    baseOnly: false,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: AstTypes.CharacterClass,\n    negate: opts.negate,\n    elements: opts.baseOnly ? [] : [createCharacterClassIntersection()],\n  };\n}\n\nfunction createCharacterClassIntersection() {\n  return {\n    type: AstTypes.CharacterClassIntersection,\n    classes: [createCharacterClass({negate: false, baseOnly: true})],\n  };\n}\n\nfunction createCharacterClassRange(min, max) {\n  if (max.value < min.value) {\n    throw new Error('Character class range out of order');\n  }\n  return {\n    type: AstTypes.CharacterClassRange,\n    min,\n    max,\n  };\n}\n\nfunction createCharacterSet(kind, {negate}) {\n  const node = {\n    type: AstTypes.CharacterSet,\n    kind: throwIfNot(AstCharacterSetKinds[kind], `Unexpected character set kind \"${kind}\"`),\n  };\n  if (\n    kind === TokenCharacterSetKinds.digit ||\n    kind === TokenCharacterSetKinds.hex ||\n    kind === TokenCharacterSetKinds.space ||\n    kind === TokenCharacterSetKinds.word\n  ) {\n    node.negate = negate;\n  }\n  return node;\n}\n\nfunction createDirectiveFromToken({kind, flags}) {\n  const node = {\n    type: AstTypes.Directive,\n    kind: throwIfNot(AstDirectiveKinds[kind], `Unexpected directive kind \"${kind}\"`),\n  };\n  // Can't optimize by simply creating a `Group` with a `flags` prop and wrapping the remainder of\n  // the open group or pattern in it, because the flag modifier's effect might extend across\n  // alternation. Ex: `a(?i)b|c` is equivalent to `a(?i:b)|(?i:c)`, not `a(?i:b|c)`\n  if (kind === TokenDirectiveKinds.flags) {\n    node.flags = flags;\n  }\n  return node;\n}\n\nfunction createFlags({ignoreCase, dotAll, extended, digitIsAscii, spaceIsAscii, wordIsAscii}) {\n  return {\n    type: AstTypes.Flags,\n    ignoreCase,\n    dotAll,\n    extended,\n    digitIsAscii,\n    spaceIsAscii,\n    wordIsAscii,\n  };\n}\n\nfunction createGroup(options) {\n  const atomic = options?.atomic;\n  const flags = options?.flags;\n  return {\n    type: AstTypes.Group,\n    ...(atomic && {atomic}),\n    ...(flags && {flags}),\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createLookaround(options) {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: AstTypes.Assertion,\n    kind: opts.behind ? AstAssertionKinds.lookbehind : AstAssertionKinds.lookahead,\n    negate: opts.negate,\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createPattern() {\n  return {\n    type: AstTypes.Pattern,\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createQuantifier(element, min, max, greedy = true, possessive = false) {\n  const node = {\n    type: AstTypes.Quantifier,\n    min,\n    max,\n    greedy,\n    possessive,\n    element,\n  };\n  if (max < min) {\n    return {\n      ...node,\n      min: max,\n      max: min,\n      possessive: true,\n    };\n  }\n  return node;\n}\n\nfunction createRegex(pattern, flags) {\n  return {\n    type: AstTypes.Regex,\n    pattern,\n    flags,\n  };\n}\n\nfunction createSubroutine(ref) {\n  return {\n    type: AstTypes.Subroutine,\n    ref,\n  };\n}\n\nfunction createUnicodeProperty(value, options) {\n  const opts = {\n    negate: false,\n    skipPropertyNameValidation: false,\n    ...options,\n  };\n  return {\n    type: AstTypes.CharacterSet,\n    kind: AstCharacterSetKinds.property,\n    value: opts.skipPropertyNameValidation ? value : getJsUnicodePropertyName(value),\n    negate: opts.negate,\n  }\n}\n\nfunction createVariableLengthCharacterSet(kind) {\n  return {\n    type: AstTypes.VariableLengthCharacterSet,\n    kind: throwIfNot({\n      '\\\\R': AstVariableLengthCharacterSetKinds.newline,\n      '\\\\X': AstVariableLengthCharacterSetKinds.grapheme,\n    }[kind], `Unexpected varcharset kind \"${kind}\"`),\n  };\n}\n\n// Unlike Onig, JS Unicode property names are case sensitive, don't ignore spaces, hyphens, and\n// underscores, and require underscores in specific positions\nfunction getJsUnicodePropertyName(value) {\n  const slugged = slug(value);\n  if (JsUnicodePropertiesOfStringsMap.has(slugged)) {\n    // Variable-length properties of strings aren't supported by Onig\n    throw new Error(r`Unicode property \"\\p{${value}}\" unsupported in Oniguruma`);\n  }\n  const jsName = JsUnicodePropertiesMap.get(slugged);\n  if (jsName) {\n    return jsName;\n  }\n  // Assume it's a script name (avoids including heavyweight data for long list of script names);\n  // JS requires formatting `Like_This`, so use best effort to reformat the name (covers a lot, but\n  // isn't able to map for all possible formatting differences)\n  return value.\n    trim().\n    replace(/[- _]+/g, '_').\n    replace(/[A-Z][a-z]+(?=[A-Z])/g, '$&_'). // `PropertyName` to `Property_Name`\n    replace(/[A-Za-z]+/g, m => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\n\n// If a direct child group is needlessly nested, return it instead (after modifying it)\nfunction getOptimizedGroup(node) {\n  const firstAltFirstEl = node.alternatives[0].elements[0];\n  if (\n    node.type === AstTypes.Group &&\n    hasOnlyChild(node, kid => kid.type === AstTypes.Group) &&\n    !(node.atomic && firstAltFirstEl.flags) &&\n    !(node.flags && (firstAltFirstEl.atomic || firstAltFirstEl.flags))\n  ) {\n    if (node.atomic) {\n      firstAltFirstEl.atomic = true;\n    } else if (node.flags) {\n      firstAltFirstEl.flags = node.flags;\n    }\n    return firstAltFirstEl;\n  }\n  return node;\n}\n\nfunction isValidGroupNameOniguruma(name) {\n  // The more restrictive rules for valid JS group names are captured in `isValidGroupNameJs`. Note\n  // that backrefs and subroutines might contextually use `-` and `+` to indicate relative index or\n  // recursion level\n  return /^[\\p{Alpha}\\p{Pc}][^)]*$/u.test(name);\n}\n\n// For any intersection classes that contain only a class, swap the parent with its (modded) child\nfunction optimizeCharacterClassIntersection(intersection) {\n  for (let i = 0; i < intersection.classes.length; i++) {\n    const cc = intersection.classes[i];\n    const firstChild = cc.elements[0];\n    if (cc.elements.length === 1 && firstChild.type === AstTypes.CharacterClass) {\n      intersection.classes[i] = firstChild;\n      firstChild.negate = cc.negate !== firstChild.negate;\n    }\n  }\n}\n\nfunction throwIfUnclosedCharacterClass(token, firstClassToken) {\n  return throwIfNot(\n    token,\n    // Easier to understand error when applicable\n    `${firstClassToken?.value === 93 ? 'Empty' : 'Unclosed'} character class`\n  );\n}\n\nfunction throwIfUnclosedGroup(token) {\n  return throwIfNot(token, 'Unclosed group');\n}\n\nexport {\n  AstAbsentFunctionKinds,\n  AstAssertionKinds,\n  AstCharacterSetKinds,\n  AstDirectiveKinds,\n  AstTypes,\n  AstVariableLengthCharacterSetKinds,\n  createAbsentFunction,\n  createAlternative,\n  createAssertion,\n  createBackreference,\n  createCapturingGroup,\n  createCharacter,\n  createCharacterClass,\n  createCharacterClassIntersection,\n  createCharacterClassRange,\n  createCharacterSet,\n  createFlags,\n  createGroup,\n  createLookaround,\n  createPattern,\n  createQuantifier,\n  createRegex,\n  createSubroutine,\n  createUnicodeProperty,\n  createVariableLengthCharacterSet,\n  parse,\n};\n", "import {Accuracy, Target} from './options.js';\nimport {AstAssertionKinds, AstCharacterSetKinds, AstDirectiveKinds, AstTypes, AstVariableLengthCharacterSetKinds, createAlternative, createAssertion, createBackreference, createCapturingGroup, createCharacterSet, createGroup, createLookaround, createQuantifier, createUnicodeProperty, parse} from './parse.js';\nimport {tokenize} from './tokenize.js';\nimport {traverse} from './traverse.js';\nimport {JsUnicodeProperties, PosixClassesMap} from './unicode.js';\nimport {cp, getNewCurrentFlags, getOrCreate, isMinTarget, r} from './utils.js';\nimport {hasOnlyChild, isAlwaysNonZeroLength, isAlwaysZeroLength, isConsumptiveGroup, isLookaround} from './utils-ast.js';\nimport emojiRegex from 'emoji-regex-xs';\n\n/**\n@typedef {{\n  type: 'Regex';\n  parent: null;\n  pattern: Object;\n  flags: Object;\n  options: Object;\n  _strategy: string | null;\n}} RegexAst\n*/\n/**\nTransforms an Oniguruma AST in-place to a [Regex+](https://github.com/slevithan/regex) AST.\nAssumes target ES2025, expecting the generator to down-convert to the desired JS target version.\n\nRegex+'s syntax and behavior is a strict superset of native JavaScript, so the AST is very close\nto representing native ES2025 `RegExp` but with some added features (atomic groups, possessive\nquantifiers, recursion). The AST doesn't use some of Regex+'s extended features like flag x or\nsubroutines because they follow PCRE behavior and work somewhat differently than in Oniguruma. The\nAST represents what's needed to precisely reproduce Oniguruma behavior using Regex+.\n@param {import('./parse.js').OnigurumaAst} ast\n@param {{\n  accuracy?: keyof Accuracy;\n  asciiWordBoundaries?: boolean;\n  avoidSubclass?: boolean;\n  bestEffortTarget?: keyof Target;\n}} [options]\n@returns {RegexAst}\n*/\nfunction transform(ast, options) {\n  const opts = {\n    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n    // - `VariableLengthCharacterSet` kind `grapheme` (`\\X`): An exact representation would require\n    //   heavy Unicode data; a best-effort approximation requires knowing the target.\n    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode-based\n    //   representations would be hard to change to ASCII-based after the fact in the generator\n    //   based on `target`/`accuracy`, so produce the appropriate structure here.\n    accuracy: 'default',\n    asciiWordBoundaries: false,\n    avoidSubclass: false,\n    bestEffortTarget: 'ES2025',\n    ...options,\n  };\n  const firstPassState = {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    flagDirectivesByAlt: new Map(),\n    jsGroupNameMap: new Map(),\n    minTargetEs2024: isMinTarget(opts.bestEffortTarget, 'ES2024'),\n    passedLookbehind: false,\n    strategy: null,\n    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n    subroutineRefMap: new Map(),\n    supportedGNodes: new Set(),\n    digitIsAscii: ast.flags.digitIsAscii,\n    spaceIsAscii: ast.flags.spaceIsAscii,\n    wordIsAscii: ast.flags.wordIsAscii,\n  };\n  traverse({node: ast}, firstPassState, FirstPassVisitor);\n  // Global flags modified by the first pass\n  const globalFlags = {\n    dotAll: ast.flags.dotAll,\n    ignoreCase: ast.flags.ignoreCase,\n  };\n  // The interplay of subroutines (with Onig's unique rules/behavior for them; see comments in the\n  // parser for details) with backref multiplexing (a unique Onig feature), flag modifiers, and\n  // duplicate group names (which might be indirectly referenced by subroutines even though\n  // subroutines can't directly reference duplicate names) is extremely complicated to emulate in\n  // JS in a way that handles all edge cases, so we need multiple passes to do it\n  const secondPassState = {\n    currentFlags: globalFlags,\n    prevFlags: null,\n    globalFlags,\n    groupOriginByCopy: new Map(),\n    groupsByName: new Map(),\n    multiplexCapturesToLeftByRef: new Map(),\n    openRefs: new Map(),\n    reffedNodesByReferencer: new Map(),\n    subroutineRefMap: firstPassState.subroutineRefMap,\n  };\n  traverse({node: ast}, secondPassState, SecondPassVisitor);\n  const thirdPassState = {\n    groupsByName: secondPassState.groupsByName,\n    highestOrphanBackref: 0,\n    numCapturesToLeft: 0,\n    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer,\n  };\n  traverse({node: ast}, thirdPassState, ThirdPassVisitor);\n  ast._strategy = firstPassState.strategy;\n  return ast;\n}\n\nconst FirstPassVisitor = {\n  AbsentFunction({node, replaceWith}) {\n    // Convert absent repeater `(?~\u2026)` to `(?:(?:(?!\u2026)\\p{Any})*)`\n    const group = prepContainer(createGroup(), [\n      adoptAndSwapKids(createLookaround({negate: true}), node.alternatives),\n      createUnicodeProperty('Any'),\n    ]);\n    const quantifier = createQuantifier(group, 0, Infinity);\n    group.parent = quantifier;\n    replaceWith(prepContainer(createGroup(), [quantifier]));\n  },\n\n  Alternative: {\n    enter({node, parent, key}, {flagDirectivesByAlt}) {\n      // Look for own-level flag directives when entering an alternative because after traversing\n      // the directive itself, any subsequent flag directives will no longer be at the same level\n      const flagDirectives = node.elements.filter(el => el.kind === AstDirectiveKinds.flags);\n      for (let i = key + 1; i < parent.alternatives.length; i++) {\n        const forwardSiblingAlt = parent.alternatives[i];\n        getOrCreate(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n      }\n    },\n    exit({node}, {flagDirectivesByAlt}) {\n      // Wait until exiting to wrap an alternative's nodes with flag groups that extend flag\n      // directives from prior sibling alternatives because doing this at the end allows inner\n      // nodes to accurately check their level in the tree\n      if (flagDirectivesByAlt.get(node)?.length) {\n        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n        if (flags) {\n          const flagGroup = prepContainer(createGroup({flags}), node.elements);\n          // Manually set the parent since we're not using `replaceWith`\n          flagGroup.parent = node;\n          node.elements = [flagGroup];\n        }\n      }\n    },\n  },\n\n  Assertion({node, key, container, ast, remove, replaceWith}, state) {\n    const {kind, negate} = node;\n    const {asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii} = state;\n    if (kind === AstAssertionKinds.line_end) {\n      // Onig's only line break char is line feed, unlike JS\n      replaceWith(parseFragment(r`(?=\\z|\\n)`));\n    } else if (kind === AstAssertionKinds.line_start) {\n      // Onig's only line break char is line feed, unlike JS. Onig's `^` doesn't match after a\n      // string-terminating line feed\n      replaceWith(parseFragment(r`(?<=\\A|\\n(?!\\z))`, {skipLookbehindValidation: true}));\n    } else if (kind === AstAssertionKinds.lookbehind) {\n      state.passedLookbehind = true;\n    } else if (kind === AstAssertionKinds.search_start) {\n      if (supportedGNodes.has(node)) {\n        ast.flags.sticky = true;\n        remove();\n      } else {\n        const prev = container[key - 1]; // parent.elements[key - 1]\n        // Not all ways of blocking the `\\G` from matching are covered (ex: a node prior to the\n        // prev node could block), but blocked `\\G` is an edge case so it's okay if some blocked\n        // cases resulting in the standard error for being unsupported\n        if (prev && isAlwaysNonZeroLength(prev)) {\n          replaceWith(prepContainer(createLookaround({negate: true})));\n        } else if (avoidSubclass) {\n          throw new Error(r`Uses \"\\G\" in a way that requires a subclass`);\n        } else {\n          replaceWith(createAssertion(AstAssertionKinds.string_start));\n          state.strategy = 'search_start_clip';\n        }\n      }\n    } else if (kind === AstAssertionKinds.string_end_newline) {\n      replaceWith(parseFragment(r`(?=\\n?\\z)`));\n    } else if (kind === AstAssertionKinds.word_boundary && !wordIsAscii && !asciiWordBoundaries) {\n      const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n      const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n      replaceWith(parseFragment(negate ? B : b));\n    }\n    // Kinds `string_end` and `string_start` don't need transformation since JS flag m isn't used.\n    // Kinds `lookahead` and `lookbehind` also don't need transformation\n  },\n\n  Backreference({node}, {jsGroupNameMap}) {\n    let {ref} = node;\n    if (typeof ref === 'string' && !isValidGroupNameJs(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n\n  CapturingGroup({node}, {jsGroupNameMap, subroutineRefMap}) {\n    let {name} = node;\n    if (name && !isValidGroupNameJs(name)) {\n      name = getAndStoreJsGroupName(name, jsGroupNameMap);\n      node.name = name;\n    }\n    subroutineRefMap.set(node.number, node);\n    if (name) {\n      subroutineRefMap.set(name, node);\n    }\n  },\n\n  CharacterSet({node, replaceWith}, {accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii}) {\n    const {kind, negate, value} = node;\n    // Flag D with `\\d`, `\\p{Digit}`, `[[:digit:]]`\n    if (digitIsAscii && (kind === AstCharacterSetKinds.digit || value === 'digit')) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.digit, {negate}));\n      return;\n    }\n    // Flag S with `\\s`, `\\p{Space}`, `[[:space:]]`\n    if (spaceIsAscii && (kind === AstCharacterSetKinds.space || value === 'space')) {\n      replaceWith(setNegate(parseFragment(asciiSpaceChar), negate));\n      return;\n    }\n    // Flag W with `\\w`, `\\p{Word}`, `[[:word:]]`\n    if (wordIsAscii && (kind === AstCharacterSetKinds.word || value === 'word')) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.word, {negate}));\n      return;\n    }\n    if (kind === AstCharacterSetKinds.any) {\n      replaceWith(createUnicodeProperty('Any'));\n    } else if (kind === AstCharacterSetKinds.digit) {\n      replaceWith(createUnicodeProperty('Nd', {negate}));\n    } else if (kind === AstCharacterSetKinds.hex) {\n      replaceWith(createUnicodeProperty('AHex', {negate}));\n    } else if (kind === AstCharacterSetKinds.non_newline) {\n      replaceWith(parseFragment(r`[^\\n]`));\n    } else if (kind === AstCharacterSetKinds.space) {\n      // Can't use JS's Unicode-based `\\s` since unlike Onig it includes `\\uFEFF`, excludes `\\x85`\n      replaceWith(createUnicodeProperty('space', {negate}));\n    } else if (kind === AstCharacterSetKinds.word) {\n      replaceWith(setNegate(parseFragment(defaultWordChar), negate));\n    } else if (kind === AstCharacterSetKinds.property) {\n      if (!JsUnicodeProperties.has(value)) {\n        // Assume it's a script; no error checking is the price for avoiding heavyweight Unicode\n        // data for all script names\n        node.key = 'sc';\n      }\n    } else if (kind === AstCharacterSetKinds.posix) {\n      if (!minTargetEs2024 && (value === 'graph' || value === 'print')) {\n        if (accuracy === 'strict') {\n          throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n        }\n        let ascii = {\n          graph: '!-~',\n          print: ' -~',\n        }[value];\n        if (negate) {\n          // POSIX classes are always nested in a char class; manually invert the range rather than\n          // using `[^\u2026]` so it can be unwrapped since ES2018 doesn't support nested classes\n          ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n        }\n        replaceWith(parseFragment(`[${ascii}]`));\n      } else {\n        replaceWith(setNegate(parseFragment(PosixClassesMap.get(value)), negate));\n      }\n    }\n  },\n\n  Directive(path, state) {\n    const {node, parent, ast, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings} = path;\n    const {kind, flags} = node;\n    if (kind === AstDirectiveKinds.flags) {\n      if (!flags.enable && !flags.disable) {\n        // Flag directive without flags; ex: `(?-)`, `(?--)`\n        remove();\n      } else {\n        const flagGroup = prepContainer(createGroup({flags}), removeAllNextSiblings());\n        replaceWith(flagGroup);\n        traverseReplacement(flagGroup, path, state, FirstPassVisitor);\n      }\n    } else if (kind === AstDirectiveKinds.keep) {\n      const firstAltFirstEl = ast.pattern.alternatives[0].elements[0];\n      // Supporting a full-pattern wrapper around `\\K` enables use with flag modifiers\n      const hasWrapperGroup =\n        // Not emulatable if within a `CapturingGroup`\n        hasOnlyChild(ast.pattern, kid => kid.type === AstTypes.Group) &&\n        firstAltFirstEl.alternatives.length === 1;\n      const topLevel = hasWrapperGroup ? firstAltFirstEl : ast.pattern;\n      if (parent.parent !== topLevel || topLevel.alternatives.length > 1) {\n        throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n      }\n      replaceWith(prepContainer(createLookaround({behind: true}), removeAllPrevSiblings()));\n    }\n  },\n\n  Flags({node, parent}) {\n    // Remove Onig flags that aren't available in JS\n    [ 'digitIsAscii', // Flag D\n      'extended', // Flag x\n      'spaceIsAscii', // Flag S\n      'wordIsAscii', // Flag W\n    ].forEach(f => delete node[f]);\n    Object.assign(node, {\n      // JS flag g; no Onig equiv\n      global: false,\n      // JS flag d; no Onig equiv\n      hasIndices: false,\n      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n      // results (also allows `^` and `$` to be used in the generator for string start and end)\n      multiline: false,\n      // JS flag y; no Onig equiv, but used for `\\G` emulation\n      sticky: node.sticky ?? false,\n      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out\n      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values\n      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)\n    });\n    // Options accepted by Regex+; see <github.com/slevithan/regex#-options>\n    parent.options = {\n      disable: {\n        // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n        x: true,\n        // Onig has no flag to control \"named capture only\" mode but contextually applies its\n        // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n        n: true,\n      },\n      force: {\n        // Always add flag v because we're generating an AST that relies on it (it enables JS\n        // support for Onig features nested classes, set intersection, Unicode properties, etc.).\n        // However, the generator might disable flag v based on its `target` option\n        v: true,\n      },\n    };\n  },\n\n  Group({node}) {\n    if (!node.flags) {\n      return;\n    }\n    const {enable, disable} = node.flags;\n    // Onig's flag x (`extended`) isn't available in JS\n    enable?.extended && delete enable.extended;\n    disable?.extended && delete disable.extended;\n    // JS doesn't support flag groups that enable and disable the same flag; ex: `(?i-i:)`\n    enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n    // Cleanup\n    enable && !Object.keys(enable).length && delete node.flags.enable;\n    disable && !Object.keys(disable).length && delete node.flags.disable;\n    !node.flags.enable && !node.flags.disable && delete node.flags;\n  },\n\n  Pattern: {\n    enter({node}, {supportedGNodes}) {\n      // For `\\G` to be accurately emulatable using JS flag y, it must be at (and only at) the start\n      // of every top-level alternative (with complex rules for what determines being at the start).\n      // Additional `\\G` error checking in `Assertion` visitor\n      const leadingGs = [];\n      let hasAltWithLeadG = false;\n      let hasAltWithoutLeadG = false;\n      for (const alt of node.alternatives) {\n        if (alt.elements.length === 1 && alt.elements[0].kind === AstAssertionKinds.search_start) {\n          // Remove the `\\G` (leaving behind an empty alternative, and without adding JS flag y)\n          // since a top-level alternative that includes only `\\G` always matches at the start of the\n          // match attempt. Note that this is based on Oniguruma's rules, and is different than other\n          // regex flavors where `\\G` matches at the end of the previous match (a subtle distinction\n          // that's relevant after zero-length matches)\n          alt.elements.pop();\n        } else {\n          const leadingG = getLeadingG(alt.elements);\n          if (leadingG) {\n            hasAltWithLeadG = true;\n            Array.isArray(leadingG) ?\n              leadingGs.push(...leadingG) :\n              leadingGs.push(leadingG);\n          } else {\n            hasAltWithoutLeadG = true;\n          }\n        }\n      }\n      if (hasAltWithLeadG && !hasAltWithoutLeadG) {\n        // Supported `\\G` nodes will be removed (and add flag y) when traversed\n        leadingGs.forEach(g => supportedGNodes.add(g));\n      }\n    },\n    exit(_, {accuracy, passedLookbehind, strategy}) {\n      if (accuracy === 'strict' && passedLookbehind && strategy) {\n        throw new Error(r`Uses \"\\G\" in a way that requires non-strict accuracy`);\n      }\n    },\n  },\n\n  Quantifier({node}) {\n    if (node.element.type === AstTypes.Quantifier) {\n      // Change e.g. `a**` to `(?:a*)*`\n      const group = prepContainer(createGroup(), [node.element]);\n      // Manually set the parent since we're not using `replaceWith`\n      group.parent = node;\n      node.element = group;\n    }\n  },\n\n  Subroutine({node}, {jsGroupNameMap}) {\n    let {ref} = node;\n    if (typeof ref === 'string' && !isValidGroupNameJs(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n\n  VariableLengthCharacterSet({node, replaceWith}, {accuracy, minTargetEs2024}) {\n    const {kind} = node;\n    if (kind === AstVariableLengthCharacterSetKinds.newline) {\n      replaceWith(parseFragment('(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])'));\n    } else if (kind === AstVariableLengthCharacterSetKinds.grapheme) {\n      if (accuracy === 'strict') {\n        throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n      }\n      // `emojiRegex` is more permissive than `\\p{RGI_Emoji}` since it allows over/under-qualified\n      // emoji using a general pattern that matches any Unicode sequence following the structure of\n      // a valid emoji. That actually makes it more accurate for matching any grapheme\n      const emoji = minTargetEs2024 ? r`\\p{RGI_Emoji}` : emojiRegex().source.replace(/\\\\u\\{/g, `\\\\x{`);\n      // Close approximation of an extended grapheme cluster. Details: <unicode.org/reports/tr29/>.\n      // Skip name check to allow `RGI_Emoji` through, which Onig doesn't support\n      replaceWith(parseFragment(r`(?>\\r\\n|${emoji}|\\P{M}\\p{M}*)`, {skipPropertyNameValidation: true}));\n    } else {\n      throw new Error(`Unexpected varcharset kind \"${kind}\"`);\n    }\n  },\n};\n\nconst SecondPassVisitor = {\n  Backreference({node}, {multiplexCapturesToLeftByRef, reffedNodesByReferencer}) {\n    const {orphan, ref} = node;\n    if (!orphan) {\n      // Copy the current state for later multiplexing expansion. That's done in a subsequent pass\n      // because backref numbers need to be recalculated after subroutine expansion\n      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({node}) => node)]);\n    }\n  },\n\n  CapturingGroup: {\n    enter(\n      { node,\n        replaceWith,\n        skip,\n      },\n      { groupOriginByCopy,\n        groupsByName,\n        multiplexCapturesToLeftByRef,\n        openRefs,\n        reffedNodesByReferencer,\n      }\n    ) {\n      // Has value if we're within a subroutine expansion\n      const origin = groupOriginByCopy.get(node);\n\n      // ## Handle recursion; runs after subroutine expansion\n      if (origin && openRefs.has(node.number)) {\n        // Recursion doesn't affect any following backrefs to its `ref` (unlike other subroutines),\n        // so don't wrap with a capture. The reffed group might have its name removed due to later\n        // subroutine expansion\n        const recursion = createRecursion(node.number);\n        reffedNodesByReferencer.set(recursion, openRefs.get(node.number));\n        replaceWith(recursion);\n        // This node's kids have been removed from the tree, so no need to traverse them\n        skip();\n        return;\n      }\n      openRefs.set(node.number, node);\n\n      // ## Track data for backref multiplexing\n      multiplexCapturesToLeftByRef.set(node.number, []);\n      if (node.name) {\n        getOrCreate(multiplexCapturesToLeftByRef, node.name, []);\n      }\n      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n      for (let i = 0; i < multiplexNodes.length; i++) {\n        // Captures added via subroutine expansion (maybe indirectly because they were descendant\n        // captures of the reffed group or in a nested subroutine expansion) form a set with their\n        // origin group and any other copies of it added via subroutines. Only the most recently\n        // matched within this set is added to backref multiplexing. So search the list of already-\n        // tracked multiplexed nodes for this group name or number to see if there's a node being\n        // replaced by this capture\n        const multiplex = multiplexNodes[i];\n        if (\n          // This group is from subroutine expansion, and there's a multiplex value from either the\n          // origin node or a prior subroutine expansion group with the same origin\n          (origin === multiplex.node || (origin && origin === multiplex.origin)) ||\n          // This group is not from subroutine expansion, and it comes after a subroutine expansion\n          // group that refers to this group\n          node === multiplex.origin\n        ) {\n          multiplexNodes.splice(i, 1);\n          break;\n        }\n      }\n      multiplexCapturesToLeftByRef.get(node.number).push({node, origin});\n      if (node.name) {\n        multiplexCapturesToLeftByRef.get(node.name).push({node, origin});\n      }\n\n      // ## Track data for duplicate names\n      // Pre-ES2025 doesn't allow duplicate names, but ES2025 allows duplicate names that are\n      // unique per mutually exclusive alternation path. However, Oniguruma's handling for named\n      // subpatterns on match results means we can't use this ES2025 feature even when in an ES2025\n      // env. So, if using a duplicate name, remove the name from all but the first instance that\n      // wasn't created by subroutine expansion\n      if (node.name) {\n        const groupsWithSameName = getOrCreate(groupsByName, node.name, new Map());\n        let hasDuplicateNameToRemove = false;\n        if (origin) {\n          // Subroutines and their child captures shouldn't hold duplicate names in the final state\n          hasDuplicateNameToRemove = true;\n        } else {\n          for (const groupInfo of groupsWithSameName.values()) {\n            if (!groupInfo.hasDuplicateNameToRemove) {\n              // Will change to an unnamed capture in a later pass\n              hasDuplicateNameToRemove = true;\n              break;\n            }\n          }\n        }\n        groupsByName.get(node.name).set(node, {node, hasDuplicateNameToRemove});\n      }\n      if (origin) {\n        // Used by the generator to handle subroutines and their child captures as emulation groups\n        node._originNumber = origin.number;\n      }\n    },\n    exit({node}, {openRefs}) {\n      openRefs.delete(node.number);\n    },\n  },\n\n  Group: {\n    enter({node}, state) {\n      // Flag directives have already been converted to flag groups by the previous pass\n      state.prevFlags = state.currentFlags;\n      if (node.flags) {\n        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n      }\n    },\n    exit(_, state) {\n      state.currentFlags = state.prevFlags;\n    },\n  },\n\n  Recursion({node, parent}, {reffedNodesByReferencer}) {\n    // Recursion nodes are created during the current traversal; they're only traversed here if a\n    // recursion node created during traversal is then copied by a subroutine expansion, e.g. with\n    // `(?<a>\\g<a>)\\g<a>`\n    const {ref} = node;\n    // Immediate parent is an alternative or quantifier; can skip\n    let reffed = parent;\n    while ((reffed = reffed.parent)) {\n      if (reffed.type === AstTypes.CapturingGroup && (reffed.name === ref || reffed.number === ref)) {\n        break;\n      }\n    }\n    // Track the referenced node because `ref`s are rewritten in a subsequent pass; capturing group\n    // names and numbers might change due to subroutine expansion and duplicate group names\n    reffedNodesByReferencer.set(node, reffed);\n  },\n\n  Subroutine(path, state) {\n    const {node, replaceWith} = path;\n    const {ref} = node;\n    const reffedGroupNode = state.subroutineRefMap.get(ref);\n    // Other forms of recursion are handled by the `CapturingGroup` visitor\n    const isGlobalRecursion = ref === 0;\n    const expandedSubroutine = isGlobalRecursion ?\n      createRecursion(0) :\n      // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null);\n    let replacement = expandedSubroutine;\n    if (!isGlobalRecursion) {\n      // Subroutines take their flags from the reffed group, not the flags surrounding themselves\n      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, node => {\n        return node.type === AstTypes.Group && !!node.flags;\n      }));\n      const reffedGroupFlags = reffedGroupFlagMods ?\n        getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) :\n        state.globalFlags;\n      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n        replacement = prepContainer(createGroup({\n          flags: getFlagModsFromFlags(reffedGroupFlags),\n        }), [expandedSubroutine]);\n      }\n    }\n    replaceWith(replacement);\n    if (!isGlobalRecursion) {\n      traverseReplacement(replacement, path, state, SecondPassVisitor);\n    }\n  },\n};\n\nconst ThirdPassVisitor = {\n  Backreference({node, replaceWith}, state) {\n    if (node.orphan) {\n      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n      // Don't renumber; used with `allowOrphanBackrefs`\n      return;\n    }\n    const reffedNodes = state.reffedNodesByReferencer.get(node);\n    const participants = reffedNodes.filter(reffed => canParticipateWithNode(reffed, node));\n    // For the backref's `ref`, use `number` rather than `name` because group names might have been\n    // removed if they're duplicates within their alternation path, or they might be removed later\n    // by the generator (depending on target) if they're duplicates within the overall pattern.\n    // Backrefs must come after groups they ref, so reffed node `number`s are already recalculated\n    if (!participants.length) {\n      // If no participating capture, convert backref to to `(?!)`; backrefs to nonparticipating\n      // groups can't match in Onig but match the empty string in JS\n      replaceWith(prepContainer(createLookaround({negate: true})));\n    } else if (participants.length > 1) {\n      // Multiplex\n      const alts = participants.map(reffed => adoptAndSwapKids(\n        createAlternative(),\n        [createBackreference(reffed.number)]\n      ));\n      replaceWith(adoptAndSwapKids(createGroup(), alts));\n    } else {\n      node.ref = participants[0].number;\n    }\n  },\n\n  CapturingGroup({node}, state) {\n    // Recalculate the number since the current value might be wrong due to subroutine expansion\n    node.number = ++state.numCapturesToLeft;\n    if (node.name) {\n      // Removing duplicate names here rather than in an earlier pass avoids extra complexity when\n      // handling subroutine expansion and backref multiplexing\n      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n        delete node.name;\n      }\n    }\n  },\n\n  Recursion({node}, state) {\n    if (node.ref === 0) {\n      return;\n    }\n    // For the recursion's `ref`, use `number` rather than `name` because group names might have\n    // been removed if they're duplicates within their alternation path, or they might be removed\n    // later by the generator (depending on target) if they're duplicates within the overall\n    // pattern. Since recursion appears within the group it refs, the reffed node's `number` has\n    // already been recalculated\n    node.ref = state.reffedNodesByReferencer.get(node).number;\n  },\n\n  Regex: {\n    exit({node}, state) {\n      // [HACK] Add unnamed captures to the end of the regex if needed to allow orphaned backrefs\n      // to be valid in JS with flag u/v. This is needed to support TextMate grammars, which\n      // replace numbered backrefs in their `end` pattern with values matched by captures in their\n      // `begin` pattern! See <github.com/microsoft/vscode-textmate/blob/7e0ea282f4f25fef12a6c84fa4fa7266f67b58dc/src/rule.ts#L661-L663>\n      // An `end` pattern, prior to this substitution, might have backrefs to a group that doesn't\n      // exist within `end`. This presents a dilemma since both Oniguruma and JS (with flag u/v)\n      // error for backrefs to undefined captures. So adding captures to the end is a solution that\n      // doesn't change what the regex matches, and lets invalid numbered backrefs through. Note:\n      // Orphan backrefs are only allowed if `allowOrphanBackrefs` is enabled\n      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n      for (let i = 0; i < numCapsNeeded; i++) {\n        const emptyCapture = createCapturingGroup();\n        node.pattern.alternatives.at(-1).elements.push(emptyCapture);\n      }\n    },\n  },\n};\n\n// `\\t\\n\\v\\f\\r\\x20`\nconst asciiSpaceChar = '[\\t-\\r ]';\n// Different than `PosixClassesMap`'s `word`\nconst defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\n\nfunction adoptAndSwapKids(parent, kids) {\n  kids.forEach(kid => kid.parent = parent);\n  parent[getContainerAccessor(parent)] = kids;\n  return parent;\n}\n\nfunction areFlagsEqual(a, b) {\n  return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\n\nfunction canParticipateWithNode(capture, node) {\n  // Walks to the left (prev siblings), down (sibling descendants), up (parent), then back down\n  // (parent's prev sibling descendants) the tree in a loop\n  let rightmostPoint = node;\n  do {\n    if (rightmostPoint.type === AstTypes.Pattern) {\n      // End of the line; capture is not in node's alternation path\n      return false;\n    }\n    if (rightmostPoint.type === AstTypes.Alternative) {\n      // Skip past alts to their parent because we don't want to look at the kids of preceding alts\n      continue;\n    }\n    if (rightmostPoint === capture) {\n      // Capture is ancestor of node\n      return false;\n    }\n    const kidsOfParent = getKids(rightmostPoint.parent);\n    for (const kid of kidsOfParent) {\n      if (kid === rightmostPoint) {\n        // Reached rightmost node in sibling list that we want to consider; break to parent loop\n        break;\n      }\n      if (kid === capture) {\n        return true;\n      }\n      if (hasDescendant(kid, capture)) {\n        return true;\n      }\n    }\n  } while ((rightmostPoint = rightmostPoint.parent));\n  throw new Error('Unexpected path');\n}\n\n// Creates a deep copy of the provided node, with special handling:\n// - Make `parent` props point to their parent in the copy\n// - Update the provided `originMap` for each cloned capturing group (outer and nested)\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n  const store = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === 'parent') {\n      // If the last cloned item was a container array (for holding kids), use the object above it\n      store.parent = Array.isArray(up) ? up2 : up;\n    } else if (value && typeof value === 'object') {\n      store[key] = cloneCapturingGroup(value, originMap, store, up);\n    } else {\n      if (key === 'type' && value === AstTypes.CapturingGroup) {\n        // Key is the copied node, value is the origin node\n        originMap.set(store, originMap.get(obj) ?? obj);\n      }\n      store[key] = value;\n    }\n  }\n  return store;\n}\n\n// `Recursion` nodes are used only by the transformer\nfunction createRecursion(ref) {\n  return {\n    type: AstTypes.Recursion,\n    ref,\n  };\n}\n\nfunction getAllParents(node, filterFn) {\n  const results = [];\n  while ((node = node.parent)) {\n    if (!filterFn || filterFn(node)) {\n      results.push(node);\n    }\n  }\n  return results;\n}\n\n// See also `isValidGroupNameJs`\nfunction getAndStoreJsGroupName(name, map) {\n  if (map.has(name)) {\n    return map.get(name);\n  }\n  // Onig group names can't start with `$`, but JS names can\n  const jsName = `$${map.size}_${name.replace(/^[^$_\\p{IDS}]|[^$\\u200C\\u200D\\p{IDC}]/ug, '_')}`;\n  map.set(name, jsName);\n  return jsName;\n}\n\n// Returns the string key for the container that holds the node's kids\nfunction getContainerAccessor(node) {\n  for (const accessor of ['alternatives', 'classes', 'elements']) {\n    if (node[accessor]) {\n      return accessor;\n    }\n  }\n  return null;\n}\n\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n  const flagProps = ['dotAll', 'ignoreCase'];\n  const combinedFlags = {enable: {}, disable: {}};\n  flagNodes.forEach(({flags}) => {\n    flagProps.forEach(prop => {\n      if (flags.enable?.[prop]) {\n        // Need to remove `disable` since disabled flags take precedence\n        delete combinedFlags.disable[prop];\n        combinedFlags.enable[prop] = true;\n      }\n      if (flags.disable?.[prop]) {\n        combinedFlags.disable[prop] = true;\n      }\n    });\n  });\n  if (!Object.keys(combinedFlags.enable).length) {\n    delete combinedFlags.enable;\n  }\n  if (!Object.keys(combinedFlags.disable).length) {\n    delete combinedFlags.disable;\n  }\n  if (combinedFlags.enable || combinedFlags.disable) {\n    return combinedFlags;\n  }\n  return null;\n}\n\nfunction getFlagModsFromFlags({dotAll, ignoreCase}) {\n  const mods = {};\n  if (dotAll || ignoreCase) {\n    mods.enable = {};\n    dotAll && (mods.enable.dotAll = true);\n    ignoreCase && (mods.enable.ignoreCase = true);\n  }\n  if (!dotAll || !ignoreCase) {\n    mods.disable = {};\n    !dotAll && (mods.disable.dotAll = true);\n    !ignoreCase && (mods.disable.ignoreCase = true);\n  }\n  return mods;\n}\n\nfunction getKids(node) {\n  if (!node) {\n    throw new Error('Node expected');\n  }\n  // [NOTE] Not handling `Regex` kids (`pattern`, `flags`) and `CharacterClassRange` kids (`min`,\n  // `max`) only because not needed by current callers\n  if (node.type === AstTypes.Quantifier) {\n    return [node.element];\n  }\n  const accessor = getContainerAccessor(node);\n  return accessor && node[accessor];\n}\n\nfunction getLeadingG(els) {\n  const firstToConsider = els.find(el => (\n    el.kind === AstAssertionKinds.search_start ||\n    isLoneGLookaround(el, {negate: false}) ||\n    !isAlwaysZeroLength(el)\n  ));\n  if (!firstToConsider) {\n    return null;\n  }\n  if (firstToConsider.kind === AstAssertionKinds.search_start) {\n    return firstToConsider;\n  }\n  if (isLookaround(firstToConsider)) {\n    return firstToConsider.alternatives[0].elements[0];\n  }\n  if (isConsumptiveGroup(firstToConsider)) {\n    const gNodesForGroup = [];\n    // Recursively find `\\G` nodes for all alternatives in the group\n    for (const alt of firstToConsider.alternatives) {\n      const leadingG = getLeadingG(alt.elements);\n      if (!leadingG) {\n        // Don't return `gNodesForGroup` collected so far since this alt didn't qualify\n        return null;\n      }\n      Array.isArray(leadingG) ?\n        gNodesForGroup.push(...leadingG) :\n        gNodesForGroup.push(leadingG);\n    }\n    return gNodesForGroup;\n  }\n  return null;\n}\n\nfunction hasDescendant(node, descendant) {\n  const kids = getKids(node) ?? [];\n  for (const kid of kids) {\n    if (\n      kid === descendant ||\n      hasDescendant(kid, descendant)\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isLoneGLookaround(node, options) {\n  const opts = {\n    negate: null,\n    ...options,\n  };\n  return (\n    isLookaround(node) &&\n    (opts.negate === null || node.negate === opts.negate) &&\n    hasOnlyChild(node, kid => kid.kind === AstAssertionKinds.search_start)\n  );\n}\n\n// See also `getAndStoreJsGroupName`\nfunction isValidGroupNameJs(name) {\n  // JS group names are more restrictive than Onig; see `isValidGroupNameOniguruma` and\n  // <developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers>\n  return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\n\n// Returns a single node, either the given node or all nodes wrapped in a noncapturing group\nfunction parseFragment(pattern, options) {\n  const ast = parse(tokenize(pattern), options);\n  const alts = ast.pattern.alternatives;\n  if (alts.length > 1 || alts[0].elements.length > 1) {\n    return adoptAndSwapKids(createGroup(), alts);\n  }\n  return alts[0].elements[0];\n}\n\nfunction prepContainer(node, kids) {\n  const accessor = getContainerAccessor(node);\n  // Set the parent for the default container of a new node\n  node[accessor][0].parent = node;\n  if (kids) {\n    adoptAndSwapKids(node[accessor][0], kids);\n  }\n  return node;\n}\n\nfunction setNegate(node, negate) {\n  node.negate = negate;\n  return node;\n}\n\nfunction traverseReplacement(replacement, {parent, key, container}, state, visitor) {\n  traverse({\n    // Don't use the `node` from `path`\n    node: replacement,\n    parent,\n    key,\n    container,\n  }, state, visitor);\n}\n\nexport {\n  transform,\n};\n", "import {getOptions} from './options.js';\nimport {AstAssertionKinds, AstCharacterSetKinds, AstTypes} from './parse.js';\nimport {traverse} from './traverse.js';\nimport {getIgnoreCaseMatchChars, UnicodePropertiesWithSpecificCase} from './unicode.js';\nimport {cp, getNewCurrentFlags, isMinTarget, r} from './utils.js';\nimport {isLookaround} from './utils-ast.js';\nimport {emulationGroupMarker} from 'regex/internals';\n\n/**\nGenerates a Regex+ compatible `pattern`, `flags`, and `options` from a Regex+ AST.\n@param {import('./transform.js').RegexAst} ast\n@param {import('.').OnigurumaToEsOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n  options: Object;\n}}\n*/\nfunction generate(ast, options) {\n  const opts = getOptions(options);\n  const minTargetEs2024 = isMinTarget(opts.target, 'ES2024');\n  const minTargetEs2025 = isMinTarget(opts.target, 'ES2025');\n  const recursionLimit = opts.rules.recursionLimit;\n  if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {\n    throw new Error('Invalid recursionLimit; use 2-20');\n  }\n\n  // If the output can't use flag groups, we need a pre-pass to check for the use of chars with\n  // case in case sensitive/insensitive states. This minimizes the need for case expansions (though\n  // expansions are lossless, even given Unicode case complexities) and allows supporting case\n  // insensitive backrefs in more cases\n  // [TODO] Consider gathering this data in the transformer's final traversal to avoid work here\n  let hasCaseInsensitiveNode = null;\n  let hasCaseSensitiveNode = null;\n  if (!minTargetEs2025) {\n    const iStack = [ast.flags.ignoreCase];\n    traverse({node: ast}, {\n      getCurrentModI: () => iStack.at(-1),\n      popModI() {iStack.pop()},\n      pushModI(isIOn) {iStack.push(isIOn)},\n      setHasCasedChar() {\n        if (iStack.at(-1)) {\n          hasCaseInsensitiveNode = true;\n        } else {\n          hasCaseSensitiveNode = true;\n        }\n      },\n    }, FlagModifierVisitor);\n  }\n\n  const appliedGlobalFlags = {\n    dotAll: ast.flags.dotAll,\n    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n    //   used (to avoid unnecessary node expansion).\n    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n    //   forced without the use of ES2025 flag groups)\n    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode),\n  };\n  let lastNode = null;\n  const state = {\n    accuracy: opts.accuracy,\n    appliedGlobalFlags,\n    avoidSubclass: opts.avoidSubclass,\n    captureMap: new Map(),\n    currentFlags: {\n      dotAll: ast.flags.dotAll,\n      ignoreCase: ast.flags.ignoreCase,\n    },\n    inCharClass: false,\n    lastNode,\n    recursionLimit,\n    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n    useFlagMods: minTargetEs2025,\n    useFlagV: minTargetEs2024,\n    verbose: opts.verbose,\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    switch (node.type) {\n      case AstTypes.Regex:\n        // Final result is an object; other node types return strings\n        return {\n          pattern: gen(node.pattern),\n          flags: gen(node.flags),\n          options: {...node.options},\n        };\n      case AstTypes.Alternative:\n        return node.elements.map(gen).join('');\n      case AstTypes.Assertion:\n        return genAssertion(node, state, gen);\n      case AstTypes.Backreference:\n        return genBackreference(node, state);\n      case AstTypes.CapturingGroup:\n        return genCapturingGroup(node, state, gen);\n      case AstTypes.Character:\n        return genCharacter(node, state);\n      case AstTypes.CharacterClass:\n        return genCharacterClass(node, state, gen);\n      case AstTypes.CharacterClassIntersection:\n        if (!state.useFlagV) {\n          throw new Error('Use of class intersection requires min target ES2024');\n        }\n        return node.classes.map(gen).join('&&');\n      case AstTypes.CharacterClassRange:\n        return genCharacterClassRange(node, state);\n      case AstTypes.CharacterSet:\n        return genCharacterSet(node, state);\n      case AstTypes.Flags:\n        return genFlags(node, state);\n      case AstTypes.Group:\n        return genGroup(node, state, gen);\n      case AstTypes.Pattern:\n        return node.alternatives.map(gen).join('|');\n      case AstTypes.Quantifier:\n        return gen(node.element) + getQuantifierStr(node);\n      case AstTypes.Recursion:\n        return genRecursion(node, state);\n      default:\n        // Node types `AbsentFunction`, `Directive`, `Subroutine`, and `VariableLengthCharacterSet`\n        // are never included in transformer output\n        throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n  }\n\n  const result = gen(ast);\n  if (!minTargetEs2024) {\n    // Switch from flag v to u. By default, Regex+ implicitly chooses; control it instead\n    delete result.options.force.v;\n    result.options.disable.v = true;\n    result.options.unicodeSetsPlugin = null;\n  }\n  return result;\n}\n\nconst FlagModifierVisitor = {\n  AnyGroup: {\n    enter({node}, state) {\n      const currentModI = state.getCurrentModI();\n      state.pushModI(\n        node.flags ?\n          getNewCurrentFlags({ignoreCase: currentModI}, node.flags).ignoreCase :\n          currentModI\n      );\n    },\n    exit(_, state) {\n      state.popModI();\n    },\n  },\n  Backreference(_, state) {\n    // Can't know for sure, so assume the backref will include chars with case (best that could be\n    // done is not calling `setHasCasedChar` if the reffed group doesn't contain a char with case\n    // or most kinds of char sets)\n    state.setHasCasedChar();\n  },\n  Character({node}, state) {\n    if (charHasCase(cp(node.value))) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterClassRange({node, skip}, state) {\n    skip();\n    if (getCasesOutsideCharClassRange(node, {firstOnly: true}).length) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterSet({node}, state) {\n    if (\n      node.kind === AstCharacterSetKinds.property &&\n      UnicodePropertiesWithSpecificCase.has(node.value)\n    ) {\n      state.setHasCasedChar();\n    }\n  },\n};\n\nconst BaseEscapeChars = new Set([\n  '$', '(', ')', '*', '+', '.', '?', '[', '\\\\', ']', '^', '{', '|', '}',\n]);\nconst CharClassEscapeChars = new Set([\n  '-', '\\\\', ']', '^',\n  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n  // linters and regex syntax processors that expect unescaped `[` to create a nested class\n  '[',\n]);\nconst CharClassEscapeCharsFlagV = new Set([\n  '(', ')', '-', '/', '[', '\\\\', ']', '^', '{', '|', '}',\n  // Double punctuators; also includes already-listed `-` and `^`\n  '!', '#', '$', '%', '&', '*', '+', ',', '.', ':', ';', '<', '=', '>', '?', '@', '`', '~',\n]);\nconst CharCodeEscapeMap = new Map([\n  [ 9, r`\\t`], // horizontal tab\n  [10, r`\\n`], // line feed\n  [11, r`\\v`], // vertical tab\n  [12, r`\\f`], // form feed\n  [13, r`\\r`], // carriage return\n  [0x2028, r`\\u2028`], // line separator\n  [0x2029, r`\\u2029`], // paragraph separator\n  [0xFEFF, r`\\uFEFF`], // ZWNBSP/BOM\n]);\n\nconst casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n  return casedRe.test(char);\n}\n\nfunction genAssertion(node, _, gen) {\n  const {kind, negate, alternatives} = node;\n  if (isLookaround(node)) {\n    const prefix = `${kind === AstAssertionKinds.lookahead ? '' : '<'}${negate ? '!' : '='}`;\n    return `(?${prefix}${alternatives.map(gen).join('|')})`;\n  }\n  // Can always use `^` and `$` for string boundaries since JS flag m is never relied on; Onig uses\n  // different line break chars\n  if (kind === AstAssertionKinds.string_end) {\n    return '$';\n  }\n  if (kind === AstAssertionKinds.string_start) {\n    return '^';\n  }\n  // If a word boundary came through the transformer unaltered, that means `wordIsAscii` or\n  // `asciiWordBoundaries` is enabled\n  if (kind === AstAssertionKinds.word_boundary) {\n    return negate ? r`\\B` : r`\\b`;\n  }\n  // Kinds `line_end`, `line_start`, `search_start`, and `string_end_newline` are never included in\n  // transformer output\n  throw new Error(`Unexpected assertion kind \"${kind}\"`);\n}\n\nfunction genBackreference({ref}, state) {\n  if (typeof ref !== 'number') {\n    throw new Error('Unexpected named backref in transformed AST');\n  }\n  if (\n    !state.useFlagMods &&\n    state.accuracy === 'strict' &&\n    state.currentFlags.ignoreCase &&\n    !state.captureMap.get(ref).ignoreCase\n  ) {\n    throw new Error('Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy');\n  }\n  return '\\\\' + ref;\n}\n\nfunction genCapturingGroup({name, number, alternatives, _originNumber}, state, gen) {\n  state.captureMap.set(number, {ignoreCase: state.currentFlags.ignoreCase});\n  return `(${\n    name ? `?<${name}>` : ''\n  }${\n    !state.avoidSubclass && _originNumber ?\n      // All captures from/within expanded subroutines are marked as emulation groups, and some are\n      // specially marked as emulation groups with transfer. `number` is based on the pattern after\n      // subroutine expansion, whereas `_originNumber` points to the origin capture of an expanded\n      // subroutine (or child capture) *prior* to subroutine expansion. `_originNumber` is\n      // `undefined` if the current capture isn't from an expanded subroutine\n      `${_originNumber < number ? `$${_originNumber}` : ''}${emulationGroupMarker}` :\n      ''\n  }${\n    alternatives.map(gen).join('|')\n  })`;\n}\n\nfunction genCharacter({value}, state) {\n  const char = cp(value);\n  const escaped = getCharEscape(value, {\n    isAfterBackref: state.lastNode.type === AstTypes.Backreference,\n    inCharClass: state.inCharClass,\n    useFlagV: state.useFlagV,\n  });\n  if (escaped !== char) {\n    return escaped;\n  }\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n    const cases = getIgnoreCaseMatchChars(char);\n    return state.inCharClass ?\n      cases.join('') :\n      (cases.length > 1 ? `[${cases.join('')}]` : cases[0]);\n  }\n  return char;\n}\n\nfunction genCharacterClass({negate, parent, elements}, state, gen) {\n  const genClass = () => `[${negate ? '^' : ''}${elements.map(gen).join('')}]`;\n  if (!state.inCharClass) {\n    // For the outermost char class, set state\n    state.inCharClass = true;\n    const result = genClass();\n    state.inCharClass = false;\n    return result;\n  }\n  // No first element for implicit class in empty intersection like `[&&]`\n  const firstType = elements[0]?.type;\n  if (\n    !negate &&\n    firstType &&\n    (\n      ( // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n        (!state.useFlagV || !state.verbose) &&\n        parent.type === AstTypes.CharacterClass &&\n        firstType !== AstTypes.CharacterClassIntersection\n      ) ||\n      ( !state.verbose &&\n        parent.type === AstTypes.CharacterClassIntersection &&\n        // JS doesn't allow intersection with union or ranges\n        elements.length === 1 &&\n        firstType !== AstTypes.CharacterClass &&\n        firstType !== AstTypes.CharacterClassRange\n      )\n    )\n  ) {\n    // Remove unnecessary nesting; unwrap kids into the parent char class. Some basic char class\n    // optimization has already been done in the parser\n    return elements.map(gen).join('');\n  }\n  if (!state.useFlagV && parent.type === AstTypes.CharacterClass) {\n    throw new Error('Use of nested character class requires min target ES2024');\n  }\n  return genClass();\n}\n\nfunction genCharacterClassRange(node, state) {\n  const min = node.min.value;\n  const max = node.max.value;\n  const escOpts = {\n    isAfterBackref: false,\n    inCharClass: true,\n    useFlagV: state.useFlagV,\n  };\n  const minStr = getCharEscape(min, escOpts);\n  const maxStr = getCharEscape(max, escOpts);\n  const extraChars = new Set();\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n    // [TODO] Avoid duplication by considering other chars in the parent char class when expanding\n    const charsOutsideRange = getCasesOutsideCharClassRange(node);\n    const ranges = getCodePointRangesFromChars(charsOutsideRange);\n    ranges.forEach(value => {\n      extraChars.add(\n        Array.isArray(value) ?\n          `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` :\n          getCharEscape(value, escOpts)\n      );\n    });\n  }\n  // Create the range without calling `gen` on the `min`/`max` kids\n  return `${minStr}-${maxStr}${[...extraChars].join('')}`;\n}\n\nfunction genCharacterSet({kind, negate, value, key}, state) {\n  if (kind === AstCharacterSetKinds.dot) {\n    return state.currentFlags.dotAll ?\n      ((state.appliedGlobalFlags.dotAll || state.useFlagMods) ? '.' : '[^]') :\n      // Onig's only line break char is line feed, unlike JS\n      r`[^\\n]`;\n  }\n  if (kind === AstCharacterSetKinds.digit) {\n    return negate ? r`\\D` : r`\\d`;\n  }\n  if (kind === AstCharacterSetKinds.property) {\n    if (\n      state.useAppliedIgnoreCase &&\n      state.currentFlags.ignoreCase &&\n      UnicodePropertiesWithSpecificCase.has(value)\n    ) {\n      // Support for this would require heavy Unicode data. Could change e.g. `\\p{Lu}` to `\\p{LC}`\n      // if not using strict `accuracy` (since it's close but not 100%), but this wouldn't work\n      // for e.g. `\\p{Lt}`, and in any case, it's probably user error if using these case-specific\n      // props case-insensitively\n      throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n    }\n    return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : ''}${value}}`;\n  }\n  if (kind === AstCharacterSetKinds.word) {\n    return negate ? r`\\W` : r`\\w`;\n  }\n  // Kinds `hex`, `posix`, and `space` are never included in transformer output\n  throw new Error(`Unexpected character set kind \"${kind}\"`);\n}\n\nfunction genFlags(node, state) {\n  return (\n    // The transformer should never turn on the properties for flags d, g, and m since Onig doesn't\n    // have equivs. Flag m is never relied on since Onig uses different line break chars than JS\n    // (node.hasIndices ? 'd' : '') +\n    // (node.global ? 'g' : '') +\n    // (node.multiline ? 'm' : '') +\n    (state.appliedGlobalFlags.ignoreCase ? 'i' : '') +\n    (node.dotAll ? 's' : '') +\n    (node.sticky ? 'y' : '')\n    // Regex+ doesn't allow explicitly adding flags it handles implicitly, so there are no\n    // `unicode` (flag u) or `unicodeSets` (flag v) props; those flags are added separately\n  );\n}\n\nfunction genGroup({atomic, flags, parent, alternatives}, state, gen) {\n  const currentFlags = state.currentFlags;\n  if (flags) {\n    state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n  }\n  const contents = alternatives.map(gen).join('|');\n  const result = (\n    !state.verbose &&\n    alternatives.length === 1 &&\n    parent.type !== AstTypes.Quantifier &&\n    !atomic &&\n    (!state.useFlagMods || !flags)\n   ) ? contents : `(?${getGroupPrefix(atomic, flags, state.useFlagMods)}${contents})`;\n  state.currentFlags = currentFlags;\n  return result;\n}\n\nfunction genRecursion({ref}, state) {\n  const limit = state.recursionLimit;\n  // Using the syntax supported by `regex-recursion`\n  return ref === 0 ? `(?R=${limit})` : r`\\g<${ref}&R=${limit}>`;\n}\n\n/**\nGiven a `CharacterClassRange` node, returns an array of chars that are a case variant of a char in\nthe range, and aren't already in the range.\n*/\nfunction getCasesOutsideCharClassRange(node, options) {\n  const firstOnly = !!options?.firstOnly;\n  const min = node.min.value;\n  const max = node.max.value;\n  const found = [];\n  // Avoid unneeded work. Assumptions (per Unicode 16):\n  // - No case variants cross the Basic Multilingual Plane boundary\n  // - No cased chars appear beyond the Supplementary Multilingual Plane\n  if ((min < 65 && (max === 0xFFFF || max >= 0x1FFFF)) || (min === 0x10000 && max >= 0x1FFFF)) {\n    return found;\n  }\n  for (let i = min; i <= max; i++) {\n    const char = cp(i);\n    if (!charHasCase(char)) {\n      continue;\n    }\n    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter(caseOfChar => {\n      const num = caseOfChar.codePointAt(0);\n      return num < min || num > max;\n    });\n    if (charsOutsideRange.length) {\n      found.push(...charsOutsideRange);\n      if (firstOnly) {\n        break;\n      }\n    }\n  }\n  return found;\n}\n\n// This shouldn't modifiy any char that has case\nfunction getCharEscape(codePoint, {isAfterBackref, inCharClass, useFlagV}) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || (codePoint > 126 && codePoint < 160) ||\n    // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 0x3FFFF ||\n    // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    (isAfterBackref && isDigitCharCode(codePoint))\n  ) {\n    // Don't convert codePoint `0` to `\\0` since that's corruptible by following literal digits\n    return codePoint > 0xFF ?\n      `\\\\u{${codePoint.toString(16).toUpperCase()}}` :\n      `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, '0')}`;\n  }\n  const escapeChars = inCharClass ?\n    (useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars) :\n    BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? '\\\\' : '') + char;\n}\n\nfunction getCodePointRangesFromChars(chars) {\n  const codePoints = chars.map(char => char.codePointAt(0)).sort((a, b) => a - b);\n  const values = [];\n  let start = null;\n  for (let i = 0; i < codePoints.length; i++) {\n    if (codePoints[i + 1] === codePoints[i] + 1) {\n      start ??= codePoints[i];\n    } else if (start === null) {\n      values.push(codePoints[i]);\n    } else {\n      values.push([start, codePoints[i]]);\n      start = null;\n    }\n  }\n  return values;\n}\n\nfunction getGroupPrefix(atomic, flagMods, useFlagMods) {\n  if (atomic) {\n    return '>';\n  }\n  let mods = '';\n  if (flagMods && useFlagMods) {\n    const {enable, disable} = flagMods;\n    mods =\n      (enable?.ignoreCase ? 'i' : '') +\n      (enable?.dotAll ? 's' : '') +\n      (disable ? '-' : '') +\n      (disable?.ignoreCase ? 'i' : '') +\n      (disable?.dotAll ? 's' : '');\n  }\n  return `${mods}:`;\n}\n\nfunction getQuantifierStr({min, max, greedy, possessive}) {\n  let base;\n  if (!min && max === 1) {\n    base = '?';\n  } else if (!min && max === Infinity) {\n    base = '*';\n  } else if (min === 1 && max === Infinity) {\n    base = '+';\n  } else if (min === max) {\n    base = `{${min}}`;\n  } else {\n    base = `{${min},${max === Infinity ? '' : max}}`;\n  }\n  return base + (possessive ? '+' : (greedy ? '' : '?'));\n}\n\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\n\nexport {\n  generate,\n};\n", "import {RegExpSubclass} from 'regex/internals';\n\n/**\n@typedef {{\n  strategy?: string | null;\n  useEmulationGroups?: boolean;\n}} EmulatedRegExpOptions\n*/\n\n/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but can be given\nresults from `toDetails` to produce the same result as `toRegExp`.\n@augments RegExp\n*/\nclass EmulatedRegExp extends RegExpSubclass {\n  /**\n  @private\n  @type {string | null}\n  */\n  #strategy;\n  /**\n  Can be used to serialize the arguments used to create the instance.\n  @type {{\n    pattern: string;\n    flags: string;\n    options: EmulatedRegExpOptions;\n  }}\n  */\n  rawArgs;\n  /**\n  @overload\n  @param {string} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */\n  /**\n  @overload\n  @param {EmulatedRegExp} pattern\n  @param {string} [flags]\n  */\n  constructor(pattern, flags, options) {\n    // Argument `options` isn't provided when regexes are copied via `new EmulatedRegExp(regexp)`,\n    // including as part of the internal handling of string methods `matchAll` and `split`\n    if (pattern instanceof RegExp) {\n      if (options) {\n        throw new Error('Cannot provide options when copying a regexp');\n      }\n      super(pattern, flags);\n      if (pattern instanceof EmulatedRegExp) {\n        this.#strategy = pattern.#strategy;\n        this.rawArgs = pattern.rawArgs;\n      } else {\n        this.#strategy = null;\n        this.rawArgs = {\n          pattern: pattern.source,\n          flags: pattern.flags,\n          options: {},\n        };\n      }\n      if (flags !== undefined) {\n        this.rawArgs.flags = flags;\n      }\n    } else {\n      const opts = {\n        strategy: null,\n        useEmulationGroups: false,\n        ...options,\n      };\n      super(pattern, flags, {useEmulationGroups: opts.useEmulationGroups});\n      this.#strategy = opts.strategy;\n      this.rawArgs = {\n        pattern,\n        flags: flags ?? '',\n        options: {\n          ...(opts.strategy && {strategy: opts.strategy}),\n          ...(opts.useEmulationGroups && {useEmulationGroups: true}),\n        },\n      };\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes. Provides special case handling\n  that requires coupling with pattern changes during transpilation.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const exec = super.exec;\n    const useLastIndex = this.global || this.sticky;\n    const pos = this.lastIndex;\n\n    // Support uncommon and otherwise-unsupported uses of `\\G`\n    if (this.#strategy === 'search_start_clip' && useLastIndex && pos) {\n      // Reset since this tests on a sliced string that we want to match at the start of\n      this.lastIndex = 0;\n      // Slicing the string can lead to mismatches when three edge cases are stacked on each other:\n      // 1. An uncommon use of `\\G` that relies on subclass-based emulation, combined with...\n      // 2. Lookbehind that searches behind the search start (not match start) position...\n      // 3. During a search when the regex's `lastIndex` isn't `0`.\n      // The `search_start_clip` strategy is therefore only allowed with strict `accuracy` when\n      // lookbehind isn't present\n      const match = exec.call(this, str.slice(pos));\n      if (match) {\n        adjustMatchDetailsForOffset(match, this, str, pos);\n        this.lastIndex += pos;\n      }\n      return match;\n    }\n\n    return exec.call(this, str);\n  }\n}\n\nfunction adjustMatchDetailsForOffset(match, re, input, offset) {\n  match.input = input;\n  match.index += offset;\n  if (re.hasIndices) {\n    const indices = match.indices;\n    for (let i = 0; i < indices.length; i++) {\n      const arr = indices[i];\n      if (arr) {\n        // Replace the array rather than updating values since the keys of `match.indices` and\n        // `match.indices.groups` share their value arrays by reference. Need to be precise in case\n        // they were previously altered separately\n        indices[i] = [arr[0] + offset, arr[1] + offset];\n      }\n    }\n    const groupIndices = indices.groups;\n    if (groupIndices) {\n      Object.keys(groupIndices).forEach(key => {\n        const arr = groupIndices[key];\n        if (arr) {\n          groupIndices[key] = [arr[0] + offset, arr[1] + offset];\n        }\n      });\n    }\n  }\n}\n\nexport {\n  EmulatedRegExp,\n};\n", "import {transform} from './transform.js';\nimport {generate} from './generate.js';\nimport {Accuracy, getOptions, Target} from './options.js';\nimport {parse} from './parse.js';\nimport {EmulatedRegExp} from './subclass.js';\nimport {tokenize} from './tokenize.js';\nimport {atomic, emulationGroupMarker, possessive} from 'regex/internals';\nimport {recursion} from 'regex-recursion';\n\n// The transformation and error checking for Oniguruma's unique syntax and behavior differences\n// compared to native JS RegExp is layered into all steps of the compilation process:\n// 1. Tokenizer: Understands Oniguruma syntax, with many large and small differences from JS.\n// 2. Parser: Builds an Oniguruma AST from the tokens, with understanding of Oniguruma differences.\n// 3. Transformer: Converts the Oniguruma AST to a Regex+ AST that preserves all Oniguruma\n//    behavior. This is true even in cases of non-native-JS features that are supported by both\n//    Regex+ and Oniguruma but with subtly different behavior in each (subroutines, flag x).\n// 4. Generator: Converts the Regex+ AST to a Regex+ pattern, flags, and options.\n// 5. Compiler: Components of the Regex+ libray are used to transpile several remaining features\n//    that aren't native to JS (atomic groups, possessive quantifiers, recursion). Regex+ uses a\n//    strict superset of JS RegExp syntax, so using it allows this library to benefit from not\n//    reinventing the wheel for complex features that Regex+ already knows how to transpile to JS.\n\n/**\n@typedef {{\n  accuracy?: keyof Accuracy;\n  avoidSubclass?: boolean;\n  flags?: string;\n  global?: boolean;\n  hasIndices?: boolean;\n  rules?: {\n    allowOrphanBackrefs?: boolean;\n    asciiWordBoundaries?: boolean;\n    captureGroup?: boolean;\n    recursionLimit?: number;\n    singleline?: boolean;\n  };\n  target?: keyof Target;\n  verbose?: boolean;\n}} OnigurumaToEsOptions\n*/\n\n/**\nAccepts an Oniguruma pattern and returns the details needed to construct an equivalent JavaScript `RegExp`.\n@param {string} pattern Oniguruma regex pattern.\n@param {OnigurumaToEsOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n  options?: import('./subclass.js').EmulatedRegExpOptions;\n}}\n*/\nfunction toDetails(pattern, options) {\n  const opts = getOptions(options);\n  const avoidSubclass = opts.avoidSubclass;\n  const tokenized = tokenize(pattern, opts.flags, {\n    captureGroup: opts.rules.captureGroup,\n    singleline: opts.rules.singleline,\n  });\n  const onigurumaAst = parse(tokenized, {\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    verbose: opts.verbose,\n  });\n  const regexAst = transform(onigurumaAst, {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n    avoidSubclass,\n    bestEffortTarget: opts.target,\n  });\n  const generated = generate(regexAst, opts);\n  const pluginData = {useEmulationGroups: !avoidSubclass};\n  const result = {\n    pattern: atomic(possessive(recursion(generated.pattern, pluginData)), pluginData),\n    flags: `${opts.hasIndices ? 'd' : ''}${opts.global ? 'g' : ''}${generated.flags}${generated.options.disable.v ? 'u' : 'v'}`,\n  };\n  const useEmulationGroups = !avoidSubclass && result.pattern.includes(emulationGroupMarker);\n  const strategy = regexAst._strategy;\n  if (useEmulationGroups || strategy) {\n    result.options = {\n      ...(strategy && {strategy}),\n      ...(useEmulationGroups && {useEmulationGroups}),\n    };\n  }\n  return result;\n}\n\n/**\nReturns an Oniguruma AST generated from an Oniguruma pattern.\n@param {string} pattern Oniguruma regex pattern.\n@param {{\n  flags?: string;\n  rules?: {\n    captureGroup?: boolean;\n  };\n}} [options]\n@returns {import('./parse.js').OnigurumaAst}\n*/\nfunction toOnigurumaAst(pattern, options) {\n  const flags = options?.flags ?? '';\n  const captureGroup = options?.rules?.captureGroup ?? false;\n  return parse(tokenize(pattern, flags, {captureGroup}));\n}\n\n// // Returns a Regex+ AST generated from an Oniguruma pattern\n// function toRegexAst(pattern, options) {\n//   return transform(toOnigurumaAst(pattern, options));\n// }\n\n/**\nAccepts an Oniguruma pattern and returns an equivalent JavaScript `RegExp`.\n@param {string} pattern Oniguruma regex pattern.\n@param {OnigurumaToEsOptions} [options]\n@returns {RegExp | EmulatedRegExp}\n*/\nfunction toRegExp(pattern, options) {\n  const result = toDetails(pattern, options);\n  if (result.options) {\n    return new EmulatedRegExp(result.pattern, result.flags, result.options);\n  }\n  return new RegExp(result.pattern, result.flags);\n}\n\nexport {\n  EmulatedRegExp,\n  toDetails,\n  toOnigurumaAst,\n  // toRegexAst,\n  toRegExp,\n};\n", "import { ShikiError as ShikiError$1 } from '@shikijs/types';\nexport * from '@shikijs/types';\nimport { createOnigurumaEngine as createOnigurumaEngine$1, loadWasm as loadWasm$1, getDefaultWasmLoader } from '@shikijs/engine-oniguruma';\nimport { w as warnDeprecated } from './shared/core.Bn_XU0Iv.mjs';\nexport { e as enableDeprecationWarnings } from './shared/core.Bn_XU0Iv.mjs';\nimport { FontStyle, INITIAL, EncodedTokenMetadata, Registry as Registry$1, Theme } from '@shikijs/vscode-textmate';\nexport { FontStyle, EncodedTokenMetadata as StackElementMetadata } from '@shikijs/vscode-textmate';\nimport { toHtml } from 'hast-util-to-html';\nexport { toHtml as hastToHtml } from 'hast-util-to-html';\nimport { createJavaScriptRegexEngine as createJavaScriptRegexEngine$1, defaultJavaScriptRegexConstructor as defaultJavaScriptRegexConstructor$1 } from '@shikijs/engine-javascript';\n\nfunction createOnigurumaEngine(options) {\n  warnDeprecated(\"import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return createOnigurumaEngine$1(options);\n}\nfunction createWasmOnigEngine(options) {\n  warnDeprecated(\"import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return createOnigurumaEngine$1(options);\n}\nfunction loadWasm(options) {\n  warnDeprecated(\"import `loadWasm` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return loadWasm$1(options);\n}\n\nfunction toArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\nfunction splitLines(code, preserveEnding = false) {\n  const parts = code.split(/(\\r?\\n)/g);\n  let index = 0;\n  const lines = [];\n  for (let i = 0; i < parts.length; i += 2) {\n    const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n    lines.push([line, index]);\n    index += parts[i].length;\n    index += parts[i + 1]?.length || 0;\n  }\n  return lines;\n}\nfunction isPlainLang(lang) {\n  return !lang || [\"plaintext\", \"txt\", \"text\", \"plain\"].includes(lang);\n}\nfunction isSpecialLang(lang) {\n  return lang === \"ansi\" || isPlainLang(lang);\n}\nfunction isNoneTheme(theme) {\n  return theme === \"none\";\n}\nfunction isSpecialTheme(theme) {\n  return isNoneTheme(theme);\n}\nfunction addClassToHast(node, className) {\n  if (!className)\n    return node;\n  node.properties ||= {};\n  node.properties.class ||= [];\n  if (typeof node.properties.class === \"string\")\n    node.properties.class = node.properties.class.split(/\\s+/g);\n  if (!Array.isArray(node.properties.class))\n    node.properties.class = [];\n  const targets = Array.isArray(className) ? className : className.split(/\\s+/g);\n  for (const c of targets) {\n    if (c && !node.properties.class.includes(c))\n      node.properties.class.push(c);\n  }\n  return node;\n}\nfunction splitToken(token, offsets) {\n  let lastOffset = 0;\n  const tokens = [];\n  for (const offset of offsets) {\n    if (offset > lastOffset) {\n      tokens.push({\n        ...token,\n        content: token.content.slice(lastOffset, offset),\n        offset: token.offset + lastOffset\n      });\n    }\n    lastOffset = offset;\n  }\n  if (lastOffset < token.content.length) {\n    tokens.push({\n      ...token,\n      content: token.content.slice(lastOffset),\n      offset: token.offset + lastOffset\n    });\n  }\n  return tokens;\n}\nfunction splitTokens(tokens, breakpoints) {\n  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);\n  if (!sorted.length)\n    return tokens;\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);\n      if (!breakpointsInToken.length)\n        return token;\n      return splitToken(token, breakpointsInToken);\n    });\n  });\n}\nasync function normalizeGetter(p) {\n  return Promise.resolve(typeof p === \"function\" ? p() : p).then((r) => r.default || r);\n}\nfunction resolveColorReplacements(theme, options) {\n  const replacements = typeof theme === \"string\" ? {} : { ...theme.colorReplacements };\n  const themeName = typeof theme === \"string\" ? theme : theme.name;\n  for (const [key, value] of Object.entries(options?.colorReplacements || {})) {\n    if (typeof value === \"string\")\n      replacements[key] = value;\n    else if (key === themeName)\n      Object.assign(replacements, value);\n  }\n  return replacements;\n}\nfunction applyColorReplacements(color, replacements) {\n  if (!color)\n    return color;\n  return replacements?.[color?.toLowerCase()] || color;\n}\nfunction getTokenStyleObject(token) {\n  const styles = {};\n  if (token.color)\n    styles.color = token.color;\n  if (token.bgColor)\n    styles[\"background-color\"] = token.bgColor;\n  if (token.fontStyle) {\n    if (token.fontStyle & FontStyle.Italic)\n      styles[\"font-style\"] = \"italic\";\n    if (token.fontStyle & FontStyle.Bold)\n      styles[\"font-weight\"] = \"bold\";\n    if (token.fontStyle & FontStyle.Underline)\n      styles[\"text-decoration\"] = \"underline\";\n  }\n  return styles;\n}\nfunction stringifyTokenStyle(token) {\n  if (typeof token === \"string\")\n    return token;\n  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(\";\");\n}\nfunction createPositionConverter(code) {\n  const lines = splitLines(code, true).map(([line]) => line);\n  function indexToPos(index) {\n    if (index === code.length) {\n      return {\n        line: lines.length - 1,\n        character: lines[lines.length - 1].length\n      };\n    }\n    let character = index;\n    let line = 0;\n    for (const lineText of lines) {\n      if (character < lineText.length)\n        break;\n      character -= lineText.length;\n      line++;\n    }\n    return { line, character };\n  }\n  function posToIndex(line, character) {\n    let index = 0;\n    for (let i = 0; i < line; i++)\n      index += lines[i].length;\n    index += character;\n    return index;\n  }\n  return {\n    lines,\n    indexToPos,\n    posToIndex\n  };\n}\n\nclass ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nconst _grammarStateMap = /* @__PURE__ */ new WeakMap();\nfunction setLastGrammarStateToMap(keys, state) {\n  _grammarStateMap.set(keys, state);\n}\nfunction getLastGrammarStateFromMap(keys) {\n  return _grammarStateMap.get(keys);\n}\nclass GrammarState {\n  /**\n   * Theme to Stack mapping\n   */\n  _stacks = {};\n  lang;\n  get themes() {\n    return Object.keys(this._stacks);\n  }\n  get theme() {\n    return this.themes[0];\n  }\n  get _stack() {\n    return this._stacks[this.theme];\n  }\n  /**\n   * Static method to create a initial grammar state.\n   */\n  static initial(lang, themes) {\n    return new GrammarState(\n      Object.fromEntries(toArray(themes).map((theme) => [theme, INITIAL])),\n      lang\n    );\n  }\n  constructor(...args) {\n    if (args.length === 2) {\n      const [stacksMap, lang] = args;\n      this.lang = lang;\n      this._stacks = stacksMap;\n    } else {\n      const [stack, lang, theme] = args;\n      this.lang = lang;\n      this._stacks = { [theme]: stack };\n    }\n  }\n  /**\n   * Get the internal stack object.\n   * @internal\n   */\n  getInternalStack(theme = this.theme) {\n    return this._stacks[theme];\n  }\n  /**\n   * @deprecated use `getScopes` instead\n   */\n  get scopes() {\n    warnDeprecated(\"GrammarState.scopes is deprecated, use GrammarState.getScopes() instead\");\n    return getScopes(this._stacks[this.theme]);\n  }\n  getScopes(theme = this.theme) {\n    return getScopes(this._stacks[theme]);\n  }\n  toJSON() {\n    return {\n      lang: this.lang,\n      theme: this.theme,\n      themes: this.themes,\n      scopes: this.scopes\n    };\n  }\n}\nfunction getScopes(stack) {\n  const scopes = [];\n  const visited = /* @__PURE__ */ new Set();\n  function pushScope(stack2) {\n    if (visited.has(stack2))\n      return;\n    visited.add(stack2);\n    const name = stack2?.nameScopesList?.scopeName;\n    if (name)\n      scopes.push(name);\n    if (stack2.parent)\n      pushScope(stack2.parent);\n  }\n  pushScope(stack);\n  return scopes;\n}\nfunction getGrammarStack(state, theme) {\n  if (!(state instanceof GrammarState))\n    throw new ShikiError(\"Invalid grammar state\");\n  return state.getInternalStack(theme);\n}\n\nfunction transformerDecorations() {\n  const map = /* @__PURE__ */ new WeakMap();\n  function getContext(shiki) {\n    if (!map.has(shiki.meta)) {\n      let normalizePosition = function(p) {\n        if (typeof p === \"number\") {\n          if (p < 0 || p > shiki.source.length)\n            throw new ShikiError(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);\n          return {\n            ...converter.indexToPos(p),\n            offset: p\n          };\n        } else {\n          const line = converter.lines[p.line];\n          if (line === undefined)\n            throw new ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);\n          if (p.character < 0 || p.character > line.length)\n            throw new ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);\n          return {\n            ...p,\n            offset: converter.posToIndex(p.line, p.character)\n          };\n        }\n      };\n      const converter = createPositionConverter(shiki.source);\n      const decorations = (shiki.options.decorations || []).map((d) => ({\n        ...d,\n        start: normalizePosition(d.start),\n        end: normalizePosition(d.end)\n      }));\n      verifyIntersections(decorations);\n      map.set(shiki.meta, {\n        decorations,\n        converter,\n        source: shiki.source\n      });\n    }\n    return map.get(shiki.meta);\n  }\n  return {\n    name: \"shiki:decorations\",\n    tokens(tokens) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);\n      const splitted = splitTokens(tokens, breakpoints);\n      return splitted;\n    },\n    code(codeEl) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const lines = Array.from(codeEl.children).filter((i) => i.type === \"element\" && i.tagName === \"span\");\n      if (lines.length !== ctx.converter.lines.length)\n        throw new ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);\n      function applyLineSection(line, start, end, decoration) {\n        const lineEl = lines[line];\n        let text = \"\";\n        let startIndex = -1;\n        let endIndex = -1;\n        if (start === 0)\n          startIndex = 0;\n        if (end === 0)\n          endIndex = 0;\n        if (end === Number.POSITIVE_INFINITY)\n          endIndex = lineEl.children.length;\n        if (startIndex === -1 || endIndex === -1) {\n          for (let i = 0; i < lineEl.children.length; i++) {\n            text += stringify(lineEl.children[i]);\n            if (startIndex === -1 && text.length === start)\n              startIndex = i + 1;\n            if (endIndex === -1 && text.length === end)\n              endIndex = i + 1;\n          }\n        }\n        if (startIndex === -1)\n          throw new ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);\n        if (endIndex === -1)\n          throw new ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);\n        const children = lineEl.children.slice(startIndex, endIndex);\n        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {\n          applyDecoration(lineEl, decoration, \"line\");\n        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === \"element\") {\n          applyDecoration(children[0], decoration, \"token\");\n        } else {\n          const wrapper = {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {},\n            children\n          };\n          applyDecoration(wrapper, decoration, \"wrapper\");\n          lineEl.children.splice(startIndex, children.length, wrapper);\n        }\n      }\n      function applyLine(line, decoration) {\n        lines[line] = applyDecoration(lines[line], decoration, \"line\");\n      }\n      function applyDecoration(el, decoration, type) {\n        const properties = decoration.properties || {};\n        const transform = decoration.transform || ((i) => i);\n        el.tagName = decoration.tagName || \"span\";\n        el.properties = {\n          ...el.properties,\n          ...properties,\n          class: el.properties.class\n        };\n        if (decoration.properties?.class)\n          addClassToHast(el, decoration.properties.class);\n        el = transform(el, type) || el;\n        return el;\n      }\n      const lineApplies = [];\n      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset);\n      for (const decoration of sorted) {\n        const { start, end } = decoration;\n        if (start.line === end.line) {\n          applyLineSection(start.line, start.character, end.character, decoration);\n        } else if (start.line < end.line) {\n          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);\n          for (let i = start.line + 1; i < end.line; i++)\n            lineApplies.unshift(() => applyLine(i, decoration));\n          applyLineSection(end.line, 0, end.character, decoration);\n        }\n      }\n      lineApplies.forEach((i) => i());\n    }\n  };\n}\nfunction verifyIntersections(items) {\n  for (let i = 0; i < items.length; i++) {\n    const foo = items[i];\n    if (foo.start.offset > foo.end.offset)\n      throw new ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);\n    for (let j = i + 1; j < items.length; j++) {\n      const bar = items[j];\n      const isFooHasBarStart = foo.start.offset < bar.start.offset && bar.start.offset < foo.end.offset;\n      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset < foo.end.offset;\n      const isBarHasFooStart = bar.start.offset < foo.start.offset && foo.start.offset < bar.end.offset;\n      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset < bar.end.offset;\n      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {\n        if (isFooHasBarEnd && isFooHasBarEnd)\n          continue;\n        if (isBarHasFooStart && isBarHasFooEnd)\n          continue;\n        throw new ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);\n      }\n    }\n  }\n}\nfunction stringify(el) {\n  if (el.type === \"text\")\n    return el.value;\n  if (el.type === \"element\")\n    return el.children.map(stringify).join(\"\");\n  return \"\";\n}\n\nconst builtInTransformers = [\n  /* @__PURE__ */ transformerDecorations()\n];\nfunction getTransformers(options) {\n  return [\n    ...options.transformers || [],\n    ...builtInTransformers\n  ];\n}\n\n// src/colors.ts\nvar namedColors = [\n  \"black\",\n  \"red\",\n  \"green\",\n  \"yellow\",\n  \"blue\",\n  \"magenta\",\n  \"cyan\",\n  \"white\",\n  \"brightBlack\",\n  \"brightRed\",\n  \"brightGreen\",\n  \"brightYellow\",\n  \"brightBlue\",\n  \"brightMagenta\",\n  \"brightCyan\",\n  \"brightWhite\"\n];\n\n// src/decorations.ts\nvar decorations = {\n  1: \"bold\",\n  2: \"dim\",\n  3: \"italic\",\n  4: \"underline\",\n  7: \"reverse\",\n  9: \"strikethrough\"\n};\n\n// src/parser.ts\nfunction findSequence(value, position) {\n  const nextEscape = value.indexOf(\"\\x1B[\", position);\n  if (nextEscape !== -1) {\n    const nextClose = value.indexOf(\"m\", nextEscape);\n    return {\n      sequence: value.substring(nextEscape + 2, nextClose).split(\";\"),\n      startPosition: nextEscape,\n      position: nextClose + 1\n    };\n  }\n  return {\n    position: value.length\n  };\n}\nfunction parseColor(sequence, index) {\n  let offset = 1;\n  const colorMode = sequence[index + offset++];\n  let color;\n  if (colorMode === \"2\") {\n    const rgb = [\n      sequence[index + offset++],\n      sequence[index + offset++],\n      sequence[index + offset]\n    ].map((x) => Number.parseInt(x));\n    if (rgb.length === 3 && !rgb.some((x) => Number.isNaN(x))) {\n      color = {\n        type: \"rgb\",\n        rgb\n      };\n    }\n  } else if (colorMode === \"5\") {\n    const colorIndex = Number.parseInt(sequence[index + offset]);\n    if (!Number.isNaN(colorIndex)) {\n      color = { type: \"table\", index: Number(colorIndex) };\n    }\n  }\n  return [offset, color];\n}\nfunction parseSequence(sequence) {\n  const commands = [];\n  for (let i = 0; i < sequence.length; i++) {\n    const code = sequence[i];\n    const codeInt = Number.parseInt(code);\n    if (Number.isNaN(codeInt))\n      continue;\n    if (codeInt === 0) {\n      commands.push({ type: \"resetAll\" });\n    } else if (codeInt <= 9) {\n      const decoration = decorations[codeInt];\n      if (decoration) {\n        commands.push({\n          type: \"setDecoration\",\n          value: decorations[codeInt]\n        });\n      }\n    } else if (codeInt <= 29) {\n      const decoration = decorations[codeInt - 20];\n      if (decoration) {\n        commands.push({\n          type: \"resetDecoration\",\n          value: decoration\n        });\n      }\n    } else if (codeInt <= 37) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 30] }\n      });\n    } else if (codeInt === 38) {\n      const [offset, color] = parseColor(sequence, i);\n      if (color) {\n        commands.push({\n          type: \"setForegroundColor\",\n          value: color\n        });\n      }\n      i += offset;\n    } else if (codeInt === 39) {\n      commands.push({\n        type: \"resetForegroundColor\"\n      });\n    } else if (codeInt <= 47) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 40] }\n      });\n    } else if (codeInt === 48) {\n      const [offset, color] = parseColor(sequence, i);\n      if (color) {\n        commands.push({\n          type: \"setBackgroundColor\",\n          value: color\n        });\n      }\n      i += offset;\n    } else if (codeInt === 49) {\n      commands.push({\n        type: \"resetBackgroundColor\"\n      });\n    } else if (codeInt >= 90 && codeInt <= 97) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 90 + 8] }\n      });\n    } else if (codeInt >= 100 && codeInt <= 107) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 100 + 8] }\n      });\n    }\n  }\n  return commands;\n}\nfunction createAnsiSequenceParser() {\n  let foreground = null;\n  let background = null;\n  let decorations2 = /* @__PURE__ */ new Set();\n  return {\n    parse(value) {\n      const tokens = [];\n      let position = 0;\n      do {\n        const findResult = findSequence(value, position);\n        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);\n        if (text.length > 0) {\n          tokens.push({\n            value: text,\n            foreground,\n            background,\n            decorations: new Set(decorations2)\n          });\n        }\n        if (findResult.sequence) {\n          const commands = parseSequence(findResult.sequence);\n          for (const styleToken of commands) {\n            if (styleToken.type === \"resetAll\") {\n              foreground = null;\n              background = null;\n              decorations2.clear();\n            } else if (styleToken.type === \"resetForegroundColor\") {\n              foreground = null;\n            } else if (styleToken.type === \"resetBackgroundColor\") {\n              background = null;\n            } else if (styleToken.type === \"resetDecoration\") {\n              decorations2.delete(styleToken.value);\n            }\n          }\n          for (const styleToken of commands) {\n            if (styleToken.type === \"setForegroundColor\") {\n              foreground = styleToken.value;\n            } else if (styleToken.type === \"setBackgroundColor\") {\n              background = styleToken.value;\n            } else if (styleToken.type === \"setDecoration\") {\n              decorations2.add(styleToken.value);\n            }\n          }\n        }\n        position = findResult.position;\n      } while (position < value.length);\n      return tokens;\n    }\n  };\n}\n\n// src/palette.ts\nvar defaultNamedColorsMap = {\n  black: \"#000000\",\n  red: \"#bb0000\",\n  green: \"#00bb00\",\n  yellow: \"#bbbb00\",\n  blue: \"#0000bb\",\n  magenta: \"#ff00ff\",\n  cyan: \"#00bbbb\",\n  white: \"#eeeeee\",\n  brightBlack: \"#555555\",\n  brightRed: \"#ff5555\",\n  brightGreen: \"#00ff00\",\n  brightYellow: \"#ffff55\",\n  brightBlue: \"#5555ff\",\n  brightMagenta: \"#ff55ff\",\n  brightCyan: \"#55ffff\",\n  brightWhite: \"#ffffff\"\n};\nfunction createColorPalette(namedColorsMap = defaultNamedColorsMap) {\n  function namedColor(name) {\n    return namedColorsMap[name];\n  }\n  function rgbColor(rgb) {\n    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, \"0\")).join(\"\")}`;\n  }\n  let colorTable;\n  function getColorTable() {\n    if (colorTable) {\n      return colorTable;\n    }\n    colorTable = [];\n    for (let i = 0; i < namedColors.length; i++) {\n      colorTable.push(namedColor(namedColors[i]));\n    }\n    let levels = [0, 95, 135, 175, 215, 255];\n    for (let r = 0; r < 6; r++) {\n      for (let g = 0; g < 6; g++) {\n        for (let b = 0; b < 6; b++) {\n          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));\n        }\n      }\n    }\n    let level = 8;\n    for (let i = 0; i < 24; i++, level += 10) {\n      colorTable.push(rgbColor([level, level, level]));\n    }\n    return colorTable;\n  }\n  function tableColor(index) {\n    return getColorTable()[index];\n  }\n  function value(color) {\n    switch (color.type) {\n      case \"named\":\n        return namedColor(color.name);\n      case \"rgb\":\n        return rgbColor(color.rgb);\n      case \"table\":\n        return tableColor(color.index);\n    }\n  }\n  return {\n    value\n  };\n}\n\nfunction tokenizeAnsiWithTheme(theme, fileContents, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const lines = splitLines(fileContents);\n  const colorPalette = createColorPalette(\n    Object.fromEntries(\n      namedColors.map((name) => [\n        name,\n        theme.colors?.[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]\n      ])\n    )\n  );\n  const parser = createAnsiSequenceParser();\n  return lines.map(\n    (line) => parser.parse(line[0]).map((token) => {\n      let color;\n      let bgColor;\n      if (token.decorations.has(\"reverse\")) {\n        color = token.background ? colorPalette.value(token.background) : theme.bg;\n        bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n      } else {\n        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n        bgColor = token.background ? colorPalette.value(token.background) : undefined;\n      }\n      color = applyColorReplacements(color, colorReplacements);\n      bgColor = applyColorReplacements(bgColor, colorReplacements);\n      if (token.decorations.has(\"dim\"))\n        color = dimColor(color);\n      let fontStyle = FontStyle.None;\n      if (token.decorations.has(\"bold\"))\n        fontStyle |= FontStyle.Bold;\n      if (token.decorations.has(\"italic\"))\n        fontStyle |= FontStyle.Italic;\n      if (token.decorations.has(\"underline\"))\n        fontStyle |= FontStyle.Underline;\n      return {\n        content: token.value,\n        offset: line[1],\n        // TODO: more accurate offset? might need to fork ansi-sequence-parser\n        color,\n        bgColor,\n        fontStyle\n      };\n    })\n  );\n}\nfunction dimColor(color) {\n  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);\n  if (hexMatch) {\n    if (hexMatch[3]) {\n      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, \"0\");\n      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;\n    } else if (hexMatch[2]) {\n      return `#${hexMatch[1]}${hexMatch[2]}80`;\n    } else {\n      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join(\"\")}80`;\n    }\n  }\n  const cssVarMatch = color.match(/var\\((--[\\w-]+-ansi-[\\w-]+)\\)/);\n  if (cssVarMatch)\n    return `var(${cssVarMatch[1]}-dim)`;\n  return color;\n}\n\nfunction codeToTokensBase(internal, code, options = {}) {\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    return splitLines(code).map((line) => [{ content: line[0], offset: line[1] }]);\n  const { theme, colorMap } = internal.setTheme(themeName);\n  if (lang === \"ansi\")\n    return tokenizeAnsiWithTheme(theme, code, options);\n  const _grammar = internal.getLanguage(lang);\n  if (options.grammarState) {\n    if (options.grammarState.lang !== _grammar.name) {\n      throw new ShikiError$1(`Grammar state language \"${options.grammarState.lang}\" does not match highlight language \"${_grammar.name}\"`);\n    }\n    if (!options.grammarState.themes.includes(theme.name)) {\n      throw new ShikiError$1(`Grammar state themes \"${options.grammarState.themes}\" do not contain highlight theme \"${theme.name}\"`);\n    }\n  }\n  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);\n}\nfunction getLastGrammarState(...args) {\n  if (args.length === 2) {\n    return getLastGrammarStateFromMap(args[1]);\n  }\n  const [internal, code, options = {}] = args;\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    throw new ShikiError$1(\"Plain language does not have grammar state\");\n  if (lang === \"ansi\")\n    throw new ShikiError$1(\"ANSI language does not have grammar state\");\n  const { theme, colorMap } = internal.setTheme(themeName);\n  const _grammar = internal.getLanguage(lang);\n  return new GrammarState(\n    _tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack,\n    _grammar.name,\n    theme.name\n  );\n}\nfunction tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);\n  const grammarState = new GrammarState(\n    _tokenizeWithTheme(code, grammar, theme, colorMap, options).stateStack,\n    grammar.name,\n    theme.name\n  );\n  setLastGrammarStateToMap(result.tokens, grammarState);\n  return result.tokens;\n}\nfunction _tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const {\n    tokenizeMaxLineLength = 0,\n    tokenizeTimeLimit = 500\n  } = options;\n  const lines = splitLines(code);\n  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(\n    options.grammarContextCode,\n    grammar,\n    theme,\n    colorMap,\n    {\n      ...options,\n      grammarState: undefined,\n      grammarContextCode: undefined\n    }\n  ).stateStack : INITIAL;\n  let actual = [];\n  const final = [];\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const [line, lineOffset] = lines[i];\n    if (line === \"\") {\n      actual = [];\n      final.push([]);\n      continue;\n    }\n    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {\n      actual = [];\n      final.push([{\n        content: line,\n        offset: lineOffset,\n        color: \"\",\n        fontStyle: 0\n      }]);\n      continue;\n    }\n    let resultWithScopes;\n    let tokensWithScopes;\n    let tokensWithScopesIndex;\n    if (options.includeExplanation) {\n      resultWithScopes = grammar.tokenizeLine(line, stateStack);\n      tokensWithScopes = resultWithScopes.tokens;\n      tokensWithScopesIndex = 0;\n    }\n    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);\n    const tokensLength = result.tokens.length / 2;\n    for (let j = 0; j < tokensLength; j++) {\n      const startIndex = result.tokens[2 * j];\n      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;\n      if (startIndex === nextStartIndex)\n        continue;\n      const metadata = result.tokens[2 * j + 1];\n      const color = applyColorReplacements(\n        colorMap[EncodedTokenMetadata.getForeground(metadata)],\n        colorReplacements\n      );\n      const fontStyle = EncodedTokenMetadata.getFontStyle(metadata);\n      const token = {\n        content: line.substring(startIndex, nextStartIndex),\n        offset: lineOffset + startIndex,\n        color,\n        fontStyle\n      };\n      if (options.includeExplanation) {\n        const themeSettingsSelectors = [];\n        if (options.includeExplanation !== \"scopeName\") {\n          for (const setting of theme.settings) {\n            let selectors;\n            switch (typeof setting.scope) {\n              case \"string\":\n                selectors = setting.scope.split(/,/).map((scope) => scope.trim());\n                break;\n              case \"object\":\n                selectors = setting.scope;\n                break;\n              default:\n                continue;\n            }\n            themeSettingsSelectors.push({\n              settings: setting,\n              selectors: selectors.map((selector) => selector.split(/ /))\n            });\n          }\n        }\n        token.explanation = [];\n        let offset = 0;\n        while (startIndex + offset < nextStartIndex) {\n          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];\n          const tokenWithScopesText = line.substring(\n            tokenWithScopes.startIndex,\n            tokenWithScopes.endIndex\n          );\n          offset += tokenWithScopesText.length;\n          token.explanation.push({\n            content: tokenWithScopesText,\n            scopes: options.includeExplanation === \"scopeName\" ? explainThemeScopesNameOnly(\n              tokenWithScopes.scopes\n            ) : explainThemeScopesFull(\n              themeSettingsSelectors,\n              tokenWithScopes.scopes\n            )\n          });\n          tokensWithScopesIndex += 1;\n        }\n      }\n      actual.push(token);\n    }\n    final.push(actual);\n    actual = [];\n    stateStack = result.ruleStack;\n  }\n  return {\n    tokens: final,\n    stateStack\n  };\n}\nfunction explainThemeScopesNameOnly(scopes) {\n  return scopes.map((scope) => ({ scopeName: scope }));\n}\nfunction explainThemeScopesFull(themeSelectors, scopes) {\n  const result = [];\n  for (let i = 0, len = scopes.length; i < len; i++) {\n    const scope = scopes[i];\n    result[i] = {\n      scopeName: scope,\n      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))\n    };\n  }\n  return result;\n}\nfunction matchesOne(selector, scope) {\n  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === \".\";\n}\nfunction matches(selectors, scope, parentScopes) {\n  if (!matchesOne(selectors[selectors.length - 1], scope))\n    return false;\n  let selectorParentIndex = selectors.length - 2;\n  let parentIndex = parentScopes.length - 1;\n  while (selectorParentIndex >= 0 && parentIndex >= 0) {\n    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))\n      selectorParentIndex -= 1;\n    parentIndex -= 1;\n  }\n  if (selectorParentIndex === -1)\n    return true;\n  return false;\n}\nfunction explainThemeScope(themeSettingsSelectors, scope, parentScopes) {\n  const result = [];\n  for (const { selectors, settings } of themeSettingsSelectors) {\n    for (const selectorPieces of selectors) {\n      if (matches(selectorPieces, scope, parentScopes)) {\n        result.push(settings);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfunction codeToTokensWithThemes(internal, code, options) {\n  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));\n  const themedTokens = themes.map((t) => {\n    const tokens2 = codeToTokensBase(internal, code, {\n      ...options,\n      theme: t.theme\n    });\n    const state = getLastGrammarStateFromMap(tokens2);\n    const theme = typeof t.theme === \"string\" ? t.theme : t.theme.name;\n    return {\n      tokens: tokens2,\n      state,\n      theme\n    };\n  });\n  const tokens = syncThemesTokenization(\n    ...themedTokens.map((i) => i.tokens)\n  );\n  const mergedTokens = tokens[0].map(\n    (line, lineIdx) => line.map((_token, tokenIdx) => {\n      const mergedToken = {\n        content: _token.content,\n        variants: {},\n        offset: _token.offset\n      };\n      if (\"includeExplanation\" in options && options.includeExplanation) {\n        mergedToken.explanation = _token.explanation;\n      }\n      tokens.forEach((t, themeIdx) => {\n        const {\n          content: _,\n          explanation: __,\n          offset: ___,\n          ...styles\n        } = t[lineIdx][tokenIdx];\n        mergedToken.variants[themes[themeIdx].color] = styles;\n      });\n      return mergedToken;\n    })\n  );\n  const mergedGrammarState = themedTokens[0].state ? new GrammarState(\n    Object.fromEntries(themedTokens.map((s) => [s.theme, s.state?.getInternalStack(s.theme)])),\n    themedTokens[0].state.lang\n  ) : undefined;\n  if (mergedGrammarState)\n    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);\n  return mergedTokens;\n}\nfunction syncThemesTokenization(...themes) {\n  const outThemes = themes.map(() => []);\n  const count = themes.length;\n  for (let i = 0; i < themes[0].length; i++) {\n    const lines = themes.map((t) => t[i]);\n    const outLines = outThemes.map(() => []);\n    outThemes.forEach((t, i2) => t.push(outLines[i2]));\n    const indexes = lines.map(() => 0);\n    const current = lines.map((l) => l[0]);\n    while (current.every((t) => t)) {\n      const minLength = Math.min(...current.map((t) => t.content.length));\n      for (let n = 0; n < count; n++) {\n        const token = current[n];\n        if (token.content.length === minLength) {\n          outLines[n].push(token);\n          indexes[n] += 1;\n          current[n] = lines[n][indexes[n]];\n        } else {\n          outLines[n].push({\n            ...token,\n            content: token.content.slice(0, minLength)\n          });\n          current[n] = {\n            ...token,\n            content: token.content.slice(minLength),\n            offset: token.offset + minLength\n          };\n        }\n      }\n    }\n  }\n  return outThemes;\n}\n\nfunction codeToTokens(internal, code, options) {\n  let bg;\n  let fg;\n  let tokens;\n  let themeName;\n  let rootStyle;\n  let grammarState;\n  if (\"themes\" in options) {\n    const {\n      defaultColor = \"light\",\n      cssVariablePrefix = \"--shiki-\"\n    } = options;\n    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);\n    if (themes.length === 0)\n      throw new ShikiError$1(\"`themes` option must not be empty\");\n    const themeTokens = codeToTokensWithThemes(\n      internal,\n      code,\n      options\n    );\n    grammarState = getLastGrammarStateFromMap(themeTokens);\n    if (defaultColor && !themes.find((t) => t.color === defaultColor))\n      throw new ShikiError$1(`\\`themes\\` option must contain the defaultColor key \\`${defaultColor}\\``);\n    const themeRegs = themes.map((t) => internal.getTheme(t.theme));\n    const themesOrder = themes.map((t) => t.color);\n    tokens = themeTokens.map((line) => line.map((token) => mergeToken(token, themesOrder, cssVariablePrefix, defaultColor)));\n    if (grammarState)\n      setLastGrammarStateToMap(tokens, grammarState);\n    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));\n    fg = themes.map((t, idx) => (idx === 0 && defaultColor ? \"\" : `${cssVariablePrefix + t.color}:`) + (applyColorReplacements(themeRegs[idx].fg, themeColorReplacements[idx]) || \"inherit\")).join(\";\");\n    bg = themes.map((t, idx) => (idx === 0 && defaultColor ? \"\" : `${cssVariablePrefix + t.color}-bg:`) + (applyColorReplacements(themeRegs[idx].bg, themeColorReplacements[idx]) || \"inherit\")).join(\";\");\n    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(\" \")}`;\n    rootStyle = defaultColor ? undefined : [fg, bg].join(\";\");\n  } else if (\"theme\" in options) {\n    const colorReplacements = resolveColorReplacements(options.theme, options);\n    tokens = codeToTokensBase(\n      internal,\n      code,\n      options\n    );\n    const _theme = internal.getTheme(options.theme);\n    bg = applyColorReplacements(_theme.bg, colorReplacements);\n    fg = applyColorReplacements(_theme.fg, colorReplacements);\n    themeName = _theme.name;\n    grammarState = getLastGrammarStateFromMap(tokens);\n  } else {\n    throw new ShikiError$1(\"Invalid options, either `theme` or `themes` must be provided\");\n  }\n  return {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  };\n}\nfunction mergeToken(merged, variantsOrder, cssVariablePrefix, defaultColor) {\n  const token = {\n    content: merged.content,\n    explanation: merged.explanation,\n    offset: merged.offset\n  };\n  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));\n  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));\n  const mergedStyles = {};\n  styles.forEach((cur, idx) => {\n    for (const key of styleKeys) {\n      const value = cur[key] || \"inherit\";\n      if (idx === 0 && defaultColor) {\n        mergedStyles[key] = value;\n      } else {\n        const keyName = key === \"color\" ? \"\" : key === \"background-color\" ? \"-bg\" : `-${key}`;\n        const varKey = cssVariablePrefix + variantsOrder[idx] + (key === \"color\" ? \"\" : keyName);\n        mergedStyles[varKey] = value;\n      }\n    }\n  });\n  token.htmlStyle = mergedStyles;\n  return token;\n}\n\nfunction codeToHast(internal, code, options, transformerContext = {\n  meta: {},\n  options,\n  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n}) {\n  let input = code;\n  for (const transformer of getTransformers(options))\n    input = transformer.preprocess?.call(transformerContext, input, options) || input;\n  let {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  } = codeToTokens(internal, input, options);\n  const {\n    mergeWhitespaces = true\n  } = options;\n  if (mergeWhitespaces === true)\n    tokens = mergeWhitespaceTokens(tokens);\n  else if (mergeWhitespaces === \"never\")\n    tokens = splitWhitespaceTokens(tokens);\n  const contextSource = {\n    ...transformerContext,\n    get source() {\n      return input;\n    }\n  };\n  for (const transformer of getTransformers(options))\n    tokens = transformer.tokens?.call(contextSource, tokens) || tokens;\n  return tokensToHast(\n    tokens,\n    {\n      ...options,\n      fg,\n      bg,\n      themeName,\n      rootStyle\n    },\n    contextSource,\n    grammarState\n  );\n}\nfunction tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {\n  const transformers = getTransformers(options);\n  const lines = [];\n  const root = {\n    type: \"root\",\n    children: []\n  };\n  const {\n    structure = \"classic\",\n    tabindex = \"0\"\n  } = options;\n  let preNode = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {\n      class: `shiki ${options.themeName || \"\"}`,\n      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,\n      ...tabindex !== false && tabindex != null ? {\n        tabindex: tabindex.toString()\n      } : {},\n      ...Object.fromEntries(\n        Array.from(\n          Object.entries(options.meta || {})\n        ).filter(([key]) => !key.startsWith(\"_\"))\n      )\n    },\n    children: []\n  };\n  let codeNode = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: {},\n    children: lines\n  };\n  const lineNodes = [];\n  const context = {\n    ...transformerContext,\n    structure,\n    addClassToHast,\n    get source() {\n      return transformerContext.source;\n    },\n    get tokens() {\n      return tokens;\n    },\n    get options() {\n      return options;\n    },\n    get root() {\n      return root;\n    },\n    get pre() {\n      return preNode;\n    },\n    get code() {\n      return codeNode;\n    },\n    get lines() {\n      return lineNodes;\n    }\n  };\n  tokens.forEach((line, idx) => {\n    if (idx) {\n      if (structure === \"inline\")\n        root.children.push({ type: \"element\", tagName: \"br\", properties: {}, children: [] });\n      else if (structure === \"classic\")\n        lines.push({ type: \"text\", value: \"\\n\" });\n    }\n    let lineNode = {\n      type: \"element\",\n      tagName: \"span\",\n      properties: { class: \"line\" },\n      children: []\n    };\n    let col = 0;\n    for (const token of line) {\n      let tokenNode = {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          ...token.htmlAttrs\n        },\n        children: [{ type: \"text\", value: token.content }]\n      };\n      if (typeof token.htmlStyle === \"string\")\n        warnDeprecated(\"`htmlStyle` as a string is deprecated. Use an object instead.\");\n      const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n      if (style)\n        tokenNode.properties.style = style;\n      for (const transformer of transformers)\n        tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;\n      if (structure === \"inline\")\n        root.children.push(tokenNode);\n      else if (structure === \"classic\")\n        lineNode.children.push(tokenNode);\n      col += token.content.length;\n    }\n    if (structure === \"classic\") {\n      for (const transformer of transformers)\n        lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;\n      lineNodes.push(lineNode);\n      lines.push(lineNode);\n    }\n  });\n  if (structure === \"classic\") {\n    for (const transformer of transformers)\n      codeNode = transformer?.code?.call(context, codeNode) || codeNode;\n    preNode.children.push(codeNode);\n    for (const transformer of transformers)\n      preNode = transformer?.pre?.call(context, preNode) || preNode;\n    root.children.push(preNode);\n  }\n  let result = root;\n  for (const transformer of transformers)\n    result = transformer?.root?.call(context, result) || result;\n  if (grammarState)\n    setLastGrammarStateToMap(result, grammarState);\n  return result;\n}\nfunction mergeWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    const newLine = [];\n    let carryOnContent = \"\";\n    let firstOffset = 0;\n    line.forEach((token, idx) => {\n      const isUnderline = token.fontStyle && token.fontStyle & FontStyle.Underline;\n      const couldMerge = !isUnderline;\n      if (couldMerge && token.content.match(/^\\s+$/) && line[idx + 1]) {\n        if (!firstOffset)\n          firstOffset = token.offset;\n        carryOnContent += token.content;\n      } else {\n        if (carryOnContent) {\n          if (couldMerge) {\n            newLine.push({\n              ...token,\n              offset: firstOffset,\n              content: carryOnContent + token.content\n            });\n          } else {\n            newLine.push(\n              {\n                content: carryOnContent,\n                offset: firstOffset\n              },\n              token\n            );\n          }\n          firstOffset = 0;\n          carryOnContent = \"\";\n        } else {\n          newLine.push(token);\n        }\n      }\n    });\n    return newLine;\n  });\n}\nfunction splitWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      if (token.content.match(/^\\s+$/))\n        return token;\n      const match = token.content.match(/^(\\s*)(.*?)(\\s*)$/);\n      if (!match)\n        return token;\n      const [, leading, content, trailing] = match;\n      if (!leading && !trailing)\n        return token;\n      const expanded = [{\n        ...token,\n        offset: token.offset + leading.length,\n        content\n      }];\n      if (leading) {\n        expanded.unshift({\n          content: leading,\n          offset: token.offset\n        });\n      }\n      if (trailing) {\n        expanded.push({\n          content: trailing,\n          offset: token.offset + leading.length + content.length\n        });\n      }\n      return expanded;\n    });\n  });\n}\n\nfunction codeToHtml(internal, code, options) {\n  const context = {\n    meta: {},\n    options,\n    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n  };\n  let result = toHtml(codeToHast(internal, code, options, context));\n  for (const transformer of getTransformers(options))\n    result = transformer.postprocess?.call(context, result, options) || result;\n  return result;\n}\n\nconst VSCODE_FALLBACK_EDITOR_FG = { light: \"#333333\", dark: \"#bbbbbb\" };\nconst VSCODE_FALLBACK_EDITOR_BG = { light: \"#fffffe\", dark: \"#1e1e1e\" };\nconst RESOLVED_KEY = \"__shiki_resolved\";\nfunction normalizeTheme(rawTheme) {\n  if (rawTheme?.[RESOLVED_KEY])\n    return rawTheme;\n  const theme = {\n    ...rawTheme\n  };\n  if (theme.tokenColors && !theme.settings) {\n    theme.settings = theme.tokenColors;\n    delete theme.tokenColors;\n  }\n  theme.type ||= \"dark\";\n  theme.colorReplacements = { ...theme.colorReplacements };\n  theme.settings ||= [];\n  let { bg, fg } = theme;\n  if (!bg || !fg) {\n    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : undefined;\n    if (globalSetting?.settings?.foreground)\n      fg = globalSetting.settings.foreground;\n    if (globalSetting?.settings?.background)\n      bg = globalSetting.settings.background;\n    if (!fg && theme?.colors?.[\"editor.foreground\"])\n      fg = theme.colors[\"editor.foreground\"];\n    if (!bg && theme?.colors?.[\"editor.background\"])\n      bg = theme.colors[\"editor.background\"];\n    if (!fg)\n      fg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;\n    if (!bg)\n      bg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;\n    theme.fg = fg;\n    theme.bg = bg;\n  }\n  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {\n    theme.settings.unshift({\n      settings: {\n        foreground: theme.fg,\n        background: theme.bg\n      }\n    });\n  }\n  let replacementCount = 0;\n  const replacementMap = /* @__PURE__ */ new Map();\n  function getReplacementColor(value) {\n    if (replacementMap.has(value))\n      return replacementMap.get(value);\n    replacementCount += 1;\n    const hex = `#${replacementCount.toString(16).padStart(8, \"0\").toLowerCase()}`;\n    if (theme.colorReplacements?.[`#${hex}`])\n      return getReplacementColor(value);\n    replacementMap.set(value, hex);\n    return hex;\n  }\n  theme.settings = theme.settings.map((setting) => {\n    const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith(\"#\");\n    const replaceBg = setting.settings?.background && !setting.settings.background.startsWith(\"#\");\n    if (!replaceFg && !replaceBg)\n      return setting;\n    const clone = {\n      ...setting,\n      settings: {\n        ...setting.settings\n      }\n    };\n    if (replaceFg) {\n      const replacement = getReplacementColor(setting.settings.foreground);\n      theme.colorReplacements[replacement] = setting.settings.foreground;\n      clone.settings.foreground = replacement;\n    }\n    if (replaceBg) {\n      const replacement = getReplacementColor(setting.settings.background);\n      theme.colorReplacements[replacement] = setting.settings.background;\n      clone.settings.background = replacement;\n    }\n    return clone;\n  });\n  for (const key of Object.keys(theme.colors || {})) {\n    if (key === \"editor.foreground\" || key === \"editor.background\" || key.startsWith(\"terminal.ansi\")) {\n      if (!theme.colors[key]?.startsWith(\"#\")) {\n        const replacement = getReplacementColor(theme.colors[key]);\n        theme.colorReplacements[replacement] = theme.colors[key];\n        theme.colors[key] = replacement;\n      }\n    }\n  }\n  Object.defineProperty(theme, RESOLVED_KEY, {\n    enumerable: false,\n    writable: false,\n    value: true\n  });\n  return theme;\n}\n\nasync function resolveLangs(langs) {\n  return Array.from(new Set((await Promise.all(\n    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))\n  )).flat()));\n}\nasync function resolveThemes(themes) {\n  const resolved = await Promise.all(\n    themes.map(\n      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))\n    )\n  );\n  return resolved.filter((i) => !!i);\n}\n\nclass Registry extends Registry$1 {\n  constructor(_resolver, _themes, _langs, _alias = {}) {\n    super(_resolver);\n    this._resolver = _resolver;\n    this._themes = _themes;\n    this._langs = _langs;\n    this._alias = _alias;\n    this._themes.map((t) => this.loadTheme(t));\n    this.loadLanguages(this._langs);\n  }\n  _resolvedThemes = /* @__PURE__ */ new Map();\n  _resolvedGrammars = /* @__PURE__ */ new Map();\n  _langMap = /* @__PURE__ */ new Map();\n  _langGraph = /* @__PURE__ */ new Map();\n  _textmateThemeCache = /* @__PURE__ */ new WeakMap();\n  _loadedThemesCache = null;\n  _loadedLanguagesCache = null;\n  getTheme(theme) {\n    if (typeof theme === \"string\")\n      return this._resolvedThemes.get(theme);\n    else\n      return this.loadTheme(theme);\n  }\n  loadTheme(theme) {\n    const _theme = normalizeTheme(theme);\n    if (_theme.name) {\n      this._resolvedThemes.set(_theme.name, _theme);\n      this._loadedThemesCache = null;\n    }\n    return _theme;\n  }\n  getLoadedThemes() {\n    if (!this._loadedThemesCache)\n      this._loadedThemesCache = [...this._resolvedThemes.keys()];\n    return this._loadedThemesCache;\n  }\n  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`\n  // is expensive. Themes can switch often especially for dual-theme support.\n  //\n  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,\n  // we omit here so it's easier to cache the themes.\n  setTheme(theme) {\n    let textmateTheme = this._textmateThemeCache.get(theme);\n    if (!textmateTheme) {\n      textmateTheme = Theme.createFromRawTheme(theme);\n      this._textmateThemeCache.set(theme, textmateTheme);\n    }\n    this._syncRegistry.setTheme(textmateTheme);\n  }\n  getGrammar(name) {\n    if (this._alias[name]) {\n      const resolved = /* @__PURE__ */ new Set([name]);\n      while (this._alias[name]) {\n        name = this._alias[name];\n        if (resolved.has(name))\n          throw new ShikiError(`Circular alias \\`${Array.from(resolved).join(\" -> \")} -> ${name}\\``);\n        resolved.add(name);\n      }\n    }\n    return this._resolvedGrammars.get(name);\n  }\n  loadLanguage(lang) {\n    if (this.getGrammar(lang.name))\n      return;\n    const embeddedLazilyBy = new Set(\n      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(lang.name))\n    );\n    this._resolver.addLanguage(lang);\n    const grammarConfig = {\n      balancedBracketSelectors: lang.balancedBracketSelectors || [\"*\"],\n      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []\n    };\n    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);\n    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);\n    g.name = lang.name;\n    this._resolvedGrammars.set(lang.name, g);\n    if (lang.aliases) {\n      lang.aliases.forEach((alias) => {\n        this._alias[alias] = lang.name;\n      });\n    }\n    this._loadedLanguagesCache = null;\n    if (embeddedLazilyBy.size) {\n      for (const e of embeddedLazilyBy) {\n        this._resolvedGrammars.delete(e.name);\n        this._loadedLanguagesCache = null;\n        this._syncRegistry?._injectionGrammars?.delete(e.scopeName);\n        this._syncRegistry?._grammars?.delete(e.scopeName);\n        this.loadLanguage(this._langMap.get(e.name));\n      }\n    }\n  }\n  dispose() {\n    super.dispose();\n    this._resolvedThemes.clear();\n    this._resolvedGrammars.clear();\n    this._langMap.clear();\n    this._langGraph.clear();\n    this._loadedThemesCache = null;\n  }\n  loadLanguages(langs) {\n    for (const lang of langs)\n      this.resolveEmbeddedLanguages(lang);\n    const langsGraphArray = Array.from(this._langGraph.entries());\n    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);\n    if (missingLangs.length) {\n      const dependents = langsGraphArray.filter(([_, lang]) => lang && lang.embeddedLangs?.some((l) => missingLangs.map(([name]) => name).includes(l))).filter((lang) => !missingLangs.includes(lang));\n      throw new ShikiError(`Missing languages ${missingLangs.map(([name]) => `\\`${name}\\``).join(\", \")}, required by ${dependents.map(([name]) => `\\`${name}\\``).join(\", \")}`);\n    }\n    for (const [_, lang] of langsGraphArray)\n      this._resolver.addLanguage(lang);\n    for (const [_, lang] of langsGraphArray)\n      this.loadLanguage(lang);\n  }\n  getLoadedLanguages() {\n    if (!this._loadedLanguagesCache) {\n      this._loadedLanguagesCache = [\n        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])\n      ];\n    }\n    return this._loadedLanguagesCache;\n  }\n  resolveEmbeddedLanguages(lang) {\n    this._langMap.set(lang.name, lang);\n    this._langGraph.set(lang.name, lang);\n    if (lang.embeddedLangs) {\n      for (const embeddedLang of lang.embeddedLangs)\n        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));\n    }\n  }\n}\n\nclass Resolver {\n  _langs = /* @__PURE__ */ new Map();\n  _scopeToLang = /* @__PURE__ */ new Map();\n  _injections = /* @__PURE__ */ new Map();\n  _onigLib;\n  constructor(engine, langs) {\n    this._onigLib = {\n      createOnigScanner: (patterns) => engine.createScanner(patterns),\n      createOnigString: (s) => engine.createString(s)\n    };\n    langs.forEach((i) => this.addLanguage(i));\n  }\n  get onigLib() {\n    return this._onigLib;\n  }\n  getLangRegistration(langIdOrAlias) {\n    return this._langs.get(langIdOrAlias);\n  }\n  loadGrammar(scopeName) {\n    return this._scopeToLang.get(scopeName);\n  }\n  addLanguage(l) {\n    this._langs.set(l.name, l);\n    if (l.aliases) {\n      l.aliases.forEach((a) => {\n        this._langs.set(a, l);\n      });\n    }\n    this._scopeToLang.set(l.scopeName, l);\n    if (l.injectTo) {\n      l.injectTo.forEach((i) => {\n        if (!this._injections.get(i))\n          this._injections.set(i, []);\n        this._injections.get(i).push(l.scopeName);\n      });\n    }\n  }\n  getInjections(scopeName) {\n    const scopeParts = scopeName.split(\".\");\n    let injections = [];\n    for (let i = 1; i <= scopeParts.length; i++) {\n      const subScopeName = scopeParts.slice(0, i).join(\".\");\n      injections = [...injections, ...this._injections.get(subScopeName) || []];\n    }\n    return injections;\n  }\n}\n\nlet instancesCount = 0;\nfunction createShikiInternalSync(options) {\n  instancesCount += 1;\n  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)\n    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \\`highlighter.dispose()\\` to release unused instances.`);\n  let isDisposed = false;\n  if (!options.engine)\n    throw new ShikiError(\"`engine` option is required for synchronous mode\");\n  const langs = (options.langs || []).flat(1);\n  const themes = (options.themes || []).flat(1).map(normalizeTheme);\n  const resolver = new Resolver(options.engine, langs);\n  const _registry = new Registry(resolver, themes, langs, options.langAlias);\n  let _lastTheme;\n  function getLanguage(name) {\n    ensureNotDisposed();\n    const _lang = _registry.getGrammar(typeof name === \"string\" ? name : name.name);\n    if (!_lang)\n      throw new ShikiError(`Language \\`${name}\\` not found, you may need to load it first`);\n    return _lang;\n  }\n  function getTheme(name) {\n    if (name === \"none\")\n      return { bg: \"\", fg: \"\", name: \"none\", settings: [], type: \"dark\" };\n    ensureNotDisposed();\n    const _theme = _registry.getTheme(name);\n    if (!_theme)\n      throw new ShikiError(`Theme \\`${name}\\` not found, you may need to load it first`);\n    return _theme;\n  }\n  function setTheme(name) {\n    ensureNotDisposed();\n    const theme = getTheme(name);\n    if (_lastTheme !== name) {\n      _registry.setTheme(theme);\n      _lastTheme = name;\n    }\n    const colorMap = _registry.getColorMap();\n    return {\n      theme,\n      colorMap\n    };\n  }\n  function getLoadedThemes() {\n    ensureNotDisposed();\n    return _registry.getLoadedThemes();\n  }\n  function getLoadedLanguages() {\n    ensureNotDisposed();\n    return _registry.getLoadedLanguages();\n  }\n  function loadLanguageSync(...langs2) {\n    ensureNotDisposed();\n    _registry.loadLanguages(langs2.flat(1));\n  }\n  async function loadLanguage(...langs2) {\n    return loadLanguageSync(await resolveLangs(langs2));\n  }\n  function loadThemeSync(...themes2) {\n    ensureNotDisposed();\n    for (const theme of themes2.flat(1)) {\n      _registry.loadTheme(theme);\n    }\n  }\n  async function loadTheme(...themes2) {\n    ensureNotDisposed();\n    return loadThemeSync(await resolveThemes(themes2));\n  }\n  function ensureNotDisposed() {\n    if (isDisposed)\n      throw new ShikiError(\"Shiki instance has been disposed\");\n  }\n  function dispose() {\n    if (isDisposed)\n      return;\n    isDisposed = true;\n    _registry.dispose();\n    instancesCount -= 1;\n  }\n  return {\n    setTheme,\n    getTheme,\n    getLanguage,\n    getLoadedThemes,\n    getLoadedLanguages,\n    loadLanguage,\n    loadLanguageSync,\n    loadTheme,\n    loadThemeSync,\n    dispose,\n    [Symbol.dispose]: dispose\n  };\n}\n\nasync function createShikiInternal(options = {}) {\n  if (options.loadWasm) {\n    warnDeprecated(\"`loadWasm` option is deprecated. Use `engine: createOnigurumaEngine(loadWasm)` instead.\");\n  }\n  const [\n    themes,\n    langs,\n    engine\n  ] = await Promise.all([\n    resolveThemes(options.themes || []),\n    resolveLangs(options.langs || []),\n    options.engine || createOnigurumaEngine$1(options.loadWasm || getDefaultWasmLoader())\n  ]);\n  return createShikiInternalSync({\n    ...options,\n    loadWasm: undefined,\n    themes,\n    langs,\n    engine\n  });\n}\nfunction getShikiInternal(options = {}) {\n  warnDeprecated(\"`getShikiInternal` is deprecated. Use `createShikiInternal` instead.\");\n  return createShikiInternal(options);\n}\n\nasync function createHighlighterCore(options = {}) {\n  const internal = await createShikiInternal(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction createHighlighterCoreSync(options = {}) {\n  const internal = createShikiInternalSync(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction makeSingletonHighlighterCore(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighterCore2(options = {}) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighterCore2;\n}\nconst getSingletonHighlighterCore = /* @__PURE__ */ makeSingletonHighlighterCore(createHighlighterCore);\nfunction getHighlighterCore(options = {}) {\n  warnDeprecated(\"`getHighlighterCore` is deprecated. Use `createHighlighterCore` or `getSingletonHighlighterCore` instead.\");\n  return createHighlighterCore(options);\n}\n\nfunction createdBundledHighlighter(arg1, arg2, arg3) {\n  let bundledLanguages;\n  let bundledThemes;\n  let engine;\n  if (arg2) {\n    warnDeprecated(\"`createdBundledHighlighter` signature with `bundledLanguages` and `bundledThemes` is deprecated. Use the options object signature instead.\");\n    bundledLanguages = arg1;\n    bundledThemes = arg2;\n    engine = () => createOnigurumaEngine(arg3);\n  } else {\n    const options = arg1;\n    bundledLanguages = options.langs;\n    bundledThemes = options.themes;\n    engine = options.engine;\n  }\n  async function createHighlighter(options) {\n    function resolveLang(lang) {\n      if (typeof lang === \"string\") {\n        if (isSpecialLang(lang))\n          return [];\n        const bundle = bundledLanguages[lang];\n        if (!bundle)\n          throw new ShikiError$1(`Language \\`${lang}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return lang;\n    }\n    function resolveTheme(theme) {\n      if (isSpecialTheme(theme))\n        return \"none\";\n      if (typeof theme === \"string\") {\n        const bundle = bundledThemes[theme];\n        if (!bundle)\n          throw new ShikiError$1(`Theme \\`${theme}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return theme;\n    }\n    const _themes = (options.themes ?? []).map((i) => resolveTheme(i));\n    const langs = (options.langs ?? []).map((i) => resolveLang(i));\n    const core = await createHighlighterCore({\n      engine: options.engine ?? engine(),\n      ...options,\n      themes: _themes,\n      langs\n    });\n    return {\n      ...core,\n      loadLanguage(...langs2) {\n        return core.loadLanguage(...langs2.map(resolveLang));\n      },\n      loadTheme(...themes) {\n        return core.loadTheme(...themes.map(resolveTheme));\n      }\n    };\n  }\n  return createHighlighter;\n}\nfunction makeSingletonHighlighter(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighter(options = {}) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighter;\n}\nfunction createSingletonShorthands(createHighlighter) {\n  const getSingletonHighlighter = makeSingletonHighlighter(createHighlighter);\n  return {\n    getSingletonHighlighter(options) {\n      return getSingletonHighlighter(options);\n    },\n    async codeToHtml(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n      });\n      return shiki.codeToHtml(code, options);\n    },\n    async codeToHast(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n      });\n      return shiki.codeToHast(code, options);\n    },\n    async codeToTokens(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n      });\n      return shiki.codeToTokens(code, options);\n    },\n    async codeToTokensBase(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: [options.theme]\n      });\n      return shiki.codeToTokensBase(code, options);\n    },\n    async codeToTokensWithThemes(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: Object.values(options.themes).filter(Boolean)\n      });\n      return shiki.codeToTokensWithThemes(code, options);\n    },\n    async getLastGrammarState(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: [options.theme]\n      });\n      return shiki.getLastGrammarState(code, options);\n    }\n  };\n}\n\nfunction createJavaScriptRegexEngine(options) {\n  warnDeprecated(\"import `createJavaScriptRegexEngine` from `@shikijs/engine-javascript` or `shiki/engine/javascript` instead\");\n  return createJavaScriptRegexEngine$1(options);\n}\nfunction defaultJavaScriptRegexConstructor(pattern) {\n  warnDeprecated(\"import `defaultJavaScriptRegexConstructor` from `@shikijs/engine-javascript` or `shiki/engine/javascript` instead\");\n  return defaultJavaScriptRegexConstructor$1(pattern);\n}\n\nfunction createCssVariablesTheme(options = {}) {\n  const {\n    name = \"css-variables\",\n    variablePrefix = \"--shiki-\",\n    fontStyle = true\n  } = options;\n  const variable = (name2) => {\n    if (options.variableDefaults?.[name2])\n      return `var(${variablePrefix}${name2}, ${options.variableDefaults[name2]})`;\n    return `var(${variablePrefix}${name2})`;\n  };\n  const theme = {\n    name,\n    type: \"dark\",\n    colors: {\n      \"editor.foreground\": variable(\"foreground\"),\n      \"editor.background\": variable(\"background\"),\n      \"terminal.ansiBlack\": variable(\"ansi-black\"),\n      \"terminal.ansiRed\": variable(\"ansi-red\"),\n      \"terminal.ansiGreen\": variable(\"ansi-green\"),\n      \"terminal.ansiYellow\": variable(\"ansi-yellow\"),\n      \"terminal.ansiBlue\": variable(\"ansi-blue\"),\n      \"terminal.ansiMagenta\": variable(\"ansi-magenta\"),\n      \"terminal.ansiCyan\": variable(\"ansi-cyan\"),\n      \"terminal.ansiWhite\": variable(\"ansi-white\"),\n      \"terminal.ansiBrightBlack\": variable(\"ansi-bright-black\"),\n      \"terminal.ansiBrightRed\": variable(\"ansi-bright-red\"),\n      \"terminal.ansiBrightGreen\": variable(\"ansi-bright-green\"),\n      \"terminal.ansiBrightYellow\": variable(\"ansi-bright-yellow\"),\n      \"terminal.ansiBrightBlue\": variable(\"ansi-bright-blue\"),\n      \"terminal.ansiBrightMagenta\": variable(\"ansi-bright-magenta\"),\n      \"terminal.ansiBrightCyan\": variable(\"ansi-bright-cyan\"),\n      \"terminal.ansiBrightWhite\": variable(\"ansi-bright-white\")\n    },\n    tokenColors: [\n      {\n        scope: [\n          \"keyword.operator.accessor\",\n          \"meta.group.braces.round.function.arguments\",\n          \"meta.template.expression\",\n          \"markup.fenced_code meta.embedded.block\"\n        ],\n        settings: {\n          foreground: variable(\"foreground\")\n        }\n      },\n      {\n        scope: \"emphasis\",\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: [\"strong\", \"markup.heading.markdown\", \"markup.bold.markdown\"],\n        settings: {\n          fontStyle: \"bold\"\n        }\n      },\n      {\n        scope: [\"markup.italic.markdown\"],\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: \"meta.link.inline.markdown\",\n        settings: {\n          fontStyle: \"underline\",\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        scope: [\"string\", \"markup.fenced_code\", \"markup.inline\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        scope: [\"comment\", \"string.quoted.docstring.multi\"],\n        settings: {\n          foreground: variable(\"token-comment\")\n        }\n      },\n      {\n        scope: [\n          \"constant.numeric\",\n          \"constant.language\",\n          \"constant.other.placeholder\",\n          \"constant.character.format.placeholder\",\n          \"variable.language.this\",\n          \"variable.other.object\",\n          \"variable.other.class\",\n          \"variable.other.constant\",\n          \"meta.property-name\",\n          \"meta.property-value\",\n          \"support\"\n        ],\n        settings: {\n          foreground: variable(\"token-constant\")\n        }\n      },\n      {\n        scope: [\n          \"keyword\",\n          \"storage.modifier\",\n          \"storage.type\",\n          \"storage.control.clojure\",\n          \"entity.name.function.clojure\",\n          \"entity.name.tag.yaml\",\n          \"support.function.node\",\n          \"support.type.property-name.json\",\n          \"punctuation.separator.key-value\",\n          \"punctuation.definition.template-expression\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        scope: \"variable.parameter.function\",\n        settings: {\n          foreground: variable(\"token-parameter\")\n        }\n      },\n      {\n        scope: [\n          \"support.function\",\n          \"entity.name.type\",\n          \"entity.other.inherited-class\",\n          \"meta.function-call\",\n          \"meta.instance.constructor\",\n          \"entity.other.attribute-name\",\n          \"entity.name.function\",\n          \"constant.keyword.clojure\"\n        ],\n        settings: {\n          foreground: variable(\"token-function\")\n        }\n      },\n      {\n        scope: [\n          \"entity.name.tag\",\n          \"string.quoted\",\n          \"string.regexp\",\n          \"string.interpolated\",\n          \"string.template\",\n          \"string.unquoted.plain.out.yaml\",\n          \"keyword.other.template\"\n        ],\n        settings: {\n          foreground: variable(\"token-string-expression\")\n        }\n      },\n      {\n        scope: [\n          \"punctuation.definition.arguments\",\n          \"punctuation.definition.dict\",\n          \"punctuation.separator\",\n          \"meta.function-call.arguments\"\n        ],\n        settings: {\n          foreground: variable(\"token-punctuation\")\n        }\n      },\n      {\n        // [Custom] Markdown links\n        scope: [\n          \"markup.underline.link\",\n          \"punctuation.definition.metadata.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        // [Custom] Markdown list\n        scope: [\"beginning.punctuation.definition.list.markdown\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        // [Custom] Markdown punctuation definition brackets\n        scope: [\n          \"punctuation.definition.string.begin.markdown\",\n          \"punctuation.definition.string.end.markdown\",\n          \"string.other.link.title.markdown\",\n          \"string.other.link.description.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        // [Custom] Diff\n        scope: [\n          \"markup.inserted\",\n          \"meta.diff.header.to-file\",\n          \"punctuation.definition.inserted\"\n        ],\n        settings: {\n          foreground: variable(\"token-inserted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.deleted\",\n          \"meta.diff.header.from-file\",\n          \"punctuation.definition.deleted\"\n        ],\n        settings: {\n          foreground: variable(\"token-deleted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.changed\",\n          \"punctuation.definition.changed\"\n        ],\n        settings: {\n          foreground: variable(\"token-changed\")\n        }\n      }\n    ]\n  };\n  if (!fontStyle) {\n    theme.tokenColors = theme.tokenColors?.map((tokenColor) => {\n      if (tokenColor.settings?.fontStyle)\n        delete tokenColor.settings.fontStyle;\n      return tokenColor;\n    });\n  }\n  return theme;\n}\n\nexport { addClassToHast, applyColorReplacements, codeToHast, codeToHtml, codeToTokens, codeToTokensBase, codeToTokensWithThemes, createCssVariablesTheme, createHighlighterCore, createHighlighterCoreSync, createJavaScriptRegexEngine, createOnigurumaEngine, createPositionConverter, createShikiInternal, createShikiInternalSync, createSingletonShorthands, createWasmOnigEngine, createdBundledHighlighter, defaultJavaScriptRegexConstructor, getHighlighterCore, getShikiInternal, getSingletonHighlighterCore, getTokenStyleObject, isNoneTheme, isPlainLang, isSpecialLang, isSpecialTheme, loadWasm, makeSingletonHighlighter, makeSingletonHighlighterCore, normalizeGetter, normalizeTheme, resolveColorReplacements, splitLines, splitToken, splitTokens, stringifyTokenStyle, toArray, tokenizeAnsiWithTheme, tokenizeWithTheme, tokensToHast, transformerDecorations, warnDeprecated };\n", "import { splitTokens } from '@shikijs/core';\n\nclass ShikiTwoslashError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiTwoslashError\";\n  }\n}\n\nclass TwoslashIncludesManager {\n  constructor(map = /* @__PURE__ */ new Map()) {\n    this.map = map;\n  }\n  add(name, code) {\n    const lines = [];\n    code.split(\"\\n\").forEach((l, _i) => {\n      const trimmed = l.trim();\n      if (trimmed.startsWith(\"// - \")) {\n        const key = trimmed.split(\"// - \")[1].split(\" \")[0];\n        this.map.set(`${name}-${key}`, lines.join(\"\\n\"));\n      } else {\n        lines.push(l);\n      }\n    });\n    this.map.set(name, lines.join(\"\\n\"));\n  }\n  applyInclude(code) {\n    const reMarker = /\\/\\/ @include: (.*)$/gm;\n    const toReplace = [];\n    for (const match of code.matchAll(reMarker)) {\n      const key = match[1];\n      const replaceWith = this.map.get(key);\n      if (!replaceWith) {\n        const msg = `Could not find an include with the key: '${key}'.\nThere is: ${Array.from(this.map.keys())}.`;\n        throw new Error(msg);\n      } else {\n        toReplace.push([match.index, match[0].length, replaceWith]);\n      }\n    }\n    let newCode = code.toString();\n    toReplace.reverse().forEach(([index, length, replacementCode]) => {\n      newCode = newCode.slice(0, index) + replacementCode + newCode.slice(index + length);\n    });\n    return newCode;\n  }\n}\nconst INCLUDE_META_REGEX = /include\\s+([\\w-]+)\\b.*/;\nfunction parseIncludeMeta(meta) {\n  if (!meta)\n    return null;\n  const match = meta.match(INCLUDE_META_REGEX);\n  return match?.[1] ?? null;\n}\n\nconst module = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\td: \"M11 2H2v9h2V4h7V2z\",\n\t\t\t\tfill: \"currentColor\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\td: \"M2 21v9h9v-2H4v-7H2z\",\n\t\t\t\tfill: \"currentColor\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\td: \"M30 11V2h-9v2h7v7h2z\",\n\t\t\t\tfill: \"currentColor\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\td: \"M21 30h9v-9h-2v7h-7v2z\",\n\t\t\t\tfill: \"currentColor\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\td: \"M25.49 10.13l-9-5a1 1 0 0 0-1 0l-9 5A1 1 0 0 0 6 11v10a1 1 0 0 0 .51.87l9 5a1 1 0 0 0 1 0l9-5A1 1 0 0 0 26 21V11a1 1 0 0 0-.51-.87zM16 7.14L22.94 11L16 14.86L9.06 11zM8 12.7l7 3.89v7.71l-7-3.89zm9 11.6v-7.71l7-3.89v7.71z\",\n\t\t\t\tfill: \"currentColor\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst method = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"m19.626 29.526l-.516-1.933a12.004 12.004 0 0 0 6.121-19.26l1.538-1.28a14.003 14.003 0 0 1-7.143 22.473\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M10 29H8v-3.82l.804-.16C10.262 24.727 12 23.62 12 20v-1.382l-4-2v-2.236l4-2V12c0-5.467 3.925-9 10-9h2v3.82l-.804.16C21.738 7.273 20 8.38 20 12v.382l4 2v2.236l-4 2V20c0 5.467-3.925 9-10 9m0-2c4.935 0 8-2.682 8-7v-2.618l3.764-1.882L18 13.618V12c0-4.578 2.385-6.192 4-6.76V5c-4.935 0-8 2.682-8 7v1.618L10.236 15.5L14 17.382V20c0 4.578-2.385 6.192-4 6.76Z\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M5.231 24.947a14.003 14.003 0 0 1 7.147-22.474l.516 1.932a12.004 12.004 0 0 0-6.125 19.263Z\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst property = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M12.1 2a9.8 9.8 0 0 0-5.4 1.6l6.4 6.4a2.1 2.1 0 0 1 .2 3a2.1 2.1 0 0 1-3-.2L3.7 6.4A9.84 9.84 0 0 0 2 12.1a10.14 10.14 0 0 0 10.1 10.1a10.9 10.9 0 0 0 2.6-.3l6.7 6.7a5 5 0 0 0 7.1-7.1l-6.7-6.7a10.9 10.9 0 0 0 .3-2.6A10 10 0 0 0 12.1 2m8 10.1a7.61 7.61 0 0 1-.3 2.1l-.3 1.1l.8.8l6.7 6.7a2.88 2.88 0 0 1 .9 2.1A2.72 2.72 0 0 1 27 27a2.9 2.9 0 0 1-4.2 0l-6.7-6.7l-.8-.8l-1.1.3a7.61 7.61 0 0 1-2.1.3a8.27 8.27 0 0 1-5.7-2.3A7.63 7.63 0 0 1 4 12.1a8.33 8.33 0 0 1 .3-2.2l4.4 4.4a4.14 4.14 0 0 0 5.9.2a4.14 4.14 0 0 0-.2-5.9L10 4.2a6.45 6.45 0 0 1 2-.3a8.27 8.27 0 0 1 5.7 2.3a8.49 8.49 0 0 1 2.4 5.9\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst constructor = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\td: \"M21.49 13.115l-9-5a1 1 0 0 0-1 0l-9 5A1.008 1.008 0 0 0 2 14v9.995a1 1 0 0 0 .52.87l9 5A1.004 1.004 0 0 0 12 30a1.056 1.056 0 0 0 .49-.135l9-5A.992.992 0 0 0 22 24V14a1.008 1.008 0 0 0-.51-.885zM11 27.295l-7-3.89v-7.72l7 3.89zm1-9.45L5.06 14L12 10.135l6.94 3.86zm8 5.56l-7 3.89v-7.72l7-3.89z\",\n\t\t\t\tfill: \"currentColor\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\td: \"M30 6h-4V2h-2v4h-4v2h4v4h2V8h4V6z\",\n\t\t\t\tfill: \"currentColor\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst string = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M29 22h-5a2.003 2.003 0 0 1-2-2v-6a2.002 2.002 0 0 1 2-2h5v2h-5v6h5zM18 12h-4V8h-2v14h6a2.003 2.003 0 0 0 2-2v-6a2.002 2.002 0 0 0-2-2m-4 8v-6h4v6zm-6-8H3v2h5v2H4a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h6v-8a2.002 2.002 0 0 0-2-2m0 8H4v-2h4z\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst completionIcons = {\n\tmodule: module,\n\t\"class\": {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M26 16a3.961 3.961 0 0 0-2.02.566l-2.859-2.859l2.293-2.293a2 2 0 0 0 0-2.828l-6-6a2 2 0 0 0-2.828 0l-6 6a2 2 0 0 0 0 2.828l2.293 2.293l-2.859 2.859a4.043 4.043 0 1 0 1.414 1.414l2.859-2.859l2.293 2.293a1.977 1.977 0 0 0 .414.31V22h-3v8h8v-8h-3v-4.277a1.977 1.977 0 0 0 .414-.309l2.293-2.293l2.859 2.859A3.989 3.989 0 1 0 26 16M8 20a2 2 0 1 1-2-2a2.002 2.002 0 0 1 2 2m10 4v4h-4v-4zm-2-8l-6-6l6-6l6 6Zm10 6a2 2 0 1 1 2-2a2.002 2.002 0 0 1-2 2\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n},\n\tmethod: method,\n\tproperty: property,\n\tconstructor: constructor,\n\t\"interface\": {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M23 16.01a7 7 0 0 0-4.18 1.39l-4.22-4.22A6.86 6.86 0 0 0 16 9.01a7 7 0 1 0-2.81 5.59l4.21 4.22a7 7 0 1 0 5.6-2.81m-19-7a5 5 0 1 1 5 5a5 5 0 0 1-5-5\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n},\n\t\"function\": {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"m19.626 29.526l-.516-1.933a12.004 12.004 0 0 0 6.121-19.26l1.538-1.28a14.003 14.003 0 0 1-7.143 22.473\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M10 29H8v-3.82l.804-.16C10.262 24.727 12 23.62 12 20v-1.382l-4-2v-2.236l4-2V12c0-5.467 3.925-9 10-9h2v3.82l-.804.16C21.738 7.273 20 8.38 20 12v.382l4 2v2.236l-4 2V20c0 5.467-3.925 9-10 9m0-2c4.935 0 8-2.682 8-7v-2.618l3.764-1.882L18 13.618V12c0-4.578 2.385-6.192 4-6.76V5c-4.935 0-8 2.682-8 7v1.618L10.236 15.5L14 17.382V20c0 4.578-2.385 6.192-4 6.76Z\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M5.231 24.947a14.003 14.003 0 0 1 7.147-22.474l.516 1.932a12.004 12.004 0 0 0-6.125 19.263Z\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n},\n\tstring: string\n};\n\nconst log = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M17 22v-8h-4v2h2v6h-3v2h8v-2zM16 8a1.5 1.5 0 1 0 1.5 1.5A1.5 1.5 0 0 0 16 8\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M26 28H6a2.002 2.002 0 0 1-2-2V6a2.002 2.002 0 0 1 2-2h20a2.002 2.002 0 0 1 2 2v20a2.002 2.002 0 0 1-2 2M6 6v20h20V6Z\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst error = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M16 2a14 14 0 1 0 14 14A14 14 0 0 0 16 2m0 26a12 12 0 1 1 12-12a12 12 0 0 1-12 12\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M15 8h2v11h-2zm1 14a1.5 1.5 0 1 0 1.5 1.5A1.5 1.5 0 0 0 16 22\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst warn = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M16 23a1.5 1.5 0 1 0 1.5 1.5A1.5 1.5 0 0 0 16 23m-1-11h2v9h-2z\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M29 30H3a1 1 0 0 1-.887-1.461l13-25a1 1 0 0 1 1.774 0l13 25A1 1 0 0 1 29 30M4.65 28h22.7l.001-.003L16.002 6.17h-.004L4.648 27.997Z\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst annotate = {\n\ttype: \"element\",\n\ttagName: \"svg\",\n\tproperties: {\n\t\tviewBox: \"0 0 32 32\"\n\t},\n\tchildren: [\n\t\t{\n\t\t\ttype: \"element\",\n\t\t\ttagName: \"path\",\n\t\t\tproperties: {\n\t\t\t\tfill: \"currentColor\",\n\t\t\t\td: \"M11 24h10v2H11zm2 4h6v2h-6zm3-26A10 10 0 0 0 6 12a9.19 9.19 0 0 0 3.46 7.62c1 .93 1.54 1.46 1.54 2.38h2c0-1.84-1.11-2.87-2.19-3.86A7.2 7.2 0 0 1 8 12a8 8 0 0 1 16 0a7.2 7.2 0 0 1-2.82 6.14c-1.07 1-2.18 2-2.18 3.86h2c0-.92.53-1.45 1.54-2.39A9.18 9.18 0 0 0 26 12A10 10 0 0 0 16 2\"\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t]\n\t\t}\n\t]\n};\nconst tagIcons = {\n\tlog: log,\n\terror: error,\n\twarn: warn,\n\tannotate: annotate\n};\n\nconst defaultCompletionIcons = completionIcons;\nconst defaultCustomTagIcons = tagIcons;\n\nfunction rendererClassic() {\n  return {\n    nodeStaticInfo(info, node) {\n      return {\n        type: \"element\",\n        tagName: \"data-lsp\",\n        properties: {\n          lsp: info.text\n        },\n        children: [node]\n      };\n    },\n    nodeError(_, node) {\n      return {\n        type: \"element\",\n        tagName: \"data-err\",\n        properties: {},\n        children: [node]\n      };\n    },\n    lineError(error) {\n      return [\n        {\n          type: \"element\",\n          tagName: \"div\",\n          properties: {\n            class: \"error\"\n          },\n          children: [\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: {},\n              children: [\n                {\n                  type: \"text\",\n                  value: error.text\n                }\n              ]\n            },\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: {\n                class: \"code\"\n              },\n              children: [\n                {\n                  type: \"text\",\n                  value: String(error.code)\n                }\n              ]\n            }\n          ]\n        },\n        {\n          type: \"element\",\n          tagName: \"span\",\n          properties: {\n            class: \"error-behind\"\n          },\n          children: [\n            {\n              type: \"text\",\n              value: error.text\n            }\n          ]\n        }\n      ];\n    },\n    lineCompletion(query) {\n      return [\n        {\n          type: \"element\",\n          tagName: \"div\",\n          properties: { class: \"meta-line\" },\n          children: [\n            { type: \"text\", value: \" \".repeat(query.character) },\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: { class: \"inline-completions\" },\n              children: [{\n                type: \"element\",\n                tagName: \"ul\",\n                properties: { class: \"dropdown\" },\n                children: query.completions.filter((i) => i.name.startsWith(query.completionsPrefix || \"____\")).map((i) => ({\n                  type: \"element\",\n                  tagName: \"li\",\n                  properties: {\n                    class: \"kindModifiers\" in i && typeof i.kindModifiers === \"string\" && i.kindModifiers?.split(\",\").includes(\"deprecated\") ? \"deprecated\" : undefined\n                  },\n                  children: [{\n                    type: \"element\",\n                    tagName: \"span\",\n                    properties: {},\n                    children: [\n                      {\n                        type: \"element\",\n                        tagName: \"span\",\n                        properties: { class: \"result-found\" },\n                        children: [\n                          {\n                            type: \"text\",\n                            value: query.completionsPrefix || \"\"\n                          }\n                        ]\n                      },\n                      {\n                        type: \"text\",\n                        value: i.name.slice(query.completionsPrefix?.length || 0)\n                      }\n                    ]\n                  }]\n                }))\n              }]\n            }\n          ]\n        }\n      ];\n    },\n    lineQuery(query, targetNode) {\n      const targetText = targetNode?.type === \"text\" ? targetNode.value : \"\";\n      const offset = Math.max(0, (query.character || 0) + Math.floor(targetText.length / 2) - 1);\n      return [\n        {\n          type: \"element\",\n          tagName: \"div\",\n          properties: { class: \"meta-line\" },\n          children: [\n            { type: \"text\", value: \" \".repeat(offset) },\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: { class: \"popover\" },\n              children: [\n                {\n                  type: \"element\",\n                  tagName: \"div\",\n                  properties: { class: \"arrow\" },\n                  children: []\n                },\n                {\n                  type: \"text\",\n                  value: query.text || \"\"\n                }\n              ]\n            }\n          ]\n        }\n      ];\n    },\n    lineCustomTag(tag) {\n      return [\n        {\n          type: \"element\",\n          tagName: \"div\",\n          properties: { class: `meta-line logger ${tag.name}-log` },\n          children: [\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: { class: \"message\" },\n              children: [\n                {\n                  type: \"text\",\n                  value: tag.text || \"\"\n                }\n              ]\n            }\n          ]\n        }\n      ];\n    }\n  };\n}\n\nfunction extend(extension, node) {\n  if (!extension)\n    return node;\n  return {\n    ...node,\n    tagName: extension.tagName ?? node.tagName,\n    properties: {\n      ...node.properties,\n      class: extension.class || node.properties?.class,\n      ...extension.properties\n    },\n    children: extension.children?.(node.children) ?? node.children\n  };\n}\nfunction renderMarkdownPassThrough(markdown) {\n  return [\n    {\n      type: \"text\",\n      value: markdown\n    }\n  ];\n}\nfunction rendererRich(options = {}) {\n  const {\n    completionIcons = defaultCompletionIcons,\n    customTagIcons = defaultCustomTagIcons,\n    processHoverInfo = defaultHoverInfoProcessor,\n    processHoverDocs = (docs) => docs,\n    classExtra = \"\",\n    jsdoc = true,\n    errorRendering = \"line\",\n    queryRendering = \"popup\",\n    renderMarkdown = renderMarkdownPassThrough,\n    renderMarkdownInline = renderMarkdownPassThrough,\n    hast\n  } = options;\n  function highlightPopupContent(info) {\n    if (!info.text)\n      return [];\n    const content = processHoverInfo(info.text);\n    if (!content || content === \"any\")\n      return [];\n    const popupContents = [];\n    const typeCode = {\n      type: \"element\",\n      tagName: \"code\",\n      properties: {},\n      children: this.codeToHast(\n        content,\n        {\n          ...this.options,\n          meta: {},\n          transformers: [],\n          lang: this.options.lang === \"tsx\" || this.options.lang === \"jsx\" ? \"tsx\" : \"ts\",\n          structure: content.trim().includes(\"\\n\") ? \"classic\" : \"inline\"\n        }\n      ).children\n    };\n    typeCode.properties.class = \"twoslash-popup-code\";\n    popupContents.push(\n      extend(\n        hast?.popupTypes,\n        typeCode\n      )\n    );\n    if (jsdoc && info.docs) {\n      const docs = processHoverDocs(info.docs) ?? info.docs;\n      if (docs) {\n        const children = renderMarkdown.call(this, docs);\n        popupContents.push(extend(\n          hast?.popupDocs,\n          {\n            type: \"element\",\n            tagName: \"div\",\n            properties: { class: \"twoslash-popup-docs\" },\n            children\n          }\n        ));\n      }\n    }\n    if (jsdoc && info.tags?.length) {\n      popupContents.push(extend(\n        hast?.popupDocsTags,\n        {\n          type: \"element\",\n          tagName: \"div\",\n          properties: {\n            class: \"twoslash-popup-docs twoslash-popup-docs-tags\"\n          },\n          children: info.tags.map((tag) => ({\n            type: \"element\",\n            tagName: \"span\",\n            properties: {\n              class: `twoslash-popup-docs-tag`\n            },\n            children: [\n              {\n                type: \"element\",\n                tagName: \"span\",\n                properties: {\n                  class: \"twoslash-popup-docs-tag-name\"\n                },\n                children: [\n                  {\n                    type: \"text\",\n                    value: `@${tag[0]}`\n                  }\n                ]\n              },\n              ...tag[1] ? [\n                {\n                  type: \"element\",\n                  tagName: \"span\",\n                  properties: {\n                    class: \"twoslash-popup-docs-tag-value\"\n                  },\n                  children: renderMarkdownInline.call(this, tag[1], `tag:${tag[0]}`)\n                }\n              ] : []\n            ]\n          }))\n        }\n      ));\n    }\n    return popupContents;\n  }\n  return {\n    nodeStaticInfo(info, node) {\n      const themedContent = highlightPopupContent.call(this, info);\n      if (!themedContent.length)\n        return node;\n      const popup = extend(\n        hast?.hoverPopup,\n        {\n          type: \"element\",\n          tagName: \"span\",\n          properties: {\n            class: [\"twoslash-popup-container\", classExtra].filter(Boolean).join(\" \")\n          },\n          children: themedContent\n        }\n      );\n      return extend(\n        hast?.hoverToken,\n        {\n          type: \"element\",\n          tagName: \"span\",\n          properties: {\n            class: \"twoslash-hover\"\n          },\n          children: hast?.hoverCompose ? hast?.hoverCompose({ popup, token: node }) : [popup, node]\n        }\n      );\n    },\n    nodeQuery(query, node) {\n      if (!query.text)\n        return {};\n      const themedContent = highlightPopupContent.call(this, query);\n      if (queryRendering !== \"popup\") {\n        return extend(\n          hast?.queryToken,\n          {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {\n              class: \"twoslash-hover\"\n            },\n            children: [\n              node\n            ]\n          }\n        );\n      }\n      const popup = extend(\n        hast?.queryPopup,\n        {\n          type: \"element\",\n          tagName: \"span\",\n          properties: {\n            class: [\"twoslash-popup-container\", classExtra].filter(Boolean).join(\" \")\n          },\n          children: [\n            {\n              type: \"element\",\n              tagName: \"div\",\n              properties: { class: \"twoslash-popup-arrow\" },\n              children: []\n            },\n            ...themedContent\n          ]\n        }\n      );\n      return extend(\n        hast?.queryToken,\n        {\n          type: \"element\",\n          tagName: \"span\",\n          properties: {\n            class: \"twoslash-hover twoslash-query-presisted\"\n          },\n          children: hast?.queryCompose ? hast?.queryCompose({ popup, token: node }) : [popup, node]\n        }\n      );\n    },\n    nodeCompletion(query, node) {\n      if (node.type !== \"text\")\n        throw new ShikiTwoslashError(`Renderer hook nodeCompletion only works on text nodes, got ${node.type}`);\n      const items = query.completions.map((i) => {\n        const kind = i.kind || \"default\";\n        const isDeprecated = \"kindModifiers\" in i && typeof i.kindModifiers === \"string\" && i.kindModifiers?.split(\",\").includes(\"deprecated\");\n        return {\n          type: \"element\",\n          tagName: \"li\",\n          properties: {},\n          children: [\n            ...completionIcons ? [{\n              type: \"element\",\n              tagName: \"span\",\n              properties: { class: `twoslash-completions-icon completions-${kind.replace(/\\s/g, \"-\")}` },\n              children: [\n                completionIcons[kind] || completionIcons.property\n              ].filter(Boolean)\n            }] : [],\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: {\n                class: isDeprecated ? \"deprecated\" : undefined\n              },\n              children: [\n                {\n                  type: \"element\",\n                  tagName: \"span\",\n                  properties: { class: \"twoslash-completions-matched\" },\n                  children: [\n                    {\n                      type: \"text\",\n                      value: i.name.startsWith(query.completionsPrefix) ? query.completionsPrefix : \"\"\n                    }\n                  ]\n                },\n                {\n                  type: \"element\",\n                  tagName: \"span\",\n                  properties: { class: \"twoslash-completions-unmatched\" },\n                  children: [\n                    {\n                      type: \"text\",\n                      value: i.name.startsWith(query.completionsPrefix) ? i.name.slice(query.completionsPrefix.length || 0) : i.name\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        };\n      });\n      const cursor = extend(\n        hast?.completionCursor,\n        {\n          type: \"element\",\n          tagName: \"span\",\n          properties: {\n            class: [\"twoslash-completion-cursor\", classExtra].filter(Boolean).join(\" \")\n          },\n          children: []\n        }\n      );\n      const popup = extend(\n        hast?.completionPopup,\n        {\n          type: \"element\",\n          tagName: \"ul\",\n          properties: {\n            class: [\"twoslash-completion-list\", classExtra].filter(Boolean).join(\" \")\n          },\n          children: items\n        }\n      );\n      const children = [];\n      if (node.value)\n        children.push({ type: \"text\", value: node.value });\n      if (hast?.completionCompose) {\n        children.push(...hast.completionCompose({ popup, cursor }));\n      } else {\n        children.push({\n          ...cursor,\n          children: [popup]\n        });\n      }\n      return extend(\n        hast?.completionToken,\n        {\n          type: \"element\",\n          tagName: \"span\",\n          properties: {},\n          children\n        }\n      );\n    },\n    nodesError(error, children) {\n      if (errorRendering !== \"hover\") {\n        return [\n          extend(\n            hast?.errorToken,\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: {\n                class: [`twoslash-error`, getErrorLevelClass(error)].filter(Boolean).join(\" \")\n              },\n              children\n            }\n          )\n        ];\n      }\n      const popup = extend(\n        hast?.errorPopup,\n        {\n          type: \"element\",\n          tagName: \"span\",\n          properties: {\n            class: [\"twoslash-popup-container\", classExtra].filter(Boolean).join(\" \")\n          },\n          children: [\n            extend(\n              hast?.popupError,\n              {\n                type: \"element\",\n                tagName: \"div\",\n                properties: {\n                  class: \"twoslash-popup-error\"\n                },\n                children: renderMarkdown.call(this, error.text)\n              }\n            )\n          ]\n        }\n      );\n      const token = {\n        type: \"element\",\n        tagName: \"span\",\n        children,\n        properties: {}\n      };\n      return [\n        extend(\n          hast?.errorToken,\n          {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {\n              class: `twoslash-error twoslash-error-hover ${getErrorLevelClass(error)}`\n            },\n            children: hast?.errorCompose ? hast?.errorCompose({ popup, token }) : [popup, token]\n          }\n        )\n      ];\n    },\n    lineQuery(query, node) {\n      if (queryRendering !== \"line\")\n        return [];\n      const themedContent = highlightPopupContent.call(this, query);\n      const targetNode = node?.type === \"element\" ? node.children[0] : undefined;\n      const targetText = targetNode?.type === \"text\" ? targetNode.value : \"\";\n      const offset = Math.max(0, (query.character || 0) + Math.floor(targetText.length / 2) - 2);\n      return [\n        {\n          type: \"element\",\n          tagName: \"div\",\n          properties: {\n            class: [\"twoslash-meta-line twoslash-query-line\", classExtra].filter(Boolean).join(\" \")\n          },\n          children: [\n            { type: \"text\", value: \" \".repeat(offset) },\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: {\n                class: [\"twoslash-popup-container\", classExtra].filter(Boolean).join(\" \")\n              },\n              children: [\n                {\n                  type: \"element\",\n                  tagName: \"div\",\n                  properties: { class: \"twoslash-popup-arrow\" },\n                  children: []\n                },\n                ...themedContent\n              ]\n            }\n          ]\n        }\n      ];\n    },\n    lineError(error) {\n      if (errorRendering !== \"line\")\n        return [];\n      return [\n        {\n          type: \"element\",\n          tagName: \"div\",\n          properties: {\n            class: [\"twoslash-meta-line twoslash-error-line\", getErrorLevelClass(error), classExtra].filter(Boolean).join(\" \")\n          },\n          children: [\n            {\n              type: \"text\",\n              value: error.text\n            }\n          ]\n        }\n      ];\n    },\n    lineCustomTag(tag) {\n      return [\n        {\n          type: \"element\",\n          tagName: \"div\",\n          properties: {\n            class: [`twoslash-tag-line twoslash-tag-${tag.name}-line`, classExtra].filter(Boolean).join(\" \")\n          },\n          children: [\n            ...customTagIcons ? [{\n              type: \"element\",\n              tagName: \"span\",\n              properties: { class: `twoslash-tag-icon tag-${tag.name}-icon` },\n              children: [\n                customTagIcons[tag.name]\n              ].filter(Boolean)\n            }] : [],\n            {\n              type: \"text\",\n              value: tag.text || \"\"\n            }\n          ]\n        }\n      ];\n    },\n    nodesHighlight(highlight, nodes) {\n      return [\n        extend(\n          hast?.nodesHighlight,\n          {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {\n              class: \"twoslash-highlighted\"\n            },\n            children: nodes\n          }\n        )\n      ];\n    }\n  };\n}\nconst regexType = /^[A-Z]\\w*(<[^>]*>)?:/;\nconst regexFunction = /^\\w*\\(/;\nfunction defaultHoverInfoProcessor(type) {\n  let content = type.replace(/^\\(([\\w-]+)\\)\\s+/gm, \"\").replace(/\\nimport .*$/, \"\").replace(/^(interface|namespace) \\w+$/gm, \"\").trim();\n  if (content.match(regexType))\n    content = `type ${content}`;\n  else if (content.match(regexFunction))\n    content = `function ${content}`;\n  return content;\n}\nfunction getErrorLevelClass(error) {\n  switch (error.level) {\n    case \"warning\":\n      return \"twoslash-error-level-warning\";\n    case \"suggestion\":\n      return \"twoslash-error-level-suggestion\";\n    case \"message\":\n      return \"twoslash-error-level-message\";\n    default:\n      return \"\";\n  }\n}\n\nfunction defaultTwoslashOptions() {\n  return {\n    customTags: [\"annotate\", \"log\", \"warn\", \"error\"]\n  };\n}\nfunction createTransformerFactory(defaultTwoslasher, defaultRenderer) {\n  return function transformerTwoslash(options = {}) {\n    const {\n      langs = [\"ts\", \"tsx\"],\n      twoslashOptions = defaultTwoslashOptions(),\n      langAlias = {\n        typescript: \"ts\",\n        json5: \"json\",\n        yml: \"yaml\"\n      },\n      twoslasher = defaultTwoslasher,\n      explicitTrigger = false,\n      disableTriggers = [\"notwoslash\", \"no-twoslash\"],\n      renderer = defaultRenderer,\n      throws = true,\n      includesMap = /* @__PURE__ */ new Map()\n    } = options;\n    const onTwoslashError = options.onTwoslashError || (throws ? (error) => {\n      throw error;\n    } : () => false);\n    const onShikiError = options.onShikiError || (throws ? (error) => {\n      throw error;\n    } : () => false);\n    const trigger = explicitTrigger instanceof RegExp ? explicitTrigger : /\\btwoslash\\b/;\n    if (!renderer)\n      throw new ShikiTwoslashError(\"Missing renderer\");\n    const map = /* @__PURE__ */ new WeakMap();\n    const {\n      filter = (lang, _, options2) => {\n        return langs.includes(lang) && (!explicitTrigger || trigger.test(options2.meta?.__raw || \"\")) && !disableTriggers.some((i) => typeof i === \"string\" ? options2.meta?.__raw?.includes(i) : i.test(options2.meta?.__raw || \"\"));\n      }\n    } = options;\n    const includes = new TwoslashIncludesManager(includesMap);\n    return {\n      preprocess(code) {\n        let lang = this.options.lang;\n        if (lang in langAlias)\n          lang = langAlias[this.options.lang];\n        if (filter(lang, code, this.options)) {\n          try {\n            const codeWithIncludes = includes.applyInclude(code);\n            const include = parseIncludeMeta(this.options.meta?.__raw);\n            if (include)\n              includes.add(include, codeWithIncludes);\n            const twoslash = twoslasher(codeWithIncludes, lang, twoslashOptions);\n            map.set(this.meta, twoslash);\n            this.meta.twoslash = twoslash;\n            this.options.lang = twoslash.meta?.extension || lang;\n            return twoslash.code;\n          } catch (error) {\n            const result = onTwoslashError(error, code, lang, this.options);\n            if (typeof result === \"string\")\n              return code;\n          }\n        }\n      },\n      tokens(tokens) {\n        const twoslash = map.get(this.meta);\n        if (!twoslash)\n          return;\n        return splitTokens(\n          tokens,\n          twoslash.nodes.flatMap(\n            (i) => [\"hover\", \"error\", \"query\", \"highlight\", \"completion\"].includes(i.type) ? [i.start, i.start + i.length] : []\n          )\n        );\n      },\n      pre(pre) {\n        const twoslash = map.get(this.meta);\n        if (!twoslash)\n          return;\n        this.addClassToHast(pre, \"twoslash lsp\");\n      },\n      code(codeEl) {\n        const twoslash = map.get(this.meta);\n        if (!twoslash)\n          return;\n        const insertAfterLine = (line, nodes) => {\n          if (!nodes.length)\n            return;\n          let index;\n          if (line >= this.lines.length) {\n            index = codeEl.children.length;\n          } else {\n            const lineEl = this.lines[line];\n            index = codeEl.children.indexOf(lineEl);\n            if (index === -1) {\n              onShikiError(new ShikiTwoslashError(`Cannot find line ${line} in code element`), this.source, this.options.lang);\n              return;\n            }\n          }\n          const nodeAfter = codeEl.children[index + 1];\n          if (nodeAfter && nodeAfter.type === \"text\" && nodeAfter.value === \"\\n\")\n            codeEl.children.splice(index + 1, 1);\n          codeEl.children.splice(index + 1, 0, ...nodes);\n        };\n        const tokensMap = [];\n        this.lines.forEach((lineEl, line) => {\n          let index = 0;\n          for (const token of lineEl.children.flatMap((i) => i.type === \"element\" ? i.children || [] : [])) {\n            if (\"value\" in token && typeof token.value === \"string\") {\n              tokensMap.push([line, index, index + token.value.length, token]);\n              index += token.value.length;\n            }\n          }\n        });\n        const locateTextTokens = (line, character, length) => {\n          const start = character;\n          const end = character + length;\n          if (length === 0) {\n            return tokensMap.filter(([l, s, e]) => l === line && s < start && start <= e).map((i) => i[3]);\n          }\n          return tokensMap.filter(([l, s, e]) => l === line && (start <= s && s < end) && (start < e && e <= end)).map((i) => i[3]);\n        };\n        const tokensSkipHover = /* @__PURE__ */ new Set();\n        const actionsHovers = [];\n        const actionsHighlights = [];\n        for (const node of twoslash.nodes) {\n          if (node.type === \"tag\") {\n            if (renderer.lineCustomTag)\n              insertAfterLine(node.line, renderer.lineCustomTag.call(this, node));\n            continue;\n          }\n          const tokens = locateTextTokens(node.line, node.character, node.length);\n          if (!tokens.length && !(node.type === \"error\" && renderer.nodesError)) {\n            onShikiError(new ShikiTwoslashError(`Cannot find tokens for node: ${JSON.stringify(node)}`), this.source, this.options.lang);\n            continue;\n          }\n          const wrapTokens = (fn) => {\n            const line = this.lines[node.line];\n            let charIndex = 0;\n            let itemStart = line.children.length;\n            let itemEnd = 0;\n            line.children.forEach((token, index) => {\n              if (charIndex >= node.character && index < itemStart)\n                itemStart = index;\n              if (charIndex <= node.character + node.length && index > itemEnd)\n                itemEnd = index;\n              charIndex += getTokenString(token).length;\n            });\n            if (charIndex <= node.character + node.length)\n              itemEnd = line.children.length;\n            const targets = line.children.slice(itemStart, itemEnd);\n            const length = targets.length;\n            line.children.splice(itemStart, length, ...fn(targets));\n          };\n          switch (node.type) {\n            case \"error\": {\n              if (renderer.nodeError) {\n                tokens.forEach((token) => {\n                  tokensSkipHover.add(token);\n                  const clone = { ...token };\n                  Object.assign(token, renderer.nodeError.call(this, node, clone));\n                });\n              }\n              if (renderer.nodesError) {\n                tokens.forEach((token) => {\n                  tokensSkipHover.add(token);\n                });\n                actionsHighlights.push(() => {\n                  wrapTokens((targets) => renderer.nodesError?.call(this, node, targets) || targets);\n                });\n              }\n              if (renderer.lineError)\n                insertAfterLine(node.line, renderer.lineError.call(this, node));\n              break;\n            }\n            case \"query\": {\n              const token = tokens[0];\n              if (token && renderer.nodeQuery) {\n                tokensSkipHover.add(token);\n                const clone = { ...token };\n                Object.assign(token, renderer.nodeQuery.call(this, node, clone));\n              }\n              if (renderer.lineQuery)\n                insertAfterLine(node.line, renderer.lineQuery.call(this, node, token));\n              break;\n            }\n            case \"completion\": {\n              if (renderer.nodeCompletion) {\n                tokens.forEach((token) => {\n                  tokensSkipHover.add(token);\n                  const clone = { ...token };\n                  Object.assign(token, renderer.nodeCompletion.call(this, node, clone));\n                });\n              }\n              if (renderer.lineCompletion)\n                insertAfterLine(node.line, renderer.lineCompletion.call(this, node));\n              break;\n            }\n            case \"highlight\": {\n              if (renderer.nodesHighlight) {\n                actionsHighlights.push(() => {\n                  wrapTokens((targets) => renderer.nodesHighlight?.call(this, node, targets) || targets);\n                });\n              }\n              break;\n            }\n            case \"hover\": {\n              if (renderer.nodeStaticInfo) {\n                actionsHovers.push(() => {\n                  tokens.forEach((token) => {\n                    if (tokensSkipHover.has(token))\n                      return;\n                    tokensSkipHover.add(token);\n                    const clone = { ...token };\n                    Object.assign(token, renderer.nodeStaticInfo.call(this, node, clone));\n                  });\n                });\n              }\n              break;\n            }\n            default: {\n              onShikiError(new ShikiTwoslashError(`Unknown node type: ${node?.type}`), this.source, this.options.lang);\n            }\n          }\n        }\n        actionsHovers.forEach((i) => i());\n        actionsHighlights.forEach((i) => i());\n      }\n    };\n  };\n}\nfunction getTokenString(token) {\n  if (\"value\" in token)\n    return token.value;\n  return token.children?.map(getTokenString).join(\"\") || \"\";\n}\n\nexport { ShikiTwoslashError, createTransformerFactory, defaultCompletionIcons, defaultCustomTagIcons, defaultHoverInfoProcessor, defaultTwoslashOptions, rendererClassic, rendererRich };\n", "import ts from 'typescript';\nimport { createTwoslasher as createTwoslasher$1, twoslasher as twoslasher$1 } from './core.mjs';\nexport { validateCodeForErrors } from './core.mjs';\nexport { T as TwoslashError, d as defaultCompilerOptions, c as defaultHandbookOptions, f as findCutNotations, a as findFlagNotations, b as findQueryMarkers, g as getObjectHash, r as removeTwoslashNotations } from './shared/twoslash.a8564bda.mjs';\nexport * from 'twoslash-protocol/types';\nimport '@typescript/vfs';\nimport 'twoslash-protocol';\n\nfunction convertLegacyOptions(opts) {\n  return {\n    ...opts,\n    handbookOptions: opts.handbookOptions || opts.defaultOptions,\n    compilerOptions: opts.compilerOptions || opts.defaultCompilerOptions\n  };\n}\nfunction convertLegacyReturn(result) {\n  return {\n    code: result.code,\n    extension: result.meta.extension,\n    staticQuickInfos: result.hovers.map((i) => ({\n      text: i.text,\n      docs: i.docs || \"\",\n      start: i.start,\n      length: i.length,\n      line: i.line,\n      character: i.character,\n      targetString: i.target\n    })),\n    tags: result.tags.map((t) => ({\n      name: t.name,\n      line: t.line,\n      annotation: t.text\n    })),\n    highlights: result.highlights.map((h) => ({\n      kind: \"highlight\",\n      // it's a bit confusing that `offset` and `start` are flipped\n      offset: h.start,\n      start: h.character,\n      length: h.length,\n      line: h.line,\n      text: h.text || \"\"\n    })),\n    queries: [\n      ...result.queries.map((q) => ({\n        kind: \"query\",\n        docs: q.docs || \"\",\n        offset: q.character,\n        start: q.start,\n        length: q.length,\n        line: q.line + 1,\n        text: q.text\n      })),\n      ...result.completions.map((q) => ({\n        kind: \"completions\",\n        offset: q.character,\n        start: q.start,\n        length: q.length,\n        line: q.line + 1,\n        completions: q.completions,\n        completionsPrefix: q.completionsPrefix\n      }))\n    ].sort((a, b) => a.start - b.start),\n    errors: result.errors.map((e) => ({\n      id: e.id ?? \"\",\n      code: e.code,\n      start: e.start,\n      length: e.length,\n      line: e.line,\n      character: e.character,\n      renderedMessage: e.text,\n      category: errorLevelToCategory(e.level)\n    })),\n    playgroundURL: \"\"\n  };\n}\nfunction errorLevelToCategory(level) {\n  switch (level) {\n    case \"warning\":\n      return 0;\n    case \"suggestion\":\n      return 2;\n    case \"message\":\n      return 3;\n    case \"error\":\n      return 1;\n  }\n  return 1;\n}\n\nconst cwd = typeof process !== \"undefined\" && typeof process.cwd === \"function\" ? process.cwd() : \"\";\nfunction createTwoslasher(opts) {\n  return createTwoslasher$1({\n    vfsRoot: cwd,\n    tsModule: ts,\n    ...opts\n  });\n}\nfunction twoslasher(code, lang, opts) {\n  return twoslasher$1(code, lang, {\n    vfsRoot: cwd,\n    tsModule: ts,\n    ...opts\n  });\n}\nfunction twoslasherLegacy(code, lang, opts) {\n  return convertLegacyReturn(\n    twoslasher$1(code, lang, convertLegacyOptions({\n      vfsRoot: cwd,\n      tsModule: ts,\n      ...opts\n    }))\n  );\n}\n\nexport { convertLegacyOptions, convertLegacyReturn, createTwoslasher, twoslasher, twoslasherLegacy };\n", "type System = import(\"typescript\").System\ntype CompilerOptions = import(\"typescript\").CompilerOptions\ntype CustomTransformers = import(\"typescript\").CustomTransformers\ntype LanguageServiceHost = import(\"typescript\").LanguageServiceHost\ntype CompilerHost = import(\"typescript\").CompilerHost\ntype SourceFile = import(\"typescript\").SourceFile\ntype TS = typeof import(\"typescript\")\n\ntype FetchLike = (url: string) => Promise<{ json(): Promise<any>; text(): Promise<string> }>\n\ninterface LocalStorageLike {\n  getItem(key: string): string | null\n  setItem(key: string, value: string): void\n  removeItem(key: string): void\n}\n\ndeclare var localStorage: LocalStorageLike | undefined;\ndeclare var fetch: FetchLike | undefined;\n\nlet hasLocalStorage = false\ntry {\n  hasLocalStorage = typeof localStorage !== `undefined`\n} catch (error) { }\n\nconst hasProcess = typeof process !== `undefined`\nconst shouldDebug = (hasLocalStorage && typeof localStorage!.getItem === 'function' && localStorage!.getItem(\"DEBUG\")) || (hasProcess && process.env.DEBUG)\nconst debugLog = shouldDebug ? console.log : (_message?: any, ..._optionalParams: any[]) => \"\"\n\nexport interface VirtualTypeScriptEnvironment {\n  sys: System\n  languageService: import(\"typescript\").LanguageService\n  getSourceFile: (fileName: string) => import(\"typescript\").SourceFile | undefined\n  createFile: (fileName: string, content: string) => void\n  updateFile: (fileName: string, content: string, replaceTextSpan?: import(\"typescript\").TextSpan) => void\n  deleteFile: (fileName: string) => void\n}\n\n/**\n * Makes a virtual copy of the TypeScript environment. This is the main API you want to be using with\n * @typescript/vfs. A lot of the other exposed functions are used by this function to get set up.\n *\n * @param sys an object which conforms to the TS Sys (a shim over read/write access to the fs)\n * @param rootFiles a list of files which are considered inside the project\n * @param ts a copy pf the TypeScript module\n * @param compilerOptions the options for this compiler run\n * @param customTransformers custom transformers for this compiler run\n */\n\nexport function createVirtualTypeScriptEnvironment(\n  sys: System,\n  rootFiles: string[],\n  ts: TS,\n  compilerOptions: CompilerOptions = {},\n  customTransformers?: CustomTransformers\n): VirtualTypeScriptEnvironment {\n  const mergedCompilerOpts = { ...defaultCompilerOptions(ts), ...compilerOptions }\n\n  const { languageServiceHost, updateFile, deleteFile } = createVirtualLanguageServiceHost(\n    sys,\n    rootFiles,\n    mergedCompilerOpts,\n    ts,\n    customTransformers\n  )\n  const languageService = ts.createLanguageService(languageServiceHost)\n  const diagnostics = languageService.getCompilerOptionsDiagnostics()\n\n  if (diagnostics.length) {\n    const compilerHost = createVirtualCompilerHost(sys, compilerOptions, ts)\n    throw new Error(ts.formatDiagnostics(diagnostics, compilerHost.compilerHost))\n  }\n\n  return {\n    // @ts-ignore\n    name: \"vfs\",\n    sys,\n    languageService,\n    getSourceFile: fileName => languageService.getProgram()?.getSourceFile(fileName),\n\n    createFile: (fileName, content) => {\n      updateFile(ts.createSourceFile(fileName, content, mergedCompilerOpts.target!, false))\n    },\n    updateFile: (fileName, content, optPrevTextSpan) => {\n      const prevSourceFile = languageService.getProgram()!.getSourceFile(fileName)\n      if (!prevSourceFile) {\n        throw new Error(\"Did not find a source file for \" + fileName)\n      }\n      const prevFullContents = prevSourceFile.text\n\n      // TODO: Validate if the default text span has a fencepost error?\n      const prevTextSpan = optPrevTextSpan ?? ts.createTextSpan(0, prevFullContents.length)\n      const newText =\n        prevFullContents.slice(0, prevTextSpan.start) +\n        content +\n        prevFullContents.slice(prevTextSpan.start + prevTextSpan.length)\n      const newSourceFile = ts.updateSourceFile(prevSourceFile, newText, {\n        span: prevTextSpan,\n        newLength: content.length,\n      })\n\n      updateFile(newSourceFile)\n    },\n    deleteFile(fileName) {\n      const sourceFile = languageService.getProgram()!.getSourceFile(fileName)\n      if (sourceFile) {\n        deleteFile(sourceFile)\n      }\n    }\n  }\n}\n\n// TODO: This could be replaced by grabbing: https://github.com/microsoft/TypeScript/blob/main/src/lib/libs.json\n// and then using that to generate the list of files from the server, but it is not included in the npm package\n\n/**\n * Grab the list of lib files for a particular target, will return a bit more than necessary (by including\n * the dom) but that's OK, we're really working with the constraint that you can't get a list of files\n * when running in a browser.\n *\n * @param target The compiler settings target baseline\n * @param ts A copy of the TypeScript module\n */\nexport const knownLibFilesForCompilerOptions = (compilerOptions: CompilerOptions, ts: TS) => {\n  const target = compilerOptions.target || ts.ScriptTarget.ES5\n  const lib = compilerOptions.lib || []\n\n  // Note that this will include files which can't be found for particular versions of TS\n  // TODO: Replace this with some sort of API call if https://github.com/microsoft/TypeScript/pull/54011\n  // or similar is merged.\n  const files = [\n    \"lib.d.ts\",\n    \"lib.core.d.ts\",\n    \"lib.decorators.d.ts\",\n    \"lib.decorators.legacy.d.ts\",\n    \"lib.dom.asynciterable.d.ts\",\n    \"lib.dom.d.ts\",\n    \"lib.dom.iterable.d.ts\",\n    \"lib.webworker.asynciterable.d.ts\",\n    \"lib.webworker.d.ts\",\n    \"lib.webworker.importscripts.d.ts\",\n    \"lib.webworker.iterable.d.ts\",\n    \"lib.scripthost.d.ts\",\n    \"lib.es5.d.ts\",\n    \"lib.es6.d.ts\",\n    \"lib.es7.d.ts\",\n    \"lib.core.es6.d.ts\",\n    \"lib.core.es7.d.ts\",\n    \"lib.es2015.collection.d.ts\",\n    \"lib.es2015.core.d.ts\",\n    \"lib.es2015.d.ts\",\n    \"lib.es2015.generator.d.ts\",\n    \"lib.es2015.iterable.d.ts\",\n    \"lib.es2015.promise.d.ts\",\n    \"lib.es2015.proxy.d.ts\",\n    \"lib.es2015.reflect.d.ts\",\n    \"lib.es2015.symbol.d.ts\",\n    \"lib.es2015.symbol.wellknown.d.ts\",\n    \"lib.es2016.array.include.d.ts\",\n    \"lib.es2016.d.ts\",\n    \"lib.es2016.full.d.ts\",\n    \"lib.es2016.intl.d.ts\",\n    \"lib.es2017.arraybuffer.d.ts\",\n    \"lib.es2017.d.ts\",\n    \"lib.es2017.date.d.ts\",\n    \"lib.es2017.full.d.ts\",\n    \"lib.es2017.intl.d.ts\",\n    \"lib.es2017.object.d.ts\",\n    \"lib.es2017.sharedmemory.d.ts\",\n    \"lib.es2017.string.d.ts\",\n    \"lib.es2017.typedarrays.d.ts\",\n    \"lib.es2018.asyncgenerator.d.ts\",\n    \"lib.es2018.asynciterable.d.ts\",\n    \"lib.es2018.d.ts\",\n    \"lib.es2018.full.d.ts\",\n    \"lib.es2018.intl.d.ts\",\n    \"lib.es2018.promise.d.ts\",\n    \"lib.es2018.regexp.d.ts\",\n    \"lib.es2019.array.d.ts\",\n    \"lib.es2019.d.ts\",\n    \"lib.es2019.full.d.ts\",\n    \"lib.es2019.intl.d.ts\",\n    \"lib.es2019.object.d.ts\",\n    \"lib.es2019.string.d.ts\",\n    \"lib.es2019.symbol.d.ts\",\n    \"lib.es2020.bigint.d.ts\",\n    \"lib.es2020.d.ts\",\n    \"lib.es2020.date.d.ts\",\n    \"lib.es2020.full.d.ts\",\n    \"lib.es2020.intl.d.ts\",\n    \"lib.es2020.number.d.ts\",\n    \"lib.es2020.promise.d.ts\",\n    \"lib.es2020.sharedmemory.d.ts\",\n    \"lib.es2020.string.d.ts\",\n    \"lib.es2020.symbol.wellknown.d.ts\",\n    \"lib.es2021.d.ts\",\n    \"lib.es2021.full.d.ts\",\n    \"lib.es2021.intl.d.ts\",\n    \"lib.es2021.promise.d.ts\",\n    \"lib.es2021.string.d.ts\",\n    \"lib.es2021.weakref.d.ts\",\n    \"lib.es2022.array.d.ts\",\n    \"lib.es2022.d.ts\",\n    \"lib.es2022.error.d.ts\",\n    \"lib.es2022.full.d.ts\",\n    \"lib.es2022.intl.d.ts\",\n    \"lib.es2022.object.d.ts\",\n    \"lib.es2022.regexp.d.ts\",\n    \"lib.es2022.sharedmemory.d.ts\",\n    \"lib.es2022.string.d.ts\",\n    \"lib.es2023.array.d.ts\",\n    \"lib.es2023.collection.d.ts\",\n    \"lib.es2023.d.ts\",\n    \"lib.es2023.full.d.ts\",\n    \"lib.es2023.intl.d.ts\",\n    \"lib.es2024.arraybuffer.d.ts\",\n    \"lib.es2024.collection.d.ts\",\n    \"lib.es2024.d.ts\",\n    \"lib.es2024.full.d.ts\",\n    \"lib.es2024.object.d.ts\",\n    \"lib.es2024.promise.d.ts\",\n    \"lib.es2024.regexp.d.ts\",\n    \"lib.es2024.sharedmemory.d.ts\",\n    \"lib.es2024.string.d.ts\",\n    \"lib.esnext.array.d.ts\",\n    \"lib.esnext.asynciterable.d.ts\",\n    \"lib.esnext.bigint.d.ts\",\n    \"lib.esnext.collection.d.ts\",\n    \"lib.esnext.d.ts\",\n    \"lib.esnext.decorators.d.ts\",\n    \"lib.esnext.disposable.d.ts\",\n    \"lib.esnext.float16.d.ts\",\n    \"lib.esnext.full.d.ts\",\n    \"lib.esnext.intl.d.ts\",\n    \"lib.esnext.iterator.d.ts\",\n    \"lib.esnext.object.d.ts\",\n    \"lib.esnext.promise.d.ts\",\n    \"lib.esnext.regexp.d.ts\",\n    \"lib.esnext.string.d.ts\",\n    \"lib.esnext.symbol.d.ts\",\n    \"lib.esnext.weakref.d.ts\"\n  ]\n\n  const targetToCut = ts.ScriptTarget[target]\n  const matches = files.filter(f => f.startsWith(`lib.${targetToCut.toLowerCase()}`))\n  const targetCutIndex = files.indexOf(matches.pop()!)\n\n  const getMax = (array: number[]) =>\n    array && array.length ? array.reduce((max, current) => (current > max ? current : max)) : undefined\n\n  // Find the index for everything in\n  const indexesForCutting = lib.map(lib => {\n    const matches = files.filter(f => f.startsWith(`lib.${lib.toLowerCase()}`))\n    if (matches.length === 0) return 0\n\n    const cutIndex = files.indexOf(matches.pop()!)\n    return cutIndex\n  })\n\n  const libCutIndex = getMax(indexesForCutting) || 0\n\n  const finalCutIndex = Math.max(targetCutIndex, libCutIndex)\n  return files.slice(0, finalCutIndex + 1)\n}\n\n/**\n * Sets up a Map with lib contents by grabbing the necessary files from\n * the local copy of typescript via the file system.\n *\n * The first two args are un-used, but kept around so as to not cause a\n * semver major bump for no gain to module users.\n */\nexport const createDefaultMapFromNodeModules = (\n  _compilerOptions: CompilerOptions,\n  _ts?: typeof import(\"typescript\"),\n  tsLibDirectory?: string\n) => {\n  const path = requirePath()\n  const fs = requireFS()\n\n  const getLib = (name: string) => {\n    const lib = tsLibDirectory || path.dirname(require.resolve(\"typescript\"))\n    return fs.readFileSync(path.join(lib, name), \"utf8\")\n  }\n\n  const isDtsFile = (file: string) => /\\.d\\.([^\\.]+\\.)?[cm]?ts$/i.test(file)\n\n  const libFiles = fs.readdirSync(tsLibDirectory || path.dirname(require.resolve(\"typescript\")))\n  const knownLibFiles = libFiles.filter(f => f.startsWith(\"lib.\") && isDtsFile(f))\n\n  const fsMap = new Map<string, string>()\n  knownLibFiles.forEach(lib => {\n    fsMap.set(\"/\" + lib, getLib(lib))\n  })\n  return fsMap\n}\n\n/**\n * Adds recursively files from the FS into the map based on the folder\n */\nexport const addAllFilesFromFolder = (map: Map<string, string>, workingDir: string): void => {\n  const path = requirePath()\n  const fs = requireFS()\n\n  const walk = function (dir: string) {\n    let results: string[] = []\n    const list = fs.readdirSync(dir)\n    list.forEach(function (file: string) {\n      file = path.join(dir, file)\n      const stat = fs.statSync(file)\n      if (stat && stat.isDirectory()) {\n        /* Recurse into a subdirectory */\n        results = results.concat(walk(file))\n      } else {\n        /* Is a file */\n        results.push(file)\n      }\n    })\n    return results\n  }\n\n  const allFiles = walk(workingDir)\n\n  allFiles.forEach(lib => {\n    const fsPath = \"/node_modules/@types\" + lib.replace(workingDir, \"\")\n    const content = fs.readFileSync(lib, \"utf8\")\n    const validExtensions = [\".ts\", \".tsx\"]\n\n    if (validExtensions.includes(path.extname(fsPath))) {\n      map.set(fsPath, content)\n    }\n  })\n}\n\n/** Adds all files from node_modules/@types into the FS Map */\nexport const addFilesForTypesIntoFolder = (map: Map<string, string>) =>\n  addAllFilesFromFolder(map, \"node_modules/@types\")\n\nexport interface LZString {\n  compressToUTF16(input: string): string\n  decompressFromUTF16(compressed: string): string\n}\n\n/**\n * Create a virtual FS Map with the lib files from a particular TypeScript\n * version based on the target, Always includes dom ATM.\n *\n * @param options The compiler target, which dictates the libs to set up\n * @param version the versions of TypeScript which are supported\n * @param cache should the values be stored in local storage\n * @param ts a copy of the typescript import\n * @param lzstring an optional copy of the lz-string import\n * @param fetcher an optional replacement for the global fetch function (tests mainly)\n * @param storer an optional replacement for the localStorage global (tests mainly)\n */\nexport const createDefaultMapFromCDN = (\n  options: CompilerOptions,\n  version: string,\n  cache: boolean,\n  ts: TS,\n  lzstring?: LZString,\n  fetcher?: FetchLike,\n  storer?: LocalStorageLike\n) => {\n  const fetchlike = fetcher || fetch!\n  const fsMap = new Map<string, string>()\n  const files = knownLibFilesForCompilerOptions(options, ts)\n  const prefix = `https://playgroundcdn.typescriptlang.org/cdn/${version}/typescript/lib/`\n\n  function zip(str: string) {\n    return lzstring ? lzstring.compressToUTF16(str) : str\n  }\n\n  function unzip(str: string) {\n    return lzstring ? lzstring.decompressFromUTF16(str) : str\n  }\n\n  // Map the known libs to a node fetch promise, then return the contents\n  function uncached() {\n    return (\n      Promise.all(files.map(lib => fetchlike(prefix + lib).then(resp => resp.text())))\n        .then(contents => {\n          contents.forEach((text, index) => fsMap.set(\"/\" + files[index], text))\n        })\n        // Return a NOOP for .d.ts files which aren't in the current build of TypeScript\n        .catch(() => { })\n    )\n  }\n\n  // A localstorage and lzzip aware version of the lib files\n  function cached() {\n    const storelike = storer || localStorage!\n\n    const keys = Object.keys(storelike)\n    keys.forEach(key => {\n      // Remove anything which isn't from this version\n      if (key.startsWith(\"ts-lib-\") && !key.startsWith(\"ts-lib-\" + version)) {\n        storelike.removeItem(key)\n      }\n    })\n\n    return Promise.all(\n      files.map(lib => {\n        const cacheKey = `ts-lib-${version}-${lib}`\n        const content = storelike.getItem(cacheKey)\n\n        if (!content) {\n          // Make the API call and store the text concent in the cache\n          return (\n            fetchlike(prefix + lib)\n              .then(resp => resp.text())\n              .then(t => {\n                storelike.setItem(cacheKey, zip(t))\n                return t\n              })\n              // Return a NOOP for .d.ts files which aren't in the current build of TypeScript\n              .catch(() => { })\n          )\n        } else {\n          return Promise.resolve(unzip(content))\n        }\n      })\n    ).then(contents => {\n      contents.forEach((text, index) => {\n        if (text) {\n          const name = \"/\" + files[index]\n          fsMap.set(name, text)\n        }\n      })\n    })\n  }\n\n  const func = cache ? cached : uncached\n  return func().then(() => fsMap)\n}\n\nfunction notImplemented(methodName: string): any {\n  throw new Error(`Method '${methodName}' is not implemented.`)\n}\n\nfunction audit<ArgsT extends any[], ReturnT>(\n  name: string,\n  fn: (...args: ArgsT) => ReturnT\n): (...args: ArgsT) => ReturnT {\n  return (...args) => {\n    const res = fn(...args)\n\n    const smallres = typeof res === \"string\" ? res.slice(0, 80) + \"...\" : res\n    debugLog(\"> \" + name, ...args)\n    debugLog(\"< \" + smallres)\n\n    return res\n  }\n}\n\n/** The default compiler options if TypeScript could ever change the compiler options */\nconst defaultCompilerOptions = (ts: typeof import(\"typescript\")): CompilerOptions => {\n  return {\n    ...ts.getDefaultCompilerOptions(),\n    jsx: ts.JsxEmit.React,\n    strict: true,\n    esModuleInterop: true,\n    module: ts.ModuleKind.ESNext,\n    suppressOutputPathCheck: true,\n    skipLibCheck: true,\n    skipDefaultLibCheck: true,\n    moduleResolution: ts.ModuleResolutionKind.NodeJs,\n  }\n}\n\n// \"/DOM.d.ts\" => \"/lib.dom.d.ts\"\nconst libize = (path: string) => path.replace(\"/\", \"/lib.\").toLowerCase()\n\n/**\n * Creates an in-memory System object which can be used in a TypeScript program, this\n * is what provides read/write aspects of the virtual fs\n */\nexport function createSystem(files: Map<string, string>): System {\n  return {\n    args: [],\n    createDirectory: () => notImplemented(\"createDirectory\"),\n    // TODO: could make a real file tree\n    directoryExists: audit(\"directoryExists\", directory => {\n      return Array.from(files.keys()).some(path => path.startsWith(directory))\n    }),\n    exit: () => notImplemented(\"exit\"),\n    fileExists: audit(\"fileExists\", fileName => files.has(fileName) || files.has(libize(fileName))),\n    getCurrentDirectory: () => \"/\",\n    getDirectories: () => [],\n    getExecutingFilePath: () => notImplemented(\"getExecutingFilePath\"),\n    readDirectory: audit(\"readDirectory\", directory => (directory === \"/\" ? Array.from(files.keys()) : [])),\n    readFile: audit(\"readFile\", fileName => files.get(fileName) ?? files.get(libize(fileName))),\n    resolvePath: path => path,\n    newLine: \"\\n\",\n    useCaseSensitiveFileNames: true,\n    write: () => notImplemented(\"write\"),\n    writeFile: (fileName, contents) => {\n      files.set(fileName, contents)\n    },\n    deleteFile: (fileName) => {\n      files.delete(fileName)\n    },\n  }\n}\n\n/**\n * Creates a file-system backed System object which can be used in a TypeScript program, you provide\n * a set of virtual files which are prioritised over the FS versions, then a path to the root of your\n * project (basically the folder your node_modules lives)\n */\nexport function createFSBackedSystem(\n  files: Map<string, string>,\n  _projectRoot: string,\n  ts: TS,\n  tsLibDirectory?: string\n): System {\n  // We need to make an isolated folder for the tsconfig, but also need to be able to resolve the\n  // existing node_modules structures going back through the history\n  const root = _projectRoot + \"/vfs\"\n  const path = requirePath()\n\n  // The default System in TypeScript\n  const nodeSys = ts.sys\n  const tsLib = tsLibDirectory ?? path.dirname(require.resolve(\"typescript\"))\n\n  return {\n    // @ts-ignore\n    name: \"fs-vfs\",\n    root,\n    args: [],\n    createDirectory: () => notImplemented(\"createDirectory\"),\n    // TODO: could make a real file tree\n    directoryExists: audit(\"directoryExists\", directory => {\n      return Array.from(files.keys()).some(path => path.startsWith(directory)) || nodeSys.directoryExists(directory)\n    }),\n    exit: nodeSys.exit,\n    fileExists: audit(\"fileExists\", fileName => {\n      if (files.has(fileName)) return true\n      // Don't let other tsconfigs end up touching the vfs\n      if (fileName.includes(\"tsconfig.json\") || fileName.includes(\"tsconfig.json\")) return false\n      if (fileName.startsWith(\"/lib\")) {\n        const tsLibName = `${tsLib}/${fileName.replace(\"/\", \"\")}`\n        return nodeSys.fileExists(tsLibName)\n      }\n      return nodeSys.fileExists(fileName)\n    }),\n    getCurrentDirectory: () => root,\n    getDirectories: nodeSys.getDirectories,\n    getExecutingFilePath: () => notImplemented(\"getExecutingFilePath\"),\n    readDirectory: audit(\"readDirectory\", (...args) => {\n      if (args[0] === \"/\") {\n        return Array.from(files.keys())\n      } else {\n        return nodeSys.readDirectory(...args)\n      }\n    }),\n    readFile: audit(\"readFile\", fileName => {\n      if (files.has(fileName)) return files.get(fileName)\n      if (fileName.startsWith(\"/lib\")) {\n        const tsLibName = `${tsLib}/${fileName.replace(\"/\", \"\")}`\n        const result = nodeSys.readFile(tsLibName)\n        if (!result) {\n          const libs = nodeSys.readDirectory(tsLib)\n          throw new Error(\n            `TSVFS: A request was made for ${tsLibName} but there wasn't a file found in the file map. You likely have a mismatch in the compiler options for the CDN download vs the compiler program. Existing Libs: ${libs}.`\n          )\n        }\n        return result\n      }\n      return nodeSys.readFile(fileName)\n    }),\n    resolvePath: path => {\n      if (files.has(path)) return path\n      return nodeSys.resolvePath(path)\n    },\n    newLine: \"\\n\",\n    useCaseSensitiveFileNames: true,\n    write: () => notImplemented(\"write\"),\n    writeFile: (fileName, contents) => {\n      files.set(fileName, contents)\n    },\n    deleteFile: (fileName) => {\n      files.delete(fileName)\n    },\n    realpath: nodeSys.realpath,\n  }\n}\n\n/**\n * Creates an in-memory CompilerHost -which is essentially an extra wrapper to System\n * which works with TypeScript objects - returns both a compiler host, and a way to add new SourceFile\n * instances to the in-memory file system.\n */\nexport function createVirtualCompilerHost(sys: System, compilerOptions: CompilerOptions, ts: TS) {\n  const sourceFiles = new Map<string, SourceFile>()\n  const save = (sourceFile: SourceFile) => {\n    sourceFiles.set(sourceFile.fileName, sourceFile)\n    return sourceFile\n  }\n\n  type Return = {\n    compilerHost: CompilerHost\n    updateFile: (sourceFile: SourceFile) => boolean\n    deleteFile: (sourceFile: SourceFile) => boolean\n  }\n\n  const vHost: Return = {\n    compilerHost: {\n      ...sys,\n      getCanonicalFileName: fileName => fileName,\n      getDefaultLibFileName: () => \"/\" + ts.getDefaultLibFileName(compilerOptions), // '/lib.d.ts',\n      // getDefaultLibLocation: () => '/',\n      getNewLine: () => sys.newLine,\n      getSourceFile: (fileName, languageVersionOrOptions) => {\n        return (\n          sourceFiles.get(fileName) ||\n          save(\n            ts.createSourceFile(\n              fileName,\n              sys.readFile(fileName)!,\n              languageVersionOrOptions ?? compilerOptions.target ?? defaultCompilerOptions(ts).target!,\n              false\n            )\n          )\n        )\n      },\n      useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,\n    },\n    updateFile: sourceFile => {\n      const alreadyExists = sourceFiles.has(sourceFile.fileName)\n      sys.writeFile(sourceFile.fileName, sourceFile.text)\n      sourceFiles.set(sourceFile.fileName, sourceFile)\n      return alreadyExists\n    },\n    deleteFile: sourceFile => {\n      const alreadyExists = sourceFiles.has(sourceFile.fileName)\n      sourceFiles.delete(sourceFile.fileName)\n      sys.deleteFile!(sourceFile.fileName)\n      return alreadyExists\n    }\n  }\n  return vHost\n}\n\n/**\n * Creates an object which can host a language service against the virtual file-system\n */\nexport function createVirtualLanguageServiceHost(\n  sys: System,\n  rootFiles: string[],\n  compilerOptions: CompilerOptions,\n  ts: TS,\n  customTransformers?: CustomTransformers\n) {\n  const fileNames = [...rootFiles]\n  const { compilerHost, updateFile, deleteFile } = createVirtualCompilerHost(sys, compilerOptions, ts)\n  const fileVersions = new Map<string, string>()\n  let projectVersion = 0\n  const languageServiceHost: LanguageServiceHost = {\n    ...compilerHost,\n    getProjectVersion: () => projectVersion.toString(),\n    getCompilationSettings: () => compilerOptions,\n    getCustomTransformers: () => customTransformers,\n    // A couple weeks of 4.8 TypeScript nightlies had a bug where the Program's\n    // list of files was just a reference to the array returned by this host method,\n    // which means mutations by the host that ought to result in a new Program being\n    // created were not detected, since the old list of files and the new list of files\n    // were in fact a reference to the same underlying array. That was fixed in\n    // https://github.com/microsoft/TypeScript/pull/49813, but since the twoslash runner\n    // is used in bisecting for changes, it needs to guard against being busted in that\n    // couple-week period, so we defensively make a slice here.\n    getScriptFileNames: () => fileNames.slice(),\n    getScriptSnapshot: fileName => {\n      const contents = sys.readFile(fileName)\n      if (contents && typeof contents === \"string\") {\n        return ts.ScriptSnapshot.fromString(contents)\n      }\n      return\n    },\n    getScriptVersion: fileName => {\n      return fileVersions.get(fileName) || \"0\"\n    },\n    writeFile: sys.writeFile,\n  }\n\n  type Return = {\n    languageServiceHost: LanguageServiceHost\n    updateFile: (sourceFile: import(\"typescript\").SourceFile) => void\n    deleteFile: (sourceFile: import(\"typescript\").SourceFile) => void\n  }\n\n  const lsHost: Return = {\n    languageServiceHost,\n    updateFile: sourceFile => {\n      projectVersion++\n      fileVersions.set(sourceFile.fileName, projectVersion.toString())\n      if (!fileNames.includes(sourceFile.fileName)) {\n        fileNames.push(sourceFile.fileName)\n      }\n      updateFile(sourceFile)\n    },\n    deleteFile: sourceFile => {\n      projectVersion++\n      fileVersions.set(sourceFile.fileName, projectVersion.toString())\n      const index = fileNames.indexOf(sourceFile.fileName)\n      if (index !== -1) {\n        fileNames.splice(index, 1)\n      }\n      deleteFile(sourceFile)\n    }\n  }\n  return lsHost\n}\n\nconst requirePath = () => {\n  return require(String.fromCharCode(112, 97, 116, 104)) as typeof import(\"path\")\n}\n\nconst requireFS = () => {\n  return require(String.fromCharCode(102, 115)) as typeof import(\"fs\")\n}\n", "function isInRange(index, range, inclusive = true) {\n  if (inclusive)\n    return range[0] <= index && index <= range[1];\n  else\n    return range[0] < index && index < range[1];\n}\nfunction isInRanges(index, ranges, inclusive = true) {\n  return ranges.find((range) => isInRange(index, range, inclusive));\n}\nfunction mergeRanges(ranges) {\n  ranges.sort((a, b) => a[0] - b[0]);\n  const merged = [];\n  for (const range of ranges) {\n    const last = merged[merged.length - 1];\n    if (last && last[1] >= range[0])\n      last[1] = Math.max(last[1], range[1]);\n    else\n      merged.push(range);\n  }\n  return merged;\n}\nfunction splitLines(code, preserveEnding = false) {\n  const parts = code.split(/(\\r?\\n)/g);\n  let index = 0;\n  const lines = [];\n  for (let i = 0; i < parts.length; i += 2) {\n    const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n    lines.push([line, index]);\n    index += parts[i].length;\n    index += parts[i + 1]?.length || 0;\n  }\n  return lines;\n}\nfunction createPositionConverter(code) {\n  const lines = splitLines(code, true).map(([line]) => line);\n  function indexToPos(index) {\n    let character = index;\n    let line = 0;\n    for (const lineText of lines) {\n      if (character < lineText.length)\n        break;\n      character -= lineText.length;\n      line++;\n    }\n    return { line, character };\n  }\n  function posToIndex(line, character) {\n    let index = 0;\n    for (let i = 0; i < line; i++)\n      index += lines[i].length;\n    index += character;\n    return index;\n  }\n  return {\n    lines,\n    indexToPos,\n    posToIndex\n  };\n}\nfunction removeCodeRanges(code, removals, nodes) {\n  const ranges = mergeRanges(removals).sort((a, b) => b[0] - a[0]);\n  let outputCode = code;\n  for (const remove of ranges) {\n    const removalLength = remove[1] - remove[0];\n    outputCode = outputCode.slice(0, remove[0]) + outputCode.slice(remove[1]);\n    nodes?.forEach((node) => {\n      if (node.start + node.length <= remove[0])\n        return void 0;\n      else if (node.start < remove[1])\n        node.start = -1;\n      else\n        node.start -= removalLength;\n    });\n  }\n  return {\n    code: outputCode,\n    removals: ranges,\n    nodes\n  };\n}\nfunction resolveNodePositions(nodes, options) {\n  const indexToPos = typeof options === \"string\" ? createPositionConverter(options).indexToPos : options;\n  const resolved = nodes.filter((node) => node.start >= 0).sort((a, b) => a.start - b.start || a.type.localeCompare(b.type));\n  resolved.forEach((node) => Object.assign(node, indexToPos(node.start)));\n  return resolved;\n}\n\nexport { createPositionConverter, isInRange, isInRanges, mergeRanges, removeCodeRanges, resolveNodePositions, splitLines };\n", "import { removeCodeRanges } from 'twoslash-protocol';\n\nconst defaultCompilerOptions = {\n  strict: true,\n  module: 99,\n  target: 99,\n  allowJs: true,\n  skipDefaultLibCheck: true,\n  skipLibCheck: true,\n  moduleDetection: 3\n};\nconst defaultHandbookOptions = {\n  errors: [],\n  noErrors: false,\n  noErrorsCutted: false,\n  noErrorValidation: false,\n  noStaticSemanticInfo: false,\n  showEmit: false,\n  showEmittedFile: void 0,\n  keepNotations: false\n};\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TwoslashError extends Error {\n  constructor(title, description, recommendation, code) {\n    let message = `\n## ${title}\n\n${description}\n`;\n    if (recommendation)\n      message += `\n${recommendation}`;\n    if (code)\n      message += `\n${code}`;\n    super(message);\n    __publicField(this, \"title\");\n    __publicField(this, \"description\");\n    __publicField(this, \"recommendation\");\n    __publicField(this, \"code\");\n    this.title = title;\n    this.description = description;\n    this.recommendation = recommendation;\n    this.code = code;\n  }\n}\n\nconst defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\n\nconst reConfigBoolean = /^\\/\\/\\s?@(\\w+)$/gm;\nconst reConfigValue = /^\\/\\/\\s?@(\\w+):\\s?(.+)$/gm;\nconst reAnnonateMarkers = /^\\s*\\/\\/\\s*\\^(\\?|\\||\\^+)( .*)?$/gm;\nconst reCutBefore = /^[\\t\\v\\f ]*\\/\\/\\s?---cut(-before)?---\\r?\\n/gm;\nconst reCutAfter = /^[\\t\\v\\f ]*\\/\\/\\s?---cut-after---$/gm;\nconst reCutStart = /^[\\t\\v\\f ]*\\/\\/\\s?---cut-start---$/gm;\nconst reCutEnd = /^[\\t\\v\\f ]*\\/\\/\\s?---cut-end---\\r?\\n/gm;\nconst reFilenamesMakers = /^[\\t\\v\\f ]*\\/\\/\\s?@filename: (.+)$/gm;\n\nfunction getObjectHash(obj) {\n  return objectHash(obj);\n}\nfunction parsePrimitive(value, type) {\n  if (typeof value === type)\n    return value;\n  switch (type) {\n    case \"number\":\n      return +value;\n    case \"string\":\n      return value;\n    case \"boolean\":\n      return value.toLowerCase() === \"true\" || value.length === 0;\n  }\n  throw new TwoslashError(\n    `Unknown primitive value in compiler flag`,\n    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,\n    `This is likely a typo.`\n  );\n}\nfunction typesToExtension(types) {\n  const map = {\n    js: \"js\",\n    javascript: \"js\",\n    ts: \"ts\",\n    typescript: \"ts\",\n    tsx: \"tsx\",\n    jsx: \"jsx\",\n    json: \"json\",\n    jsn: \"json\",\n    map: \"json\",\n    mts: \"ts\",\n    cts: \"ts\",\n    mjs: \"js\",\n    cjs: \"js\"\n  };\n  if (map[types])\n    return map[types];\n  throw new TwoslashError(\n    `Unknown TypeScript extension given to Twoslash`,\n    `Received ${types} but Twoslash only accepts: ${Object.keys(map)} `,\n    ``\n  );\n}\nfunction getIdentifierTextSpans(ts, sourceFile, fileOffset) {\n  const textSpans = [];\n  checkChildren(sourceFile);\n  return textSpans;\n  function checkChildren(node) {\n    ts.forEachChild(node, (child) => {\n      if (ts.isIdentifier(child)) {\n        const text = child.getText(sourceFile);\n        const start = child.getStart(sourceFile, false) + fileOffset;\n        const end = start + text.length;\n        textSpans.push([start, end, text]);\n      }\n      checkChildren(child);\n    });\n  }\n}\nfunction getOptionValueFromMap(name, key, optMap) {\n  const result = optMap.get(key.toLowerCase());\n  if (result === void 0) {\n    const keys = Array.from(optMap.keys());\n    throw new TwoslashError(\n      `Invalid inline compiler value`,\n      `Got ${key} for ${name} but it is not a supported value by the TS compiler.`,\n      `Allowed values: ${keys.join(\",\")}`\n    );\n  }\n  return result;\n}\nfunction splitFiles(code, defaultFileName, root) {\n  const matches = Array.from(code.matchAll(reFilenamesMakers));\n  const allFilenames = matches.map((match) => match[1].trimEnd());\n  let currentFileName = allFilenames.includes(defaultFileName) ? \"__index__.ts\" : defaultFileName;\n  const files = [];\n  let index = 0;\n  for (const match of matches) {\n    const offset = match.index;\n    const content = code.slice(index, offset);\n    if (content) {\n      files.push({\n        offset: index,\n        filename: currentFileName,\n        filepath: root + currentFileName,\n        content,\n        extension: getExtension(currentFileName)\n      });\n    }\n    currentFileName = match[1].trimEnd();\n    index = offset;\n  }\n  if (index < code.length) {\n    const content = code.slice(index);\n    files.push({\n      offset: index,\n      filename: currentFileName,\n      filepath: root + currentFileName,\n      content,\n      extension: getExtension(currentFileName)\n    });\n  }\n  return files;\n}\nfunction getExtension(fileName) {\n  return fileName.split(\".\").pop();\n}\nfunction parseFlag(name, value, start, end, customTags, tsOptionDeclarations) {\n  if (customTags.includes(name)) {\n    return {\n      type: \"tag\",\n      name,\n      value,\n      start,\n      end\n    };\n  }\n  const compilerDecl = tsOptionDeclarations.find((d) => d.name.toLocaleLowerCase() === name.toLocaleLowerCase());\n  if (compilerDecl) {\n    switch (compilerDecl.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n        return {\n          type: \"compilerOptions\",\n          name: compilerDecl.name,\n          value: parsePrimitive(value, compilerDecl.type),\n          start,\n          end\n        };\n      case \"list\": {\n        const elementType = compilerDecl.element.type;\n        const strings = value.split(\",\");\n        const resolved = typeof elementType === \"string\" ? strings.map((v) => parsePrimitive(v, elementType)) : strings.map((v) => getOptionValueFromMap(compilerDecl.name, v, elementType));\n        return {\n          type: \"compilerOptions\",\n          name: compilerDecl.name,\n          value: resolved,\n          start,\n          end\n        };\n      }\n      case \"object\":\n        return {\n          type: \"compilerOptions\",\n          name: compilerDecl.name,\n          value: JSON.parse(value),\n          start,\n          end\n        };\n      default: {\n        return {\n          type: \"compilerOptions\",\n          name: compilerDecl.name,\n          value: getOptionValueFromMap(compilerDecl.name, value, compilerDecl.type),\n          start,\n          end\n        };\n      }\n    }\n  }\n  if (Object.keys(defaultHandbookOptions).includes(name)) {\n    if (name === \"errors\" && typeof value === \"string\")\n      value = value.split(\" \").map(Number);\n    if (name === \"noErrors\" && typeof value === \"string\") {\n      if (value === \"true\")\n        value = true;\n      else if (value === \"false\")\n        value = false;\n      else\n        value = value.split(\" \").map(Number);\n    }\n    return {\n      type: \"handbookOptions\",\n      name,\n      value,\n      start,\n      end\n    };\n  }\n  return {\n    type: \"unknown\",\n    name,\n    value,\n    start,\n    end\n  };\n}\nfunction findFlagNotations(code, customTags, tsOptionDeclarations) {\n  const flagNotations = [];\n  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {\n    const index = match.index;\n    const name = match[1];\n    flagNotations.push(\n      parseFlag(name, true, index, index + match[0].length + 1, customTags, tsOptionDeclarations)\n    );\n  });\n  Array.from(code.matchAll(reConfigValue)).forEach((match) => {\n    const name = match[1];\n    if (name === \"filename\")\n      return;\n    const index = match.index;\n    const value = match[2];\n    flagNotations.push(\n      parseFlag(name, value, index, index + match[0].length + 1, customTags, tsOptionDeclarations)\n    );\n  });\n  return flagNotations;\n}\nfunction findCutNotations(code, meta) {\n  const removals = [];\n  const cutBefore = [...code.matchAll(reCutBefore)];\n  const cutAfter = [...code.matchAll(reCutAfter)];\n  const cutStart = [...code.matchAll(reCutStart)];\n  const cutEnd = [...code.matchAll(reCutEnd)];\n  if (cutBefore.length) {\n    const last = cutBefore[cutBefore.length - 1];\n    removals.push([0, last.index + last[0].length]);\n  }\n  if (cutAfter.length) {\n    const first = cutAfter[0];\n    removals.push([first.index, code.length]);\n  }\n  if (cutStart.length !== cutEnd.length) {\n    throw new TwoslashError(\n      `Mismatched cut markers`,\n      `You have ${cutStart.length} cut-starts and ${cutEnd.length} cut-ends`,\n      `Make sure you have a matching pair for each.`\n    );\n  }\n  for (let i = 0; i < cutStart.length; i++) {\n    const start = cutStart[i];\n    const end = cutEnd[i];\n    if (start.index > end.index) {\n      throw new TwoslashError(\n        `Mismatched cut markers`,\n        `You have a cut-start at ${start.index} which is after the cut-end at ${end.index}`,\n        `Make sure you have a matching pair for each.`\n      );\n    }\n    removals.push([start.index, end.index + end[0].length]);\n  }\n  if (meta)\n    meta.removals.push(...removals);\n  return removals;\n}\nfunction findQueryMarkers(code, meta, pc) {\n  if (code.includes(\"//\")) {\n    const linesQuery = /* @__PURE__ */ new Set();\n    Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {\n      const type = match[1];\n      const index = match.index;\n      meta.removals.push([index, index + match[0].length + 1]);\n      const markerIndex = match[0].indexOf(\"^\");\n      const pos = pc.indexToPos(index + markerIndex);\n      let targetLine = pos.line - 1;\n      while (linesQuery.has(targetLine) && targetLine >= 0)\n        targetLine -= 1;\n      const targetIndex = pc.posToIndex(targetLine, pos.character);\n      if (type === \"?\") {\n        meta.positionQueries.push(targetIndex);\n      } else if (type === \"|\") {\n        meta.positionCompletions.push(targetIndex);\n      } else {\n        const markerLength = match[0].lastIndexOf(\"^\") - markerIndex + 1;\n        meta.positionHighlights.push([\n          targetIndex,\n          targetIndex + markerLength,\n          match[2]?.trim()\n        ]);\n      }\n      linesQuery.add(pos.line);\n    });\n  }\n  return meta;\n}\nfunction removeTsExtension(filename) {\n  const sansMapOrDTS = filename.replace(/\\.map$/, \"\").replace(/\\.d\\.ts$/, \".ts\").replace(/\\.map$/, \"\");\n  return sansMapOrDTS.replace(/\\.[^/.]+$/, \"\");\n}\n\nconst flagKeys = [\n  \"all\",\n  \"allowArbitraryExtensions\",\n  \"allowImportingTsExtensions\",\n  \"allowJs\",\n  \"allowSyntheticDefaultImports\",\n  \"allowUmdGlobalAccess\",\n  \"allowUnreachableCode\",\n  \"allowUnusedLabels\",\n  \"alwaysStrict\",\n  \"assumeChangesOnlyAffectDirectDependencies\",\n  \"baseUrl\",\n  \"build\",\n  \"charset\",\n  \"checkJs\",\n  \"composite\",\n  \"customConditions\",\n  \"declaration\",\n  \"declarationDir\",\n  \"declarationMap\",\n  \"diagnostics\",\n  \"disableReferencedProjectLoad\",\n  \"disableSizeLimit\",\n  \"disableSolutionSearching\",\n  \"disableSourceOfProjectReferenceRedirect\",\n  \"downlevelIteration\",\n  \"emitBOM\",\n  \"emitDeclarationOnly\",\n  \"emitDecoratorMetadata\",\n  \"errors\",\n  \"esModuleInterop\",\n  \"exactOptionalPropertyTypes\",\n  \"experimentalDecorators\",\n  \"explainFiles\",\n  \"extendedDiagnostics\",\n  \"forceConsistentCasingInFileNames\",\n  \"generateCpuProfile\",\n  \"generateTrace\",\n  \"help\",\n  \"help\",\n  \"ignoreDeprecations\",\n  \"importHelpers\",\n  \"importsNotUsedAsValues\",\n  \"incremental\",\n  \"init\",\n  \"inlineSourceMap\",\n  \"inlineSources\",\n  \"isolatedModules\",\n  \"jsx\",\n  \"jsxFactory\",\n  \"jsxFragmentFactory\",\n  \"jsxImportSource\",\n  \"keepNotations\",\n  \"keyofStringsOnly\",\n  \"lib\",\n  \"listEmittedFiles\",\n  \"listFiles\",\n  \"listFilesOnly\",\n  \"locale\",\n  \"mapRoot\",\n  \"maxNodeModuleJsDepth\",\n  \"module\",\n  \"moduleDetection\",\n  \"moduleResolution\",\n  \"moduleSuffixes\",\n  \"newLine\",\n  \"noEmit\",\n  \"noEmitHelpers\",\n  \"noEmitOnError\",\n  \"noErrorTruncation\",\n  \"noErrorValidation\",\n  \"noErrors\",\n  \"noErrorsCutted\",\n  \"noFallthroughCasesInSwitch\",\n  \"noImplicitAny\",\n  \"noImplicitOverride\",\n  \"noImplicitReturns\",\n  \"noImplicitThis\",\n  \"noImplicitUseStrict\",\n  \"noLib\",\n  \"noPropertyAccessFromIndexSignature\",\n  \"noResolve\",\n  \"noStaticSemanticInfo\",\n  \"noStrictGenericChecks\",\n  \"noUncheckedIndexedAccess\",\n  \"noUnusedLocals\",\n  \"noUnusedParameters\",\n  \"out\",\n  \"outDir\",\n  \"outFile\",\n  \"paths\",\n  \"plugins\",\n  \"preserveConstEnums\",\n  \"preserveSymlinks\",\n  \"preserveValueImports\",\n  \"preserveWatchOutput\",\n  \"pretty\",\n  \"project\",\n  \"reactNamespace\",\n  \"removeComments\",\n  \"resolveJsonModule\",\n  \"resolvePackageJsonExports\",\n  \"resolvePackageJsonImports\",\n  \"rootDir\",\n  \"rootDirs\",\n  \"showConfig\",\n  \"showEmit\",\n  \"showEmittedFile\",\n  \"skipDefaultLibCheck\",\n  \"skipLibCheck\",\n  \"sourceMap\",\n  \"sourceRoot\",\n  \"strict\",\n  \"strictBindCallApply\",\n  \"strictFunctionTypes\",\n  \"strictNullChecks\",\n  \"strictPropertyInitialization\",\n  \"stripInternal\",\n  \"suppressExcessPropertyErrors\",\n  \"suppressImplicitAnyIndexErrors\",\n  \"target\",\n  \"traceResolution\",\n  \"tsBuildInfoFile\",\n  \"typeRoots\",\n  \"types\",\n  \"useDefineForClassFields\",\n  \"useUnknownInCatchVariables\",\n  \"verbatimModuleSyntax\",\n  \"version\",\n  \"watch\"\n];\n\nfunction removeTwoslashNotations(code, customTags) {\n  const meta = {\n    removals: []\n  };\n  const tags = [\n    ...customTags ?? [],\n    ...flagKeys\n  ];\n  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {\n    if (!tags.includes(match[1]))\n      return;\n    meta.removals.push([match.index, match.index + match[0].length + 1]);\n  });\n  Array.from(code.matchAll(reConfigValue)).forEach((match) => {\n    if (!tags.includes(match[1]))\n      return;\n    meta.removals.push([match.index, match.index + match[0].length + 1]);\n  });\n  findCutNotations(code, meta);\n  Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {\n    const index = match.index;\n    meta.removals.push([index, index + match[0].length + 1]);\n  });\n  return removeCodeRanges(code, meta.removals).code;\n}\n\nexport { TwoslashError as T, findFlagNotations as a, findQueryMarkers as b, defaultHandbookOptions as c, defaultCompilerOptions as d, removeTsExtension as e, findCutNotations as f, getObjectHash as g, getExtension as h, getIdentifierTextSpans as i, removeTwoslashNotations as r, splitFiles as s, typesToExtension as t };\n", "import { createSystem, createFSBackedSystem, createVirtualTypeScriptEnvironment } from '@typescript/vfs';\nimport { createPositionConverter, isInRange, removeCodeRanges, resolveNodePositions, isInRanges } from 'twoslash-protocol';\nimport { T as TwoslashError, t as typesToExtension, d as defaultCompilerOptions, c as defaultHandbookOptions, a as findFlagNotations, f as findCutNotations, b as findQueryMarkers, s as splitFiles, e as removeTsExtension, h as getExtension, g as getObjectHash, i as getIdentifierTextSpans } from './shared/twoslash.a8564bda.mjs';\nexport { r as removeTwoslashNotations } from './shared/twoslash.a8564bda.mjs';\nexport * from 'twoslash-protocol/types';\n\nfunction validateCodeForErrors(relevantErrors, handbookOptions, vfsRoot) {\n  const unspecifiedErrors = relevantErrors.filter((e) => e.code && !handbookOptions.errors.includes(e.code));\n  const errorsFound = Array.from(new Set(unspecifiedErrors.map((e) => e.code))).join(\" \");\n  if (unspecifiedErrors.length) {\n    const errorsToShow = new Set(relevantErrors.map((e) => e.code));\n    const codeToAdd = `// @errors: ${Array.from(errorsToShow).join(\" \")}`;\n    const missing = handbookOptions.errors.length ? `\nThe existing annotation specified ${handbookOptions.errors.join(\" \")}` : `\nExpected: ${codeToAdd}`;\n    const filesToErrors = {};\n    const noFiles = [];\n    unspecifiedErrors.forEach((d) => {\n      const fileRef = d.filename?.replace(vfsRoot, \"\");\n      if (!fileRef) {\n        noFiles.push(d);\n      } else {\n        const existing = filesToErrors[fileRef];\n        if (existing)\n          existing.push(d);\n        else\n          filesToErrors[fileRef] = [d];\n      }\n    });\n    const showDiagnostics = (title, diags) => {\n      return `${title}\n  ${diags.map((e) => `[${e.code}] ${e.start} - ${e.text}`).join(\"\\n  \")}`;\n    };\n    const innerDiags = [];\n    if (noFiles.length)\n      innerDiags.push(showDiagnostics(\"Ambient Errors\", noFiles));\n    Object.keys(filesToErrors).forEach((filepath) => {\n      innerDiags.push(showDiagnostics(filepath, filesToErrors[filepath]));\n    });\n    const allMessages = innerDiags.join(\"\\n\\n\");\n    const newErr = new TwoslashError(\n      `Errors were thrown in the sample, but not included in an error tag`,\n      `These errors were not marked as being expected: ${errorsFound}. ${missing}`,\n      `Compiler Errors:\n\n${allMessages}`\n    );\n    throw newErr;\n  }\n}\n\nfunction createTwoslasher(createOptions = {}) {\n  const ts = createOptions.tsModule;\n  const tsOptionDeclarations = ts.optionDeclarations;\n  const useFS = !!createOptions.fsMap;\n  const _root = createOptions.vfsRoot.replace(/\\\\/g, \"/\");\n  const vfs = createOptions.fsMap || /* @__PURE__ */ new Map();\n  const system = useFS ? createSystem(vfs) : createCacheableFSBackedSystem(vfs, _root, ts, createOptions.tsLibDirectory, createOptions.fsCache);\n  const fsRoot = useFS ? \"/\" : `${_root}/`;\n  const cache = createOptions.cache === false ? void 0 : createOptions.cache instanceof Map ? createOptions.cache : /* @__PURE__ */ new Map();\n  function getEnv(compilerOptions) {\n    if (!cache)\n      return createVirtualTypeScriptEnvironment(system, [], ts, compilerOptions, createOptions.customTransformers);\n    const key = getObjectHash(compilerOptions);\n    if (!cache?.has(key)) {\n      const env = createVirtualTypeScriptEnvironment(system, [], ts, compilerOptions, createOptions.customTransformers);\n      cache?.set(key, env);\n      return env;\n    }\n    return cache.get(key);\n  }\n  function twoslasher2(code, extension = \"ts\", options = {}) {\n    const meta = {\n      extension: typesToExtension(extension),\n      compilerOptions: {\n        ...defaultCompilerOptions,\n        baseUrl: fsRoot,\n        ...createOptions.compilerOptions,\n        ...options.compilerOptions\n      },\n      handbookOptions: {\n        ...defaultHandbookOptions,\n        ...createOptions.handbookOptions,\n        ...options.handbookOptions\n      },\n      removals: [],\n      flagNotations: [],\n      virtualFiles: [],\n      positionQueries: options.positionQueries || [],\n      positionCompletions: options.positionCompletions || [],\n      positionHighlights: options.positionHighlights || []\n    };\n    const {\n      customTags = createOptions.customTags || [],\n      shouldGetHoverInfo = createOptions.shouldGetHoverInfo || (() => true),\n      filterNode = createOptions.filterNode,\n      extraFiles = createOptions.extraFiles || {}\n    } = options;\n    const defaultFilename = `index.${meta.extension}`;\n    let nodes = [];\n    const isInRemoval = (index) => index >= code.length || index < 0 || isInRanges(index, meta.removals, false);\n    meta.flagNotations = findFlagNotations(code, customTags, tsOptionDeclarations);\n    for (const flag of meta.flagNotations) {\n      switch (flag.type) {\n        case \"unknown\":\n          continue;\n        case \"compilerOptions\":\n          meta.compilerOptions[flag.name] = flag.value;\n          break;\n        case \"handbookOptions\":\n          meta.handbookOptions[flag.name] = flag.value;\n          break;\n        case \"tag\":\n          nodes.push({\n            type: \"tag\",\n            name: flag.name,\n            start: flag.end,\n            length: 0,\n            text: flag.value\n          });\n          break;\n      }\n      meta.removals.push([flag.start, flag.end]);\n    }\n    if (!meta.handbookOptions.noErrorValidation) {\n      const unknownFlags = meta.flagNotations.filter((i) => i.type === \"unknown\");\n      if (unknownFlags.length) {\n        throw new TwoslashError(\n          `Unknown inline compiler flags`,\n          `The following flags are either valid TSConfig nor handbook options:\n${unknownFlags.map((i) => `@${i.name}`).join(\", \")}`,\n          `This is likely a typo, you can check all the compiler flags in the TSConfig reference, or check the additional Twoslash flags in the npm page for @typescript/twoslash.`\n        );\n      }\n    }\n    const env = getEnv(meta.compilerOptions);\n    const ls = env.languageService;\n    const pc = createPositionConverter(code);\n    findCutNotations(code, meta);\n    findQueryMarkers(code, meta, pc);\n    const supportedFileTyes = [\"js\", \"jsx\", \"ts\", \"tsx\"];\n    meta.virtualFiles = splitFiles(code, defaultFilename, fsRoot);\n    const identifiersMap = /* @__PURE__ */ new Map();\n    function getIdentifiersOfFile(file) {\n      if (!identifiersMap.has(file.filename)) {\n        const source = env.getSourceFile(file.filepath);\n        identifiersMap.set(file.filename, getIdentifierTextSpans(ts, source, file.offset - (file.prepend?.length || 0)));\n      }\n      return identifiersMap.get(file.filename);\n    }\n    function getFileAtPosition(pos) {\n      return meta.virtualFiles.find((i) => isInRange(pos, [i.offset, i.offset + i.content.length]));\n    }\n    function getQuickInfo(file, start, target) {\n      const quickInfo = ls.getQuickInfoAtPosition(file.filepath, getOffsetInFile(start, file));\n      if (quickInfo && quickInfo.displayParts) {\n        const text = quickInfo.displayParts.map((dp) => dp.text).join(\"\");\n        const docs = quickInfo.documentation?.map((d) => d.text).join(\"\\n\") || void 0;\n        const tags = quickInfo.tags?.map((t) => [t.name, t.text?.map((i) => i.text).join(\"\")]);\n        return {\n          type: \"hover\",\n          text,\n          docs,\n          tags,\n          start,\n          length: target.length,\n          target\n        };\n      }\n    }\n    Object.entries(extraFiles).forEach(([filename, content]) => {\n      if (!meta.virtualFiles.find((i) => i.filename === filename)) {\n        env.createFile(\n          fsRoot + filename,\n          typeof content === \"string\" ? content : (content.prepend || \"\") + (content.append || \"\")\n        );\n      }\n    });\n    for (const file of meta.virtualFiles) {\n      if (supportedFileTyes.includes(file.extension) || file.extension === \"json\" && meta.compilerOptions.resolveJsonModule) {\n        file.supportLsp = true;\n        const extra = extraFiles[file.filename];\n        if (extra && typeof extra !== \"string\") {\n          file.append = extra.append;\n          file.prepend = extra.prepend;\n        }\n        env.createFile(file.filepath, getFileContent(file));\n        getIdentifiersOfFile(file);\n      }\n    }\n    function getOffsetInFile(offset, file) {\n      return offset - file.offset + (file.prepend?.length || 0);\n    }\n    function getFileContent(file) {\n      return (file.prepend || \"\") + file.content + (file.append || \"\");\n    }\n    if (!meta.handbookOptions.showEmit) {\n      for (const file of meta.virtualFiles) {\n        if (!file.supportLsp)\n          continue;\n        if (!meta.handbookOptions.noStaticSemanticInfo) {\n          const identifiers = getIdentifiersOfFile(file);\n          for (const [start, _end, target] of identifiers) {\n            if (isInRemoval(start))\n              continue;\n            if (!shouldGetHoverInfo(target, start, file.filename))\n              continue;\n            const node = getQuickInfo(file, start, target);\n            if (node)\n              nodes.push(node);\n          }\n        }\n      }\n      for (const query of meta.positionQueries) {\n        if (isInRemoval(query)) {\n          throw new TwoslashError(\n            `Invalid quick info query`,\n            `The request on line ${pc.indexToPos(query).line + 2} for quickinfo via ^? is in a removal range.`,\n            `This is likely that the positioning is off.`\n          );\n        }\n        const file = getFileAtPosition(query);\n        const identifiers = getIdentifiersOfFile(file);\n        const id = identifiers.find((i) => isInRange(query, i));\n        let node;\n        if (id)\n          node = getQuickInfo(file, id[0], id[2]);\n        if (node) {\n          node.type = \"query\";\n          nodes.push(node);\n        } else {\n          const pos = pc.indexToPos(query);\n          throw new TwoslashError(\n            `Invalid quick info query`,\n            `The request on line ${pos.line + 2} in ${file.filename} for quickinfo via ^? returned nothing from the compiler.`,\n            `This is likely that the positioning is off.`\n          );\n        }\n      }\n      for (const highlight of meta.positionHighlights) {\n        nodes.push({\n          type: \"highlight\",\n          start: highlight[0],\n          length: highlight[1] - highlight[0],\n          text: highlight[2]\n        });\n      }\n      for (const target of meta.positionCompletions) {\n        const file = getFileAtPosition(target);\n        if (isInRemoval(target) || !file) {\n          throw new TwoslashError(\n            `Invalid completion query`,\n            `The request on line ${pc.indexToPos(target).line + 2} for completions via ^| is in a removal range.`,\n            `This is likely that the positioning is off.`\n          );\n        }\n        let prefix = code.slice(0, target).match(/[$\\w]+$/)?.[0] || \"\";\n        prefix = prefix.split(\".\").pop();\n        let completions = [];\n        if (prefix) {\n          const result = ls.getCompletionsAtPosition(file.filepath, getOffsetInFile(target, file) - 1, {\n            triggerKind: 1,\n            includeCompletionsForModuleExports: false\n          });\n          completions = result?.entries ?? [];\n          prefix = completions[0]?.replacementSpan && code.slice(\n            completions[0].replacementSpan.start,\n            target\n          ) || prefix;\n          completions = completions.filter((i) => i.name.startsWith(prefix));\n        } else {\n          prefix = code[target - 1];\n          if (prefix) {\n            const result = ls.getCompletionsAtPosition(file.filepath, getOffsetInFile(target, file), {\n              triggerKind: 2,\n              triggerCharacter: prefix,\n              includeCompletionsForModuleExports: false\n            });\n            completions = result?.entries ?? [];\n            if (completions[0]?.replacementSpan?.length) {\n              prefix = code.slice(\n                completions[0].replacementSpan.start,\n                target\n              ) || prefix;\n              const newCompletions = completions.filter((i) => i.name.startsWith(prefix));\n              if (newCompletions.length)\n                completions = newCompletions;\n            }\n          }\n        }\n        if (!completions?.length && !meta.handbookOptions.noErrorValidation) {\n          const pos = pc.indexToPos(target);\n          throw new TwoslashError(\n            `Invalid completion query`,\n            `The request on line ${pos.line} in ${file.filename} for completions via ^| returned no completions from the compiler. (prefix: ${prefix})`,\n            `This is likely that the positioning is off.`\n          );\n        }\n        nodes.push({\n          type: \"completion\",\n          start: target,\n          length: 0,\n          completions,\n          completionsPrefix: prefix\n        });\n      }\n    }\n    let errorNodes = [];\n    for (const file of meta.virtualFiles) {\n      if (!file.supportLsp)\n        continue;\n      if (meta.handbookOptions.noErrors !== true) {\n        env.updateFile(file.filepath, getFileContent(file));\n        const diagnostics = [\n          ...ls.getSemanticDiagnostics(file.filepath),\n          ...ls.getSyntacticDiagnostics(file.filepath)\n        ];\n        const ignores = Array.isArray(meta.handbookOptions.noErrors) ? meta.handbookOptions.noErrors : [];\n        for (const diagnostic of diagnostics) {\n          if (diagnostic.file?.fileName !== file.filepath)\n            continue;\n          if (ignores.includes(diagnostic.code))\n            continue;\n          const start = diagnostic.start + file.offset - (file.prepend?.length || 0);\n          if (meta.handbookOptions.noErrorsCutted && isInRemoval(start))\n            continue;\n          errorNodes.push({\n            type: \"error\",\n            start,\n            length: diagnostic.length,\n            code: diagnostic.code,\n            filename: file.filename,\n            id: `err-${diagnostic.code}-${start}-${diagnostic.length}`,\n            text: ts.flattenDiagnosticMessageText(diagnostic.messageText, \"\\n\"),\n            level: diagnosticCategoryToErrorLevel(diagnostic.category)\n          });\n        }\n      }\n    }\n    if (filterNode) {\n      nodes = nodes.filter(filterNode);\n      errorNodes = errorNodes.filter(filterNode);\n    }\n    nodes.push(...errorNodes);\n    if (!meta.handbookOptions.noErrorValidation && errorNodes.length)\n      validateCodeForErrors(errorNodes, meta.handbookOptions, fsRoot);\n    let outputCode = code;\n    if (meta.handbookOptions.showEmit) {\n      if (meta.handbookOptions.keepNotations) {\n        throw new TwoslashError(\n          `Option 'showEmit' cannot be used with 'keepNotations'`,\n          \"With `showEmit` enabled, the output will always be the emitted code\",\n          \"Remove either option to continue\"\n        );\n      }\n      if (!meta.handbookOptions.keepNotations) {\n        const { code: removedCode } = removeCodeRanges(outputCode, meta.removals);\n        const files = splitFiles(removedCode, defaultFilename, fsRoot);\n        for (const file of files)\n          env.updateFile(file.filepath, getFileContent(file));\n      }\n      const emitFilename = meta.handbookOptions.showEmittedFile ? meta.handbookOptions.showEmittedFile : meta.compilerOptions.jsx === 1 ? \"index.jsx\" : \"index.js\";\n      let emitSource = meta.virtualFiles.find((i) => removeTsExtension(i.filename) === removeTsExtension(emitFilename))?.filename;\n      if (!emitSource && !meta.compilerOptions.outFile) {\n        const allFiles = meta.virtualFiles.map((i) => i.filename).join(\", \");\n        throw new TwoslashError(\n          `Could not find source file to show the emit for`,\n          `Cannot find the corresponding **source** file: '${emitFilename}'`,\n          `Looked for: ${emitSource} in the vfs - which contains: ${allFiles}`\n        );\n      }\n      if (meta.compilerOptions.outFile)\n        emitSource = meta.virtualFiles[0].filename;\n      const output = ls.getEmitOutput(fsRoot + emitSource);\n      const outfile = output.outputFiles.find((o) => o.name === fsRoot + emitFilename || o.name === emitFilename);\n      if (!outfile) {\n        const allFiles = output.outputFiles.map((o) => o.name).join(\", \");\n        throw new TwoslashError(\n          `Cannot find the output file in the Twoslash VFS`,\n          `Looking for ${emitFilename} in the Twoslash vfs after compiling`,\n          `Looked for\" ${fsRoot + emitFilename} in the vfs - which contains ${allFiles}.`\n        );\n      }\n      outputCode = outfile.text;\n      meta.extension = typesToExtension(getExtension(outfile.name));\n      meta.removals.length = 0;\n      nodes.length = 0;\n    }\n    if (!meta.handbookOptions.keepNotations) {\n      const removed = removeCodeRanges(outputCode, meta.removals, nodes);\n      outputCode = removed.code;\n      nodes = removed.nodes;\n      meta.removals = removed.removals;\n    }\n    const indexToPos = outputCode === code ? pc.indexToPos : createPositionConverter(outputCode).indexToPos;\n    const resolvedNodes = resolveNodePositions(nodes, indexToPos);\n    for (const file of meta.virtualFiles)\n      env.createFile(file.filepath, \"\");\n    for (const file of Object.keys(extraFiles))\n      env.createFile(fsRoot + file, \"\");\n    return {\n      code: outputCode,\n      nodes: resolvedNodes,\n      meta,\n      get queries() {\n        return this.nodes.filter((i) => i.type === \"query\");\n      },\n      get completions() {\n        return this.nodes.filter((i) => i.type === \"completion\");\n      },\n      get errors() {\n        return this.nodes.filter((i) => i.type === \"error\");\n      },\n      get highlights() {\n        return this.nodes.filter((i) => i.type === \"highlight\");\n      },\n      get hovers() {\n        return this.nodes.filter((i) => i.type === \"hover\");\n      },\n      get tags() {\n        return this.nodes.filter((i) => i.type === \"tag\");\n      }\n    };\n  }\n  twoslasher2.getCacheMap = () => {\n    return cache;\n  };\n  return twoslasher2;\n}\nfunction createCacheableFSBackedSystem(vfs, root, ts, tsLibDirectory, enableFsCache = true) {\n  function withCache(fn) {\n    const cache = /* @__PURE__ */ new Map();\n    return (key) => {\n      const cached = cache.get(key);\n      if (cached !== void 0)\n        return cached;\n      const result = fn(key);\n      cache.set(key, result);\n      return result;\n    };\n  }\n  const cachedReadFile = withCache(ts.sys.readFile);\n  const cachedTs = enableFsCache ? {\n    ...ts,\n    sys: {\n      ...ts.sys,\n      directoryExists: withCache(ts.sys.directoryExists),\n      fileExists: withCache(ts.sys.fileExists),\n      ...ts.sys.realpath ? { realpath: withCache(ts.sys.realpath) } : {},\n      readFile(path, encoding) {\n        if (encoding === void 0)\n          return cachedReadFile(path);\n        return ts.sys.readFile(path, encoding);\n      }\n    }\n  } : ts;\n  return {\n    ...createFSBackedSystem(vfs, root, cachedTs, tsLibDirectory),\n    // To work with non-hoisted packages structure\n    realpath(path) {\n      if (vfs.has(path))\n        return path;\n      return cachedTs.sys.realpath?.(path) || path;\n    }\n  };\n}\nfunction twoslasher(code, lang, opts) {\n  return createTwoslasher({\n    ...opts,\n    cache: false\n  })(code, lang);\n}\nfunction diagnosticCategoryToErrorLevel(e) {\n  switch (e) {\n    case 0:\n      return \"warning\";\n    case 1:\n      return \"error\";\n    case 2:\n      return \"suggestion\";\n    case 3:\n      return \"message\";\n    default:\n      return void 0;\n  }\n}\n\nexport { TwoslashError, createTwoslasher, defaultCompilerOptions, defaultHandbookOptions, findCutNotations, findFlagNotations, findQueryMarkers, getObjectHash, twoslasher, validateCodeForErrors };\n", "import { defaultMapperFactory, resolveVueCompilerOptions, setupGlobalTypes, createVueLanguagePlugin, createLanguage, FileMap } from '@vue/language-core';\nimport { createTwoslasher as createTwoslasher$1, defaultCompilerOptions, defaultHandbookOptions, findQueryMarkers, findFlagNotations, getObjectHash } from 'twoslash';\nimport { createPositionConverter, removeCodeRanges, resolveNodePositions } from 'twoslash-protocol';\nimport ts from 'typescript';\n\nfunction createTwoslasher(createOptions = {}) {\n  const twoslasherBase = createTwoslasher$1(createOptions);\n  const cache = twoslasherBase.getCacheMap();\n  const tsOptionDeclarations = ts.optionDeclarations;\n  function getVueLanguage(compilerOptions, vueCompilerOptions) {\n    if (!cache)\n      return getLanguage();\n    const key = `vue:${getObjectHash([compilerOptions, vueCompilerOptions])}`;\n    if (!cache.has(key)) {\n      const env = getLanguage();\n      cache.set(key, env);\n      return env;\n    }\n    return cache.get(key);\n    function getLanguage() {\n      const resolvedVueOptions = resolveVueCompilerOptions(vueCompilerOptions);\n      resolvedVueOptions.__setupedGlobalTypes = setupGlobalTypes(ts.sys.getCurrentDirectory(), resolvedVueOptions, ts.sys);\n      const vueLanguagePlugin = createVueLanguagePlugin(ts, defaultCompilerOptions, resolvedVueOptions, (id) => id);\n      return createLanguage(\n        [vueLanguagePlugin],\n        new FileMap(ts.sys.useCaseSensitiveFileNames),\n        () => {\n        }\n      );\n    }\n  }\n  function twoslasher(code, extension, options = {}) {\n    if (extension !== \"vue\")\n      return twoslasherBase(code, extension, options);\n    const vueCompilerOptions = {\n      ...createOptions.vueCompilerOptions,\n      ...options.vueCompilerOptions\n    };\n    const compilerOptions = {\n      ...defaultCompilerOptions,\n      ...options.compilerOptions\n    };\n    const handbookOptions = {\n      ...defaultHandbookOptions,\n      noErrorsCutted: true,\n      ...options.handbookOptions\n    };\n    const sourceMeta = {\n      removals: [],\n      positionCompletions: [],\n      positionQueries: [],\n      positionHighlights: [],\n      flagNotations: []\n    };\n    const {\n      customTags = createOptions.customTags || []\n    } = options;\n    const pc = createPositionConverter(code);\n    findQueryMarkers(code, sourceMeta, pc);\n    const flagNotations = findFlagNotations(code, customTags, tsOptionDeclarations);\n    for (const flag of flagNotations) {\n      switch (flag.type) {\n        case \"unknown\":\n          continue;\n        case \"compilerOptions\":\n          compilerOptions[flag.name] = flag.value;\n          break;\n        case \"handbookOptions\":\n          handbookOptions[flag.name] = flag.value;\n          break;\n      }\n      sourceMeta.removals.push([flag.start, flag.end]);\n    }\n    let strippedCode = code;\n    for (const [start, end] of sourceMeta.removals) {\n      strippedCode = strippedCode.slice(0, start) + strippedCode.slice(start, end).replace(/\\S/g, \" \") + strippedCode.slice(end);\n    }\n    const lang = getVueLanguage(compilerOptions, vueCompilerOptions);\n    const sourceScript = lang.scripts.set(\"index.vue\", ts.ScriptSnapshot.fromString(strippedCode));\n    const fileCompiled = get(sourceScript.generated.embeddedCodes.values(), 2);\n    const compiled = fileCompiled.snapshot.getText(0, fileCompiled.snapshot.getLength());\n    const map = defaultMapperFactory(fileCompiled.mappings);\n    function getLastGeneratedOffset(pos) {\n      const offsets = [...map.toGeneratedLocation(pos)];\n      if (!offsets.length)\n        return void 0;\n      return offsets[offsets.length - 1]?.[0];\n    }\n    const result = twoslasherBase(compiled, \"tsx\", {\n      ...options,\n      compilerOptions: {\n        jsx: 1,\n        jsxImportSource: \"vue\",\n        noImplicitAny: false,\n        ...compilerOptions\n      },\n      handbookOptions: {\n        ...handbookOptions,\n        keepNotations: true\n      },\n      shouldGetHoverInfo(id) {\n        return !id.startsWith(\"__VLS\");\n      },\n      positionCompletions: sourceMeta.positionCompletions.map((p) => getLastGeneratedOffset(p)),\n      positionQueries: sourceMeta.positionQueries.map((p) => get(map.toGeneratedLocation(p), 0)?.[0]).filter(isNotNull),\n      positionHighlights: sourceMeta.positionHighlights.map(([start, end]) => [\n        get(map.toGeneratedLocation(start), 0)?.[0],\n        get(map.toGeneratedLocation(end), 0)?.[0]\n      ]).filter((x) => x[0] != null && x[1] != null)\n    });\n    if (createOptions.debugShowGeneratedCode)\n      return result;\n    const mappedNodes = result.nodes.map((q) => {\n      if (\"text\" in q && q.text === \"any\")\n        return void 0;\n      const startMap = get(map.toSourceLocation(q.start), 0);\n      if (!startMap)\n        return void 0;\n      const start = startMap[0];\n      let end = get(map.toSourceLocation(q.start + q.length), 0)?.[0];\n      if (end == null && startMap[1].sourceOffsets[0] === startMap[0])\n        end = startMap[1].sourceOffsets[1];\n      if (end == null || start < 0 || end < 0 || start > end)\n        return void 0;\n      return Object.assign(q, {\n        ...q,\n        target: code.slice(start, end),\n        start: startMap[0],\n        length: end - start\n      });\n    }).filter(isNotNull);\n    const mappedRemovals = [\n      ...sourceMeta.removals,\n      ...result.meta.removals.map((r) => {\n        const start = get(map.toSourceLocation(r[0]), 0)?.[0] ?? code.match(/(?<=<script[\\s\\S]*>\\s)/)?.index;\n        const end = get(map.toSourceLocation(r[1]), 0)?.[0];\n        if (start == null || end == null || start < 0 || end < 0 || start >= end)\n          return void 0;\n        return [start, end];\n      }).filter(isNotNull)\n    ];\n    if (!options.handbookOptions?.keepNotations) {\n      const removed = removeCodeRanges(code, mappedRemovals, mappedNodes);\n      result.code = removed.code;\n      result.meta.removals = removed.removals;\n      result.nodes = resolveNodePositions(removed.nodes, result.code);\n    } else {\n      result.meta.removals = mappedRemovals;\n    }\n    result.nodes = result.nodes.filter((n, idx) => {\n      const next = result.nodes[idx + 1];\n      if (!next)\n        return true;\n      if (next.type === n.type && next.start === n.start)\n        return false;\n      return true;\n    });\n    result.meta.extension = \"vue\";\n    return result;\n  }\n  twoslasher.getCacheMap = twoslasherBase.getCacheMap;\n  return twoslasher;\n}\nconst createTwoslasherVue = createTwoslasher;\nfunction isNotNull(x) {\n  return x != null;\n}\nfunction get(iterator, index) {\n  for (const item of iterator) {\n    if (index-- === 0)\n      return item;\n  }\n  return void 0;\n}\n\nexport { createTwoslasher, createTwoslasherVue };\n", "import {dequal} from 'dequal'\n\n/**\n * @type {Set<string>}\n */\nconst codesWarned = new Set()\n\nclass AssertionError extends Error {\n  name = /** @type {const} */ ('Assertion')\n  code = /** @type {const} */ ('ERR_ASSERTION')\n\n  /**\n   * Create an assertion error.\n   *\n   * @param {string} message\n   *   Message explaining error.\n   * @param {unknown} actual\n   *   Value.\n   * @param {unknown} expected\n   *   Baseline.\n   * @param {string} operator\n   *   Name of equality operation.\n   * @param {boolean} generated\n   *   Whether `message` is a custom message or not\n   * @returns\n   *   Instance.\n   */\n  // eslint-disable-next-line max-params\n  constructor(message, actual, expected, operator, generated) {\n    super(message)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n\n    /**\n     * @type {unknown}\n     */\n    this.actual = actual\n\n    /**\n     * @type {unknown}\n     */\n    this.expected = expected\n\n    /**\n     * @type {boolean}\n     */\n    this.generated = generated\n\n    /**\n     * @type {string}\n     */\n    this.operator = operator\n  }\n}\n\nclass DeprecationError extends Error {\n  name = /** @type {const} */ ('DeprecationWarning')\n\n  /**\n   * Create a deprecation message.\n   *\n   * @param {string} message\n   *   Message explaining deprecation.\n   * @param {string | undefined} code\n   *   Deprecation identifier; deprecation messages will be generated only once per code.\n   * @returns\n   *   Instance.\n   */\n  constructor(message, code) {\n    super(message)\n\n    /**\n     * @type {string | undefined}\n     */\n    this.code = code\n  }\n}\n\n/**\n * Wrap a function or class to show a deprecation message when first called.\n *\n * >  **Important**: only shows a message when the `development` condition is\n * > used, does nothing in production.\n *\n * When the resulting wrapped `fn` is called, emits a warning once to\n * `console.error` (`stderr`).\n * If a code is given, one warning message will be emitted in total per code.\n *\n * @template {Function} T\n *   Function or class kind.\n * @param {T} fn\n *   Function or class.\n * @param {string} message\n *   Message explaining deprecation.\n * @param {string | null | undefined} [code]\n *   Deprecation identifier (optional); deprecation messages will be generated\n *   only once per code.\n * @returns {T}\n *   Wrapped `fn`.\n */\nexport function deprecate(fn, message, code) {\n  let warned = false\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn)\n\n  // @ts-expect-error: its perfect, typescript\n  return deprecated\n\n  /**\n   * @this {unknown}\n   * @param  {...Array<unknown>} args\n   * @returns {unknown}\n   */\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true\n\n      if (typeof code === 'string' && codesWarned.has(code)) {\n        // Empty.\n      } else {\n        console.error(new DeprecationError(message, code || undefined))\n\n        if (typeof code === 'string') codesWarned.add(code)\n      }\n    }\n\n    return new.target\n      ? Reflect.construct(fn, args, new.target)\n      : Reflect.apply(fn, this, args)\n  }\n}\n\n/**\n * Assert deep strict equivalence.\n *\n * >  **Important**: only asserts when the `development` condition is used,\n * > does nothing in production.\n *\n * @template {unknown} T\n *   Expected kind.\n * @param {unknown} actual\n *   Value.\n * @param {T} expected\n *   Baseline.\n * @param {Error | string | null | undefined} [message]\n *   Message for assertion error (default: `'Expected values to be deeply equal'`).\n * @returns {asserts actual is T}\n *   Nothing; throws when `actual` is not deep strict equal to `expected`.\n * @throws {AssertionError}\n *   Throws when `actual` is not deep strict equal to `expected`.\n */\nexport function equal(actual, expected, message) {\n  assert(\n    dequal(actual, expected),\n    actual,\n    expected,\n    'equal',\n    'Expected values to be deeply equal',\n    message\n  )\n}\n\n/**\n * Assert if `value` is truthy.\n *\n * >  **Important**: only asserts when the `development` condition is used,\n * > does nothing in production.\n *\n * @param {unknown} value\n *   Value to assert.\n * @param {Error | string | null | undefined} [message]\n *   Message for assertion error (default: `'Expected value to be truthy'`).\n * @returns {asserts value}\n *   Nothing; throws when `value` is falsey.\n * @throws {AssertionError}\n *   Throws when `value` is falsey.\n */\nexport function ok(value, message) {\n  assert(\n    Boolean(value),\n    false,\n    true,\n    'ok',\n    'Expected value to be truthy',\n    message\n  )\n}\n\n/**\n * Assert that a code path never happens.\n *\n * >  **Important**: only asserts when the `development` condition is used,\n * > does nothing in production.\n *\n * @param {Error | string | null | undefined} [message]\n *   Message for assertion error (default: `'Unreachable'`).\n * @returns {never}\n *   Nothing; always throws.\n * @throws {AssertionError}\n *   Throws when `value` is falsey.\n */\nexport function unreachable(message) {\n  assert(false, false, true, 'ok', 'Unreachable', message)\n}\n\n/**\n * @param {boolean} bool\n *   Whether to skip this operation.\n * @param {unknown} actual\n *   Actual value.\n * @param {unknown} expected\n *   Expected value.\n * @param {string} operator\n *   Operator.\n * @param {string} defaultMessage\n *   Default message for operation.\n * @param {Error | string | null | undefined} userMessage\n *   User-provided message.\n * @returns {asserts bool}\n *   Nothing; throws when falsey.\n */\n// eslint-disable-next-line max-params\nfunction assert(bool, actual, expected, operator, defaultMessage, userMessage) {\n  if (!bool) {\n    throw userMessage instanceof Error\n      ? userMessage\n      : new AssertionError(\n          userMessage || defaultMessage,\n          actual,\n          expected,\n          operator,\n          !userMessage\n        )\n  }\n}\n", "/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n", "/// <reference lib=\"dom\" />\n\n/* global document */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string | false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const character = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  if (\n    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n    // yield `null`.\n    character.charCodeAt(character.length - 1) === 59 /* `;` */ &&\n    value !== 'semi'\n  ) {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return character === characterReference ? false : character\n}\n", "/**\n * Character codes.\n *\n * This module is compiled away!\n *\n * micromark works based on character codes.\n * This module contains constants for the ASCII block and the replacement\n * character.\n * A couple of them are handled in a special way, such as the line endings\n * (CR, LF, and CR+LF, commonly known as end-of-line: EOLs), the tab (horizontal\n * tab) and its expansion based on what column its at (virtual space),\n * and the end-of-file (eof) character.\n * As values are preprocessed before handling them, the actual characters LF,\n * CR, HT, and NUL (which is present as the replacement character), are\n * guaranteed to not exist.\n *\n * Unicode basic latin block.\n */\nexport const codes = /** @type {const} */ ({\n  carriageReturn: -5,\n  lineFeed: -4,\n  carriageReturnLineFeed: -3,\n  horizontalTab: -2,\n  virtualSpace: -1,\n  eof: null,\n  nul: 0,\n  soh: 1,\n  stx: 2,\n  etx: 3,\n  eot: 4,\n  enq: 5,\n  ack: 6,\n  bel: 7,\n  bs: 8,\n  ht: 9, // `\\t`\n  lf: 10, // `\\n`\n  vt: 11, // `\\v`\n  ff: 12, // `\\f`\n  cr: 13, // `\\r`\n  so: 14,\n  si: 15,\n  dle: 16,\n  dc1: 17,\n  dc2: 18,\n  dc3: 19,\n  dc4: 20,\n  nak: 21,\n  syn: 22,\n  etb: 23,\n  can: 24,\n  em: 25,\n  sub: 26,\n  esc: 27,\n  fs: 28,\n  gs: 29,\n  rs: 30,\n  us: 31,\n  space: 32,\n  exclamationMark: 33, // `!`\n  quotationMark: 34, // `\"`\n  numberSign: 35, // `#`\n  dollarSign: 36, // `$`\n  percentSign: 37, // `%`\n  ampersand: 38, // `&`\n  apostrophe: 39, // `'`\n  leftParenthesis: 40, // `(`\n  rightParenthesis: 41, // `)`\n  asterisk: 42, // `*`\n  plusSign: 43, // `+`\n  comma: 44, // `,`\n  dash: 45, // `-`\n  dot: 46, // `.`\n  slash: 47, // `/`\n  digit0: 48, // `0`\n  digit1: 49, // `1`\n  digit2: 50, // `2`\n  digit3: 51, // `3`\n  digit4: 52, // `4`\n  digit5: 53, // `5`\n  digit6: 54, // `6`\n  digit7: 55, // `7`\n  digit8: 56, // `8`\n  digit9: 57, // `9`\n  colon: 58, // `:`\n  semicolon: 59, // `;`\n  lessThan: 60, // `<`\n  equalsTo: 61, // `=`\n  greaterThan: 62, // `>`\n  questionMark: 63, // `?`\n  atSign: 64, // `@`\n  uppercaseA: 65, // `A`\n  uppercaseB: 66, // `B`\n  uppercaseC: 67, // `C`\n  uppercaseD: 68, // `D`\n  uppercaseE: 69, // `E`\n  uppercaseF: 70, // `F`\n  uppercaseG: 71, // `G`\n  uppercaseH: 72, // `H`\n  uppercaseI: 73, // `I`\n  uppercaseJ: 74, // `J`\n  uppercaseK: 75, // `K`\n  uppercaseL: 76, // `L`\n  uppercaseM: 77, // `M`\n  uppercaseN: 78, // `N`\n  uppercaseO: 79, // `O`\n  uppercaseP: 80, // `P`\n  uppercaseQ: 81, // `Q`\n  uppercaseR: 82, // `R`\n  uppercaseS: 83, // `S`\n  uppercaseT: 84, // `T`\n  uppercaseU: 85, // `U`\n  uppercaseV: 86, // `V`\n  uppercaseW: 87, // `W`\n  uppercaseX: 88, // `X`\n  uppercaseY: 89, // `Y`\n  uppercaseZ: 90, // `Z`\n  leftSquareBracket: 91, // `[`\n  backslash: 92, // `\\`\n  rightSquareBracket: 93, // `]`\n  caret: 94, // `^`\n  underscore: 95, // `_`\n  graveAccent: 96, // `` ` ``\n  lowercaseA: 97, // `a`\n  lowercaseB: 98, // `b`\n  lowercaseC: 99, // `c`\n  lowercaseD: 100, // `d`\n  lowercaseE: 101, // `e`\n  lowercaseF: 102, // `f`\n  lowercaseG: 103, // `g`\n  lowercaseH: 104, // `h`\n  lowercaseI: 105, // `i`\n  lowercaseJ: 106, // `j`\n  lowercaseK: 107, // `k`\n  lowercaseL: 108, // `l`\n  lowercaseM: 109, // `m`\n  lowercaseN: 110, // `n`\n  lowercaseO: 111, // `o`\n  lowercaseP: 112, // `p`\n  lowercaseQ: 113, // `q`\n  lowercaseR: 114, // `r`\n  lowercaseS: 115, // `s`\n  lowercaseT: 116, // `t`\n  lowercaseU: 117, // `u`\n  lowercaseV: 118, // `v`\n  lowercaseW: 119, // `w`\n  lowercaseX: 120, // `x`\n  lowercaseY: 121, // `y`\n  lowercaseZ: 122, // `z`\n  leftCurlyBrace: 123, // `{`\n  verticalBar: 124, // `|`\n  rightCurlyBrace: 125, // `}`\n  tilde: 126, // `~`\n  del: 127,\n  // Unicode Specials block.\n  byteOrderMarker: 65_279,\n  // Unicode Specials block.\n  replacementCharacter: 65_533 // ``\n})\n", "/**\n * This module is compiled away!\n *\n * Parsing markdown comes with a couple of constants, such as minimum or maximum\n * sizes of certain sequences.\n * Additionally, there are a couple symbols used inside micromark.\n * These are all defined here, but compiled away by scripts.\n */\nexport const constants = /** @type {const} */ ({\n  attentionSideAfter: 2, // Symbol to mark an attention sequence as after content: `a*`\n  attentionSideBefore: 1, // Symbol to mark an attention sequence as before content: `*a`\n  atxHeadingOpeningFenceSizeMax: 6, // 6 number signs is fine, 7 isnt.\n  autolinkDomainSizeMax: 63, // 63 characters is fine, 64 is too many.\n  autolinkSchemeSizeMax: 32, // 32 characters is fine, 33 is too many.\n  cdataOpeningString: 'CDATA[', // And preceded by `<![`.\n  characterGroupPunctuation: 2, // Symbol used to indicate a character is punctuation\n  characterGroupWhitespace: 1, // Symbol used to indicate a character is whitespace\n  characterReferenceDecimalSizeMax: 7, // `&#9999999;`.\n  characterReferenceHexadecimalSizeMax: 6, // `&#xff9999;`.\n  characterReferenceNamedSizeMax: 31, // `&CounterClockwiseContourIntegral;`.\n  codeFencedSequenceSizeMin: 3, // At least 3 ticks or tildes are needed.\n  contentTypeContent: 'content',\n  contentTypeDocument: 'document',\n  contentTypeFlow: 'flow',\n  contentTypeString: 'string',\n  contentTypeText: 'text',\n  hardBreakPrefixSizeMin: 2, // At least 2 trailing spaces are needed.\n  htmlBasic: 6, // Symbol for `<div`\n  htmlCdata: 5, // Symbol for `<![CDATA[]]>`\n  htmlComment: 2, // Symbol for `<!---->`\n  htmlComplete: 7, // Symbol for `<x>`\n  htmlDeclaration: 4, // Symbol for `<!doctype>`\n  htmlInstruction: 3, // Symbol for `<?php?>`\n  htmlRawSizeMax: 8, // Length of `textarea`.\n  htmlRaw: 1, // Symbol for `<script>`\n  linkResourceDestinationBalanceMax: 32, // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>\n  linkReferenceSizeMax: 999, // See: <https://spec.commonmark.org/0.30/#link-label>\n  listItemValueSizeMax: 10, // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>\n  numericBaseDecimal: 10,\n  numericBaseHexadecimal: 0x10,\n  tabSize: 4, // Tabs have a hard-coded size of 4, per CommonMark.\n  thematicBreakMarkerCountMin: 3, // At least 3 asterisks, dashes, or underscores are needed.\n  v8MaxSafeChunkSize: 10_000 // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.\n})\n", "/**\n * This module is compiled away!\n *\n * Here is the list of all types of tokens exposed by micromark, with a short\n * explanation of what they include and where they are found.\n * In picking names, generally, the rule is to be as explicit as possible\n * instead of reusing names.\n * For example, there is a `definitionDestination` and a `resourceDestination`,\n * instead of one shared name.\n */\n\n// Note: when changing the next record, you must also change `TokenTypeMap`\n// in `micromark-util-types/index.d.ts`.\nexport const types = /** @type {const} */ ({\n  // Generic type for data, such as in a title, a destination, etc.\n  data: 'data',\n\n  // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).\n  // Such as, between a fenced code fence and an info string.\n  whitespace: 'whitespace',\n\n  // Generic type for line endings (line feed, carriage return, carriage return +\n  // line feed).\n  lineEnding: 'lineEnding',\n\n  // A line ending, but ending a blank line.\n  lineEndingBlank: 'lineEndingBlank',\n\n  // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a\n  // line.\n  linePrefix: 'linePrefix',\n\n  // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a\n  // line.\n  lineSuffix: 'lineSuffix',\n\n  // Whole ATX heading:\n  //\n  // ```markdown\n  // #\n  // ## Alpha\n  // ### Bravo ###\n  // ```\n  //\n  // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.\n  atxHeading: 'atxHeading',\n\n  // Sequence of number signs in an ATX heading (`###`).\n  atxHeadingSequence: 'atxHeadingSequence',\n\n  // Content in an ATX heading (`alpha`).\n  // Includes text.\n  atxHeadingText: 'atxHeadingText',\n\n  // Whole autolink (`<https://example.com>` or `<admin@example.com>`)\n  // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.\n  autolink: 'autolink',\n\n  // Email autolink w/o markers (`admin@example.com`)\n  autolinkEmail: 'autolinkEmail',\n\n  // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).\n  autolinkMarker: 'autolinkMarker',\n\n  // Protocol autolink w/o markers (`https://example.com`)\n  autolinkProtocol: 'autolinkProtocol',\n\n  // A whole character escape (`\\-`).\n  // Includes `escapeMarker` and `characterEscapeValue`.\n  characterEscape: 'characterEscape',\n\n  // The escaped character (`-`).\n  characterEscapeValue: 'characterEscapeValue',\n\n  // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).\n  // Includes `characterReferenceMarker`, an optional\n  // `characterReferenceMarkerNumeric`, in which case an optional\n  // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.\n  characterReference: 'characterReference',\n\n  // The start or end marker (`&` or `;`).\n  characterReferenceMarker: 'characterReferenceMarker',\n\n  // Mark reference as numeric (`#`).\n  characterReferenceMarkerNumeric: 'characterReferenceMarkerNumeric',\n\n  // Mark reference as numeric (`x` or `X`).\n  characterReferenceMarkerHexadecimal: 'characterReferenceMarkerHexadecimal',\n\n  // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).\n  characterReferenceValue: 'characterReferenceValue',\n\n  // Whole fenced code:\n  //\n  // ````markdown\n  // ```js\n  // alert(1)\n  // ```\n  // ````\n  codeFenced: 'codeFenced',\n\n  // A fenced code fence, including whitespace, sequence, info, and meta\n  // (` ```js `).\n  codeFencedFence: 'codeFencedFence',\n\n  // Sequence of grave accent or tilde characters (` ``` `) in a fence.\n  codeFencedFenceSequence: 'codeFencedFenceSequence',\n\n  // Info word (`js`) in a fence.\n  // Includes string.\n  codeFencedFenceInfo: 'codeFencedFenceInfo',\n\n  // Meta words (`highlight=\"1\"`) in a fence.\n  // Includes string.\n  codeFencedFenceMeta: 'codeFencedFenceMeta',\n\n  // A line of code.\n  codeFlowValue: 'codeFlowValue',\n\n  // Whole indented code:\n  //\n  // ```markdown\n  //     alert(1)\n  // ```\n  //\n  // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.\n  codeIndented: 'codeIndented',\n\n  // A text code (``` `alpha` ```).\n  // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include\n  // `codeTextPadding`.\n  codeText: 'codeText',\n\n  codeTextData: 'codeTextData',\n\n  // A space or line ending right after or before a tick.\n  codeTextPadding: 'codeTextPadding',\n\n  // A text code fence (` `` `).\n  codeTextSequence: 'codeTextSequence',\n\n  // Whole content:\n  //\n  // ```markdown\n  // [a]: b\n  // c\n  // =\n  // d\n  // ```\n  //\n  // Includes `paragraph` and `definition`.\n  content: 'content',\n  // Whole definition:\n  //\n  // ```markdown\n  // [micromark]: https://github.com/micromark/micromark\n  // ```\n  //\n  // Includes `definitionLabel`, `definitionMarker`, `whitespace`,\n  // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.\n  definition: 'definition',\n\n  // Destination of a definition (`https://github.com/micromark/micromark` or\n  // `<https://github.com/micromark/micromark>`).\n  // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.\n  definitionDestination: 'definitionDestination',\n\n  // Enclosed destination of a definition\n  // (`<https://github.com/micromark/micromark>`).\n  // Includes `definitionDestinationLiteralMarker` and optionally\n  // `definitionDestinationString`.\n  definitionDestinationLiteral: 'definitionDestinationLiteral',\n\n  // Markers of an enclosed definition destination (`<` or `>`).\n  definitionDestinationLiteralMarker: 'definitionDestinationLiteralMarker',\n\n  // Unenclosed destination of a definition\n  // (`https://github.com/micromark/micromark`).\n  // Includes `definitionDestinationString`.\n  definitionDestinationRaw: 'definitionDestinationRaw',\n\n  // Text in an destination (`https://github.com/micromark/micromark`).\n  // Includes string.\n  definitionDestinationString: 'definitionDestinationString',\n\n  // Label of a definition (`[micromark]`).\n  // Includes `definitionLabelMarker` and `definitionLabelString`.\n  definitionLabel: 'definitionLabel',\n\n  // Markers of a definition label (`[` or `]`).\n  definitionLabelMarker: 'definitionLabelMarker',\n\n  // Value of a definition label (`micromark`).\n  // Includes string.\n  definitionLabelString: 'definitionLabelString',\n\n  // Marker between a label and a destination (`:`).\n  definitionMarker: 'definitionMarker',\n\n  // Title of a definition (`\"x\"`, `'y'`, or `(z)`).\n  // Includes `definitionTitleMarker` and optionally `definitionTitleString`.\n  definitionTitle: 'definitionTitle',\n\n  // Marker around a title of a definition (`\"`, `'`, `(`, or `)`).\n  definitionTitleMarker: 'definitionTitleMarker',\n\n  // Data without markers in a title (`z`).\n  // Includes string.\n  definitionTitleString: 'definitionTitleString',\n\n  // Emphasis (`*alpha*`).\n  // Includes `emphasisSequence` and `emphasisText`.\n  emphasis: 'emphasis',\n\n  // Sequence of emphasis markers (`*` or `_`).\n  emphasisSequence: 'emphasisSequence',\n\n  // Emphasis text (`alpha`).\n  // Includes text.\n  emphasisText: 'emphasisText',\n\n  // The character escape marker (`\\`).\n  escapeMarker: 'escapeMarker',\n\n  // A hard break created with a backslash (`\\\\n`).\n  // Note: does not include the line ending.\n  hardBreakEscape: 'hardBreakEscape',\n\n  // A hard break created with trailing spaces (`  \\n`).\n  // Does not include the line ending.\n  hardBreakTrailing: 'hardBreakTrailing',\n\n  // Flow HTML:\n  //\n  // ```markdown\n  // <div\n  // ```\n  //\n  // Inlcudes `lineEnding`, `htmlFlowData`.\n  htmlFlow: 'htmlFlow',\n\n  htmlFlowData: 'htmlFlowData',\n\n  // HTML in text (the tag in `a <i> b`).\n  // Includes `lineEnding`, `htmlTextData`.\n  htmlText: 'htmlText',\n\n  htmlTextData: 'htmlTextData',\n\n  // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or\n  // `![alpha]`).\n  // Includes `label` and an optional `resource` or `reference`.\n  image: 'image',\n\n  // Whole link label (`[*alpha*]`).\n  // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.\n  label: 'label',\n\n  // Text in an label (`*alpha*`).\n  // Includes text.\n  labelText: 'labelText',\n\n  // Start a link label (`[`).\n  // Includes a `labelMarker`.\n  labelLink: 'labelLink',\n\n  // Start an image label (`![`).\n  // Includes `labelImageMarker` and `labelMarker`.\n  labelImage: 'labelImage',\n\n  // Marker of a label (`[` or `]`).\n  labelMarker: 'labelMarker',\n\n  // Marker to start an image (`!`).\n  labelImageMarker: 'labelImageMarker',\n\n  // End a label (`]`).\n  // Includes `labelMarker`.\n  labelEnd: 'labelEnd',\n\n  // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).\n  // Includes `label` and an optional `resource` or `reference`.\n  link: 'link',\n\n  // Whole paragraph:\n  //\n  // ```markdown\n  // alpha\n  // bravo.\n  // ```\n  //\n  // Includes text.\n  paragraph: 'paragraph',\n\n  // A reference (`[alpha]` or `[]`).\n  // Includes `referenceMarker` and an optional `referenceString`.\n  reference: 'reference',\n\n  // A reference marker (`[` or `]`).\n  referenceMarker: 'referenceMarker',\n\n  // Reference text (`alpha`).\n  // Includes string.\n  referenceString: 'referenceString',\n\n  // A resource (`(https://example.com \"alpha\")`).\n  // Includes `resourceMarker`, an optional `resourceDestination` with an optional\n  // `whitespace` and `resourceTitle`.\n  resource: 'resource',\n\n  // A resource destination (`https://example.com`).\n  // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.\n  resourceDestination: 'resourceDestination',\n\n  // A literal resource destination (`<https://example.com>`).\n  // Includes `resourceDestinationLiteralMarker` and optionally\n  // `resourceDestinationString`.\n  resourceDestinationLiteral: 'resourceDestinationLiteral',\n\n  // A resource destination marker (`<` or `>`).\n  resourceDestinationLiteralMarker: 'resourceDestinationLiteralMarker',\n\n  // A raw resource destination (`https://example.com`).\n  // Includes `resourceDestinationString`.\n  resourceDestinationRaw: 'resourceDestinationRaw',\n\n  // Resource destination text (`https://example.com`).\n  // Includes string.\n  resourceDestinationString: 'resourceDestinationString',\n\n  // A resource marker (`(` or `)`).\n  resourceMarker: 'resourceMarker',\n\n  // A resource title (`\"alpha\"`, `'alpha'`, or `(alpha)`).\n  // Includes `resourceTitleMarker` and optionally `resourceTitleString`.\n  resourceTitle: 'resourceTitle',\n\n  // A resource title marker (`\"`, `'`, `(`, or `)`).\n  resourceTitleMarker: 'resourceTitleMarker',\n\n  // Resource destination title (`alpha`).\n  // Includes string.\n  resourceTitleString: 'resourceTitleString',\n\n  // Whole setext heading:\n  //\n  // ```markdown\n  // alpha\n  // bravo\n  // =====\n  // ```\n  //\n  // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and\n  // `setextHeadingLine`.\n  setextHeading: 'setextHeading',\n\n  // Content in a setext heading (`alpha\\nbravo`).\n  // Includes text.\n  setextHeadingText: 'setextHeadingText',\n\n  // Underline in a setext heading, including whitespace suffix (`==`).\n  // Includes `setextHeadingLineSequence`.\n  setextHeadingLine: 'setextHeadingLine',\n\n  // Sequence of equals or dash characters in underline in a setext heading (`-`).\n  setextHeadingLineSequence: 'setextHeadingLineSequence',\n\n  // Strong (`**alpha**`).\n  // Includes `strongSequence` and `strongText`.\n  strong: 'strong',\n\n  // Sequence of strong markers (`**` or `__`).\n  strongSequence: 'strongSequence',\n\n  // Strong text (`alpha`).\n  // Includes text.\n  strongText: 'strongText',\n\n  // Whole thematic break:\n  //\n  // ```markdown\n  // * * *\n  // ```\n  //\n  // Includes `thematicBreakSequence` and `whitespace`.\n  thematicBreak: 'thematicBreak',\n\n  // A sequence of one or more thematic break markers (`***`).\n  thematicBreakSequence: 'thematicBreakSequence',\n\n  // Whole block quote:\n  //\n  // ```markdown\n  // > a\n  // >\n  // > b\n  // ```\n  //\n  // Includes `blockQuotePrefix` and flow.\n  blockQuote: 'blockQuote',\n  // The `>` or `> ` of a block quote.\n  blockQuotePrefix: 'blockQuotePrefix',\n  // The `>` of a block quote prefix.\n  blockQuoteMarker: 'blockQuoteMarker',\n  // The optional ` ` of a block quote prefix.\n  blockQuotePrefixWhitespace: 'blockQuotePrefixWhitespace',\n\n  // Whole ordered list:\n  //\n  // ```markdown\n  // 1. a\n  //    b\n  // ```\n  //\n  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further\n  // lines.\n  listOrdered: 'listOrdered',\n\n  // Whole unordered list:\n  //\n  // ```markdown\n  // - a\n  //   b\n  // ```\n  //\n  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further\n  // lines.\n  listUnordered: 'listUnordered',\n\n  // The indent of further list item lines.\n  listItemIndent: 'listItemIndent',\n\n  // A marker, as in, `*`, `+`, `-`, `.`, or `)`.\n  listItemMarker: 'listItemMarker',\n\n  // The thing that starts a list item, such as `1. `.\n  // Includes `listItemValue` if ordered, `listItemMarker`, and\n  // `listItemPrefixWhitespace` (unless followed by a line ending).\n  listItemPrefix: 'listItemPrefix',\n\n  // The whitespace after a marker.\n  listItemPrefixWhitespace: 'listItemPrefixWhitespace',\n\n  // The numerical value of an ordered item.\n  listItemValue: 'listItemValue',\n\n  // Internal types used for subtokenizers, compiled away\n  chunkDocument: 'chunkDocument',\n  chunkContent: 'chunkContent',\n  chunkFlow: 'chunkFlow',\n  chunkText: 'chunkText',\n  chunkString: 'chunkString'\n})\n", "/**\n * This module is compiled away!\n *\n * While micromark works based on character codes, this module includes the\n * string versions of em.\n * The C0 block, except for LF, CR, HT, and w/ the replacement character added,\n * are available here.\n */\nexport const values = /** @type {const} */ ({\n  ht: '\\t',\n  lf: '\\n',\n  cr: '\\r',\n  space: ' ',\n  exclamationMark: '!',\n  quotationMark: '\"',\n  numberSign: '#',\n  dollarSign: '$',\n  percentSign: '%',\n  ampersand: '&',\n  apostrophe: \"'\",\n  leftParenthesis: '(',\n  rightParenthesis: ')',\n  asterisk: '*',\n  plusSign: '+',\n  comma: ',',\n  dash: '-',\n  dot: '.',\n  slash: '/',\n  digit0: '0',\n  digit1: '1',\n  digit2: '2',\n  digit3: '3',\n  digit4: '4',\n  digit5: '5',\n  digit6: '6',\n  digit7: '7',\n  digit8: '8',\n  digit9: '9',\n  colon: ':',\n  semicolon: ';',\n  lessThan: '<',\n  equalsTo: '=',\n  greaterThan: '>',\n  questionMark: '?',\n  atSign: '@',\n  uppercaseA: 'A',\n  uppercaseB: 'B',\n  uppercaseC: 'C',\n  uppercaseD: 'D',\n  uppercaseE: 'E',\n  uppercaseF: 'F',\n  uppercaseG: 'G',\n  uppercaseH: 'H',\n  uppercaseI: 'I',\n  uppercaseJ: 'J',\n  uppercaseK: 'K',\n  uppercaseL: 'L',\n  uppercaseM: 'M',\n  uppercaseN: 'N',\n  uppercaseO: 'O',\n  uppercaseP: 'P',\n  uppercaseQ: 'Q',\n  uppercaseR: 'R',\n  uppercaseS: 'S',\n  uppercaseT: 'T',\n  uppercaseU: 'U',\n  uppercaseV: 'V',\n  uppercaseW: 'W',\n  uppercaseX: 'X',\n  uppercaseY: 'Y',\n  uppercaseZ: 'Z',\n  leftSquareBracket: '[',\n  backslash: '\\\\',\n  rightSquareBracket: ']',\n  caret: '^',\n  underscore: '_',\n  graveAccent: '`',\n  lowercaseA: 'a',\n  lowercaseB: 'b',\n  lowercaseC: 'c',\n  lowercaseD: 'd',\n  lowercaseE: 'e',\n  lowercaseF: 'f',\n  lowercaseG: 'g',\n  lowercaseH: 'h',\n  lowercaseI: 'i',\n  lowercaseJ: 'j',\n  lowercaseK: 'k',\n  lowercaseL: 'l',\n  lowercaseM: 'm',\n  lowercaseN: 'n',\n  lowercaseO: 'o',\n  lowercaseP: 'p',\n  lowercaseQ: 'q',\n  lowercaseR: 'r',\n  lowercaseS: 's',\n  lowercaseT: 't',\n  lowercaseU: 'u',\n  lowercaseV: 'v',\n  lowercaseW: 'w',\n  lowercaseX: 'x',\n  lowercaseY: 'y',\n  lowercaseZ: 'z',\n  leftCurlyBrace: '{',\n  verticalBar: '|',\n  rightCurlyBrace: '}',\n  tilde: '~',\n  replacementCharacter: ''\n})\n", "import {constants} from 'micromark-util-symbol'\n\n/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {undefined}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if theres only a couple (10k) items.\n  if (items.length < constants.v8MaxSafeChunkSize) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, its fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(\n        chunkStart,\n        chunkStart + constants.v8MaxSafeChunkSize\n      )\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, its fine.\n      list.splice(...parameters)\n\n      chunkStart += constants.v8MaxSafeChunkSize\n      start += constants.v8MaxSafeChunkSize\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n\n  return items\n}\n", "/**\n * @import {\n *   Extension,\n *   Handles,\n *   HtmlExtension,\n *   NormalizedExtension\n * } from 'micromark-util-types'\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine multiple syntax extensions into one.\n *\n * @param {ReadonlyArray<Extension>} extensions\n *   List of syntax extensions.\n * @returns {NormalizedExtension}\n *   A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all\n *   Extension to merge into.\n * @param {Extension} extension\n *   Extension to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {keyof Extension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    /** @type {Record<string, unknown>} */\n    const left = maybe || (all[hook] = {})\n    /** @type {Record<string, unknown> | undefined} */\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    if (right) {\n      for (code in right) {\n        if (!hasOwnProperty.call(left, code)) left[code] = []\n        const value = right[code]\n        constructs(\n          // @ts-expect-error Looks like a list.\n          left[code],\n          Array.isArray(value) ? value : value ? [value] : []\n        )\n      }\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {Array<unknown>} existing\n *   List of constructs to merge into.\n * @param {Array<unknown>} list\n *   List of constructs to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {Array<unknown>} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine multiple HTML extensions into one.\n *\n * @param {ReadonlyArray<HtmlExtension>} htmlExtensions\n *   List of HTML extensions.\n * @returns {HtmlExtension}\n *   Single combined HTML extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all\n *   Extension to merge into.\n * @param {HtmlExtension} extension\n *   Extension to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction htmlExtension(all, extension) {\n  /** @type {keyof HtmlExtension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {keyof Handles} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        // @ts-expect-error assume document vs regular handler are managed correctly.\n        left[type] = right[type]\n      }\n    }\n  }\n}\n", "import {codes, values} from 'micromark-util-symbol'\n\n/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCodePoint(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n\n  if (\n    // C0 except for HT, LF, FF, CR, space.\n    code < codes.ht ||\n    code === codes.vt ||\n    (code > codes.cr && code < codes.space) ||\n    // Control character (DEL) of C0, and C1 controls.\n    (code > codes.tilde && code < 160) ||\n    // Lone high surrogates and low surrogates.\n    (code > 55_295 && code < 57_344) ||\n    // Noncharacters.\n    (code > 64_975 && code < 65_008) ||\n    /* eslint-disable no-bitwise */\n    (code & 65_535) === 65_535 ||\n    (code & 65_535) === 65_534 ||\n    /* eslint-enable no-bitwise */\n    // Out of range\n    code > 1_114_111\n  ) {\n    return values.replacementCharacter\n  }\n\n  return String.fromCodePoint(code)\n}\n", "import {values} from 'micromark-util-symbol'\n\n/**\n * Normalize an identifier (as found in references, definitions).\n *\n * Collapses markdown whitespace, trim, and then lower- and uppercase.\n *\n * Some characters are considered uppercase, such as U+03F4 (``), but if their\n * lowercase counterpart (U+03B8 (``)) is uppercased will result in a different\n * uppercase character (U+0398 (``)).\n * So, to get a canonical form, we perform both lower- and uppercase.\n *\n * Using uppercase last makes sure keys will never interact with default\n * prototypal values (such as `constructor`): nothing in the prototype of\n * `Object` is uppercase.\n *\n * @param {string} value\n *   Identifier to normalize.\n * @returns {string}\n *   Normalized identifier.\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value\n      // Collapse markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, values.space)\n      // Trim.\n      .replace(/^ | $/g, '')\n      // Some characters are considered uppercase, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n", "/**\n * @import {Code} from 'micromark-util-types'\n */\n\nimport {codes} from 'micromark-util-symbol'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < codes.space || code === codes.del)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < codes.horizontalTab\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < codes.nul || code === codes.space)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return (\n    code === codes.horizontalTab ||\n    code === codes.virtualSpace ||\n    code === codes.space\n  )\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n *   Expression.\n * @returns {(code: Code) => boolean}\n *   Check.\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code))\n  }\n}\n", "import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\nimport {codes, values} from 'micromark-util-symbol'\n\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri`).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * A regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string | null | undefined} url\n *   URI to sanitize.\n * @param {RegExp | null | undefined} [protocol]\n *   Allowed protocols.\n * @returns {string}\n *   Sanitized URI.\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n\n  if (!protocol) {\n    return value\n  }\n\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, its relative.\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, its not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) ||\n    // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n\n/**\n * Normalize a URL.\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n *   URI to normalize.\n * @returns {string}\n *   Normalized URI.\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n    let replace = ''\n\n    // A correct percent encoded value.\n    if (\n      code === codes.percentSign &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    }\n    // Astral.\n    else if (code > 55_295 && code < 57_344) {\n      const next = value.charCodeAt(index + 1)\n\n      // A correct surrogate pair.\n      if (code < 56_320 && next > 56_319 && next < 57_344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      }\n      // Lone surrogate.\n      else {\n        replace = values.replacementCharacter\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n\n  return result.join('') + value.slice(start)\n}\n", "/**\n * While micromark is a lexer/tokenizer, the common case of going from markdown\n * to html is currently built in as this module, even though the parts can be\n * used separately to build ASTs, CSTs, or many other output formats.\n *\n * Having an HTML compiler built in is useful because it allows us to check for\n * compliancy to CommonMark, the de facto norm of markdown, specified in roughly\n * 600 input/output cases.\n *\n * This module has an interface that accepts lists of events instead of the\n * whole at once, however, because markdown cant be truly streaming, we buffer\n * events before processing and outputting the final result.\n */\n\n/**\n * @import {\n *   CompileContext,\n *   CompileData,\n *   CompileOptions,\n *   Compile,\n *   Definition,\n *   Event,\n *   Handle,\n *   HtmlExtension,\n *   LineEnding,\n *   NormalizedHtmlExtension,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @typedef Media\n * @property {boolean | undefined} [image]\n * @property {string | undefined} [labelId]\n * @property {string | undefined} [label]\n * @property {string | undefined} [referenceId]\n * @property {string | undefined} [destination]\n * @property {string | undefined} [title]\n */\n\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {ok as assert} from 'devlop'\nimport {push} from 'micromark-util-chunked'\nimport {combineHtmlExtensions} from 'micromark-util-combine-extensions'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {encode as _encode} from 'micromark-util-encode'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * These two are allowlists of safe protocols for full URLs in respectively the\n * `href` (on `<a>`) and `src` (on `<img>`) attributes.\n * They are based on what is allowed on GitHub,\n * <https://github.com/syntax-tree/hast-util-sanitize/blob/9275b21/lib/github.json#L31>\n */\nconst protocolHref = /^(https?|ircs?|mailto|xmpp)$/i\nconst protocolSource = /^https?$/i\n\n/**\n * @param {CompileOptions | null | undefined} [options]\n * @returns {Compile}\n */\nexport function compile(options) {\n  const settings = options || {}\n\n  /**\n   * Tags is needed because according to markdown, links and emphasis and\n   * whatnot can exist in images, however, as HTML doesnt allow content in\n   * images, the tags are ignored in the `alt` attribute, but the content\n   * remains.\n   *\n   * @type {boolean | undefined}\n   */\n  let tags = true\n\n  /**\n   * An object to track identifiers to media (URLs and titles) defined with\n   * definitions.\n   *\n   * @type {Record<string, Definition>}\n   */\n  const definitions = {}\n\n  /**\n   * A lot of the handlers need to capture some of the output data, modify it\n   * somehow, and then deal with it.\n   * We do that by tracking a stack of buffers, that can be opened (with\n   * `buffer`) and closed (with `resume`) to access them.\n   *\n   * @type {Array<Array<string>>}\n   */\n  const buffers = [[]]\n\n  /**\n   * As we can have links in images and the other way around, where the deepest\n   * ones are closed first, we need to track which one were in.\n   *\n   * @type {Array<Media>}\n   */\n  const mediaStack = []\n\n  /**\n   * Same as `mediaStack` for tightness, which is specific to lists.\n   * We need to track if were currently in a tight or loose container.\n   *\n   * @type {Array<boolean>}\n   */\n  const tightStack = []\n\n  /** @type {HtmlExtension} */\n  const defaultHandlers = {\n    enter: {\n      blockQuote: onenterblockquote,\n      codeFenced: onentercodefenced,\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: onentercodeindented,\n      codeText: onentercodetext,\n      content: onentercontent,\n      definition: onenterdefinition,\n      definitionDestinationString: onenterdefinitiondestinationstring,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: onenteremphasis,\n      htmlFlow: onenterhtmlflow,\n      htmlText: onenterhtml,\n      image: onenterimage,\n      label: buffer,\n      link: onenterlink,\n      listItemMarker: onenterlistitemmarker,\n      listItemValue: onenterlistitemvalue,\n      listOrdered: onenterlistordered,\n      listUnordered: onenterlistunordered,\n      paragraph: onenterparagraph,\n      reference: buffer,\n      resource: onenterresource,\n      resourceDestinationString: onenterresourcedestinationstring,\n      resourceTitleString: buffer,\n      setextHeading: onentersetextheading,\n      strong: onenterstrong\n    },\n    exit: {\n      atxHeading: onexitatxheading,\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: onexitblockquote,\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: onexitflowcode,\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onresumedrop,\n      codeFlowValue: onexitcodeflowvalue,\n      codeIndented: onexitflowcode,\n      codeText: onexitcodetext,\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: onexitdefinition,\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: onexitemphasis,\n      hardBreakEscape: onexithardbreak,\n      hardBreakTrailing: onexithardbreak,\n      htmlFlow: onexithtml,\n      htmlFlowData: onexitdata,\n      htmlText: onexithtml,\n      htmlTextData: onexitdata,\n      image: onexitmedia,\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: onexitmedia,\n      listOrdered: onexitlistordered,\n      listUnordered: onexitlistunordered,\n      paragraph: onexitparagraph,\n      reference: onresumedrop,\n      referenceString: onexitreferencestring,\n      resource: onresumedrop,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      setextHeading: onexitsetextheading,\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: onexitstrong,\n      thematicBreak: onexitthematicbreak\n    }\n  }\n\n  /**\n   * Combine the HTML extensions with the default handlers.\n   * An HTML extension is an object whose fields are either `enter` or `exit`\n   * (reflecting whether a token is entered or exited).\n   * The values at such objects are names of tokens mapping to handlers.\n   * Handlers are called, respectively when a token is opener or closed, with\n   * that token, and a context as `this`.\n   */\n  const handlers = /** @type {NormalizedHtmlExtension} */ (\n    combineHtmlExtensions([defaultHandlers, ...(settings.htmlExtensions || [])])\n  )\n\n  /**\n   * Handlers do often need to keep track of some state.\n   * That state is provided here as a key-value store (an object).\n   *\n   * @type {CompileData}\n   */\n  const data = {\n    definitions,\n    tightStack\n  }\n\n  /**\n   * The context for handlers references a couple of useful functions.\n   * In handlers from extensions, those can be accessed at `this`.\n   * For the handlers here, they can be accessed directly.\n   *\n   * @type {Omit<CompileContext, 'sliceSerialize'>}\n   */\n  const context = {\n    buffer,\n    encode,\n    getData,\n    lineEndingIfNeeded,\n    options: settings,\n    raw,\n    resume,\n    setData,\n    tag\n  }\n\n  /**\n   * Generally, micromark copies line endings (`'\\r'`, `'\\n'`, `'\\r\\n'`) in the\n   * markdown document over to the compiled HTML.\n   * In some cases, such as `> a`, CommonMark requires that extra line endings\n   * are added: `<blockquote>\\n<p>a</p>\\n</blockquote>`.\n   * This variable hold the default line ending when given (or `undefined`),\n   * and in the latter case will be updated to the first found line ending if\n   * there is one.\n   */\n  let lineEndingStyle = settings.defaultLineEnding\n\n  // Return the function that handles a slice of events.\n  return compile\n\n  /**\n   * Deal w/ a slice of events.\n   * Return either the empty string if theres nothing of note to return, or the\n   * result when done.\n   *\n   * @param {ReadonlyArray<Event>} events\n   * @returns {string}\n   */\n  function compile(events) {\n    let index = -1\n    let start = 0\n    /** @type {Array<number>} */\n    const listStack = []\n    // As definitions can come after references, we need to figure out the media\n    // (urls and titles) defined by them before handling the references.\n    // So, we do sort of what HTML does: put metadata at the start (in head), and\n    // then put content after (`body`).\n    /** @type {Array<Event>} */\n    let head = []\n    /** @type {Array<Event>} */\n    let body = []\n\n    while (++index < events.length) {\n      // Figure out the line ending style used in the document.\n      if (\n        !lineEndingStyle &&\n        (events[index][1].type === types.lineEnding ||\n          events[index][1].type === types.lineEndingBlank)\n      ) {\n        lineEndingStyle = /** @type {LineEnding} */ (\n          events[index][2].sliceSerialize(events[index][1])\n        )\n      }\n\n      // Preprocess lists to infer whether the list is loose or not.\n      if (\n        events[index][1].type === types.listOrdered ||\n        events[index][1].type === types.listUnordered\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          prepareList(events.slice(listStack.pop(), index))\n        }\n      }\n\n      // Move definitions to the front.\n      if (events[index][1].type === types.definition) {\n        if (events[index][0] === 'enter') {\n          body = push(body, events.slice(start, index))\n          start = index\n        } else {\n          head = push(head, events.slice(start, index + 1))\n          start = index + 1\n        }\n      }\n    }\n\n    head = push(head, body)\n    head = push(head, events.slice(start))\n    index = -1\n    const result = head\n\n    // Handle the start of the document, if defined.\n    if (handlers.enter.null) {\n      handlers.enter.null.call(context)\n    }\n\n    // Handle all events.\n    while (++index < events.length) {\n      const handles = handlers[result[index][0]]\n      const kind = result[index][1].type\n      const handle = handles[kind]\n\n      if (hasOwnProperty.call(handles, kind) && handle) {\n        handle.call(\n          {sliceSerialize: result[index][2].sliceSerialize, ...context},\n          result[index][1]\n        )\n      }\n    }\n\n    // Handle the end of the document, if defined.\n    if (handlers.exit.null) {\n      handlers.exit.null.call(context)\n    }\n\n    return buffers[0].join('')\n  }\n\n  /**\n   * Figure out whether lists are loose or not.\n   *\n   * @param {ReadonlyArray<Event>} slice\n   * @returns {undefined}\n   */\n  function prepareList(slice) {\n    const length = slice.length\n    let index = 0 // Skip open.\n    let containerBalance = 0\n    let loose = false\n    /** @type {boolean | undefined} */\n    let atMarker\n\n    while (++index < length) {\n      const event = slice[index]\n\n      if (event[1]._container) {\n        atMarker = undefined\n\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n      } else\n        switch (event[1].type) {\n          case types.listItemPrefix: {\n            if (event[0] === 'exit') {\n              atMarker = true\n            }\n\n            break\n          }\n\n          case types.linePrefix: {\n            // Ignore\n\n            break\n          }\n\n          case types.lineEndingBlank: {\n            if (event[0] === 'enter' && !containerBalance) {\n              if (atMarker) {\n                atMarker = undefined\n              } else {\n                loose = true\n              }\n            }\n\n            break\n          }\n\n          default: {\n            atMarker = undefined\n          }\n        }\n    }\n\n    slice[0][1]._loose = loose\n  }\n\n  /**\n   * @type {CompileContext['setData']}\n   */\n  function setData(key, value) {\n    // @ts-expect-error: assume `value` is omitted (`undefined` is passed) only\n    // if allowed.\n    data[key] = value\n  }\n\n  /**\n   * @type {CompileContext['getData']}\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /** @type {CompileContext['buffer']} */\n  function buffer() {\n    buffers.push([])\n  }\n\n  /** @type {CompileContext['resume']} */\n  function resume() {\n    const buf = buffers.pop()\n    assert(buf !== undefined, 'Cannot resume w/o buffer')\n    return buf.join('')\n  }\n\n  /** @type {CompileContext['tag']} */\n  function tag(value) {\n    if (!tags) return\n    setData('lastWasTag', true)\n    buffers[buffers.length - 1].push(value)\n  }\n\n  /** @type {CompileContext['raw']} */\n  function raw(value) {\n    setData('lastWasTag')\n    buffers[buffers.length - 1].push(value)\n  }\n\n  /**\n   * Output an extra line ending.\n   *\n   * @returns {undefined}\n   */\n  function lineEnding() {\n    raw(lineEndingStyle || '\\n')\n  }\n\n  /** @type {CompileContext['lineEndingIfNeeded']} */\n  function lineEndingIfNeeded() {\n    const buffer = buffers[buffers.length - 1]\n    const slice = buffer[buffer.length - 1]\n    const previous = slice ? slice.charCodeAt(slice.length - 1) : codes.eof\n\n    if (\n      previous === codes.lf ||\n      previous === codes.cr ||\n      previous === codes.eof\n    ) {\n      return\n    }\n\n    lineEnding()\n  }\n\n  /** @type {CompileContext['encode']} */\n  function encode(value) {\n    return getData('ignoreEncode') ? value : _encode(value)\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @returns {undefined}\n   */\n  function onresumedrop() {\n    resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered(token) {\n    tightStack.push(!token._loose)\n    lineEndingIfNeeded()\n    tag('<ol')\n    setData('expectFirstItem', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistunordered(token) {\n    tightStack.push(!token._loose)\n    lineEndingIfNeeded()\n    tag('<ul')\n    setData('expectFirstItem', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectFirstItem')) {\n      const value = Number.parseInt(\n        this.sliceSerialize(token),\n        constants.numericBaseDecimal\n      )\n\n      if (value !== 1) {\n        tag(' start=\"' + encode(String(value)) + '\"')\n      }\n    }\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterlistitemmarker() {\n    if (getData('expectFirstItem')) {\n      tag('>')\n    } else {\n      onexitlistitem()\n    }\n\n    lineEndingIfNeeded()\n    tag('<li>')\n    setData('expectFirstItem')\n    // Hack to prevent a line ending from showing up if the item is empty.\n    setData('lastWasTag')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistordered() {\n    onexitlistitem()\n    tightStack.pop()\n    lineEnding()\n    tag('</ol>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistunordered() {\n    onexitlistitem()\n    tightStack.pop()\n    lineEnding()\n    tag('</ul>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitlistitem() {\n    if (getData('lastWasTag') && !getData('slurpAllLineEndings')) {\n      lineEndingIfNeeded()\n    }\n\n    tag('</li>')\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterblockquote() {\n    tightStack.push(false)\n    lineEndingIfNeeded()\n    tag('<blockquote>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitblockquote() {\n    tightStack.pop()\n    lineEndingIfNeeded()\n    tag('</blockquote>')\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterparagraph() {\n    if (!tightStack[tightStack.length - 1]) {\n      lineEndingIfNeeded()\n      tag('<p>')\n    }\n\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitparagraph() {\n    if (tightStack[tightStack.length - 1]) {\n      setData('slurpAllLineEndings', true)\n    } else {\n      tag('</p>')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercodefenced() {\n    lineEndingIfNeeded()\n    tag('<pre><code')\n    setData('fencesCount', 0)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const value = resume()\n    tag(' class=\"language-' + value + '\"')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    const count = getData('fencesCount') || 0\n\n    if (!count) {\n      tag('>')\n      setData('slurpOneLineEnding', true)\n    }\n\n    setData('fencesCount', count + 1)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercodeindented() {\n    lineEndingIfNeeded()\n    tag('<pre><code>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitflowcode() {\n    const count = getData('fencesCount')\n\n    // One special case is if we are inside a container, and the fenced code was\n    // not closed (meaning it runs to the end).\n    // In that case, the following line ending, is considered *outside* the\n    // fenced code and block quote by micromark, but CM wants to treat that\n    // ending as part of the code.\n    if (\n      count !== undefined &&\n      count < 2 &&\n      data.tightStack.length > 0 &&\n      !getData('lastWasTag')\n    ) {\n      lineEnding()\n    }\n\n    // But in most cases, its simpler: when weve seen some data, emit an extra\n    // line ending when needed.\n    if (getData('flowCodeSeenData')) {\n      lineEndingIfNeeded()\n    }\n\n    tag('</code></pre>')\n    if (count !== undefined && count < 2) lineEndingIfNeeded()\n    setData('flowCodeSeenData')\n    setData('fencesCount')\n    setData('slurpOneLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterimage() {\n    mediaStack.push({image: true})\n    tags = undefined // Disallow tags.\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlink() {\n    mediaStack.push({})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlabeltext(token) {\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlabel() {\n    mediaStack[mediaStack.length - 1].label = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitreferencestring(token) {\n    mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterresource() {\n    buffer() // We can have line endings in the resource, ignore them.\n    mediaStack[mediaStack.length - 1].destination = ''\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterresourcedestinationstring() {\n    buffer()\n    // Ignore encoding the result, as well first percent encode the url and\n    // encode manually after.\n    setData('ignoreEncode', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitresourcedestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume()\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitresourcetitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitmedia() {\n    let index = mediaStack.length - 1 // Skip current.\n    const media = mediaStack[index]\n    const id = media.referenceId || media.labelId\n    assert(id !== undefined, 'media should have `referenceId` or `labelId`')\n    assert(media.label !== undefined, 'media should have `label`')\n    const context =\n      media.destination === undefined\n        ? definitions[normalizeIdentifier(id)]\n        : media\n\n    tags = true\n\n    while (index--) {\n      if (mediaStack[index].image) {\n        tags = undefined\n        break\n      }\n    }\n\n    if (media.image) {\n      tag(\n        '<img src=\"' +\n          sanitizeUri(\n            context.destination,\n            settings.allowDangerousProtocol ? undefined : protocolSource\n          ) +\n          '\" alt=\"'\n      )\n      raw(media.label)\n      tag('\"')\n    } else {\n      tag(\n        '<a href=\"' +\n          sanitizeUri(\n            context.destination,\n            settings.allowDangerousProtocol ? undefined : protocolHref\n          ) +\n          '\"'\n      )\n    }\n\n    tag(context.title ? ' title=\"' + context.title + '\"' : '')\n\n    if (media.image) {\n      tag(' />')\n    } else {\n      tag('>')\n      raw(media.label)\n      tag('</a>')\n    }\n\n    mediaStack.pop()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterdefinition() {\n    buffer()\n    mediaStack.push({})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    resume()\n    mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterdefinitiondestinationstring() {\n    buffer()\n    setData('ignoreEncode', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    mediaStack[mediaStack.length - 1].destination = resume()\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    mediaStack[mediaStack.length - 1].title = resume()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinition() {\n    const media = mediaStack[mediaStack.length - 1]\n    assert(media.labelId !== undefined, 'media should have `labelId`')\n    const id = normalizeIdentifier(media.labelId)\n\n    resume()\n\n    if (!hasOwnProperty.call(definitions, id)) {\n      definitions[id] = mediaStack[mediaStack.length - 1]\n    }\n\n    mediaStack.pop()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentercontent() {\n    setData('slurpAllLineEndings', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    // Exit for further sequences.\n    if (getData('headingRank')) return\n    setData('headingRank', this.sliceSerialize(token).length)\n    lineEndingIfNeeded()\n    tag('<h' + getData('headingRank') + '>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onentersetextheading() {\n    buffer()\n    setData('slurpAllLineEndings')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('slurpAllLineEndings', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheading() {\n    tag('</h' + getData('headingRank') + '>')\n    setData('headingRank')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    setData(\n      'headingRank',\n      this.sliceSerialize(token).charCodeAt(0) === codes.equalsTo ? 1 : 2\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    const value = resume()\n    lineEndingIfNeeded()\n    tag('<h' + getData('headingRank') + '>')\n    raw(value)\n    tag('</h' + getData('headingRank') + '>')\n    setData('slurpAllLineEndings')\n    setData('headingRank')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdata(token) {\n    raw(encode(this.sliceSerialize(token)))\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitlineending(token) {\n    if (getData('slurpAllLineEndings')) {\n      return\n    }\n\n    if (getData('slurpOneLineEnding')) {\n      setData('slurpOneLineEnding')\n      return\n    }\n\n    if (getData('inCodeText')) {\n      raw(' ')\n      return\n    }\n\n    raw(encode(this.sliceSerialize(token)))\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeflowvalue(token) {\n    raw(encode(this.sliceSerialize(token)))\n    setData('flowCodeSeenData', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexithardbreak() {\n    tag('<br />')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterhtmlflow() {\n    lineEndingIfNeeded()\n    onenterhtml()\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexithtml() {\n    setData('ignoreEncode')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterhtml() {\n    if (settings.allowDangerousHtml) {\n      setData('ignoreEncode', true)\n    }\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenteremphasis() {\n    tag('<em>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onenterstrong() {\n    tag('<strong>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onentercodetext() {\n    setData('inCodeText', true)\n    tag('<code>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitcodetext() {\n    setData('inCodeText')\n    tag('</code>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitemphasis() {\n    tag('</em>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitstrong() {\n    tag('</strong>')\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function onexitthematicbreak() {\n    lineEndingIfNeeded()\n    tag('<hr />')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @param {Token} token\n   * @returns {undefined}\n   */\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const value = this.sliceSerialize(token)\n    const decoded = getData('characterReferenceType')\n      ? decodeNumericCharacterReference(\n          value,\n          getData('characterReferenceType') ===\n            types.characterReferenceMarkerNumeric\n            ? constants.numericBaseDecimal\n            : constants.numericBaseHexadecimal\n        )\n      : decodeNamedCharacterReference(value)\n\n    // `decodeNamedCharacterReference` can return `false` for invalid named\n    // character references,\n    // but everything weve tokenized is valid.\n    raw(encode(/** @type {string} */ (decoded)))\n    setData('characterReferenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    const uri = this.sliceSerialize(token)\n    tag(\n      '<a href=\"' +\n        sanitizeUri(\n          uri,\n          settings.allowDangerousProtocol ? undefined : protocolHref\n        ) +\n        '\">'\n    )\n    raw(encode(uri))\n    tag('</a>')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    const uri = this.sliceSerialize(token)\n    tag('<a href=\"' + sanitizeUri('mailto:' + uri) + '\">')\n    raw(encode(uri))\n    tag('</a>')\n  }\n}\n", "/**\n * @import {Effects, State, TokenType} from 'micromark-util-types'\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `` represents a tab (plus how much it expands) and `` represents a\n * single space.\n *\n * ```markdown\n * \n * \n * \n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n\n    effects.exit(type)\n    return ok(code)\n  }\n}\n", "/**\n * @import {\n *   InitialConstruct,\n *   Initializer,\n *   State,\n *   TokenizeContext,\n *   Token\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {InitialConstruct} */\nexport const content = {tokenize: initializeContent}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Initializer}\n *   Content.\n */\nfunction initializeContent(effects) {\n  const contentStart = effects.attempt(\n    this.parser.constructs.contentInitial,\n    afterContentStartConstruct,\n    paragraphInitial\n  )\n  /** @type {Token} */\n  let previous\n\n  return contentStart\n\n  /** @type {State} */\n  function afterContentStartConstruct(code) {\n    assert(\n      code === codes.eof || markdownLineEnding(code),\n      'expected eol or eof'\n    )\n\n    if (code === codes.eof) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return factorySpace(effects, contentStart, types.linePrefix)\n  }\n\n  /** @type {State} */\n  function paragraphInitial(code) {\n    assert(\n      code !== codes.eof && !markdownLineEnding(code),\n      'expected anything other than a line ending or EOF'\n    )\n    effects.enter(types.paragraph)\n    return lineStart(code)\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    const token = effects.enter(types.chunkText, {\n      contentType: constants.contentTypeText,\n      previous\n    })\n\n    if (previous) {\n      previous.next = token\n    }\n\n    previous = token\n\n    return data(code)\n  }\n\n  /** @type {State} */\n  function data(code) {\n    if (code === codes.eof) {\n      effects.exit(types.chunkText)\n      effects.exit(types.paragraph)\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      effects.exit(types.chunkText)\n      return lineStart\n    }\n\n    // Data.\n    effects.consume(code)\n    return data\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   ContainerState,\n *   InitialConstruct,\n *   Initializer,\n *   Point,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @typedef {[Construct, ContainerState]} StackItem\n *   Construct and its state.\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {InitialConstruct} */\nexport const document = {tokenize: initializeDocument}\n\n/** @type {Construct} */\nconst containerConstruct = {tokenize: tokenizeContainer}\n\n/**\n * @this {TokenizeContext}\n *   Self.\n * @type {Initializer}\n *   Initializer.\n */\nfunction initializeDocument(effects) {\n  const self = this\n  /** @type {Array<StackItem>} */\n  const stack = []\n  let continued = 0\n  /** @type {TokenizeContext | undefined} */\n  let childFlow\n  /** @type {Token | undefined} */\n  let childToken\n  /** @type {number} */\n  let lineStartOffset\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued]\n      self.containerState = item[1]\n      assert(\n        item[0].continuation,\n        'expected `continuation` to be defined on container construct'\n      )\n      return effects.attempt(\n        item[0].continuation,\n        documentContinue,\n        checkNewContainers\n      )(code)\n    }\n\n    // Done.\n    return checkNewContainers(code)\n  }\n\n  /** @type {State} */\n  function documentContinue(code) {\n    assert(\n      self.containerState,\n      'expected `containerState` to be defined after continuation'\n    )\n\n    continued++\n\n    // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but its already used in the wild by\n    // extensions.\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined\n\n      if (childFlow) {\n        closeFlow()\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {Point | undefined} */\n      let point\n\n      // Find the flow chunk.\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === types.chunkFlow\n        ) {\n          point = self.events[indexBeforeFlow][1].end\n          break\n        }\n      }\n\n      assert(point, 'could not find previous flow chunk')\n\n      exitContainers(continued)\n\n      // Fix positions.\n      let index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = {...point}\n        index++\n      }\n\n      // Inject the exits earlier (theyre still also at the end).\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      )\n\n      // Discard the duplicate exits.\n      self.events.length = index\n\n      return checkNewContainers(code)\n    }\n\n    return start(code)\n  }\n\n  /** @type {State} */\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether theres a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code)\n      }\n\n      // If we have concrete content, such as block HTML or fenced code,\n      // we cant have containers pierce into them, so we can immediately\n      // start.\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code)\n      }\n\n      // If we do have flow, it could still be a blank line,\n      // but wed be interrupting it w/ a new container if theres a current\n      // construct.\n      // To do: next major: remove `_gfmTableDynamicInterruptHack` (no longer\n      // needed in micromark-extension-gfm-table@1.0.6).\n      self.interrupt = Boolean(\n        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack\n      )\n    }\n\n    // Check if there is a new container.\n    self.containerState = {}\n    return effects.check(\n      containerConstruct,\n      thereIsANewContainer,\n      thereIsNoNewContainer\n    )(code)\n  }\n\n  /** @type {State} */\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow()\n    exitContainers(continued)\n    return documentContinued(code)\n  }\n\n  /** @type {State} */\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length\n    lineStartOffset = self.now().offset\n    return flowStart(code)\n  }\n\n  /** @type {State} */\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n\n  /** @type {State} */\n  function containerContinue(code) {\n    assert(\n      self.currentConstruct,\n      'expected `currentConstruct` to be defined on tokenizer'\n    )\n    assert(\n      self.containerState,\n      'expected `containerState` to be defined on tokenizer'\n    )\n    continued++\n    stack.push([self.currentConstruct, self.containerState])\n    // Try another.\n    return documentContinued(code)\n  }\n\n  /** @type {State} */\n  function flowStart(code) {\n    if (code === codes.eof) {\n      if (childFlow) closeFlow()\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter(types.chunkFlow, {\n      _tokenizer: childFlow,\n      contentType: constants.contentTypeFlow,\n      previous: childToken\n    })\n\n    return flowContinue(code)\n  }\n\n  /** @type {State} */\n  function flowContinue(code) {\n    if (code === codes.eof) {\n      writeToChild(effects.exit(types.chunkFlow), true)\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      writeToChild(effects.exit(types.chunkFlow))\n      // Get ready for the next line.\n      continued = 0\n      self.interrupt = undefined\n      return start\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n\n  /**\n   * @param {Token} token\n   *   Token.\n   * @param {boolean | undefined} [endOfFile]\n   *   Whether the token is at the end of the file (default: `false`).\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function writeToChild(token, endOfFile) {\n    assert(childFlow, 'expected `childFlow` to be defined when continuing')\n    const stream = self.sliceStream(token)\n    if (endOfFile) stream.push(null)\n    token.previous = childToken\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.defineSkip(token.start)\n    childFlow.write(stream)\n\n    // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line cant unmake it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which unmakes the first line\n    // and turns the whole into one content block.\n    //\n    // Weve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length\n\n      while (index--) {\n        if (\n          // The token starts before the line ending\n          childFlow.events[index][1].start.offset < lineStartOffset &&\n          // and either is not ended yet\n          (!childFlow.events[index][1].end ||\n            // or ends after it.\n            childFlow.events[index][1].end.offset > lineStartOffset)\n        ) {\n          // Exit: theres still something open, which means its a lazy line\n          // part of something.\n          return\n        }\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {boolean | undefined} */\n      let seen\n      /** @type {Point | undefined} */\n      let point\n\n      // Find the previous chunk (the one before the lazy line).\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === types.chunkFlow\n        ) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end\n            break\n          }\n\n          seen = true\n        }\n      }\n\n      assert(point, 'could not find previous flow chunk')\n\n      exitContainers(continued)\n\n      // Fix positions.\n      index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = {...point}\n        index++\n      }\n\n      // Inject the exits earlier (theyre still also at the end).\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      )\n\n      // Discard the duplicate exits.\n      self.events.length = index\n    }\n  }\n\n  /**\n   * @param {number} size\n   *   Size.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function exitContainers(size) {\n    let index = stack.length\n\n    // Exit open containers.\n    while (index-- > size) {\n      const entry = stack[index]\n      self.containerState = entry[1]\n      assert(\n        entry[0].exit,\n        'expected `exit` to be defined on container construct'\n      )\n      entry[0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function closeFlow() {\n    assert(\n      self.containerState,\n      'expected `containerState` to be defined when closing flow'\n    )\n    assert(childFlow, 'expected `childFlow` to be defined when closing it')\n    childFlow.write([codes.eof])\n    childToken = undefined\n    childFlow = undefined\n    self.containerState._closeFlow = undefined\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n *   Tokenizer.\n */\nfunction tokenizeContainer(effects, ok, nok) {\n  // Always populated by defaults.\n  assert(\n    this.parser.constructs.disable.null,\n    'expected `disable.null` to be populated'\n  )\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    types.linePrefix,\n    this.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : constants.tabSize\n  )\n}\n", "/**\n * @import {Code} from 'micromark-util-types'\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nimport {codes, constants} from 'micromark-util-symbol'\n\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * >  **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === codes.eof ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return constants.characterGroupWhitespace\n  }\n\n  if (unicodePunctuation(code)) {\n    return constants.characterGroupPunctuation\n  }\n}\n", "/**\n * @import {Event, Resolver, TokenizeContext} from 'micromark-util-types'\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {ReadonlyArray<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n", "/**\n * @import {\n *   Code,\n *   Construct,\n *   Event,\n *   Point,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  resolveAll: resolveAllAttention,\n  tokenize: tokenizeAttention\n}\n\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n// eslint-disable-next-line complexity\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n  let open\n  /** @type {Token} */\n  let group\n  /** @type {Token} */\n  let text\n  /** @type {Token} */\n  let openingSequence\n  /** @type {Token} */\n  let closingSequence\n  /** @type {number} */\n  let use\n  /** @type {Array<Event>} */\n  let nextEvents\n  /** @type {number} */\n  let offset\n\n  // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but its\n  // a bottleneck for malicious stuff.\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index\n\n      // Now walk back to find an opener.\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open &&\n          // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then dont match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          }\n\n          // Number of markers to use from the sequence.\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n\n          const start = {...events[open][1].end}\n          const end = {...events[index][1].start}\n          movePoint(start, -use)\n          movePoint(end, use)\n\n          openingSequence = {\n            type: use > 1 ? types.strongSequence : types.emphasisSequence,\n            start,\n            end: {...events[open][1].end}\n          }\n          closingSequence = {\n            type: use > 1 ? types.strongSequence : types.emphasisSequence,\n            start: {...events[index][1].start},\n            end\n          }\n          text = {\n            type: use > 1 ? types.strongText : types.emphasisText,\n            start: {...events[open][1].end},\n            end: {...events[index][1].start}\n          }\n          group = {\n            type: use > 1 ? types.strong : types.emphasis,\n            start: {...openingSequence.start},\n            end: {...closingSequence.end}\n          }\n\n          events[open][1].end = {...openingSequence.start}\n          events[index][1].start = {...closingSequence.end}\n\n          nextEvents = []\n\n          // If there are more markers in the opening, add them before.\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          }\n\n          // Opening.\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ])\n\n          // Always populated by defaults.\n          assert(\n            context.parser.constructs.insideSpan.null,\n            'expected `insideSpan` to be populated'\n          )\n\n          // Between.\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          )\n\n          // Closing.\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ])\n\n          // If there are more markers in the closing, add them after.\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          splice(events, open - 1, index - open + 3, nextEvents)\n\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  }\n\n  // Remove remaining sequences.\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /**\n   * Before a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(\n      code === codes.asterisk || code === codes.underscore,\n      'expected asterisk or underscore'\n    )\n    marker = code\n    effects.enter('attentionSequence')\n    return inside(code)\n  }\n\n  /**\n   * In a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n\n    const token = effects.exit('attentionSequence')\n\n    // To do: next major: move this to resolver, just like `markdown-rs`.\n    const after = classifyCharacter(code)\n\n    // Always populated by defaults.\n    assert(attentionMarkers, 'expected `attentionMarkers` to be populated')\n\n    const open =\n      !after ||\n      (after === constants.characterGroupPunctuation && before) ||\n      attentionMarkers.includes(code)\n    const close =\n      !before ||\n      (before === constants.characterGroupPunctuation && after) ||\n      attentionMarkers.includes(previous)\n\n    token._open = Boolean(\n      marker === codes.asterisk ? open : open && (before || !close)\n    )\n    token._close = Boolean(\n      marker === codes.asterisk ? close : close && (after || !open)\n    )\n    return ok(code)\n  }\n}\n\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! Its not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n *   Point.\n * @param {number} offset\n *   Amount to move.\n * @returns {undefined}\n *   Nothing.\n */\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {\n  asciiAlphanumeric,\n  asciiAlpha,\n  asciiAtext,\n  asciiControl\n} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const autolink = {name: 'autolink', tokenize: tokenizeAutolink}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeAutolink(effects, ok, nok) {\n  let size = 0\n\n  return start\n\n  /**\n   * Start of an autolink.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *      ^\n   * > | a<user@example.com>b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.autolink)\n    effects.enter(types.autolinkMarker)\n    effects.consume(code)\n    effects.exit(types.autolinkMarker)\n    effects.enter(types.autolinkProtocol)\n    return open\n  }\n\n  /**\n   * After `<`, at protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *       ^\n   * > | a<user@example.com>b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n\n    if (code === codes.atSign) {\n      return nok(code)\n    }\n\n    return emailAtext(code)\n  }\n\n  /**\n   * At second byte of protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *        ^\n   * > | a<user@example.com>b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function schemeOrEmailAtext(code) {\n    // ASCII alphanumeric and `+`, `-`, and `.`.\n    if (\n      code === codes.plusSign ||\n      code === codes.dash ||\n      code === codes.dot ||\n      asciiAlphanumeric(code)\n    ) {\n      // Count the previous alphabetical from `open` too.\n      size = 1\n      return schemeInsideOrEmailAtext(code)\n    }\n\n    return emailAtext(code)\n  }\n\n  /**\n   * In ambiguous protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *        ^\n   * > | a<user@example.com>b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function schemeInsideOrEmailAtext(code) {\n    if (code === codes.colon) {\n      effects.consume(code)\n      size = 0\n      return urlInside\n    }\n\n    // ASCII alphanumeric and `+`, `-`, and `.`.\n    if (\n      (code === codes.plusSign ||\n        code === codes.dash ||\n        code === codes.dot ||\n        asciiAlphanumeric(code)) &&\n      size++ < constants.autolinkSchemeSizeMax\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n\n    size = 0\n    return emailAtext(code)\n  }\n\n  /**\n   * After protocol, in URL.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function urlInside(code) {\n    if (code === codes.greaterThan) {\n      effects.exit(types.autolinkProtocol)\n      effects.enter(types.autolinkMarker)\n      effects.consume(code)\n      effects.exit(types.autolinkMarker)\n      effects.exit(types.autolink)\n      return ok\n    }\n\n    // ASCII control, space, or `<`.\n    if (\n      code === codes.eof ||\n      code === codes.space ||\n      code === codes.lessThan ||\n      asciiControl(code)\n    ) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return urlInside\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailAtext(code) {\n    if (code === codes.atSign) {\n      effects.consume(code)\n      return emailAtSignOrDot\n    }\n\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In label, after at-sign or dot.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *                 ^       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n\n  /**\n   * In label, where `.` and `>` are allowed.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailLabel(code) {\n    if (code === codes.dot) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (code === codes.greaterThan) {\n      // Exit, then change the token type.\n      effects.exit(types.autolinkProtocol).type = types.autolinkEmail\n      effects.enter(types.autolinkMarker)\n      effects.consume(code)\n      effects.exit(types.autolinkMarker)\n      effects.exit(types.autolink)\n      return ok\n    }\n\n    return emailValue(code)\n  }\n\n  /**\n   * In label, where `.` and `>` are *not* allowed.\n   *\n   * Though, this is also used in `emailLabel` to parse other values.\n   *\n   * ```markdown\n   * > | a<user.name@ex-ample.com>b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailValue(code) {\n    // ASCII alphanumeric or `-`.\n    if (\n      (code === codes.dash || asciiAlphanumeric(code)) &&\n      size++ < constants.autolinkDomainSizeMax\n    ) {\n      const next = code === codes.dash ? emailValue : emailLabel\n      effects.consume(code)\n      return next\n    }\n\n    return nok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const blankLine = {partial: true, tokenize: tokenizeBlankLine}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of blank line.\n   *\n   * >  **Note**: `` represents a space character.\n   *\n   * ```markdown\n   * > | \n   *     ^\n   * > | \n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    return markdownSpace(code)\n      ? factorySpace(effects, after, types.linePrefix)(code)\n      : after(code)\n  }\n\n  /**\n   * At eof/eol, after optional whitespace.\n   *\n   * >  **Note**: `` represents a space character.\n   *\n   * ```markdown\n   * > | \n   *       ^\n   * > | \n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   Exiter,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  continuation: {tokenize: tokenizeBlockQuoteContinuation},\n  exit,\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * Start of block quote.\n   *\n   * ```markdown\n   * > | > a\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === codes.greaterThan) {\n      const state = self.containerState\n\n      assert(state, 'expected `containerState` to be defined in container')\n\n      if (!state.open) {\n        effects.enter(types.blockQuote, {_container: true})\n        state.open = true\n      }\n\n      effects.enter(types.blockQuotePrefix)\n      effects.enter(types.blockQuoteMarker)\n      effects.consume(code)\n      effects.exit(types.blockQuoteMarker)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `>`, before optional whitespace.\n   *\n   * ```markdown\n   * > | > a\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.blockQuotePrefixWhitespace)\n      effects.consume(code)\n      effects.exit(types.blockQuotePrefixWhitespace)\n      effects.exit(types.blockQuotePrefix)\n      return ok\n    }\n\n    effects.exit(types.blockQuotePrefix)\n    return ok(code)\n  }\n}\n\n/**\n * Start of block quote continuation.\n *\n * ```markdown\n *   | > a\n * > | > b\n *     ^\n * ```\n *\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  const self = this\n\n  return contStart\n\n  /**\n   * Start of block quote continuation.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contStart(code) {\n    if (markdownSpace(code)) {\n      // Always populated by defaults.\n      assert(\n        self.parser.constructs.disable.null,\n        'expected `disable.null` to be populated'\n      )\n\n      return factorySpace(\n        effects,\n        contBefore,\n        types.linePrefix,\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : constants.tabSize\n      )(code)\n    }\n\n    return contBefore(code)\n  }\n\n  /**\n   * At `>`, after optional whitespace.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contBefore(code) {\n    return effects.attempt(blockQuote, ok, nok)(code)\n  }\n}\n\n/** @type {Exiter} */\nfunction exit(effects) {\n  effects.exit(types.blockQuote)\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {asciiPunctuation} from 'micromark-util-character'\nimport {codes, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of character escape.\n   *\n   * ```markdown\n   * > | a\\*b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.backslash, 'expected `\\\\`')\n    effects.enter(types.characterEscape)\n    effects.enter(types.escapeMarker)\n    effects.consume(code)\n    effects.exit(types.escapeMarker)\n    return inside\n  }\n\n  /**\n   * After `\\`, at punctuation.\n   *\n   * ```markdown\n   * > | a\\*b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // ASCII punctuation.\n    if (asciiPunctuation(code)) {\n      effects.enter(types.characterEscapeValue)\n      effects.consume(code)\n      effects.exit(types.characterEscapeValue)\n      effects.exit(types.characterEscape)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n", "/**\n * @import {\n *   Code,\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {\n  asciiAlphanumeric,\n  asciiDigit,\n  asciiHexDigit\n} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  const self = this\n  let size = 0\n  /** @type {number} */\n  let max\n  /** @type {(code: Code) => boolean} */\n  let test\n\n  return start\n\n  /**\n   * Start of character reference.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *      ^\n   * > | a&#123;b\n   *      ^\n   * > | a&#x9;b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.ampersand, 'expected `&`')\n    effects.enter(types.characterReference)\n    effects.enter(types.characterReferenceMarker)\n    effects.consume(code)\n    effects.exit(types.characterReferenceMarker)\n    return open\n  }\n\n  /**\n   * After `&`, at `#` for numeric references or alphanumeric for named\n   * references.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^\n   * > | a&#123;b\n   *       ^\n   * > | a&#x9;b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.characterReferenceMarkerNumeric)\n      effects.consume(code)\n      effects.exit(types.characterReferenceMarkerNumeric)\n      return numeric\n    }\n\n    effects.enter(types.characterReferenceValue)\n    max = constants.characterReferenceNamedSizeMax\n    test = asciiAlphanumeric\n    return value(code)\n  }\n\n  /**\n   * After `#`, at `x` for hexadecimals or digit for decimals.\n   *\n   * ```markdown\n   * > | a&#123;b\n   *        ^\n   * > | a&#x9;b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function numeric(code) {\n    if (code === codes.uppercaseX || code === codes.lowercaseX) {\n      effects.enter(types.characterReferenceMarkerHexadecimal)\n      effects.consume(code)\n      effects.exit(types.characterReferenceMarkerHexadecimal)\n      effects.enter(types.characterReferenceValue)\n      max = constants.characterReferenceHexadecimalSizeMax\n      test = asciiHexDigit\n      return value\n    }\n\n    effects.enter(types.characterReferenceValue)\n    max = constants.characterReferenceDecimalSizeMax\n    test = asciiDigit\n    return value(code)\n  }\n\n  /**\n   * After markers (`&#x`, `&#`, or `&`), in value, before `;`.\n   *\n   * The character reference kind defines what and how many characters are\n   * allowed.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^^^\n   * > | a&#123;b\n   *        ^^^\n   * > | a&#x9;b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function value(code) {\n    if (code === codes.semicolon && size) {\n      const token = effects.exit(types.characterReferenceValue)\n\n      if (\n        test === asciiAlphanumeric &&\n        !decodeNamedCharacterReference(self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      // To do: `markdown-rs` uses a different name:\n      // `CharacterReferenceMarkerSemi`.\n      effects.enter(types.characterReferenceMarker)\n      effects.consume(code)\n      effects.exit(types.characterReferenceMarker)\n      effects.exit(types.characterReference)\n      return ok\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n\n    return nok(code)\n  }\n}\n", "/**\n * @import {\n *   Code,\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  partial: true,\n  tokenize: tokenizeNonLazyContinuation\n}\n\n/** @type {Construct} */\nexport const codeFenced = {\n  concrete: true,\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n  const closeStart = {partial: true, tokenize: tokenizeCloseStart}\n  let initialPrefix = 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /**\n   * Start of code.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse whitespace like `markdown-rs`.\n    return beforeSequenceOpen(code)\n  }\n\n  /**\n   * In opening fence, after prefix, at sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeSequenceOpen(code) {\n    assert(\n      code === codes.graveAccent || code === codes.tilde,\n      'expected `` ` `` or `~`'\n    )\n\n    const tail = self.events[self.events.length - 1]\n    initialPrefix =\n      tail && tail[1].type === types.linePrefix\n        ? tail[2].sliceSerialize(tail[1], true).length\n        : 0\n\n    marker = code\n    effects.enter(types.codeFenced)\n    effects.enter(types.codeFencedFence)\n    effects.enter(types.codeFencedFenceSequence)\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *      ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      sizeOpen++\n      effects.consume(code)\n      return sequenceOpen\n    }\n\n    if (sizeOpen < constants.codeFencedSequenceSizeMin) {\n      return nok(code)\n    }\n\n    effects.exit(types.codeFencedFenceSequence)\n    return markdownSpace(code)\n      ? factorySpace(effects, infoBefore, types.whitespace)(code)\n      : infoBefore(code)\n  }\n\n  /**\n   * In opening fence, after the sequence (and optional whitespace), before info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function infoBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFencedFence)\n      return self.interrupt\n        ? ok(code)\n        : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)\n    }\n\n    effects.enter(types.codeFencedFenceInfo)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return info(code)\n  }\n\n  /**\n   * In info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function info(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceInfo)\n      return infoBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceInfo)\n      return factorySpace(effects, metaBefore, types.whitespace)(code)\n    }\n\n    if (code === codes.graveAccent && code === marker) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return info\n  }\n\n  /**\n   * In opening fence, after info and whitespace, before meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return infoBefore(code)\n    }\n\n    effects.enter(types.codeFencedFenceMeta)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceMeta)\n      return infoBefore(code)\n    }\n\n    if (code === codes.graveAccent && code === marker) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * At eol/eof in code, before a non-lazy closing fence or content.\n   *\n   * ```markdown\n   * > | ~~~js\n   *          ^\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function atNonLazyBreak(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    return effects.attempt(closeStart, after, contentBefore)(code)\n  }\n\n  /**\n   * Before code content, not a closing fence, at eol.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentBefore(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return contentStart\n  }\n\n  /**\n   * Before code content, not a closing fence.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return initialPrefix > 0 && markdownSpace(code)\n      ? factorySpace(\n          effects,\n          beforeContentChunk,\n          types.linePrefix,\n          initialPrefix + 1\n        )(code)\n      : beforeContentChunk(code)\n  }\n\n  /**\n   * Before code content, after optional prefix.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)\n    }\n\n    effects.enter(types.codeFlowValue)\n    return contentChunk(code)\n  }\n\n  /**\n   * In code content.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^^^^^^^^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue)\n      return beforeContentChunk(code)\n    }\n\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After code.\n   *\n   * ```markdown\n   *   | ~~~js\n   *   | alert(1)\n   * > | ~~~\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit(types.codeFenced)\n    return ok(code)\n  }\n\n  /**\n   * @this {TokenizeContext}\n   *   Context.\n   * @type {Tokenizer}\n   */\n  function tokenizeCloseStart(effects, ok, nok) {\n    let size = 0\n\n    return startBefore\n\n    /**\n     *\n     *\n     * @type {State}\n     */\n    function startBefore(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return start\n    }\n\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      // Always populated by defaults.\n      assert(\n        self.parser.constructs.disable.null,\n        'expected `disable.null` to be populated'\n      )\n\n      // To do: `enter` here or in next state?\n      effects.enter(types.codeFencedFence)\n      return markdownSpace(code)\n        ? factorySpace(\n            effects,\n            beforeSequenceClose,\n            types.linePrefix,\n            self.parser.constructs.disable.null.includes('codeIndented')\n              ? undefined\n              : constants.tabSize\n          )(code)\n        : beforeSequenceClose(code)\n    }\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      if (code === marker) {\n        effects.enter(types.codeFencedFenceSequence)\n        return sequenceClose(code)\n      }\n\n      return nok(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === marker) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n\n      if (size >= sizeOpen) {\n        effects.exit(types.codeFencedFenceSequence)\n        return markdownSpace(code)\n          ? factorySpace(effects, sequenceCloseAfter, types.whitespace)(code)\n          : sequenceCloseAfter(code)\n      }\n\n      return nok(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceCloseAfter(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(types.codeFencedFence)\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineStart\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n}\n\n/** @type {Construct} */\nconst furtherStart = {partial: true, tokenize: tokenizeFurtherStart}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of code (indented).\n   *\n   * > **Parsing note**: it is not needed to check if this first line is a\n   * > filled line (that it has a non-whitespace character), because blank lines\n   * > are parsed already, so we never run into that.\n   *\n   * ```markdown\n   * > |     aaa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: manually check if interrupting like `markdown-rs`.\n    assert(markdownSpace(code))\n    effects.enter(types.codeIndented)\n    // To do: use an improved `space_or_tab` function like `markdown-rs`,\n    // so that we can drop the next state.\n    return factorySpace(\n      effects,\n      afterPrefix,\n      types.linePrefix,\n      constants.tabSize + 1\n    )(code)\n  }\n\n  /**\n   * At start, after 1 or 4 spaces.\n   *\n   * ```markdown\n   * > |     aaa\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === types.linePrefix &&\n      tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\n      ? atBreak(code)\n      : nok(code)\n  }\n\n  /**\n   * At a break.\n   *\n   * ```markdown\n   * > |     aaa\n   *         ^  ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(furtherStart, atBreak, after)(code)\n    }\n\n    effects.enter(types.codeFlowValue)\n    return inside(code)\n  }\n\n  /**\n   * In code content.\n   *\n   * ```markdown\n   * > |     aaa\n   *         ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue)\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    return inside\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit(types.codeIndented)\n    // To do: allow interrupting like `markdown-rs`.\n    // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeFurtherStart(effects, ok, nok) {\n  const self = this\n\n  return furtherStart\n\n  /**\n   * At eol, trying to parse another indent.\n   *\n   * ```markdown\n   * > |     aaa\n   *            ^\n   *   |     bbb\n   * ```\n   *\n   * @type {State}\n   */\n  function furtherStart(code) {\n    // To do: improve `lazy` / `pierce` handling.\n    // If this is a lazy line, it cant be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return furtherStart\n    }\n\n    // To do: the code here in `micromark-js` is a bit different from\n    // `markdown-rs` because there it can attempt spaces.\n    // We cant yet.\n    //\n    // To do: use an improved `space_or_tab` function like `markdown-rs`,\n    // so that we can drop the next state.\n    return factorySpace(\n      effects,\n      afterPrefix,\n      types.linePrefix,\n      constants.tabSize + 1\n    )(code)\n  }\n\n  /**\n   * At start, after 1 or 4 spaces.\n   *\n   * ```markdown\n   * > |     aaa\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === types.linePrefix &&\n      tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\n      ? ok(code)\n      : markdownLineEnding(code)\n        ? furtherStart(code)\n        : nok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   Previous,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  previous,\n  resolve: resolveCodeText,\n  tokenize: tokenizeCodeText\n}\n\n// To do: next major: dont resolve, like `markdown-rs`.\n/** @type {Resolver} */\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === types.lineEnding ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === types.lineEnding ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === types.codeTextData) {\n        // Then we have padding.\n        events[headEnterIndex][1].type = types.codeTextPadding\n        events[tailExitIndex][1].type = types.codeTextPadding\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (\n        index !== tailExitIndex &&\n        events[index][1].type !== types.lineEnding\n      ) {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === types.lineEnding\n    ) {\n      events[enter][1].type = types.codeTextData\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== codes.graveAccent ||\n    this.events[this.events.length - 1][1].type === types.characterEscape\n  )\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this\n  let sizeOpen = 0\n  /** @type {number} */\n  let size\n  /** @type {Token} */\n  let token\n\n  return start\n\n  /**\n   * Start of code (text).\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * > | \\`a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.graveAccent, 'expected `` ` ``')\n    assert(previous.call(self, self.previous), 'expected correct previous')\n    effects.enter(types.codeText)\n    effects.enter(types.codeTextSequence)\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === codes.graveAccent) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit(types.codeTextSequence)\n    return between(code)\n  }\n\n  /**\n   * Between something and something else.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function between(code) {\n    // EOF.\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    // To do: next major: dont do spaces in resolve, but when compiling,\n    // like `markdown-rs`.\n    // Tabs dont work, and virtual spaces dont make sense.\n    if (code === codes.space) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return between\n    }\n\n    // Closing fence? Could also be data.\n    if (code === codes.graveAccent) {\n      token = effects.enter(types.codeTextSequence)\n      size = 0\n      return sequenceClose(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return between\n    }\n\n    // Data.\n    effects.enter(types.codeTextData)\n    return data(code)\n  }\n\n  /**\n   * In data.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (\n      code === codes.eof ||\n      code === codes.space ||\n      code === codes.graveAccent ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit(types.codeTextData)\n      return between(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n\n  /**\n   * In closing sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceClose(code) {\n    // More.\n    if (code === codes.graveAccent) {\n      effects.consume(code)\n      size++\n      return sequenceClose\n    }\n\n    // Done!\n    if (size === sizeOpen) {\n      effects.exit(types.codeTextSequence)\n      effects.exit(types.codeText)\n      return ok(code)\n    }\n\n    // More or less accents: mark as data.\n    token.type = types.codeTextData\n    return data(code)\n  }\n}\n", "import {constants} from 'micromark-util-symbol'\n\n/**\n * Some of the internal operations of micromark do lots of editing\n * operations on very large arrays. This runs into problems with two\n * properties of most circa-2020 JavaScript interpreters:\n *\n *  - Array-length modifications at the high end of an array (push/pop) are\n *    expected to be common and are implemented in (amortized) time\n *    proportional to the number of elements added or removed, whereas\n *    other operations (shift/unshift and splice) are much less efficient.\n *  - Function arguments are passed on the stack, so adding tens of thousands\n *    of elements to an array with `arr.push(...newElements)` will frequently\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\n *\n * SpliceBuffers are an implementation of gap buffers, which are a\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\n * maintains a cursor, and moving the cursor has cost proportional to the\n * distance the cursor moves, but inserting, deleting, or splicing in\n * new information at the cursor is as efficient as the push/pop operation.\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\n * or unshifts) as long such edits happen at the same part of the array or\n * generally sweep through the array from the beginning to the end.\n *\n * The interface for splice buffers also supports large numbers of inputs by\n * passing a single array argument rather passing multiple arguments on the\n * function call stack.\n *\n * @template T\n *   Item type.\n */\nexport class SpliceBuffer {\n  /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */\n  constructor(initial) {\n    /** @type {Array<T>} */\n    this.left = initial ? [...initial] : []\n    /** @type {Array<T>} */\n    this.right = []\n  }\n\n  /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */\n  get(index) {\n    if (index < 0 || index >= this.left.length + this.right.length) {\n      throw new RangeError(\n        'Cannot access index `' +\n          index +\n          '` in a splice buffer of size `' +\n          (this.left.length + this.right.length) +\n          '`'\n      )\n    }\n\n    if (index < this.left.length) return this.left[index]\n    return this.right[this.right.length - index + this.left.length - 1]\n  }\n\n  /**\n   * The length of the splice buffer, one greater than the largest index in the\n   * array.\n   */\n  get length() {\n    return this.left.length + this.right.length\n  }\n\n  /**\n   * Remove and return `list[0]`;\n   * moves the cursor to `0`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  shift() {\n    this.setCursor(0)\n    return this.right.pop()\n  }\n\n  /**\n   * Slice the buffer to get an array;\n   * does not move the cursor.\n   *\n   * @param {number} start\n   *   Start.\n   * @param {number | null | undefined} [end]\n   *   End (optional).\n   * @returns {Array<T>}\n   *   Array of items.\n   */\n  slice(start, end) {\n    /** @type {number} */\n    const stop =\n      end === null || end === undefined ? Number.POSITIVE_INFINITY : end\n\n    if (stop < this.left.length) {\n      return this.left.slice(start, stop)\n    }\n\n    if (start > this.left.length) {\n      return this.right\n        .slice(\n          this.right.length - stop + this.left.length,\n          this.right.length - start + this.left.length\n        )\n        .reverse()\n    }\n\n    return this.left\n      .slice(start)\n      .concat(\n        this.right.slice(this.right.length - stop + this.left.length).reverse()\n      )\n  }\n\n  /**\n   * Mimics the behavior of Array.prototype.splice() except for the change of\n   * interface necessary to avoid segfaults when patching in very large arrays.\n   *\n   * This operation moves cursor is moved to `start` and results in the cursor\n   * placed after any inserted items.\n   *\n   * @param {number} start\n   *   Start;\n   *   zero-based index at which to start changing the array;\n   *   negative numbers count backwards from the end of the array and values\n   *   that are out-of bounds are clamped to the appropriate end of the array.\n   * @param {number | null | undefined} [deleteCount=0]\n   *   Delete count (default: `0`);\n   *   maximum number of elements to delete, starting from start.\n   * @param {Array<T> | null | undefined} [items=[]]\n   *   Items to include in place of the deleted items (default: `[]`).\n   * @return {Array<T>}\n   *   Any removed items.\n   */\n  splice(start, deleteCount, items) {\n    /** @type {number} */\n    const count = deleteCount || 0\n\n    this.setCursor(Math.trunc(start))\n    const removed = this.right.splice(\n      this.right.length - count,\n      Number.POSITIVE_INFINITY\n    )\n    if (items) chunkedPush(this.left, items)\n    return removed.reverse()\n  }\n\n  /**\n   * Remove and return the highest-numbered item in the array, so\n   * `list[list.length - 1]`;\n   * Moves the cursor to `length`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  pop() {\n    this.setCursor(Number.POSITIVE_INFINITY)\n    return this.left.pop()\n  }\n\n  /**\n   * Inserts a single item to the high-numbered side of the array;\n   * moves the cursor to `length`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  push(item) {\n    this.setCursor(Number.POSITIVE_INFINITY)\n    this.left.push(item)\n  }\n\n  /**\n   * Inserts many items to the high-numbered side of the array.\n   * Moves the cursor to `length`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  pushMany(items) {\n    this.setCursor(Number.POSITIVE_INFINITY)\n    chunkedPush(this.left, items)\n  }\n\n  /**\n   * Inserts a single item to the low-numbered side of the array;\n   * Moves the cursor to `0`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshift(item) {\n    this.setCursor(0)\n    this.right.push(item)\n  }\n\n  /**\n   * Inserts many items to the low-numbered side of the array;\n   * moves the cursor to `0`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshiftMany(items) {\n    this.setCursor(0)\n    chunkedPush(this.right, items.reverse())\n  }\n\n  /**\n   * Move the cursor to a specific position in the array. Requires\n   * time proportional to the distance moved.\n   *\n   * If `n < 0`, the cursor will end up at the beginning.\n   * If `n > length`, the cursor will end up at the end.\n   *\n   * @param {number} n\n   *   Position.\n   * @return {undefined}\n   *   Nothing.\n   */\n  setCursor(n) {\n    if (\n      n === this.left.length ||\n      (n > this.left.length && this.right.length === 0) ||\n      (n < 0 && this.left.length === 0)\n    )\n      return\n    if (n < this.left.length) {\n      // Move cursor to the this.left\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY)\n      chunkedPush(this.right, removed.reverse())\n    } else {\n      // Move cursor to the this.right\n      const removed = this.right.splice(\n        this.left.length + this.right.length - n,\n        Number.POSITIVE_INFINITY\n      )\n      chunkedPush(this.left, removed.reverse())\n    }\n  }\n}\n\n/**\n * Avoid stack overflow by pushing items onto the stack in segments\n *\n * @template T\n *   Item type.\n * @param {Array<T>} list\n *   List to inject into.\n * @param {ReadonlyArray<T>} right\n *   Items to inject.\n * @return {undefined}\n *   Nothing.\n */\nfunction chunkedPush(list, right) {\n  /** @type {number} */\n  let chunkStart = 0\n\n  if (right.length < constants.v8MaxSafeChunkSize) {\n    list.push(...right)\n  } else {\n    while (chunkStart < right.length) {\n      list.push(\n        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)\n      )\n      chunkStart += constants.v8MaxSafeChunkSize\n    }\n  }\n}\n", "/**\n * @import {Chunk, Event, Token} from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {splice} from 'micromark-util-chunked'\nimport {codes, types} from 'micromark-util-symbol'\nimport {SpliceBuffer} from './lib/splice-buffer.js'\n\n// Hidden API exposed for testing.\nexport {SpliceBuffer} from './lib/splice-buffer.js'\n\n/**\n * Tokenize subcontent.\n *\n * @param {Array<Event>} eventsArray\n *   List of events.\n * @returns {boolean}\n *   Whether subtokens were found.\n */\n// eslint-disable-next-line complexity\nexport function subtokenize(eventsArray) {\n  /** @type {Record<string, number>} */\n  const jumps = {}\n  let index = -1\n  /** @type {Event} */\n  let event\n  /** @type {number | undefined} */\n  let lineIndex\n  /** @type {number} */\n  let otherIndex\n  /** @type {Event} */\n  let otherEvent\n  /** @type {Array<Event>} */\n  let parameters\n  /** @type {Array<Event>} */\n  let subevents\n  /** @type {boolean | undefined} */\n  let more\n  const events = new SpliceBuffer(eventsArray)\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index]\n    }\n\n    event = events.get(index)\n\n    // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n    if (\n      index &&\n      event[1].type === types.chunkFlow &&\n      events.get(index - 1)[1].type === types.listItemPrefix\n    ) {\n      assert(event[1]._tokenizer, 'expected `_tokenizer` on subtokens')\n      subevents = event[1]._tokenizer.events\n      otherIndex = 0\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === types.lineEndingBlank\n      ) {\n        otherIndex += 2\n      }\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === types.content\n      ) {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === types.content) {\n            break\n          }\n\n          if (subevents[otherIndex][1].type === types.chunkText) {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true\n            otherIndex++\n          }\n        }\n      }\n    }\n\n    // Enter.\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index))\n        index = jumps[index]\n        more = true\n      }\n    }\n    // Exit.\n    else if (event[1]._container) {\n      otherIndex = index\n      lineIndex = undefined\n\n      while (otherIndex--) {\n        otherEvent = events.get(otherIndex)\n\n        if (\n          otherEvent[1].type === types.lineEnding ||\n          otherEvent[1].type === types.lineEndingBlank\n        ) {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events.get(lineIndex)[1].type = types.lineEndingBlank\n            }\n\n            otherEvent[1].type = types.lineEnding\n            lineIndex = otherIndex\n          }\n        } else if (\n          otherEvent[1].type === types.linePrefix ||\n          otherEvent[1].type === types.listItemIndent\n        ) {\n          // Move past.\n        } else {\n          break\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = {...events.get(lineIndex)[1].start}\n\n        // Switch container exit w/ line endings.\n        parameters = events.slice(lineIndex, index)\n        parameters.unshift(event)\n        events.splice(lineIndex, index - lineIndex + 1, parameters)\n      }\n    }\n  }\n\n  // The changes to the `events` buffer must be copied back into the eventsArray\n  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0))\n  return !more\n}\n\n/**\n * Tokenize embedded tokens.\n *\n * @param {SpliceBuffer<Event>} events\n *   Events.\n * @param {number} eventIndex\n *   Index.\n * @returns {Record<string, number>}\n *   Gaps.\n */\nfunction subcontent(events, eventIndex) {\n  const token = events.get(eventIndex)[1]\n  const context = events.get(eventIndex)[2]\n  let startPosition = eventIndex - 1\n  /** @type {Array<number>} */\n  const startPositions = []\n  assert(token.contentType, 'expected `contentType` on subtokens')\n\n  let tokenizer = token._tokenizer\n\n  if (!tokenizer) {\n    tokenizer = context.parser[token.contentType](token.start)\n\n    if (token._contentTypeTextTrailing) {\n      tokenizer._contentTypeTextTrailing = true\n    }\n  }\n\n  const childEvents = tokenizer.events\n  /** @type {Array<[number, number]>} */\n  const jumps = []\n  /** @type {Record<string, number>} */\n  const gaps = {}\n  /** @type {Array<Chunk>} */\n  let stream\n  /** @type {Token | undefined} */\n  let previous\n  let index = -1\n  /** @type {Token | undefined} */\n  let current = token\n  let adjust = 0\n  let start = 0\n  const breaks = [start]\n\n  // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n  while (current) {\n    // Find the position of the event for this token.\n    while (events.get(++startPosition)[1] !== current) {\n      // Empty.\n    }\n\n    assert(\n      !previous || current.previous === previous,\n      'expected previous to match'\n    )\n    assert(!previous || previous.next === current, 'expected next to match')\n\n    startPositions.push(startPosition)\n\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current)\n\n      if (!current.next) {\n        stream.push(codes.eof)\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(current.start)\n      }\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true\n      }\n\n      tokenizer.write(stream)\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\n      }\n    }\n\n    // Unravel the next token.\n    previous = current\n    current = current.next\n  }\n\n  // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n  current = token\n\n  while (++index < childEvents.length) {\n    if (\n      // Find a void token that includes a break.\n      childEvents[index][0] === 'exit' &&\n      childEvents[index - 1][0] === 'enter' &&\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\n    ) {\n      assert(current, 'expected a current token')\n      start = index + 1\n      breaks.push(start)\n      // Help GC.\n      current._tokenizer = undefined\n      current.previous = undefined\n      current = current.next\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = []\n\n  // If theres one more token (which is the cases for lines that end in an\n  // EOF), thats perfect: the last point we found starts it.\n  // If there isnt then make sure any remaining content is added to it.\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined\n    current.previous = undefined\n    assert(!current.next, 'expected no next token')\n  } else {\n    breaks.pop()\n  }\n\n  // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices arent affected.\n  index = breaks.length\n\n  while (index--) {\n    const slice = childEvents.slice(breaks[index], breaks[index + 1])\n    const start = startPositions.pop()\n    assert(start !== undefined, 'expected a start position when splicing')\n    jumps.push([start, start + slice.length - 1])\n    events.splice(start, 2, slice)\n  }\n\n  jumps.reverse()\n  index = -1\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\n    adjust += jumps[index][1] - jumps[index][0] - 1\n  }\n\n  return gaps\n}\n", "/**\n * @import {\n *   Construct,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {subtokenize} from 'micromark-util-subtokenize'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/**\n * No name because it must not be turned off.\n * @type {Construct}\n */\nexport const content = {resolve: resolveContent, tokenize: tokenizeContent}\n\n/** @type {Construct} */\nconst continuationConstruct = {partial: true, tokenize: tokenizeContinuation}\n\n/**\n * Content is transparent: its parsed right now. That way, definitions are also\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\n *\n * @type {Resolver}\n */\nfunction resolveContent(events) {\n  subtokenize(events)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeContent(effects, ok) {\n  /** @type {Token | undefined} */\n  let previous\n\n  return chunkStart\n\n  /**\n   * Before a content chunk.\n   *\n   * ```markdown\n   * > | abc\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function chunkStart(code) {\n    assert(\n      code !== codes.eof && !markdownLineEnding(code),\n      'expected no eof or eol'\n    )\n\n    effects.enter(types.content)\n    previous = effects.enter(types.chunkContent, {\n      contentType: constants.contentTypeContent\n    })\n    return chunkInside(code)\n  }\n\n  /**\n   * In a content chunk.\n   *\n   * ```markdown\n   * > | abc\n   *     ^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function chunkInside(code) {\n    if (code === codes.eof) {\n      return contentEnd(code)\n    }\n\n    // To do: in `markdown-rs`, each line is parsed on its own, and everything\n    // is stitched together resolving.\n    if (markdownLineEnding(code)) {\n      return effects.check(\n        continuationConstruct,\n        contentContinue,\n        contentEnd\n      )(code)\n    }\n\n    // Data.\n    effects.consume(code)\n    return chunkInside\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function contentEnd(code) {\n    effects.exit(types.chunkContent)\n    effects.exit(types.content)\n    return ok(code)\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function contentContinue(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.consume(code)\n    effects.exit(types.chunkContent)\n    assert(previous, 'expected previous token')\n    previous.next = effects.enter(types.chunkContent, {\n      contentType: constants.contentTypeContent,\n      previous\n    })\n    previous = previous.next\n    return chunkInside\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeContinuation(effects, ok, nok) {\n  const self = this\n\n  return startLookahead\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function startLookahead(code) {\n    assert(markdownLineEnding(code), 'expected a line ending')\n    effects.exit(types.chunkContent)\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return factorySpace(effects, prefixed, types.linePrefix)\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function prefixed(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    // Always populated by defaults.\n    assert(\n      self.parser.constructs.disable.null,\n      'expected `disable.null` to be populated'\n    )\n\n    const tail = self.events[self.events.length - 1]\n\n    if (\n      !self.parser.constructs.disable.null.includes('codeIndented') &&\n      tail &&\n      tail[1].type === types.linePrefix &&\n      tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\n    ) {\n      return ok(code)\n    }\n\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)\n  }\n}\n", "/**\n * @import {Effects, State, TokenType} from 'micromark-util-types'\n */\n\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/**\n * Parse destinations.\n *\n * ###### Examples\n *\n * ```markdown\n * <a>\n * <a\\>b>\n * <a b>\n * <a)>\n * a\n * a\\)b\n * a(b)c\n * a(b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type for whole (`<a>` or `b`).\n * @param {TokenType} literalType\n *   Type when enclosed (`<a>`).\n * @param {TokenType} literalMarkerType\n *   Type for enclosing (`<` and `>`).\n * @param {TokenType} rawType\n *   Type when not enclosed (`b`).\n * @param {TokenType} stringType\n *   Type for the value (`a` or `b`).\n * @param {number | undefined} [max=Infinity]\n *   Depth of nested parens (inclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n\n  return start\n\n  /**\n   * Start of destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *     ^\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === codes.lessThan) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return enclosedBefore\n    }\n\n    // ASCII control, space, closing paren.\n    if (\n      code === codes.eof ||\n      code === codes.space ||\n      code === codes.rightParenthesis ||\n      asciiControl(code)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return raw(code)\n  }\n\n  /**\n   * After `<`, at an enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedBefore(code) {\n    if (code === codes.greaterThan) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return enclosed(code)\n  }\n\n  /**\n   * In enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosed(code) {\n    if (code === codes.greaterThan) {\n      effects.exit(types.chunkString)\n      effects.exit(stringType)\n      return enclosedBefore(code)\n    }\n\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      markdownLineEnding(code)\n    ) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash ? enclosedEscape : enclosed\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | <a\\*a>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedEscape(code) {\n    if (\n      code === codes.lessThan ||\n      code === codes.greaterThan ||\n      code === codes.backslash\n    ) {\n      effects.consume(code)\n      return enclosed\n    }\n\n    return enclosed(code)\n  }\n\n  /**\n   * In raw destination.\n   *\n   * ```markdown\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function raw(code) {\n    if (\n      !balance &&\n      (code === codes.eof ||\n        code === codes.rightParenthesis ||\n        markdownLineEndingOrSpace(code))\n    ) {\n      effects.exit(types.chunkString)\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n\n    if (balance < limit && code === codes.leftParenthesis) {\n      effects.consume(code)\n      balance++\n      return raw\n    }\n\n    if (code === codes.rightParenthesis) {\n      effects.consume(code)\n      balance--\n      return raw\n    }\n\n    // ASCII control (but *not* `\\0`) and space and `(`.\n    // Note: in `markdown-rs`, `\\0` exists in codes, in `micromark-js` it\n    // doesnt.\n    if (\n      code === codes.eof ||\n      code === codes.space ||\n      code === codes.leftParenthesis ||\n      asciiControl(code)\n    ) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash ? rawEscape : raw\n  }\n\n  /**\n   * After `\\`, at special character.\n   *\n   * ```markdown\n   * > | a\\*a\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function rawEscape(code) {\n    if (\n      code === codes.leftParenthesis ||\n      code === codes.rightParenthesis ||\n      code === codes.backslash\n    ) {\n      effects.consume(code)\n      return raw\n    }\n\n    return raw(code)\n  }\n}\n", "/**\n * @import {\n *   Effects,\n *   State,\n *   TokenizeContext,\n *   TokenType\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/**\n * Parse labels.\n *\n * >  **Note**: labels in markdown are capped at 999 characters in the string.\n *\n * ###### Examples\n *\n * ```markdown\n * [a]\n * [a\n * b]\n * [a\\]b]\n * ```\n *\n * @this {TokenizeContext}\n *   Tokenize context.\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type of the whole label (`[a]`).\n * @param {TokenType} markerType\n *   Type for the markers (`[` and `]`).\n * @param {TokenType} stringType\n *   Type for the identifier (`a`).\n * @returns {State}\n *   Start state.\n */\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this\n  let size = 0\n  /** @type {boolean} */\n  let seen\n\n  return start\n\n  /**\n   * Start of label.\n   *\n   * ```markdown\n   * > | [a]\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n\n  /**\n   * In label, at something, before something else.\n   *\n   * ```markdown\n   * > | [a]\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (\n      size > constants.linkReferenceSizeMax ||\n      code === codes.eof ||\n      code === codes.leftSquareBracket ||\n      (code === codes.rightSquareBracket && !seen) ||\n      // To do: remove in the future once weve switched from\n      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n      // which doesnt need this.\n      // Hidden footnotes hook.\n      /* c8 ignore next 3 */\n      (code === codes.caret &&\n        !size &&\n        '_hiddenFootnoteSupport' in self.parser.constructs)\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    // To do: indent? Link chunks and EOLs together?\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return atBreak\n    }\n\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return labelInside(code)\n  }\n\n  /**\n   * In label, in text.\n   *\n   * ```markdown\n   * > | [a]\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      code === codes.eof ||\n      code === codes.leftSquareBracket ||\n      code === codes.rightSquareBracket ||\n      markdownLineEnding(code) ||\n      size++ > constants.linkReferenceSizeMax\n    ) {\n      effects.exit(types.chunkString)\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    if (!seen) seen = !markdownSpace(code)\n    return code === codes.backslash ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | [a\\*a]\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (\n      code === codes.leftSquareBracket ||\n      code === codes.backslash ||\n      code === codes.rightSquareBracket\n    ) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n\n    return labelInside(code)\n  }\n}\n", "/**\n * @import {\n *   Code,\n *   Effects,\n *   State,\n *   TokenType\n * } from 'micromark-util-types'\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/**\n * Parse titles.\n *\n * ###### Examples\n *\n * ```markdown\n * \"a\"\n * 'b'\n * (c)\n * \"a\n * b\"\n * 'a\n *     b'\n * (a\\)b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type of the whole title (`\"a\"`, `'b'`, `(c)`).\n * @param {TokenType} markerType\n *   Type for the markers (`\"`, `'`, `(`, and `)`).\n * @param {TokenType} stringType\n *   Type for the value (`a`).\n * @returns {State}\n *   Start state.\n */\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /**\n   * Start of title.\n   *\n   * ```markdown\n   * > | \"a\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      effects.enter(type)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      marker = code === codes.leftParenthesis ? codes.rightParenthesis : code\n      return begin\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After opening marker.\n   *\n   * This is also used at the closing marker.\n   *\n   * ```markdown\n   * > | \"a\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function begin(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    return atBreak(code)\n  }\n\n  /**\n   * At something, before something else.\n   *\n   * ```markdown\n   * > | \"a\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return begin(marker)\n    }\n\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    // Note: blank lines cant exist in content.\n    if (markdownLineEnding(code)) {\n      // To do: use `space_or_tab_eol_with_options`, connect.\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return factorySpace(effects, atBreak, types.linePrefix)\n    }\n\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return inside(code)\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker || code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash ? escape : inside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | \"a\\*b\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function escape(code) {\n    if (code === marker || code === codes.backslash) {\n      effects.consume(code)\n      return inside\n    }\n\n    return inside(code)\n  }\n}\n", "/**\n * @import {Effects, State} from 'micromark-util-types'\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {types} from 'micromark-util-symbol'\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   line endings or spaces in markdown are often optional, in which case this\n *     factory can be used and `ok` will be switched to whether spaces were found\n *     or not\n * *   one line ending or space can be detected with\n *     `markdownLineEndingOrSpace(code)` right before using `factoryWhitespace`\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @returns {State}\n *   Start state.\n */\nexport function factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  let seen\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      seen = true\n      return start\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? types.linePrefix : types.lineSuffix\n      )(code)\n    }\n\n    return ok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {codes, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const definition = {name: 'definition', tokenize: tokenizeDefinition}\n\n/** @type {Construct} */\nconst titleBefore = {partial: true, tokenize: tokenizeTitleBefore}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n  let identifier\n\n  return start\n\n  /**\n   * At start of a definition.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Do not interrupt paragraphs (but do follow definitions).\n    // To do: do `interrupt` the way `markdown-rs` does.\n    // To do: parse whitespace the way `markdown-rs` does.\n    effects.enter(types.definition)\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at `[`.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    // To do: parse whitespace the way `markdown-rs` does.\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      // Note: we dont need to reset the way `markdown-rs` does.\n      nok,\n      types.definitionLabel,\n      types.definitionLabelMarker,\n      types.definitionLabelString\n    )(code)\n  }\n\n  /**\n   * After label.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === codes.colon) {\n      effects.enter(types.definitionMarker)\n      effects.consume(code)\n      effects.exit(types.definitionMarker)\n      return markerAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After marker.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function markerAfter(code) {\n    // Note: whitespace is optional.\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, destinationBefore)(code)\n      : destinationBefore(code)\n  }\n\n  /**\n   * Before destination.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function destinationBefore(code) {\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      // Note: we dont need to reset the way `markdown-rs` does.\n      nok,\n      types.definitionDestination,\n      types.definitionDestinationLiteral,\n      types.definitionDestinationLiteralMarker,\n      types.definitionDestinationRaw,\n      types.definitionDestinationString\n    )(code)\n  }\n\n  /**\n   * After destination.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function destinationAfter(code) {\n    return effects.attempt(titleBefore, after, after)(code)\n  }\n\n  /**\n   * After definition.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return markdownSpace(code)\n      ? factorySpace(effects, afterWhitespace, types.whitespace)(code)\n      : afterWhitespace(code)\n  }\n\n  /**\n   * After definition, after optional whitespace.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterWhitespace(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.definition)\n\n      // Note: we dont care about uniqueness.\n      // Its likely that that doesnt happen very frequently.\n      // It is more likely that it wastes precious time.\n      self.parser.defined.push(identifier)\n\n      // To do: `markdown-rs` interrupt.\n      // // Youd be interrupting.\n      // tokenizer.interrupt = true\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeTitleBefore(effects, ok, nok) {\n  return titleBefore\n\n  /**\n   * After destination, at whitespace.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, beforeMarker)(code)\n      : nok(code)\n  }\n\n  /**\n   * At title.\n   *\n   * ```markdown\n   *   | [a]: b\n   * > | \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeMarker(code) {\n    return factoryTitle(\n      effects,\n      titleAfter,\n      nok,\n      types.definitionTitle,\n      types.definitionTitleMarker,\n      types.definitionTitleString\n    )(code)\n  }\n\n  /**\n   * After title.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleAfter(code) {\n    return markdownSpace(code)\n      ? factorySpace(\n          effects,\n          titleAfterOptionalWhitespace,\n          types.whitespace\n        )(code)\n      : titleAfterOptionalWhitespace(code)\n  }\n\n  /**\n   * After title, after optional whitespace.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleAfterOptionalWhitespace(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const hardBreakEscape = {\n  name: 'hardBreakEscape',\n  tokenize: tokenizeHardBreakEscape\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of a hard break (escape).\n   *\n   * ```markdown\n   * > | a\\\n   *      ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.backslash, 'expected `\\\\`')\n    effects.enter(types.hardBreakEscape)\n    effects.consume(code)\n    return after\n  }\n\n  /**\n   * After `\\`, at eol.\n   *\n   * ```markdown\n   * > | a\\\n   *       ^\n   *   | b\n   * ```\n   *\n   *  @type {State}\n   */\n  function after(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit(types.hardBreakEscape)\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  resolve: resolveHeadingAtx,\n  tokenize: tokenizeHeadingAtx\n}\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n  let content\n  /** @type {Token} */\n  let text\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === types.whitespace) {\n    contentStart += 2\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === types.whitespace\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === types.atxHeadingSequence &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === types.whitespace))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: types.atxHeadingText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: types.chunkText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: constants.contentTypeText\n    }\n\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  let size = 0\n\n  return start\n\n  /**\n   * Start of a heading (atx).\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    effects.enter(types.atxHeading)\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at `#`.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    assert(code === codes.numberSign, 'expected `#`')\n    effects.enter(types.atxHeadingSequence)\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (\n      code === codes.numberSign &&\n      size++ < constants.atxHeadingOpeningFenceSizeMax\n    ) {\n      effects.consume(code)\n      return sequenceOpen\n    }\n\n    // Always at least one `#`.\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingSequence)\n      return atBreak(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ## aa\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.atxHeadingSequence)\n      return sequenceFurther(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.atxHeading)\n      // To do: interrupt like `markdown-rs`.\n      // // Feel free to interrupt.\n      // tokenizer.interrupt = false\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, types.whitespace)(code)\n    }\n\n    // To do: generate `data` tokens, add the `text` token later.\n    // Needs edit map, see: `markdown.rs`.\n    effects.enter(types.atxHeadingText)\n    return data(code)\n  }\n\n  /**\n   * In further sequence (after whitespace).\n   *\n   * Could be normal visible hashes in the heading or a final sequence.\n   *\n   * ```markdown\n   * > | ## aa ##\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceFurther(code) {\n    if (code === codes.numberSign) {\n      effects.consume(code)\n      return sequenceFurther\n    }\n\n    effects.exit(types.atxHeadingSequence)\n    return atBreak(code)\n  }\n\n  /**\n   * In text.\n   *\n   * ```markdown\n   * > | ## aa\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (\n      code === codes.eof ||\n      code === codes.numberSign ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit(types.atxHeadingText)\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n", "/**\n * List of lowercase HTML block tag names.\n *\n * The list, when parsing HTML (flow), results in more relaxed rules (condition\n * 6).\n * Because they are known blocks, the HTML-like syntax doesnt have to be\n * strictly parsed.\n * For tag names not in this list, a more strict algorithm (condition 7) is used\n * to detect whether the HTML-like syntax is seen as HTML (flow) or not.\n *\n * This is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n *\n * >  **Note**: `search` was added in `CommonMark@0.31`.\n */\nexport const htmlBlockNames = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'search',\n  'section',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]\n\n/**\n * List of lowercase HTML raw tag names.\n *\n * The list, when parsing HTML (flow), results in HTML that can include lines\n * without exiting, until a closing tag also in this list is found (condition\n * 1).\n *\n * This module is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n *\n * >  **Note**: `textarea` was added in `CommonMark@0.30`.\n */\nexport const htmlRawNames = ['pre', 'script', 'style', 'textarea']\n", "/**\n * @import {\n *   Code,\n *   Construct,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {\n  asciiAlphanumeric,\n  asciiAlpha,\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {codes, constants, types} from 'micromark-util-symbol'\nimport {blankLine} from './blank-line.js'\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  concrete: true,\n  name: 'htmlFlow',\n  resolveTo: resolveToHtmlFlow,\n  tokenize: tokenizeHtmlFlow\n}\n\n/** @type {Construct} */\nconst blankLineBefore = {partial: true, tokenize: tokenizeBlankLineBefore}\nconst nonLazyContinuationStart = {\n  partial: true,\n  tokenize: tokenizeNonLazyContinuationStart\n}\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n\n  while (index--) {\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === types.htmlFlow\n    ) {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start\n    // Remove the line prefix.\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n  let marker\n  /** @type {boolean} */\n  let closingTag\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {Code} */\n  let markerB\n\n  return start\n\n  /**\n   * Start of HTML (flow).\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * At `<`, after optional whitespace.\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlFlow)\n    effects.enter(types.htmlFlowData)\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | <x />\n   *      ^\n   * > | <!doctype>\n   *      ^\n   * > | <!--xxx-->\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      closingTag = true\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      marker = constants.htmlInstruction\n      // To do:\n      // tokenizer.concrete = true\n      // To do: use `markdown-rs` style interrupt.\n      // While were in an instruction instead of a declaration, were on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      assert(code !== null) // Always the case.\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *       ^\n   * > | <!--xxx-->\n   *       ^\n   * > | <![CDATA[>&<]]>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      marker = constants.htmlComment\n      return commentOpenInside\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      marker = constants.htmlCdata\n      index = 0\n      return cdataOpenInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      marker = constants.htmlDeclaration\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<!-`, inside a comment, at another `-`.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<![`, inside CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *        ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString\n\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n\n      if (index === value.length) {\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok : continuation\n      }\n\n      return cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | </x>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      assert(code !== null) // Always the case.\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In tag name.\n   *\n   * ```markdown\n   * > | <ab>\n   *      ^^\n   * > | </ab>\n   *       ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagName(code) {\n    if (\n      code === codes.eof ||\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      const slash = code === codes.slash\n      const name = buffer.toLowerCase()\n\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = constants.htmlRaw\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = constants.htmlBasic\n\n        if (slash) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      marker = constants.htmlComplete\n      // Do not support complete HTML when interrupting.\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : closingTag\n          ? completeClosingTagAfter(code)\n          : completeAttributeNameBefore(code)\n    }\n\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a basic tag name.\n   *\n   * ```markdown\n   * > | <div/>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a complete tag name.\n   *\n   * ```markdown\n   * > | <x/>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n\n  /**\n   * At an attribute name.\n   *\n   * At first, this state is used after a complete tag name, after whitespace,\n   * where it expects optional attributes or the end of the tag.\n   * It is also reused after attributes, when expecting more optional\n   * attributes.\n   *\n   * ```markdown\n   * > | <a />\n   *        ^\n   * > | <a :b>\n   *        ^\n   * > | <a _b>\n   *        ^\n   * > | <a b>\n   *        ^\n   * > | <a >\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    // ASCII alphanumerical and `:` and `_`.\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | <a :b>\n   *         ^\n   * > | <a _b>\n   *         ^\n   * > | <a b>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeName(code) {\n    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, at an optional initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b>\n   *         ^\n   * > | <a b=c>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * > | <a b=\"c\">\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      markerB = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    return completeAttributeValueUnquoted(code)\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *           ^\n   * > | <a b='c'>\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code)\n      markerB = null\n      return completeAttributeValueQuotedAfter\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.slash ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the\n   * end of the tag.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownSpace(code)\n    ) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a complete tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `>` in a complete tag.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return continuation(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In continuation of any HTML kind.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuation(code) {\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === codes.lessThan && marker === constants.htmlRaw) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === codes.greaterThan && marker === constants.htmlDeclaration) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === codes.questionMark && marker === constants.htmlInstruction) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === codes.rightSquareBracket && marker === constants.htmlCdata) {\n      effects.consume(code)\n      return continuationCdataInside\n    }\n\n    if (\n      markdownLineEnding(code) &&\n      (marker === constants.htmlBasic || marker === constants.htmlComplete)\n    ) {\n      effects.exit(types.htmlFlowData)\n      return effects.check(\n        blankLineBefore,\n        continuationAfter,\n        continuationStart\n      )(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData)\n      return continuationStart(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n\n  /**\n   * In continuation, at eol.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStart(code) {\n    return effects.check(\n      nonLazyContinuationStart,\n      continuationStartNonLazy,\n      continuationAfter\n    )(code)\n  }\n\n  /**\n   * In continuation, at eol, before non-lazy content.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStartNonLazy(code) {\n    assert(markdownLineEnding(code))\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return continuationBefore\n  }\n\n  /**\n   * In continuation, before non-lazy content.\n   *\n   * ```markdown\n   *   | <x>\n   * > | asd\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationStart(code)\n    }\n\n    effects.enter(types.htmlFlowData)\n    return continuation(code)\n  }\n\n  /**\n   * In comment continuation, after one `-`, expecting another.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `<`, at `/`.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `</`, in a raw tag name.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                             ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawEndTag(code) {\n    if (code === codes.greaterThan) {\n      const name = buffer.toLowerCase()\n\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code)\n        return continuationClose\n      }\n\n      return continuation(code)\n    }\n\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      assert(code !== null) // Always the case.\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In cdata continuation, after `]`, expecting `]>`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *                  ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCdataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In declaration or instruction continuation, at `>`.\n   *\n   * ```markdown\n   * > | <!-->\n   *         ^\n   * > | <?>\n   *       ^\n   * > | <!q>\n   *        ^\n   * > | <!--ab-->\n   *             ^\n   * > | <![CDATA[>&<]]>\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    // More dashes.\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /**\n   * In closed continuation: everything we get until the eol/eof is part of it.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData)\n      return continuationAfter(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n\n  /**\n   * Done.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationAfter(code) {\n    effects.exit(types.htmlFlow)\n    // // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    // // No longer concrete.\n    // tokenizer.concrete = false\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuationStart(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * At eol, before continuation.\n   *\n   * ```markdown\n   * > | * ```js\n   *            ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * A continuation.\n   *\n   * ```markdown\n   *   | * ```js\n   * > | b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLineBefore(effects, ok, nok) {\n  return start\n\n  /**\n   * Before eol, expecting blank line.\n   *\n   * ```markdown\n   * > | <div>\n   *          ^\n   *   |\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n", "/**\n * @import {\n *   Code,\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlphanumeric,\n  asciiAlpha,\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const htmlText = {name: 'htmlText', tokenize: tokenizeHtmlText}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code> | undefined} */\n  let marker\n  /** @type {number} */\n  let index\n  /** @type {State} */\n  let returnState\n\n  return start\n\n  /**\n   * Start of HTML (text).\n   *\n   * ```markdown\n   * > | a <b> c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlText)\n    effects.enter(types.htmlTextData)\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | a <b> c\n   *        ^\n   * > | a <!doctype> c\n   *        ^\n   * > | a <!--b--> c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      return instruction\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | a <!doctype> c\n   *         ^\n   * > | a <!--b--> c\n   *         ^\n   * > | a <![CDATA[>&<]]> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentOpenInside\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In a comment, after `<!-`, at another `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentEnd\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In comment.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function comment(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n\n  /**\n   * In comment, after `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentClose(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentEnd\n    }\n\n    return comment(code)\n  }\n\n  /**\n   * In comment, after `--`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentEnd(code) {\n    return code === codes.greaterThan\n      ? end(code)\n      : code === codes.dash\n        ? commentClose(code)\n        : comment(code)\n  }\n\n  /**\n   * After `<![`, in CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *          ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString\n\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === value.length ? cdata : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In CDATA.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                ^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdata(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n\n  /**\n   * In CDATA, after `]`, at another `]`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataClose(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  /**\n   * In CDATA, after `]]`, at `>`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataEnd(code) {\n    if (code === codes.greaterThan) {\n      return end(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  /**\n   * In declaration.\n   *\n   * ```markdown\n   * > | a <!b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declaration(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n\n  /**\n   * In instruction.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instruction(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n\n  /**\n   * In instruction, after `?`, at `>`.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instructionClose(code) {\n    return code === codes.greaterThan ? end(code) : instruction(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `</x`, in a tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagClose(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n\n  /**\n   * In closing tag, after tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return lineEndingBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n\n  /**\n   * After `<x`, in opening tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpen(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In opening tag, after tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenBetween(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return end\n    }\n\n    // ASCII alphabetical and `:` and `_`.\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return lineEndingBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeName(code) {\n    // ASCII alphabetical and `-`, `.`, `:`, and `_`.\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, before initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return lineEndingBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return lineEndingBefore(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      marker = undefined\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return lineEndingBefore(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the end\n   * of the tag.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function end(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      effects.exit(types.htmlTextData)\n      effects.exit(types.htmlText)\n      return ok\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * At eol.\n   *\n   * >  **Note**: we cant have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   * > | a <!--a\n   *            ^\n   *   | b-->\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingBefore(code) {\n    assert(returnState, 'expected return state')\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.exit(types.htmlTextData)\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineEndingAfter\n  }\n\n  /**\n   * After eol, at optional whitespace.\n   *\n   * >  **Note**: we cant have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfter(code) {\n    // Always populated by defaults.\n    assert(\n      self.parser.constructs.disable.null,\n      'expected `disable.null` to be populated'\n    )\n    return markdownSpace(code)\n      ? factorySpace(\n          effects,\n          lineEndingAfterPrefix,\n          types.linePrefix,\n          self.parser.constructs.disable.null.includes('codeIndented')\n            ? undefined\n            : constants.tabSize\n        )(code)\n      : lineEndingAfterPrefix(code)\n  }\n\n  /**\n   * After eol, after optional whitespace.\n   *\n   * >  **Note**: we cant have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfterPrefix(code) {\n    effects.enter(types.htmlTextData)\n    return returnState(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   Event,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  resolveAll: resolveAllLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  tokenize: tokenizeLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {tokenize: tokenizeResource}\n/** @type {Construct} */\nconst referenceFullConstruct = {tokenize: tokenizeReferenceFull}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {tokenize: tokenizeReferenceCollapsed}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Array<Event>} */\n  const newEvents = []\n  while (++index < events.length) {\n    const token = events[index][1]\n    newEvents.push(events[index])\n\n    if (\n      token.type === types.labelImage ||\n      token.type === types.labelLink ||\n      token.type === types.labelEnd\n    ) {\n      // Remove the marker.\n      const offset = token.type === types.labelImage ? 4 : 2\n      token.type = types.data\n      index += offset\n    }\n  }\n\n  // If the events are equal, we don't have to copy newEvents to events\n  if (events.length !== newEvents.length) {\n    splice(events, 0, events.length, newEvents)\n  }\n\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, weve been here before.\n      if (\n        token.type === types.link ||\n        (token.type === types.labelLink && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we cant have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === types.labelImage || token.type === types.labelLink) &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== types.labelLink) {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found')\n  assert(close !== undefined, '`close` is supposed to be found')\n\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: {...events[open][1].start},\n    end: {...events[events.length - 1][1].end}\n  }\n\n  const label = {\n    type: types.label,\n    start: {...events[open][1].start},\n    end: {...events[close][1].end}\n  }\n\n  const text = {\n    type: types.labelText,\n    start: {...events[open + offset + 2][1].end},\n    end: {...events[close - 2][1].start}\n  }\n\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n  assert(\n    context.parser.constructs.insideSpan.null,\n    'expected `insideSpan.null` to be populated'\n  )\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n\n  splice(events, open, events.length, media)\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === types.labelImage ||\n        self.events[index][1].type === types.labelLink) &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means wed be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We cant have that, so its just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({start: labelStart.end, end: self.now()})\n      )\n    )\n    effects.enter(types.labelEnd)\n    effects.enter(types.labelMarker)\n    effects.consume(code)\n    effects.exit(types.labelMarker)\n    effects.exit(types.labelEnd)\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * >  **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, its nothing.\n   *\n   * There was an okay opening, but we didnt match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren')\n    effects.enter(types.resource)\n    effects.enter(types.resourceMarker)\n    effects.consume(code)\n    effects.exit(types.resourceMarker)\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === codes.rightParenthesis) {\n      return resourceEnd(code)\n    }\n\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      types.resourceDestination,\n      types.resourceDestinationLiteral,\n      types.resourceDestinationLiteralMarker,\n      types.resourceDestinationRaw,\n      types.resourceDestinationString,\n      constants.linkResourceDestinationBalanceMax\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        types.resourceTitle,\n        types.resourceTitleMarker,\n        types.resourceTitleString\n      )(code)\n    }\n\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker)\n      effects.consume(code)\n      effects.exit(types.resourceMarker)\n      effects.exit(types.resource)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      types.reference,\n      types.referenceMarker,\n      types.referenceString\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * >  **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if theres a `[`.\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    effects.enter(types.reference)\n    effects.enter(types.referenceMarker)\n    effects.consume(code)\n    effects.exit(types.referenceMarker)\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * >  **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker)\n      effects.consume(code)\n      effects.exit(types.referenceMarker)\n      effects.exit(types.reference)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {codes, types} from 'micromark-util-symbol'\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartImage = {\n  name: 'labelStartImage',\n  resolveAll: labelEnd.resolveAll,\n  tokenize: tokenizeLabelStartImage\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * Start of label (image) start.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.exclamationMark, 'expected `!`')\n    effects.enter(types.labelImage)\n    effects.enter(types.labelImageMarker)\n    effects.consume(code)\n    effects.exit(types.labelImageMarker)\n    return open\n  }\n\n  /**\n   * After `!`, at `[`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.leftSquareBracket) {\n      effects.enter(types.labelMarker)\n      effects.consume(code)\n      effects.exit(types.labelMarker)\n      effects.exit(types.labelImage)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After `![`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *         ^\n   * ```\n   *\n   * This is needed in because, when GFM footnotes are enabled, images never\n   * form when started with a `^`.\n   * Instead, links form:\n   *\n   * ```markdown\n   * ![^a](b)\n   *\n   * ![^a][b]\n   *\n   * [b]: c\n   * ```\n   *\n   * ```html\n   * <p>!<a href=\\\"b\\\">^a</a></p>\n   * <p>!<a href=\\\"c\\\">^a</a></p>\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // To do: use a new field to do this, this is still needed for\n    // `micromark-extension-gfm-footnote`, but the `label-start-link`\n    // behavior isnt.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === codes.caret &&\n      '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {codes, types} from 'micromark-util-symbol'\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartLink = {\n  name: 'labelStartLink',\n  resolveAll: labelEnd.resolveAll,\n  tokenize: tokenizeLabelStartLink\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * Start of label (link) start.\n   *\n   * ```markdown\n   * > | a [b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter(types.labelLink)\n    effects.enter(types.labelMarker)\n    effects.consume(code)\n    effects.exit(types.labelMarker)\n    effects.exit(types.labelLink)\n    return after\n  }\n\n  /** @type {State} */\n  function after(code) {\n    // To do: this isnt needed in `micromark-extension-gfm-footnote`,\n    // remove.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === codes.caret &&\n      '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n", "/**\n * @import {\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const lineEnding = {name: 'lineEnding', tokenize: tokenizeLineEnding}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return factorySpace(effects, ok, types.linePrefix)\n  }\n}\n", "/**\n * @import {\n *   Code,\n *   Construct,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  let size = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /**\n   * Start of thematic break.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter(types.thematicBreak)\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at marker.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    assert(\n      code === codes.asterisk ||\n        code === codes.dash ||\n        code === codes.underscore,\n      'expected `*`, `-`, or `_`'\n    )\n    marker = code\n    return atBreak(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter(types.thematicBreakSequence)\n      return sequence(code)\n    }\n\n    if (\n      size >= constants.thematicBreakMarkerCountMin &&\n      (code === codes.eof || markdownLineEnding(code))\n    ) {\n      effects.exit(types.thematicBreak)\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n\n    effects.exit(types.thematicBreakSequence)\n    return markdownSpace(code)\n      ? factorySpace(effects, atBreak, types.whitespace)(code)\n      : atBreak(code)\n  }\n}\n", "/**\n * @import {\n *   Code,\n *   Construct,\n *   Exiter,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {codes, constants, types} from 'micromark-util-symbol'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/** @type {Construct} */\nexport const list = {\n  continuation: {tokenize: tokenizeListContinuation},\n  exit: tokenizeListEnd,\n  name: 'list',\n  tokenize: tokenizeListStart\n}\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  partial: true,\n  tokenize: tokenizeListItemPrefixWhitespace\n}\n\n/** @type {Construct} */\nconst indentConstruct = {partial: true, tokenize: tokenizeIndent}\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(self.containerState, 'expected state')\n    const kind =\n      self.containerState.type ||\n      (code === codes.asterisk || code === codes.plusSign || code === codes.dash\n        ? types.listUnordered\n        : types.listOrdered)\n\n    if (\n      kind === types.listUnordered\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {_container: true})\n      }\n\n      if (kind === types.listUnordered) {\n        effects.enter(types.listItemPrefix)\n        return code === codes.asterisk || code === codes.dash\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n\n      if (!self.interrupt || code === codes.digit1) {\n        effects.enter(types.listItemPrefix)\n        effects.enter(types.listItemValue)\n        return inside(code)\n      }\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    assert(self.containerState, 'expected state')\n    if (asciiDigit(code) && ++size < constants.listItemValueSizeMax) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === codes.rightParenthesis || code === codes.dot)\n    ) {\n      effects.exit(types.listItemValue)\n      return atMarker(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    assert(self.containerState, 'expected state')\n    assert(code !== codes.eof, 'eof (`null`) is not a marker')\n    effects.enter(types.listItemMarker)\n    effects.consume(code)\n    effects.exit(types.listItemMarker)\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine,\n      // Cant be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    assert(self.containerState, 'expected state')\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.listItemPrefixWhitespace)\n      effects.consume(code)\n      effects.exit(types.listItemPrefixWhitespace)\n      return endOfPrefix\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    assert(self.containerState, 'expected state')\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit(types.listItemPrefix), true).length\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n\n  assert(self.containerState, 'expected state')\n  self.containerState._closeFlow = undefined\n\n  return effects.check(blankLine, onBlank, notBlank)\n\n  /** @type {State} */\n  function onBlank(code) {\n    assert(self.containerState, 'expected state')\n    assert(typeof self.containerState.size === 'number', 'expected size')\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(\n      effects,\n      ok,\n      types.listItemIndent,\n      self.containerState.size + 1\n    )(code)\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    assert(self.containerState, 'expected state')\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    assert(self.containerState, 'expected state')\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true\n    // As were closing flow, were no longer interrupting.\n    self.interrupt = undefined\n    // Always populated by defaults.\n    assert(\n      self.parser.constructs.disable.null,\n      'expected `disable.null` to be populated'\n    )\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      types.linePrefix,\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : constants.tabSize\n    )(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n\n  assert(self.containerState, 'expected state')\n  assert(typeof self.containerState.size === 'number', 'expected size')\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    types.listItemIndent,\n    self.containerState.size + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    assert(self.containerState, 'expected state')\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === types.listItemIndent &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Exiter}\n */\nfunction tokenizeListEnd(effects) {\n  assert(this.containerState, 'expected state')\n  assert(typeof this.containerState.type === 'string', 'expected type')\n  effects.exit(this.containerState.type)\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n\n  // Always populated by defaults.\n  assert(\n    self.parser.constructs.disable.null,\n    'expected `disable.null` to be populated'\n  )\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    types.listItemPrefixWhitespace,\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : constants.tabSize + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === types.listItemPrefixWhitespace\n      ? ok(code)\n      : nok(code)\n  }\n}\n", "/**\n * @import {\n *   Code,\n *   Construct,\n *   Resolver,\n *   State,\n *   TokenizeContext,\n *   Tokenizer\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes, types} from 'micromark-util-symbol'\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  resolveTo: resolveToSetextUnderline,\n  tokenize: tokenizeSetextUnderline\n}\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length\n  /** @type {number | undefined} */\n  let content\n  /** @type {number | undefined} */\n  let text\n  /** @type {number | undefined} */\n  let definition\n\n  // Find the opening of the content.\n  // Itll always exist: we dont tokenize if it isnt there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === types.content) {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === types.paragraph) {\n        text = index\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === types.content) {\n        // Remove the content end (if needed well add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === types.definition) {\n        definition = index\n      }\n    }\n  }\n\n  assert(text !== undefined, 'expected a `text` index to be found')\n  assert(content !== undefined, 'expected a `text` index to be found')\n  assert(events[content][2] === context, 'enter context should be same')\n  assert(\n    events[events.length - 1][2] === context,\n    'enter context should be same'\n  )\n  const heading = {\n    type: types.setextHeading,\n    start: {...events[content][1].start},\n    end: {...events[events.length - 1][1].end}\n  }\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = types.setextHeadingText\n\n  // If we have definitions in the content, well keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = {...events[definition][1].end}\n  } else {\n    events[content][1] = heading\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context])\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length\n    /** @type {boolean | undefined} */\n    let paragraph\n\n    assert(\n      code === codes.dash || code === codes.equalsTo,\n      'expected `=` or `-`'\n    )\n\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (\n        self.events[index][1].type !== types.lineEnding &&\n        self.events[index][1].type !== types.linePrefix &&\n        self.events[index][1].type !== types.content\n      ) {\n        paragraph = self.events[index][1].type === types.paragraph\n        break\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(types.setextHeadingLine)\n      marker = code\n      return before(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter(types.setextHeadingLineSequence)\n    return inside(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n\n    effects.exit(types.setextHeadingLineSequence)\n\n    return markdownSpace(code)\n      ? factorySpace(effects, after, types.lineSuffix)(code)\n      : after(code)\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.setextHeadingLine)\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n", "/**\n * @import {\n *   InitialConstruct,\n *   Initializer,\n *   State,\n *   TokenizeContext\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {blankLine, content} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes, types} from 'micromark-util-symbol'\n\n/** @type {InitialConstruct} */\nexport const flow = {tokenize: initializeFlow}\n\n/**\n * @this {TokenizeContext}\n *   Self.\n * @type {Initializer}\n *   Initializer.\n */\nfunction initializeFlow(effects) {\n  const self = this\n  const initial = effects.attempt(\n    // Try to parse a blank line.\n    blankLine,\n    atBlankEnding,\n    // Try to parse initial flow (essentially, only code).\n    effects.attempt(\n      this.parser.constructs.flowInitial,\n      afterConstruct,\n      factorySpace(\n        effects,\n        effects.attempt(\n          this.parser.constructs.flow,\n          afterConstruct,\n          effects.attempt(content, afterConstruct)\n        ),\n        types.linePrefix\n      )\n    )\n  )\n\n  return initial\n\n  /** @type {State} */\n  function atBlankEnding(code) {\n    assert(\n      code === codes.eof || markdownLineEnding(code),\n      'expected eol or eof'\n    )\n\n    if (code === codes.eof) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter(types.lineEndingBlank)\n    effects.consume(code)\n    effects.exit(types.lineEndingBlank)\n    self.currentConstruct = undefined\n    return initial\n  }\n\n  /** @type {State} */\n  function afterConstruct(code) {\n    assert(\n      code === codes.eof || markdownLineEnding(code),\n      'expected eol or eof'\n    )\n\n    if (code === codes.eof) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    self.currentConstruct = undefined\n    return initial\n  }\n}\n", "/**\n * @import {\n *   Code,\n *   InitialConstruct,\n *   Initializer,\n *   Resolver,\n *   State,\n *   TokenizeContext\n * } from 'micromark-util-types'\n */\n\nimport {ok as assert} from 'devlop'\nimport {codes, constants, types} from 'micromark-util-symbol'\n\nexport const resolver = {resolveAll: createResolver()}\nexport const string = initializeFactory('string')\nexport const text = initializeFactory('text')\n\n/**\n * @param {'string' | 'text'} field\n *   Field.\n * @returns {InitialConstruct}\n *   Construct.\n */\nfunction initializeFactory(field) {\n  return {\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    ),\n    tokenize: initializeText\n  }\n\n  /**\n   * @this {TokenizeContext}\n   *   Context.\n   * @type {Initializer}\n   */\n  function initializeText(effects) {\n    const self = this\n    const constructs = this.parser.constructs[field]\n    const text = effects.attempt(constructs, start, notText)\n\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    /** @type {State} */\n    function notText(code) {\n      if (code === codes.eof) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter(types.data)\n      effects.consume(code)\n      return data\n    }\n\n    /** @type {State} */\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit(types.data)\n        return text(code)\n      }\n\n      // Data.\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * @param {Code} code\n     *   Code.\n     * @returns {boolean}\n     *   Whether the code is a break.\n     */\n    function atBreak(code) {\n      if (code === codes.eof) {\n        return true\n      }\n\n      const list = constructs[code]\n      let index = -1\n\n      if (list) {\n        // Always populated by defaults.\n        assert(Array.isArray(list), 'expected `disable.null` to be populated')\n\n        while (++index < list.length) {\n          const item = list[index]\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true\n          }\n        }\n      }\n\n      return false\n    }\n  }\n}\n\n/**\n * @param {Resolver | undefined} [extraResolver]\n *   Resolver.\n * @returns {Resolver}\n *   Resolver.\n */\nfunction createResolver(extraResolver) {\n  return resolveAllText\n\n  /** @type {Resolver} */\n  function resolveAllText(events, context) {\n    let index = -1\n    /** @type {number | undefined} */\n    let enter\n\n    // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === types.data) {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== types.data) {\n        // Dont do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we cant hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0 // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === types.lineEnding) &&\n      events[eventIndex - 1][1].type === types.data\n    ) {\n      const data = events[eventIndex - 1][1]\n      const chunks = context.sliceStream(data)\n      let index = chunks.length\n      let bufferIndex = -1\n      let size = 0\n      /** @type {boolean | undefined} */\n      let tabs\n\n      while (index--) {\n        const chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        }\n        // Number\n        else if (chunk === codes.horizontalTab) {\n          tabs = true\n          size++\n        } else if (chunk === codes.virtualSpace) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      // Allow final trailing whitespace.\n      if (context._contentTypeTextTrailing && eventIndex === events.length) {\n        size = 0\n      }\n\n      if (size) {\n        const token = {\n          type:\n            eventIndex === events.length ||\n            tabs ||\n            size < constants.hardBreakPrefixSizeMin\n              ? types.lineSuffix\n              : types.hardBreakTrailing,\n          start: {\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex,\n            _index: data.start._index + index,\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size\n          },\n          end: {...data.end}\n        }\n\n        data.end = {...token.start}\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n", "/**\n * @import {Extension} from 'micromark-util-types'\n */\n\nimport {\n  attention,\n  autolink,\n  blockQuote,\n  characterEscape,\n  characterReference,\n  codeFenced,\n  codeIndented,\n  codeText,\n  definition,\n  hardBreakEscape,\n  headingAtx,\n  htmlFlow,\n  htmlText,\n  labelEnd,\n  labelStartImage,\n  labelStartLink,\n  lineEnding,\n  list,\n  setextUnderline,\n  thematicBreak\n} from 'micromark-core-commonmark'\nimport {codes} from 'micromark-util-symbol'\nimport {resolver as resolveText} from './initialize/text.js'\n\n/** @satisfies {Extension['document']} */\nexport const document = {\n  [codes.asterisk]: list,\n  [codes.plusSign]: list,\n  [codes.dash]: list,\n  [codes.digit0]: list,\n  [codes.digit1]: list,\n  [codes.digit2]: list,\n  [codes.digit3]: list,\n  [codes.digit4]: list,\n  [codes.digit5]: list,\n  [codes.digit6]: list,\n  [codes.digit7]: list,\n  [codes.digit8]: list,\n  [codes.digit9]: list,\n  [codes.greaterThan]: blockQuote\n}\n\n/** @satisfies {Extension['contentInitial']} */\nexport const contentInitial = {\n  [codes.leftSquareBracket]: definition\n}\n\n/** @satisfies {Extension['flowInitial']} */\nexport const flowInitial = {\n  [codes.horizontalTab]: codeIndented,\n  [codes.virtualSpace]: codeIndented,\n  [codes.space]: codeIndented\n}\n\n/** @satisfies {Extension['flow']} */\nexport const flow = {\n  [codes.numberSign]: headingAtx,\n  [codes.asterisk]: thematicBreak,\n  [codes.dash]: [setextUnderline, thematicBreak],\n  [codes.lessThan]: htmlFlow,\n  [codes.equalsTo]: setextUnderline,\n  [codes.underscore]: thematicBreak,\n  [codes.graveAccent]: codeFenced,\n  [codes.tilde]: codeFenced\n}\n\n/** @satisfies {Extension['string']} */\nexport const string = {\n  [codes.ampersand]: characterReference,\n  [codes.backslash]: characterEscape\n}\n\n/** @satisfies {Extension['text']} */\nexport const text = {\n  [codes.carriageReturn]: lineEnding,\n  [codes.lineFeed]: lineEnding,\n  [codes.carriageReturnLineFeed]: lineEnding,\n  [codes.exclamationMark]: labelStartImage,\n  [codes.ampersand]: characterReference,\n  [codes.asterisk]: attention,\n  [codes.lessThan]: [autolink, htmlText],\n  [codes.leftSquareBracket]: labelStartLink,\n  [codes.backslash]: [hardBreakEscape, characterEscape],\n  [codes.rightSquareBracket]: labelEnd,\n  [codes.underscore]: attention,\n  [codes.graveAccent]: codeText\n}\n\n/** @satisfies {Extension['insideSpan']} */\nexport const insideSpan = {null: [attention, resolveText]}\n\n/** @satisfies {Extension['attentionMarkers']} */\nexport const attentionMarkers = {null: [codes.asterisk, codes.underscore]}\n\n/** @satisfies {Extension['disable']} */\nexport const disable = {null: []}\n", "/**\n * @import {\n *   Chunk,\n *   Code,\n *   ConstructRecord,\n *   Construct,\n *   Effects,\n *   InitialConstruct,\n *   ParseContext,\n *   Point,\n *   State,\n *   TokenizeContext,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @callback Restore\n *   Restore the state.\n * @returns {undefined}\n *   Nothing.\n *\n * @typedef Info\n *   Info.\n * @property {Restore} restore\n *   Restore.\n * @property {number} from\n *   From.\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n *   Construct.\n * @param {Info} info\n *   Info.\n * @returns {undefined}\n *   Nothing.\n */\n\nimport createDebug from 'debug'\nimport {ok as assert} from 'devlop'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes, values} from 'micromark-util-symbol'\n\nconst debug = createDebug('micromark')\n\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesnt receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n *   Parser.\n * @param {InitialConstruct} initialize\n *   Construct.\n * @param {Omit<Point, '_bufferIndex' | '_index'> | undefined} [from]\n *   Point (optional).\n * @returns {TokenizeContext}\n *   Context.\n */\nexport function createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  let point = {\n    _bufferIndex: -1,\n    _index: 0,\n    line: (from && from.line) || 1,\n    column: (from && from.column) || 1,\n    offset: (from && from.offset) || 0\n  }\n  /** @type {Record<string, number>} */\n  const columnStart = {}\n  /** @type {Array<Construct>} */\n  const resolveAllConstructs = []\n  /** @type {Array<Chunk>} */\n  let chunks = []\n  /** @type {Array<Token>} */\n  let stack = []\n  /** @type {boolean | undefined} */\n  let consumed = true\n\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n  const effects = {\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    consume,\n    enter,\n    exit,\n    interrupt: constructFactory(onsuccessfulcheck, {interrupt: true})\n  }\n\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n  const context = {\n    code: codes.eof,\n    containerState: {},\n    defineSkip,\n    events: [],\n    now,\n    parser,\n    previous: codes.eof,\n    sliceSerialize,\n    sliceStream,\n    write\n  }\n\n  /**\n   * The state function.\n   *\n   * @type {State | undefined}\n   */\n  let state = initialize.tokenize.call(context, effects)\n\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n  let expectedCode\n\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  }\n\n  return context\n\n  /** @type {TokenizeContext['write']} */\n  function write(slice) {\n    chunks = push(chunks, slice)\n\n    main()\n\n    // Exit if were not done, resolve might change stuff.\n    if (chunks[chunks.length - 1] !== codes.eof) {\n      return []\n    }\n\n    addResult(initialize, 0)\n\n    // Otherwise, resolve, and exit.\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n\n    return context.events\n  }\n\n  //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs)\n  }\n\n  /** @type {TokenizeContext['sliceStream']} */\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n\n  /** @type {TokenizeContext['now']} */\n  function now() {\n    // This is a hot path, so we clone manually instead of `Object.assign({}, point)`\n    const {_bufferIndex, _index, line, column, offset} = point\n    return {_bufferIndex, _index, line, column, offset}\n  }\n\n  /** @type {TokenizeContext['defineSkip']} */\n  function defineSkip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n    debug('position: define skip: `%j`', point)\n  }\n\n  //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function main() {\n    /** @type {number} */\n    let chunkIndex\n\n    while (point._index < chunks.length) {\n      const chunk = chunks[point._index]\n\n      // If were in a buffer chunk, loop through it.\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  }\n\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   *   Code.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function go(code) {\n    assert(consumed === true, 'expected character to be consumed')\n    consumed = undefined\n    debug('main: passing `%s` to %s', code, state && state.name)\n    expectedCode = code\n    assert(typeof state === 'function', 'expected state')\n    state = state(code)\n  }\n\n  /** @type {Effects['consume']} */\n  function consume(code) {\n    assert(code === expectedCode, 'expected given code to equal expected code')\n\n    debug('consume: `%s`', code)\n\n    assert(\n      consumed === undefined,\n      'expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used'\n    )\n    assert(\n      code === null\n        ? context.events.length === 0 ||\n            context.events[context.events.length - 1][0] === 'exit'\n        : context.events[context.events.length - 1][0] === 'enter',\n      'expected last token to be open'\n    )\n\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === codes.carriageReturnLineFeed ? 2 : 1\n      accountForPotentialSkip()\n      debug('position: after eol: `%j`', point)\n    } else if (code !== codes.virtualSpace) {\n      point.column++\n      point.offset++\n    }\n\n    // Not in a string chunk.\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++\n\n      // At end of string chunk.\n      if (\n        point._bufferIndex ===\n        // Points w/ non-negative `_bufferIndex` reference\n        // strings.\n        /** @type {string} */ (chunks[point._index]).length\n      ) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    }\n\n    // Expose the previous character.\n    context.previous = code\n\n    // Mark as consumed.\n    consumed = true\n  }\n\n  /** @type {Effects['enter']} */\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    const token = fields || {}\n    token.type = type\n    token.start = now()\n\n    assert(typeof type === 'string', 'expected string type')\n    assert(type.length > 0, 'expected non-empty string')\n    debug('enter: `%s`', type)\n\n    context.events.push(['enter', token, context])\n\n    stack.push(token)\n\n    return token\n  }\n\n  /** @type {Effects['exit']} */\n  function exit(type) {\n    assert(typeof type === 'string', 'expected string type')\n    assert(type.length > 0, 'expected non-empty string')\n\n    const token = stack.pop()\n    assert(token, 'cannot close w/o open tokens')\n    token.end = now()\n\n    assert(type === token.type, 'expected exit token to match current token')\n\n    assert(\n      !(\n        token.start._index === token.end._index &&\n        token.start._bufferIndex === token.end._bufferIndex\n      ),\n      'expected non-empty token (`' + type + '`)'\n    )\n\n    debug('exit: `%s`', token.type)\n    context.events.push(['exit', token, context])\n\n    return token\n  }\n\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  }\n\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulcheck(_, info) {\n    info.restore()\n  }\n\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   *   Callback.\n   * @param {{interrupt?: boolean | undefined} | undefined} [fields]\n   *   Fields.\n   */\n  function constructFactory(onreturn, fields) {\n    return hook\n\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Array<Construct> | ConstructRecord | Construct} constructs\n     *   Constructs.\n     * @param {State} returnState\n     *   State.\n     * @param {State | undefined} [bogusState]\n     *   State.\n     * @returns {State}\n     *   State.\n     */\n    function hook(constructs, returnState, bogusState) {\n      /** @type {ReadonlyArray<Construct>} */\n      let listOfConstructs\n      /** @type {number} */\n      let constructIndex\n      /** @type {Construct} */\n      let currentConstruct\n      /** @type {Info} */\n      let info\n\n      return Array.isArray(constructs)\n        ? /* c8 ignore next 1 */\n          handleListOfConstructs(constructs)\n        : 'tokenize' in constructs\n          ? // Looks like a construct.\n            handleListOfConstructs([/** @type {Construct} */ (constructs)])\n          : handleMapOfConstructs(constructs)\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       *   Constructs.\n       * @returns {State}\n       *   State.\n       */\n      function handleMapOfConstructs(map) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          const left = code !== null && map[code]\n          const all = code !== null && map.null\n          const list = [\n            // To do: add more extension tests.\n            /* c8 ignore next 2 */\n            ...(Array.isArray(left) ? left : left ? [left] : []),\n            ...(Array.isArray(all) ? all : all ? [all] : [])\n          ]\n\n          return handleListOfConstructs(list)(code)\n        }\n      }\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ReadonlyArray<Construct>} list\n       *   Constructs.\n       * @returns {State}\n       *   State.\n       */\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n\n        if (list.length === 0) {\n          assert(bogusState, 'expected `bogusState` to be given')\n          return bogusState\n        }\n\n        return handleConstruct(list[constructIndex])\n      }\n\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       *   Construct.\n       * @returns {State}\n       *   State.\n       */\n      function handleConstruct(construct) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesnt work because `inspect` in document does a check\n          // w/o a bogus, which doesnt make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          // Always populated by defaults.\n          assert(\n            context.parser.constructs.disable.null,\n            'expected `disable.null` to be populated'\n          )\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.includes(construct.name)\n          ) {\n            return nok(code)\n          }\n\n          return construct.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a live binding, which is needed for `interrupt`.\n            fields ? Object.assign(Object.create(context), fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n\n      /** @type {State} */\n      function ok(code) {\n        assert(code === expectedCode, 'expected code')\n        consumed = true\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n\n      /** @type {State} */\n      function nok(code) {\n        assert(code === expectedCode, 'expected code')\n        consumed = true\n        info.restore()\n\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n\n        return bogusState\n      }\n    }\n  }\n\n  /**\n   * @param {Construct} construct\n   *   Construct.\n   * @param {number} from\n   *   From.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct)\n    }\n\n    if (construct.resolve) {\n      splice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n\n    assert(\n      construct.partial ||\n        context.events.length === 0 ||\n        context.events[context.events.length - 1][0] === 'exit',\n      'expected last token to end'\n    )\n  }\n\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   *   Info.\n   */\n  function store() {\n    const startPoint = now()\n    const startPrevious = context.previous\n    const startCurrentConstruct = context.currentConstruct\n    const startEventsIndex = context.events.length\n    const startStack = Array.from(stack)\n\n    return {from: startEventsIndex, restore}\n\n    /**\n     * Restore state.\n     *\n     * @returns {undefined}\n     *   Nothing.\n     */\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n      debug('position: restore: `%j`', point)\n    }\n  }\n\n  /**\n   * Move the current point a bit forward in the line when its on a column\n   * skip.\n   *\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {ReadonlyArray<Chunk>} chunks\n *   Chunks.\n * @param {Pick<Token, 'end' | 'start'>} token\n *   Token.\n * @returns {Array<Chunk>}\n *   Chunks.\n */\nfunction sliceChunks(chunks, token) {\n  const startIndex = token.start._index\n  const startBufferIndex = token.start._bufferIndex\n  const endIndex = token.end._index\n  const endBufferIndex = token.end._bufferIndex\n  /** @type {Array<Chunk>} */\n  let view\n\n  if (startIndex === endIndex) {\n    assert(endBufferIndex > -1, 'expected non-negative end buffer index')\n    assert(startBufferIndex > -1, 'expected non-negative start buffer index')\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n\n    if (startBufferIndex > -1) {\n      const head = view[0]\n      if (typeof head === 'string') {\n        view[0] = head.slice(startBufferIndex)\n        /* c8 ignore next 4 -- used to be used, no longer */\n      } else {\n        assert(startBufferIndex === 0, 'expected `startBufferIndex` to be `0`')\n        view.shift()\n      }\n    }\n\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n\n  return view\n}\n\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {ReadonlyArray<Chunk>} chunks\n *   Chunks.\n * @param {boolean | undefined} [expandTabs=false]\n *   Whether to expand tabs (default: `false`).\n * @returns {string}\n *   Result.\n */\nfunction serializeChunks(chunks, expandTabs) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case codes.carriageReturn: {\n          value = values.cr\n\n          break\n        }\n\n        case codes.lineFeed: {\n          value = values.lf\n\n          break\n        }\n\n        case codes.carriageReturnLineFeed: {\n          value = values.cr + values.lf\n\n          break\n        }\n\n        case codes.horizontalTab: {\n          value = expandTabs ? values.space : values.ht\n\n          break\n        }\n\n        case codes.virtualSpace: {\n          if (!expandTabs && atTab) continue\n          value = values.space\n\n          break\n        }\n\n        default: {\n          assert(typeof chunk === 'number', 'expected number')\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk)\n        }\n      }\n\n    atTab = chunk === codes.horizontalTab\n    result.push(value)\n  }\n\n  return result.join('')\n}\n", "/**\n * @import {\n *   Create,\n *   FullNormalizedExtension,\n *   InitialConstruct,\n *   ParseContext,\n *   ParseOptions\n * } from 'micromark-util-types'\n */\n\nimport {combineExtensions} from 'micromark-util-combine-extensions'\nimport {content} from './initialize/content.js'\nimport {document} from './initialize/document.js'\nimport {flow} from './initialize/flow.js'\nimport {string, text} from './initialize/text.js'\nimport * as defaultConstructs from './constructs.js'\nimport {createTokenizer} from './create-tokenizer.js'\n\n/**\n * @param {ParseOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ParseContext}\n *   Parser.\n */\nexport function parse(options) {\n  const settings = options || {}\n  const constructs = /** @type {FullNormalizedExtension} */ (\n    combineExtensions([defaultConstructs, ...(settings.extensions || [])])\n  )\n\n  /** @type {ParseContext} */\n  const parser = {\n    constructs,\n    content: create(content),\n    defined: [],\n    document: create(document),\n    flow: create(flow),\n    lazy: {},\n    string: create(string),\n    text: create(text)\n  }\n\n  return parser\n\n  /**\n   * @param {InitialConstruct} initial\n   *   Construct to start with.\n   * @returns {Create}\n   *   Create a tokenizer.\n   */\n  function create(initial) {\n    return creator\n    /** @type {Create} */\n    function creator(from) {\n      return createTokenizer(parser, initial, from)\n    }\n  }\n}\n", "/**\n * @import {Event} from 'micromark-util-types'\n */\n\nimport {subtokenize} from 'micromark-util-subtokenize'\n\n/**\n * @param {Array<Event>} events\n *   Events.\n * @returns {Array<Event>}\n *   Events.\n */\nexport function postprocess(events) {\n  while (!subtokenize(events)) {\n    // Empty\n  }\n\n  return events\n}\n", "/**\n * @import {Chunk, Code, Encoding, Value} from 'micromark-util-types'\n */\n\n/**\n * @callback Preprocessor\n *   Preprocess a value.\n * @param {Value} value\n *   Value.\n * @param {Encoding | null | undefined} [encoding]\n *   Encoding when `value` is a typed array (optional).\n * @param {boolean | null | undefined} [end=false]\n *   Whether this is the last chunk (default: `false`).\n * @returns {Array<Chunk>}\n *   Chunks.\n */\n\nimport {codes, constants} from 'micromark-util-symbol'\n\nconst search = /[\\0\\t\\n\\r]/g\n\n/**\n * @returns {Preprocessor}\n *   Preprocess a value.\n */\nexport function preprocess() {\n  let column = 1\n  let buffer = ''\n  /** @type {boolean | undefined} */\n  let start = true\n  /** @type {boolean | undefined} */\n  let atCarriageReturn\n\n  return preprocessor\n\n  /** @type {Preprocessor} */\n  // eslint-disable-next-line complexity\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = []\n    /** @type {RegExpMatchArray | null} */\n    let match\n    /** @type {number} */\n    let next\n    /** @type {number} */\n    let startPosition\n    /** @type {number} */\n    let endPosition\n    /** @type {Code} */\n    let code\n\n    value =\n      buffer +\n      (typeof value === 'string'\n        ? value.toString()\n        : new TextDecoder(encoding || undefined).decode(value))\n\n    startPosition = 0\n    buffer = ''\n\n    if (start) {\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\n      if (value.charCodeAt(0) === codes.byteOrderMarker) {\n        startPosition++\n      }\n\n      start = undefined\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition\n      match = search.exec(value)\n      endPosition =\n        match && match.index !== undefined ? match.index : value.length\n      code = value.charCodeAt(endPosition)\n\n      if (!match) {\n        buffer = value.slice(startPosition)\n        break\n      }\n\n      if (\n        code === codes.lf &&\n        startPosition === endPosition &&\n        atCarriageReturn\n      ) {\n        chunks.push(codes.carriageReturnLineFeed)\n        atCarriageReturn = undefined\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(codes.carriageReturn)\n          atCarriageReturn = undefined\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition))\n          column += endPosition - startPosition\n        }\n\n        switch (code) {\n          case codes.nul: {\n            chunks.push(codes.replacementCharacter)\n            column++\n\n            break\n          }\n\n          case codes.ht: {\n            next = Math.ceil(column / constants.tabSize) * constants.tabSize\n            chunks.push(codes.horizontalTab)\n            while (column++ < next) chunks.push(codes.virtualSpace)\n\n            break\n          }\n\n          case codes.lf: {\n            chunks.push(codes.lineFeed)\n            column = 1\n\n            break\n          }\n\n          default: {\n            atCarriageReturn = true\n            column = 1\n          }\n        }\n      }\n\n      startPosition = endPosition + 1\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(codes.carriageReturn)\n      if (buffer) chunks.push(buffer)\n      chunks.push(codes.eof)\n    }\n\n    return chunks\n  }\n}\n", "import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {codes, constants} from 'micromark-util-symbol'\n\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The string content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @param {string} $1\n *   Character escape.\n * @param {string} $2\n *   Character reference.\n * @returns {string}\n *   Decoded value\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0)\n\n  if (head === codes.numberSign) {\n    const head = $2.charCodeAt(1)\n    const hex = head === codes.lowercaseX || head === codes.uppercaseX\n    return decodeNumericCharacterReference(\n      $2.slice(hex ? 2 : 1),\n      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal\n    )\n  }\n\n  return decodeNamedCharacterReference($2) || $0\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Point | PointLike | Position | PositionLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n", "/**\n * @import {\n *   Break,\n *   Blockquote,\n *   Code,\n *   Definition,\n *   Emphasis,\n *   Heading,\n *   Html,\n *   Image,\n *   InlineCode,\n *   Link,\n *   ListItem,\n *   List,\n *   Nodes,\n *   Paragraph,\n *   PhrasingContent,\n *   ReferenceType,\n *   Root,\n *   Strong,\n *   Text,\n *   ThematicBreak\n * } from 'mdast'\n * @import {\n *   Encoding,\n *   Event,\n *   Token,\n *   Value\n * } from 'micromark-util-types'\n * @import {Point} from 'unist'\n * @import {\n *   CompileContext,\n *   CompileData,\n *   Config,\n *   Extension,\n *   Handle,\n *   OnEnterError,\n *   Options\n * } from './types.js'\n */\n\nimport {ok as assert} from 'devlop'\nimport {toString} from 'mdast-util-to-string'\nimport {parse, postprocess, preprocess} from 'micromark'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {codes, constants, types} from 'micromark-util-symbol'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding\n    encoding = undefined\n  }\n\n  return compiler(options)(\n    postprocess(\n      parse(options)\n        .document()\n        .write(preprocess()(value, encoding, true))\n    )\n  )\n}\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      characterReference: onexitcharacterreference,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {type: 'root', children: []}\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === types.listOrdered ||\n        events[index][1].type === types.listUnordered\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          assert(typeof tail === 'number', 'expected list ot be open')\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {sliceSerialize: events[index][2].sliceSerialize},\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0 ? events[0][1].start : {line: 1, column: 1, offset: 0}\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {line: 1, column: 1, offset: 0}\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n\n    while (++index <= length) {\n      const event = events[index]\n\n      switch (event[1].type) {\n        case types.listUnordered:\n        case types.listOrdered:\n        case types.blockQuote: {\n          if (event[0] === 'enter') {\n            containerBalance++\n          } else {\n            containerBalance--\n          }\n\n          atMarker = undefined\n\n          break\n        }\n\n        case types.lineEndingBlank: {\n          if (event[0] === 'enter') {\n            if (\n              listItem &&\n              !atMarker &&\n              !containerBalance &&\n              !firstBlankLineIndex\n            ) {\n              firstBlankLineIndex = index\n            }\n\n            atMarker = undefined\n          }\n\n          break\n        }\n\n        case types.linePrefix:\n        case types.listItemValue:\n        case types.listItemMarker:\n        case types.listItemPrefix:\n        case types.listItemPrefixWhitespace: {\n          // Empty.\n\n          break\n        }\n\n        default: {\n          atMarker = undefined\n        }\n      }\n\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === types.listItemPrefix) ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === types.listUnordered ||\n            event[1].type === types.listOrdered))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n\n            if (\n              tailEvent[1].type === types.lineEnding ||\n              tailEvent[1].type === types.lineEndingBlank\n            ) {\n              if (tailEvent[0] === 'exit') continue\n\n              if (lineIndex) {\n                events[lineIndex][1].type = types.lineEndingBlank\n                listSpread = true\n              }\n\n              tailEvent[1].type = types.lineEnding\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === types.linePrefix ||\n              tailEvent[1].type === types.blockQuotePrefix ||\n              tailEvent[1].type === types.blockQuotePrefixWhitespace ||\n              tailEvent[1].type === types.blockQuoteMarker ||\n              tailEvent[1].type === types.listItemIndent\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === types.listItemPrefix) {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: well add `end` in a second.\n            end: undefined\n          }\n          listItem = item\n          events.splice(index, 0, ['enter', item, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @type {CompileContext['buffer']}\n   */\n  function buffer() {\n    this.stack.push({type: 'fragment', children: []})\n  }\n\n  /**\n   * @type {CompileContext['enter']}\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    assert(parent, 'expected `parent`')\n    assert('children' in parent, 'expected `parent`')\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    siblings.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler || undefined])\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    }\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @type {CompileContext['exit']}\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    assert(node, 'expected `node`')\n    const open = this.tokenStack.pop()\n\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({start: token.start, end: token.end}) +\n          '): its not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n\n    assert(node.type !== 'fragment', 'unexpected fragment `exit`ed')\n    assert(node.position, 'expected `position` to be defined')\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @type {CompileContext['resume']}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2]\n      assert(ancestor, 'expected nodes on stack')\n      assert(ancestor.type === 'list', 'expected list on stack')\n      ancestor.start = Number.parseInt(\n        this.sliceSerialize(token),\n        constants.numericBaseDecimal\n      )\n      this.data.expectingFirstListItemValue = undefined\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return\n    this.buffer()\n    this.data.flowCodeInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    this.data.flowCodeInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'code', 'expected code on stack')\n\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'definition', 'expected definition on stack')\n\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'heading', 'expected heading on stack')\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n\n      assert(\n        depth === 1 ||\n          depth === 2 ||\n          depth === 3 ||\n          depth === 4 ||\n          depth === 5 ||\n          depth === 6,\n        'expected `depth` between `1` and `6`'\n      )\n\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'heading', 'expected heading on stack')\n\n    node.depth =\n      this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert('children' in node, 'expected parent on stack')\n    /** @type {Array<Nodes>} */\n    const siblings = node.children\n\n    let tail = siblings[siblings.length - 1]\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: well add `end` later.\n        end: undefined\n      }\n      siblings.push(tail)\n    }\n\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    assert(tail, 'expected a `node` to be on the stack')\n    assert('value' in tail, 'expected a `literal` to be on the stack')\n    assert(tail.position, 'expected `node` to have an open position')\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    assert(context, 'expected `node`')\n\n    // If were at a hard break, include the line ending in there.\n    if (this.data.atHardBreak) {\n      assert('children' in context, 'expected `parent`')\n      const tail = context.children[context.children.length - 1]\n      assert(tail.position, 'expected tail to have a starting position')\n      tail.position.end = point(token.end)\n      this.data.atHardBreak = undefined\n      return\n    }\n\n    if (\n      !this.data.setextHeadingSlurpLineEnding &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'html', 'expected html on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'html', 'expected html on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'inlineCode', 'expected inline code on stack')\n\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut'\n\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n\n    this.data.referenceType = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'image', 'expected image on stack')\n\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut'\n\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n\n    this.data.referenceType = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    assert(ancestor, 'expected ancestor on stack')\n    assert(\n      ancestor.type === 'image' || ancestor.type === 'link',\n      'expected image or link on stack'\n    )\n\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    assert(fragment, 'expected node on stack')\n    assert(fragment.type === 'fragment', 'expected fragment on stack')\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n\n    // Assume a reference.\n    this.data.inReference = true\n\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children\n\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image or link on stack'\n    )\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    this.data.inReference = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed'\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(\n      node.type === 'image' || node.type === 'link',\n      'expected image reference or link reference on stack'\n    )\n\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    this.data.referenceType = 'full'\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    assert(\n      token.type === 'characterReferenceMarkerNumeric' ||\n        token.type === 'characterReferenceMarkerHexadecimal'\n    )\n    this.data.characterReferenceType = token.type\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = this.data.characterReferenceType\n    /** @type {string} */\n    let value\n\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === types.characterReferenceMarkerNumeric\n          ? constants.numericBaseDecimal\n          : constants.numericBaseHexadecimal\n      )\n      this.data.characterReferenceType = undefined\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      assert(result !== false, 'expected reference to decode')\n      value = result\n    }\n\n    const tail = this.stack[this.stack.length - 1]\n    assert(tail, 'expected `node`')\n    assert('value' in tail, 'expected `node.value`')\n    tail.value += value\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreference(token) {\n    const tail = this.stack.pop()\n    assert(tail, 'expected `node`')\n    assert(tail.position, 'expected `node.position`')\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    assert(node, 'expected node on stack')\n    assert(node.type === 'link', 'expected link on stack')\n\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {type: 'blockquote', children: []}\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {type: 'code', lang: null, meta: null, value: ''}\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {type: 'inlineCode', value: ''}\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {type: 'emphasis', children: []}\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {type: 'break'}\n  }\n\n  /** @returns {Html} */\n  function html() {\n    return {type: 'html', value: ''}\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {type: 'image', title: null, url: '', alt: null}\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {type: 'link', title: null, url: '', children: []}\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {type: 'paragraph', children: []}\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {type: 'strong', children: []}\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {type: 'text', value: ''}\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {type: 'thematicBreak'}\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {line: d.line, column: d.column, offset: d.offset}\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n\n  while (++index < extensions.length) {\n    const value = extensions[index]\n\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols': {\n          const right = extension[key]\n          if (right) {\n            combined[key].push(...right)\n          }\n\n          break\n        }\n\n        case 'transforms': {\n          const right = extension[key]\n          if (right) {\n            combined[key].push(...right)\n          }\n\n          break\n        }\n\n        case 'enter':\n        case 'exit': {\n          const right = extension[key]\n          if (right) {\n            Object.assign(combined[key], right)\n          }\n\n          break\n        }\n        // No default\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({start: left.start, end: left.end}) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({start: right.start, end: right.end}) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({start: right.start, end: right.end}) +\n        ') is still open'\n    )\n  }\n}\n", "export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n", "/**\n * @import {Node, Parent} from 'unist'\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | ReadonlyArray<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodes parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends ReadonlyArray<string>>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition[number]}) &\n   *   (<Condition extends Array<string>>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition[number]}) &\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test)\n          ? anyFactory(test)\n          : // Cast because `ReadonlyArray` goes into the above but `isArray`\n            // narrows to `Array`.\n            propertiesFactory(/** @type {Props} */ (test))\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propertiesFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n", "/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n", "/**\n * @import {Node as UnistNode, Parent as UnistParent} from 'unist'\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends ReadonlyArray<infer T>\n *   ? MatchesOne<Value, T>\n *   : Check extends Array<infer T>\n *   ? MatchesOne<Value, T>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodes children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isnt a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n            typeof value.name === 'string'\n            ? value.name\n            : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n", "/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`)  whole match\n *   * `...capture` (`Array<string>`)  matches from regex capture groups\n *   * `match` (`RegExpMatchObject`)  info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * or when `false`, do not replace at all\n *   * or when `string`, replace with a text node of that value\n *   * or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasnt a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n", "/**\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\nimport {ccount} from 'ccount'\nimport {ok as assert} from 'devlop'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '@',\n        before: '[+\\\\-.\\\\w]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: '.',\n        before: '[Ww]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: ':',\n        before: '[ps]',\n        after: '\\\\/',\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'link')\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Array<PhrasingContent> | Link | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    // If its an email, the previous character should not be a slash.\n    (!email || code !== 47)\n  )\n}\n", "/**\n * @import {\n *   CompileContext,\n *   Extension as FromMarkdownExtension,\n *   Handle as FromMarkdownHandle\n * } from 'mdast-util-from-markdown'\n * @import {ToMarkdownOptions} from 'mdast-util-gfm-footnote'\n * @import {\n *   Handle as ToMarkdownHandle,\n *   Map,\n *   Options as ToMarkdownExtension\n * } from 'mdast-util-to-markdown'\n * @import {FootnoteDefinition, FootnoteReference} from 'mdast'\n */\n\nimport {ok as assert} from 'devlop'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'footnoteReference')\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n  node.label = label\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'footnoteDefinition')\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n  node.label = label\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[^')\n  const exit = state.enter('footnoteReference')\n  const subexit = state.enter('reference')\n  value += tracker.move(\n    state.safe(state.associationId(node), {after: ']', before: value})\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteCallString: enterFootnoteCallString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: enterFootnoteDefinition\n    },\n    exit: {\n      gfmFootnoteCallString: exitFootnoteCallString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: exitFootnoteDefinition\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown(options) {\n  // To do: next major: change default.\n  let firstLineBlank = false\n\n  if (options && options.firstLineBlank) {\n    firstLineBlank = true\n  }\n\n  return {\n    handlers: {footnoteDefinition, footnoteReference},\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['label', 'phrasing', 'reference']}]\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteDefinition} node\n   */\n  function footnoteDefinition(node, _, state, info) {\n    const tracker = state.createTracker(info)\n    let value = tracker.move('[^')\n    const exit = state.enter('footnoteDefinition')\n    const subexit = state.enter('label')\n    value += tracker.move(\n      state.safe(state.associationId(node), {before: value, after: ']'})\n    )\n    subexit()\n\n    value += tracker.move(']:')\n\n    if (node.children && node.children.length > 0) {\n      tracker.shift(4)\n\n      value += tracker.move(\n        (firstLineBlank ? '\\n' : ' ') +\n          state.indentLines(\n            state.containerFlow(node, tracker.current()),\n            firstLineBlank ? mapAll : mapExceptFirst\n          )\n      )\n    }\n\n    exit()\n\n    return value\n  }\n}\n\n/** @type {Map} */\nfunction mapExceptFirst(line, index, blank) {\n  return index === 0 ? line : mapAll(line, index, blank)\n}\n\n/** @type {Map} */\nfunction mapAll(line, index, blank) {\n  return (blank ? '' : '    ') + line\n}\n", "/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: ['delete'],\n    enter: {strikethrough: enterStrikethrough},\n    exit: {strikethrough: exitStrikethrough}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '~',\n        inConstruct: 'phrasing',\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: {delete: handleDelete}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  const exit = state.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n", "/**\n * @import {Options, State} from './types.js'\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'extensions': {\n          // Empty.\n          break\n        }\n\n        /* c8 ignore next 4 */\n        case 'unsafe': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'join': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'handlers': {\n          map(base[key], extension[key])\n          break\n        }\n\n        default: {\n          // @ts-expect-error: matches.\n          base.options[key] = extension[key]\n        }\n      }\n    }\n  }\n\n  return base\n}\n\n/**\n * @template T\n * @param {Array<T>} left\n * @param {Array<T> | null | undefined} right\n */\nfunction list(left, right) {\n  if (right) {\n    left.push(...right)\n  }\n}\n\n/**\n * @template T\n * @param {Record<string, T>} left\n * @param {Record<string, T> | null | undefined} right\n */\nfunction map(left, right) {\n  if (right) {\n    Object.assign(left, right)\n  }\n}\n", "/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * Encode a code point as a character reference.\n *\n * @param {number} code\n *   Code point to encode.\n * @returns {string}\n *   Encoded character reference.\n */\nexport function encodeCharacterReference(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n", "/**\n * @import {EncodeSides} from '../types.js'\n */\n\nimport {classifyCharacter} from 'micromark-util-classify-character'\n\n/**\n * Check whether to encode (as a character reference) the characters\n * surrounding an attention run.\n *\n * Which characters are around an attention run influence whether it works or\n * not.\n *\n * See <https://github.com/orgs/syntax-tree/discussions/60> for more info.\n * See this markdown in a particular renderer to see what works:\n *\n * ```markdown\n * |                         | A (letter inside) | B (punctuation inside) | C (whitespace inside) | D (nothing inside) |\n * | ----------------------- | ----------------- | ---------------------- | --------------------- | ------------------ |\n * | 1 (letter outside)      | x*y*z             | x*.*z                  | x* *z                 | x**z               |\n * | 2 (punctuation outside) | .*y*.             | .*.*.                  | .* *.                 | .**.               |\n * | 3 (whitespace outside)  | x *y* z           | x *.* z                | x * * z               | x ** z             |\n * | 4 (nothing outside)     | *x*               | *.*                    | * *                   | **                 |\n * ```\n *\n * @param {number} outside\n *   Code point on the outer side of the run.\n * @param {number} inside\n *   Code point on the inner side of the run.\n * @param {'*' | '_'} marker\n *   Marker of the run.\n *   Underscores are handled more strictly (they form less often) than\n *   asterisks.\n * @returns {EncodeSides}\n *   Whether to encode characters.\n */\n// Important: punctuation must never be encoded.\n// Punctuation is solely used by markdown constructs.\n// And by encoding itself.\n// Encoding them will break constructs or double encode things.\nexport function encodeInfo(outside, inside, marker) {\n  const outsideKind = classifyCharacter(outside)\n  const insideKind = classifyCharacter(inside)\n\n  // Letter outside:\n  if (outsideKind === undefined) {\n    return insideKind === undefined\n      ? // Letter inside:\n        // we have to encode *both* letters for `_` as it is looser.\n        // it already forms for `*` (and GFMs `~`).\n        marker === '_'\n        ? {inside: true, outside: true}\n        : {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (letter, whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: encode outer (letter)\n          {inside: false, outside: true}\n  }\n\n  // Whitespace outside:\n  if (outsideKind === 1) {\n    return insideKind === undefined\n      ? // Letter inside: already forms.\n        {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: already forms.\n          {inside: false, outside: false}\n  }\n\n  // Punctuation outside:\n  return insideKind === undefined\n    ? // Letter inside: already forms.\n      {inside: false, outside: false}\n    : insideKind === 1\n      ? // Whitespace inside: encode inner (whitespace).\n        {inside: true, outside: false}\n      : // Punctuation inside: already forms.\n        {inside: false, outside: false}\n}\n", "/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Emphasis, Parents} from 'mdast'\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nemphasis.peek = emphasisPeek\n\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n", "/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when its released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n", "/**\n * @import {Html} from 'mdast'\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n", "/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Image, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n", "/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {ImageReference, Parents} from 'mdast'\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n", "/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n", "/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Link} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n", "/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Link, Parents} from 'mdast'\n * @import {Exit} from '../types.js'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n", "/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {LinkReference, Parents} from 'mdast'\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n", "/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * >  **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n", "/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Strong} from 'mdast'\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nstrong.peek = strongPeek\n\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker + marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker + marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n", "/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').TableRow} TableRow\n *\n * @typedef {import('markdown-table').Options} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').State} State\n * @typedef {import('mdast-util-to-markdown').Info} Info\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells (default:\n *   `true`).\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters (default: `true`).\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells (optional).\n */\n\nimport {ok as assert} from 'devlop'\nimport {markdownTable} from 'markdown-table'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM tables in\n * markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM tables.\n */\nexport function gfmTableFromMarkdown() {\n  return {\n    enter: {\n      table: enterTable,\n      tableData: enterCell,\n      tableHeader: enterCell,\n      tableRow: enterRow\n    },\n    exit: {\n      codeText: exitCodeText,\n      table: exitTable,\n      tableData: exit,\n      tableHeader: exit,\n      tableRow: exit\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  const align = token._align\n  assert(align, 'expected `_align` on table')\n  this.enter(\n    {\n      type: 'table',\n      align: align.map(function (d) {\n        return d === 'none' ? null : d\n      }),\n      children: []\n    },\n    token\n  )\n  this.data.inTable = true\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.data.inTable = undefined\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.data.inTable) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'inlineCode')\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      inlineCode: inlineCodeWithTable,\n      table: handleTable,\n      tableCell: handleTableCell,\n      tableRow: handleTableRow\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, state, info) {\n    return serializeData(handleTableAsData(node, state, info), node.align)\n  }\n\n  /**\n   * This function isnt really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, state, info) {\n    const row = handleTableRowAsData(node, state, info)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, state, info) {\n    const exit = state.enter('tableCell')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...info,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {State} state\n   * @param {Info} info\n   */\n  function handleTableAsData(node, state, info) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = state.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(children[index], state, info)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {State} state\n   * @param {Info} info\n   */\n  function handleTableRowAsData(node, state, info) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = state.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(children[index], node, state, info)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, state) {\n    let value = defaultHandlers.inlineCode(node, parent, state)\n\n    if (state.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n", "/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n", "/**\n * @import {Extension as FromMarkdownExtension} from 'mdast-util-from-markdown'\n * @import {Options} from 'mdast-util-gfm'\n * @import {Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown(),\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown(),\n    gfmTableFromMarkdown(),\n    gfmTaskListItemFromMarkdown()\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown(),\n      gfmFootnoteToMarkdown(options),\n      gfmStrikethroughToMarkdown(),\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown()\n    ]\n  }\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  /** @type {Properties} */\n  const properties = {}\n\n  if (node.lang) {\n    properties.className = ['language-' + node.lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  let reuseCounter = state.footnoteCounts.get(id)\n\n  if (reuseCounter === undefined) {\n    reuseCounter = 0\n    state.footnoteOrder.push(id)\n    counter = state.footnoteOrder.length\n  } else {\n    counter = index + 1\n  }\n\n  reuseCounter += 1\n  state.footnoteCounts.set(id, reuseCounter)\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + clobberPrefix + 'fn-' + safeId,\n      id:\n        clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Html} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Element | Raw | undefined}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.options.allowDangerousHtml) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  return undefined\n}\n", "/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Reference} Reference\n *\n * @typedef {import('./state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Extract<Nodes, Reference>} node\n *   Reference node (image, link).\n * @returns {Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return [{type: 'text', value: '![' + node.alt + suffix}]\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const definition = state.definitionById.get(id)\n\n  if (!definition) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(definition.url || ''), alt: node.alt}\n\n  if (definition.title !== null && definition.title !== undefined) {\n    properties.title = definition.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const definition = state.definitionById.get(id)\n\n  if (!definition) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(definition.url || '')}\n\n  if (definition.title !== null && definition.title !== undefined) {\n    properties.title = definition.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === null || spread === undefined\n    ? node.children.length > 1\n    : spread\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Parents} HastParents\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastParents}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'end' | 'start'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {Node | NodeLike | null | undefined} [node]\n   * @returns {Point | undefined}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    if (\n      typeof point.line === 'number' &&\n      point.line > 0 &&\n      typeof point.column === 'number' &&\n      point.column > 0\n    ) {\n      return {\n        line: point.line,\n        column: point.column,\n        offset:\n          typeof point.offset === 'number' && point.offset > -1\n            ? point.offset\n            : undefined\n      }\n    }\n  }\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {Node | NodeLike | null | undefined} [node]\n *   Node.\n * @returns {Position | undefined}\n *   Position.\n */\nexport function position(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  if (start && end) {\n    return {start, end}\n  }\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointEnd, pointStart} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start && end) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  // To do: option to use `style`?\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(cell, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n", "/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastElement | HastText}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n *\n * @satisfies {import('../state.js').Handlers}\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  // @ts-expect-error: root is different, but hard to type.\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  return undefined\n}\n", "export const VOID       = -1;\nexport const PRIMITIVE  = 0;\nexport const ARRAY      = 1;\nexport const OBJECT     = 2;\nexport const DATE       = 3;\nexport const REGEXP     = 4;\nexport const MAP        = 5;\nexport const SET        = 6;\nexport const ERROR      = 7;\nexport const BIGINT     = 8;\n// export const SYMBOL = 9;\n", "import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst env = typeof self === 'object' ? self : globalThis;\n\nconst deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n\n  const unpair = index => {\n    if ($.has(index))\n      return $.get(index);\n\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index of value)\n          arr.push(unpair(index));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index] of value)\n          object[unpair(key)] = unpair(index);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(new Map, index);\n        for (const [key, index] of value)\n          map.set(unpair(key), unpair(index));\n        return map;\n      }\n      case SET: {\n        const set = as(new Set, index);\n        for (const index of value)\n          set.add(unpair(index));\n        return set;\n      }\n      case ERROR: {\n        const {name, message} = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case 'BigInt':\n        return as(Object(BigInt(value)), index);\n      case 'ArrayBuffer':\n        return as(new Uint8Array(value).buffer, value);\n      case 'DataView': {\n        const { buffer } = new Uint8Array(value);\n        return as(new DataView(buffer), value);\n      }\n    }\n    return as(new env[type](value), index);\n  };\n\n  return unpair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns a deserialized value from a serialized array of Records.\n * @param {Record[]} serialized a previously serialized value.\n * @returns {any}\n */\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\n", "import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type) {\n          let spread = value;\n          if (type === 'DataView') {\n            spread = new Uint8Array(value.buffer);\n          }\n          else if (type === 'ArrayBuffer') {\n            spread = new Uint8Array(value);\n          }\n          return as([type, [...spread]], value);\n        }\n\n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n", "import {deserialize} from './deserialize.js';\nimport {serialize} from './serialize.js';\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} any a serializable value.\n * @param {{transfer?: any[], json?: boolean, lossy?: boolean}?} options an object with\n * a transfer option (ignored when polyfilled) and/or non standard fields that\n * fallback to the polyfill if present.\n * @returns {Record[]}\n */\nexport default typeof structuredClone === \"function\" ?\n  /* c8 ignore start */\n  (any, options) => (\n    options && ('json' in options || 'lossy' in options) ?\n      deserialize(serialize(any, options)) : structuredClone(any)\n  ) :\n  (any, options) => deserialize(serialize(any, options));\n  /* c8 ignore stop */\n\nexport {deserialize, serialize};\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @callback FootnoteBackContentTemplate\n *   Generate content for the backreference dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent> | ElementContent | string}\n *   Content for the backreference when linking back from definitions to their\n *   reference.\n *\n * @callback FootnoteBackLabelTemplate\n *   Generate a back label dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Back label to use when linking back from definitions to their reference.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate the default content that GitHub uses on backreferences.\n *\n * @param {number} _\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent>}\n *   Content.\n */\nexport function defaultFootnoteBackContent(_, rereferenceIndex) {\n  /** @type {Array<ElementContent>} */\n  const result = [{type: 'text', value: ''}]\n\n  if (rereferenceIndex > 1) {\n    result.push({\n      type: 'element',\n      tagName: 'sup',\n      properties: {},\n      children: [{type: 'text', value: String(rereferenceIndex)}]\n    })\n  }\n\n  return result\n}\n\n/**\n * Generate the default label that GitHub uses on backreferences.\n *\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Label.\n */\nexport function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n  return (\n    'Back to reference ' +\n    (referenceIndex + 1) +\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n  )\n}\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\n// eslint-disable-next-line complexity\nexport function footer(state) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const footnoteBackContent =\n    state.options.footnoteBackContent || defaultFootnoteBackContent\n  const footnoteBackLabel =\n    state.options.footnoteBackLabel || defaultFootnoteBackLabel\n  const footnoteLabel = state.options.footnoteLabel || 'Footnotes'\n  const footnoteLabelTagName = state.options.footnoteLabelTagName || 'h2'\n  const footnoteLabelProperties = state.options.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let referenceIndex = -1\n\n  while (++referenceIndex < state.footnoteOrder.length) {\n    const definition = state.footnoteById.get(\n      state.footnoteOrder[referenceIndex]\n    )\n\n    if (!definition) {\n      continue\n    }\n\n    const content = state.all(definition)\n    const id = String(definition.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let rereferenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n    const counts = state.footnoteCounts.get(id)\n\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (counts !== undefined && ++rereferenceIndex <= counts) {\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      let children =\n        typeof footnoteBackContent === 'string'\n          ? footnoteBackContent\n          : footnoteBackContent(referenceIndex, rereferenceIndex)\n\n      if (typeof children === 'string') {\n        children = {type: 'text', value: children}\n      }\n\n      backReferences.push({\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (rereferenceIndex > 1 ? '-' + rereferenceIndex : ''),\n          dataFootnoteBackref: '',\n          ariaLabel:\n            typeof footnoteBackLabel === 'string'\n              ? footnoteBackLabel\n              : footnoteBackLabel(referenceIndex, rereferenceIndex),\n          className: ['data-footnote-backref']\n        },\n        children: Array.isArray(children) ? children : [children]\n      })\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(definition, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: footnoteLabelTagName,\n        properties: {\n          ...structuredClone(footnoteLabelProperties),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n", "/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: ''}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the ``\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a nodes positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {visit} from 'unist-util-visit'\nimport {position} from 'unist-util-position'\nimport {handlers as defaultHandlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map()\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map()\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map()\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {...defaultHandlers, ...settings.handlers}\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  }\n\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById\n      const id = String(node.identifier).toUpperCase()\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node)\n      }\n    }\n  })\n\n  return state\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n  function one(node, parent) {\n    const type = node.type\n    const handle = state.handlers[type]\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent)\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {children, ...shallow} = node\n        const result = structuredClone(shallow)\n        // @ts-expect-error: TS doesnt understand\n        result.children = state.all(node)\n        // @ts-expect-error: TS doesnt understand\n        return result\n      }\n\n      // @ts-expect-error: its custom.\n      return structuredClone(node)\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\n\n    return unknown(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = []\n\n    if ('children' in parent) {\n      const nodes = parent.children\n      let index = -1\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent)\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value)\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0]\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value)\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result)\n          } else {\n            values.push(result)\n          }\n        }\n      }\n    }\n\n    return values\n  }\n}\n\n/**\n * Copy a nodes positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result]\n        result = {type: 'element', tagName: hName, properties: {}, children}\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties))\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastElement | HastText} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: state.all(node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0\n  let code = value.charCodeAt(index)\n\n  while (code === 9 || code === 32) {\n    index++\n    code = value.charCodeAt(index)\n  }\n\n  return value.slice(index)\n}\n", "/**\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('./state.js').Options} Options\n */\n\nimport {ok as assert} from 'devlop'\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones dont:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isnt in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesnt have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   hast tree.\n */\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, undefined)\n  const foot = footer(state)\n  /** @type {HastNodes} */\n  const result = Array.isArray(node)\n    ? {type: 'root', children: node}\n    : node || {type: 'root', children: []}\n\n  if (foot) {\n    // If theres a footer, there were definitions, meaning block\n    // content.\n    // So `result` is a parent node.\n    assert('children' in result)\n    result.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  return result\n}\n", "import { createTransformerFactory } from '@shikijs/twoslash/core';\nimport { removeTwoslashNotations } from 'twoslash';\nimport { createTwoslasher } from 'twoslash-vue';\nimport { rendererRich } from '@shikijs/twoslash';\nexport { defaultHoverInfoProcessor } from '@shikijs/twoslash';\nimport { fromMarkdown } from 'mdast-util-from-markdown';\nimport { gfmFromMarkdown } from 'mdast-util-gfm';\nimport { toHast, defaultHandlers } from 'mdast-util-to-hast';\n\nfunction rendererFloatingVue(options = {}) {\n  const {\n    classCopyIgnore = \"vp-copy-ignore\",\n    classFloatingPanel = \"twoslash-floating\",\n    classCode = \"vp-code\",\n    classMarkdown = \"vp-doc\",\n    floatingVueTheme = \"twoslash\",\n    floatingVueThemeQuery = \"twoslash-query\",\n    floatingVueThemeCompletion = \"twoslash-completion\"\n  } = options.floatingVue || {};\n  const {\n    errorRendering = \"line\"\n  } = options;\n  const hoverBasicProps = {\n    \"class\": \"twoslash-hover\",\n    \"popper-class\": [\"shiki\", classFloatingPanel, classCopyIgnore, classCode].join(\" \"),\n    \"theme\": floatingVueTheme\n  };\n  const rich = rendererRich({\n    classExtra: classCopyIgnore,\n    ...options,\n    renderMarkdown,\n    renderMarkdownInline,\n    hast: {\n      hoverToken: {\n        tagName: \"v-menu\",\n        properties: hoverBasicProps\n      },\n      hoverCompose: compose,\n      queryToken: {\n        tagName: \"v-menu\",\n        properties: {\n          ...hoverBasicProps,\n          \":shown\": \"true\",\n          \"theme\": floatingVueThemeQuery\n        }\n      },\n      queryCompose: compose,\n      popupDocs: {\n        class: `twoslash-popup-docs ${classMarkdown}`\n      },\n      popupDocsTags: {\n        class: `twoslash-popup-docs twoslash-popup-docs-tags ${classMarkdown}`\n      },\n      popupError: {\n        class: `twoslash-popup-error ${classMarkdown}`\n      },\n      errorToken: errorRendering === \"line\" ? undefined : {\n        tagName: \"v-menu\",\n        properties: {\n          ...hoverBasicProps,\n          class: \"twoslash-error twoslash-error-hover\"\n        }\n      },\n      errorCompose: compose,\n      completionCompose({ popup, cursor }) {\n        return [\n          {\n            type: \"element\",\n            tagName: \"v-menu\",\n            properties: {\n              \"popper-class\": [\"shiki twoslash-completion\", classCopyIgnore, classFloatingPanel],\n              \"theme\": floatingVueThemeCompletion,\n              \":shown\": \"true\"\n            },\n            children: [\n              cursor,\n              {\n                type: \"element\",\n                tagName: \"template\",\n                properties: {\n                  \"v-slot:popper\": \"{}\"\n                },\n                content: {\n                  type: \"root\",\n                  children: [vPre(popup)]\n                }\n              }\n            ]\n          }\n        ];\n      }\n    }\n  });\n  return rich;\n}\nfunction vPre(el) {\n  if (el.type === \"element\") {\n    el.properties = el.properties || {};\n    el.properties[\"v-pre\"] = \"\";\n  }\n  return el;\n}\nfunction renderMarkdown(md) {\n  const mdast = fromMarkdown(\n    md.replace(/\\{@link ([^}]*)\\}/g, \"$1\"),\n    // replace jsdoc links\n    { mdastExtensions: [gfmFromMarkdown()] }\n  );\n  return toHast(\n    mdast,\n    {\n      handlers: {\n        code: (state, node) => {\n          const lang = node.lang || \"\";\n          if (lang) {\n            return {\n              type: \"element\",\n              tagName: \"code\",\n              properties: {},\n              children: this.codeToHast(\n                node.value,\n                {\n                  ...this.options,\n                  transformers: [],\n                  lang,\n                  structure: node.value.trim().includes(\"\\n\") ? \"classic\" : \"inline\"\n                }\n              ).children\n            };\n          }\n          return defaultHandlers.code(state, node);\n        }\n      }\n    }\n  ).children;\n}\nfunction renderMarkdownInline(md, context) {\n  if (context === \"tag:param\")\n    md = md.replace(/^([\\w$-]+)/, \"`$1` \");\n  const children = renderMarkdown.call(this, md);\n  if (children.length === 1 && children[0].type === \"element\" && children[0].tagName === \"p\")\n    return children[0].children;\n  return children;\n}\nfunction compose(parts) {\n  return [\n    {\n      type: \"element\",\n      tagName: \"span\",\n      properties: {},\n      children: [parts.token]\n    },\n    {\n      type: \"element\",\n      tagName: \"template\",\n      properties: {\n        \"v-slot:popper\": \"{}\"\n      },\n      content: {\n        type: \"root\",\n        children: [vPre(parts.popup)]\n      },\n      children: []\n    }\n  ];\n}\n\nfunction transformerTwoslash(options = {}) {\n  const {\n    explicitTrigger = true,\n    typesCache\n  } = options;\n  const onError = (error, code) => {\n    const isCI = typeof process !== \"undefined\" && process?.env?.CI;\n    const isDev = typeof process !== \"undefined\" && process?.env?.NODE_ENV === \"development\";\n    const shouldThrow = (options.throws || isCI || !isDev) && options.throws !== false;\n    console.error(`\n\n--------\nTwoslash error in code:\n--------\n${code.split(/\\n/g).slice(0, 15).join(\"\\n\").trim()}\n--------\n`);\n    if (shouldThrow)\n      throw error;\n    else\n      console.error(error);\n    removeTwoslashNotations(code);\n  };\n  const defaultTwoslasher = createTwoslasher(options.twoslashOptions);\n  let twoslasher = defaultTwoslasher;\n  if (typesCache) {\n    twoslasher = (code, extension, options2) => {\n      const cached = typesCache.read(code);\n      if (cached)\n        return cached;\n      const twoslashResult = defaultTwoslasher(code, extension, options2);\n      typesCache.write(code, twoslashResult);\n      return twoslashResult;\n    };\n    twoslasher.getCacheMap = defaultTwoslasher.getCacheMap;\n  }\n  const twoslash = createTransformerFactory(twoslasher)({\n    langs: [\"ts\", \"tsx\", \"js\", \"jsx\", \"json\", \"vue\"],\n    renderer: rendererFloatingVue(options),\n    onTwoslashError: onError,\n    onShikiError: onError,\n    ...options,\n    explicitTrigger\n  });\n  const trigger = explicitTrigger instanceof RegExp ? explicitTrigger : /\\btwoslash\\b/;\n  typesCache?.init?.();\n  return {\n    ...twoslash,\n    name: \"@shikijs/vitepress-twoslash\",\n    preprocess(code, options2) {\n      const cleanup = options2.transformers?.find((i) => i.name === \"vitepress:clean-up\");\n      if (cleanup)\n        options2.transformers?.splice(options2.transformers.indexOf(cleanup), 1);\n      if (!explicitTrigger || options2.meta?.__raw?.match(trigger)) {\n        const vPre = options2.transformers?.find((i) => i.name === \"vitepress:v-pre\");\n        if (vPre)\n          options2.transformers?.splice(options2.transformers.indexOf(vPre), 1);\n      }\n      return twoslash.preprocess.call(this, code, options2);\n    },\n    postprocess(html) {\n      if (this.meta.twoslash)\n        return html.replace(/\\{/g, \"&#123;\");\n    }\n  };\n}\n\nexport { rendererFloatingVue, transformerTwoslash };\n"],
  "mappings": "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AO,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,SAAQ,KAAO,SAAQ,KAAS,UAAS,KAAS,UAAS,KAAO,QAAO,KAAO,QAAO,KAAS,QAAO,KAAS,QAAO,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAS,QAAO,KAAS,SAAQ,KAAS,UAAS,KAAS,UAAS,KAAS,SAAQ,MAAK,SAAQ,KAAS,SAAQ,KAAS,QAAO,KAAS,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,SAAQ,KAAS,SAAQ,KAAS,QAAO,KAAS,QAAO,KAAS,UAAS,MAAe,OAAM,KAAS,WAAU,MAAe,QAAO,MAAe,QAAO,KAAS,QAAO,KAAS,OAAM,KAAS,QAAO,KAAS,SAAQ,KAAS,SAAQ,KAAS,QAAO,KAAS,UAAS,KAAS,UAAS,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAS,MAAK,MAAe,QAAO,KAAS,QAAO,KAAS,MAAK,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,SAAQ,KAAO,SAAQ,KAAO,QAAO,KAAO,QAAO,KAAS,UAAS,KAAS,UAAS,KAAS,QAAO,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,KAAS,UAAS,KAAS,UAAS,MAAe,OAAM,MAAe,QAAO,KAAS,OAAM,MAAe,QAAO,KAAS,QAAO,MAAe,OAAM,MAAe,QAAO,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAS,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,KAAS,QAAO,MAAe,QAAO,MAAe,OAAM,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAO,UAAS,KAAO,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,OAAM,KAAS,OAAM,MAAe,QAAO,MAAe,OAAM,KAAS,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAO,QAAO,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,SAAQ,KAAO,SAAQ,KAAO,QAAO,KAAO,QAAO,KAAS,UAAS,KAAS,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,KAAS,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,KAAS,QAAO,KAAS,UAAS,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,KAAS,QAAO,KAAS,MAAK,KAAS,QAAO,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAS,MAAK,KAAS,UAAS,KAAS,UAAS,KAAS,SAAQ,KAAS,SAAQ,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAO,SAAQ,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,SAAQ,KAAS,UAAS,KAAS,UAAS,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAO,UAAS,KAAS,UAAS,KAAS,UAAS,KAAO,SAAQ,KAAO,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAO,QAAO,KAAO,QAAO,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,KAAS,SAAQ,KAAS,SAAQ,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,MAAe,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAO,UAAS,KAAO,UAAS,KAAS,SAAQ,KAAS,SAAQ,KAAO,QAAO,KAAS,QAAO,MAAe,QAAO,MAAe,OAAM,MAAe,QAAO,KAAS,OAAM,KAAS,QAAO,MAAe,QAAO,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,UAAS,KAAS,QAAO,KAAS,QAAO,KAAS,SAAQ,KAAO,SAAQ,KAAO,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,QAAO,KAAS,QAAO,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,SAAQ,KAAS,QAAO,KAAS,SAAQ,KAAS,WAAU,KAAS,UAAS,KAAS,UAAS,KAAS,QAAO,KAAS,QAAO,KAAS,OAAM,KAAS,OAAM,KAAS,SAAQ,KAAS,UAAS,KAAS,SAAQ,KAAS,QAAO,KAAS,QAAO,KAAS,SAAQ,KAAS,UAAS,KAAS,SAAQ,KAAS,UAAS,KAAS,UAAS,KAAS,MAAK,KAAO,SAAQ,KAAS,MAAK,KAAS,MAAK,KAAS,MAAK,KAAS,MAAK,KAAS,MAAK,KAAS,WAAU,KAAS,WAAU,KAAS,MAAK,KAAS,OAAM,KAAS,MAAK,KAAS,OAAM,KAAS,QAAO,KAAS,OAAM,KAAS,SAAQ,KAAS,SAAQ,KAAS,UAAS,KAAS,OAAM,KAAS,OAAM,KAAS,QAAO,KAAS,WAAU,KAAS,QAAO,KAAS,OAAM,KAAS,QAAO,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,SAAQ,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,OAAM,KAAS,QAAO,KAAS,QAAO,KAAS,OA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AAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,SAAS,wBAAwBX,OAAM,YAAY;AACjD,QAAM,OAAO;AAAA,IACX,UAAU,CAAC;AAAA,EACb;AACA,QAAM,OAAO;AAAA,IACX,GAAG,cAAc,CAAC;AA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",
  "names": ["extend", "key", "range", "string", "html", "index", "text", "isComponent", "key", "content", "index", "body", "node", "link", "error", "code", "root", "p", "element", "extend", "node2", "list", "matches", "push", "resolver", "text", "siblings", "stack", "cp", "raw", "raw", "code", "node", "extend", "transformModel", "transformOn", "p", "key", "error", "ts", "text", "node", "_a", "range", "options", "property", "define", "element", "ts", "node", "text", "key", "token", "all", "code", "code", "shouldSkip", "ts", "text", "node", "walkIdentifiers", "module", "r", "range", "module", "body", "p", "position", "r", "types", "p", "re", "body", "_a", "start", "final", "i", "acc", "_hasMagic", "p", "ext", "defaults", "def", "list", "dd", "p2", "re", "track", "push", "splice", "stack", "exports", "p", "toString", "create", "replace", "replacer", "node", "ts", "code", "code", "node", "isComponent", "codes", "code", "_a", "_b", "content", "node", "_a", "node", "key", "index", "node", "codes", "code", "node", "content", "node", "node", "code", "node", "isComponentTag", "p", "key", "_a", "content", "element", "ts", "property", "text", "node", "require_binarySearch", "values", "index", "key", "i", "exports", "p", "code", "text", "require_types", "FileMap", "key", "exports", "p", "createLanguage", "defaultMapperFactory", "code", "sourceScript", "content", "parse", "compiler", "node", "content", "p", "content", "codes", "content", "require_shared", "content", "ts", "index", "index", "compiler", "node", "content", "generate", "node", "content", "parse", "codes", "visit", "node", "_a", "i", "content", "code", "System", "Link", "get", "link", "Dependency", "Subscriber", "link", "link", "keys", "index", "p", "key", "exports", "p", "exports", "p", "module", "code", "cwd", "normalize", "join", "parse", "code", "codes", "p", "require_template", "option", "code", "content", "code", "generate", "require_context", "range", "p", "define", "codes", "code", "range", "mark", "ts", "raw", "node", "content", "ts", "codes", "code", "require_types", "exports", "p", "module", "line", "module", "root", "hasOwnProperty", "object", "index", "merge", "defaults", "key", "encode", "string", "decode", "html", "isArray", "isFunction", "isObject", "toRawType", "isPlainObject", "isPromise", "toString", "replacer", "toNumber", "makeMap", "str", "list", "hasOwnProperty", "hasOwn", "key", "camelizeRE", "camelize", "capitalize", "hyphenateRE", "hyphenate", "extend", "modules", "keys", "looseEqual", "looseIndexOf", "hasChanged", "def", "doctype", "comment", "html", "re", "stack", "isUnaryTag", "canBeLeftOpenTag", "index", "text", "next", "all", "endTag", "warn", "range", "start", "end", "node", "target", "method", "isRef", "property", "r", "fns", "on", "add", "remove", "createOnceHandler", "hash", "cached", "values", "isWhitespace", "handlers", "performance", "seen", "transformModel", "repeat", "vm", "normalizeProps", "valid", "len", "isBooleanAttr", "isHTMLTag", "validDivisionCharRE", "p", "wrapFilter", "delimiters", "number", "chr", "forAliasRE", "forIteratorRE", "stripParensRE", "whitespaceRE", "parse", "isReservedTag", "root", "inVPre", "inPre", "element", "processFor", "processIf", "processSlotOutlet", "code", "value", "fnExpRE", "isNative", "handler", "maybeComponent", "el", "normalizationType", "genNode", "genComment", "genText", "bind", "prohibitedKeywordRE", "stripStringRE", "generateCodeFrame", "compile", "compileToFunctions", "baseCompile", "createCompiler", "baseOptions", "tip", "propsToAttrMap", "walk", "generate", "compile", "error", "baseCompile", "transformIf", "transformFor", "content", "r", "code", "codes", "content", "plugin", "matches", "ts", "content", "ast", "module", "ts", "createVueLanguagePlugin", "key", "r", "values", "ts", "code", "root", "resolveVueCompilerOptions", "setupGlobalTypes", "ts", "extension", "key", "error", "require_language_core", "exports", "p", "module", "parse", "require_common", "module", "env", "createDebug", "disable", "key", "debug", "self", "index", "extend", "search", "module", "index", "error", "r", "ShikiError", "key", "__publicField", "string", "index", "p", "property", "space", "space", "property", "definition", "property", "property", "space", "index", "values", "key", "definition", "property", "property", "property", "property", "property", "property", "html", "svg", "key", "one", "handlers", "index", "all", "code", "code", "own", "code", "code", "node", "encode", "index", "values", "stringify", "values", "increment", "index", "siblings", "own", "handlers", "node", "index", "html", "index", "body", "html", "tbody", "node", "head", "seen", "child", "index", "previous", "node", "index", "svg", "content", "values", "key", "stringify", "node", "node", "index", "node", "node", "emptyChildren", "svg", "html", "node", "index", "r", "r", "r", "p", "r", "range", "r", "r", "r", "code", "index", "node", "token", "p", "r", "key", "color", "ShikiError", "keys", "stack", "stack2", "decorations", "text", "stringify", "_a", "transform", "position", "root", "_b", "content", "Registry", "resolver", "code", "code", "key", "index", "extension", "node", "completionIcons", "renderMarkdown", "renderMarkdownInline", "content", "error", "token", "transformerTwoslash", "twoslasher", "_a", "code", "index", "hasLocalStorage", "localStorage", "error", "hasProcess", "process", "shouldDebug", "getItem", "env", "DEBUG", "debugLog", "console", "log", "_message", "createVirtualTypeScriptEnvironment", "sys", "rootFiles", "ts", "compilerOptions", "customTransformers", "mergedCompilerOpts", "_extends", "defaultCompilerOptions", "_createVirtualLanguag", "createVirtualLanguageServiceHost", "languageServiceHost", "updateFile", "deleteFile", "languageService", "createLanguageService", "diagnostics", "getCompilerOptionsDiagnostics", "length", "compilerHost", "createVirtualCompilerHost", "Error", "formatDiagnostics", "name", "getSourceFile", "fileName", "_languageService$getP", "getProgram", "createFile", "content", "createSourceFile", "target", "optPrevTextSpan", "prevSourceFile", "prevFullContents", "text", "prevTextSpan", "createTextSpan", "newText", "slice", "start", "newSourceFile", "updateSourceFile", "span", "newLength", "sourceFile", "notImplemented", "methodName", "Error", "audit", "name", "fn", "_len", "arguments", "length", "args", "Array", "_key", "res", "apply", "smallres", "slice", "debugLog", "concat", "defaultCompilerOptions", "ts", "_extends", "getDefaultCompilerOptions", "jsx", "JsxEmit", "React", "strict", "esModuleInterop", "module", "ModuleKind", "ESNext", "suppressOutputPathCheck", "skipLibCheck", "skipDefaultLibCheck", "moduleResolution", "ModuleResolutionKind", "NodeJs", "libize", "path", "replace", "toLowerCase", "createSystem", "files", "createDirectory", "directoryExists", "directory", "from", "keys", "some", "startsWith", "exit", "fileExists", "fileName", "has", "getCurrentDirectory", "getDirectories", "getExecutingFilePath", "readDirectory", "readFile", "_files$get", "get", "resolvePath", "newLine", "useCaseSensitiveFileNames", "write", "writeFile", "contents", "set", "deleteFile", "createFSBackedSystem", "_projectRoot", "tsLibDirectory", "root", "requirePath", "nodeSys", "sys", "tsLib", "dirname", "require", "resolve", "includes", "tsLibName", "undefined", "result", "libs", "realpath", "createVirtualCompilerHost", "compilerOptions", "sourceFiles", "Map", "save", "sourceFile", "vHost", "compilerHost", "getCanonicalFileName", "getDefaultLibFileName", "getNewLine", "getSourceFile", "languageVersionOrOptions", "_ref", "createSourceFile", "target", "updateFile", "alreadyExists", "text", "createVirtualLanguageServiceHost", "rootFiles", "customTransformers", "fileNames", "_createVirtualCompile", "fileVersions", "projectVersion", "languageServiceHost", "getProjectVersion", "toString", "getCompilationSettings", "getCustomTransformers", "getScriptFileNames", "getScriptSnapshot", "ScriptSnapshot", "fromString", "getScriptVersion", "lsHost", "push", "index", "indexOf", "splice", "String", "fromCharCode", "index", "range", "splitLines", "code", "createPositionConverter", "remove", "node", "defaultCompilerOptions", "__defProp", "__defNormalProp", "key", "__publicField", "code", "keys", "string", "number", "xml", "types", "ts", "node", "text", "root", "matches", "index", "content", "ts", "key", "env", "code", "extension", "defaultCompilerOptions", "index", "createPositionConverter", "_a", "_b", "text", "content", "node", "root", "createTwoslasher", "ts", "import_typescript", "createTwoslasher", "ts", "key", "env", "defaultCompilerOptions", "twoslasher", "code", "extension", "createPositionConverter", "_a", "p", "r", "index", "assert", "assert", "emptyOptions", "one", "all", "values", "index", "element", "characterReference", "constants", "list", "remove", "constants", "hasOwnProperty", "all", "index", "extension", "code", "list", "code", "code", "index", "code", "replace", "hasOwnProperty", "ok", "code", "previous", "code", "token", "constants", "document", "self", "stack", "code", "point", "index", "constants", "token", "seen", "ok", "code", "constants", "constructs", "index", "index", "text", "ok", "attentionMarkers", "previous", "code", "token", "constants", "point", "ok", "code", "constants", "ok", "code", "ok", "self", "code", "constants", "ok", "code", "ok", "self", "code", "constants", "token", "ok", "self", "code", "constants", "effects", "nok", "start", "ok", "self", "code", "constants", "furtherStart", "index", "code", "ok", "self", "token", "index", "list", "constants", "index", "token", "tokenizer", "previous", "start", "content", "ok", "previous", "code", "constants", "self", "ok", "code", "constants", "raw", "ok", "self", "seen", "code", "constants", "ok", "code", "constants", "ok", "seen", "code", "ok", "self", "code", "titleBefore", "ok", "code", "content", "text", "constants", "ok", "code", "index", "ok", "self", "code", "constants", "ok", "self", "index", "code", "comment", "constants", "index", "token", "text", "ok", "self", "code", "constants", "ok", "self", "code", "ok", "self", "code", "ok", "code", "ok", "code", "constants", "ok", "self", "code", "constants", "index", "content", "text", "definition", "heading", "ok", "self", "code", "paragraph", "self", "content", "code", "string", "text", "self", "constructs", "code", "list", "index", "token", "constants", "document", "flow", "string", "text", "document", "flow", "string", "text", "createDebug", "point", "stack", "exit", "main", "token", "code", "constructs", "all", "list", "ok", "from", "head", "index", "parse", "constructs", "create", "document", "string", "text", "code", "constants", "head", "constants", "point", "own", "parse", "link", "heading", "blockQuote", "codeText", "definition", "emphasis", "hardBreak", "html", "image", "listItem", "list", "paragraph", "strong", "thematicBreak", "compile", "exit", "index", "defaultOnError", "point", "create", "token", "node", "siblings", "constants", "data", "text", "string", "extension", "key", "string", "ok", "checks", "index", "all", "node", "key", "empty", "is", "node", "index", "visit", "list", "node", "index", "siblings", "find", "replace", "position", "token", "node", "previous", "code", "token", "node", "exit", "token", "node", "exit", "own", "code", "node", "exit", "node", "index", "html", "node", "node", "exit", "node", "exit", "stack", "node", "index", "position", "node", "raw", "node", "exit", "stack", "value", "node", "exit", "text", "stack", "node", "exit", "exit", "token", "node", "token", "node", "head", "siblings", "index", "blockquote", "node", "hardBreak", "node", "code", "node", "node", "emphasis", "node", "footnoteReference", "node", "index", "link", "heading", "node", "html", "node", "node", "head", "imageReference", "node", "definition", "image", "node", "inlineCode", "node", "text", "linkReference", "node", "definition", "link", "node", "listItem", "node", "head", "paragraph", "index", "list", "node", "index", "paragraph", "node", "root", "node", "strong", "node", "point", "node", "position", "node", "head", "body", "node", "siblings", "cells", "result", "node", "search", "code", "text", "node", "thematicBreak", "node", "blockquote", "hardBreak", "code", "emphasis", "footnoteReference", "heading", "html", "imageReference", "image", "inlineCode", "linkReference", "link", "listItem", "list", "paragraph", "root", "strong", "text", "thematicBreak", "index", "key", "toString", "index", "key", "definition", "content", "listItem", "own", "emptyOptions", "handlers", "all", "one", "node", "handle", "unknown", "values", "index", "head", "position", "code", "node", "node", "error", "code", "_a", "createTwoslasher", "twoslasher", "extension", "vPre", "html"]
}
